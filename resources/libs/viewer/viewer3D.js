
function getGlobal() {
    return (typeof window !== "undefined" && window !== null)
            ? window
            : (typeof self !== "undefined" && self !== null)
                ? self
                : this;
}

/**
 * Create namespace
 * @param {string} s - namespace (e.g. 'Autodesk.Viewing')
 * @return {Object} namespace
 */
var AutodeskNamespace = function (s) {
    var ns = getGlobal();

    var parts = s.split('.');
    for (var i = 0; i < parts.length; ++i) {
        ns[parts[i]] = ns[parts[i]] || {};
        ns = ns[parts[i]];
    }

    return ns;
};

// Define the most often used ones
AutodeskNamespace("Autodesk.Viewing.Private");

AutodeskNamespace("Autodesk.Viewing.Extensions");

AutodeskNamespace("Autodesk.Viewing.Shaders");

AutodeskNamespace('Autodesk.Viewing.UI');

AutodeskNamespace('Autodesk.LMVTK');

Autodesk.Viewing.getGlobal = getGlobal;

(typeof module !== "undefined") && (module.exports = { AutodeskNamespace: AutodeskNamespace,
                                                       Autodesk: Autodesk });
;
function getGlobal() {
    return (typeof window !== "undefined" && window !== null)
            ? window
            : (typeof self !== "undefined" && self !== null)
                ? self
                : GLOBAL;
}

var av = Autodesk.Viewing,
    avp = av.Private;

av.getGlobal = getGlobal;

var isBrowser = av.isBrowser = (typeof navigator !== "undefined");

var _isIE11 = av.isIE11 = isBrowser && !!navigator.userAgent.match(/Trident\/7\./);

// fix IE events
if(typeof window !== "undefined" && _isIE11){
    (function () {
        function CustomEvent ( event, params ) {
            params = params || { bubbles: false, cancelable: false, detail: undefined };
            var evt = document.createEvent( 'CustomEvent' );
            evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
            return evt;
        };

        CustomEvent.prototype = window.CustomEvent.prototype;

        window.CustomEvent = CustomEvent;
    })();
}

// IE does not implement ArrayBuffer slice. Handy!
if (!ArrayBuffer.prototype.slice) {
    ArrayBuffer.prototype.slice = function(start, end) {
        // Normalize start/end values
        if (!end || end > this.byteLength) {
            end = this.byteLength;
        }
        else if (end < 0) {
            end = this.byteLength + end;
            if (end < 0) end = 0;
        }
        if (start < 0) {
            start = this.byteLength + start;
            if (start < 0) start = 0;
        }

        if (end <= start) {
            return new ArrayBuffer();
        }

        // Bytewise copy- this will not be fast, but what choice do we have?
        var len = end - start;
        var view = new Uint8Array(this, start, len);
        var out = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            out[i] = view[i];
        }
        return out.buffer;
    }
}


//The BlobBuilder object
if (typeof window !== "undefined")
    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;


// Launch full screen on the given element with the available method
function launchFullscreen(element, options) {
    if (element.requestFullscreen) {
        element.requestFullscreen(options);
    } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen(options);
    } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen(options);
    } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen(options);
    }
}

// Exit full screen with the available method
function exitFullscreen() {
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
    }
}

// Determines if the browser is in full screen
function inFullscreen(){

    // Special case for Ms-Edge that has webkitIsFullScreen with correct value
    // and fullscreenEnabled with wrong value (thanks MS)
    if ("webkitIsFullScreen" in document) return document.webkitIsFullScreen;
    return !!(document.mozFullScreenElement ||
        document.msFullscreenElement ||
        document.fullscreenEnabled || // Check last-ish because it is true in Ms-Edge
        document.querySelector(".viewer-fill-browser")); // Fallback for iPad
}

function fullscreenElement() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
}

function isFullscreenAvailable(element) {
    return element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.msRequestFullscreen;
}

// Get the version of the android device through user agent.
// Return the version string of android device, e.g. 4.4, 5.0...
function getAndroidVersion(ua) {
    var ua = ua || navigator.userAgent;
    var match = ua.match(/Android\s([0-9\.]*)/);
    return match ? match[1] : false;
};

// Determine if this is a touch or notouch device.
function isTouchDevice() {
    /*
    // Temporarily disable touch support through hammer on Android 5, to debug
    // some specific gesture issue with Chromium WebView when loading viewer3D.js.
    if (parseInt(getAndroidVersion()) == 5) {
        return false;
    }
    */

    return ('ontouchstart' in window);
}

av.isIOSDevice = function() {
    if (!isBrowser) return false;
    return /ip(ad|hone|od)/.test(navigator.userAgent.toLowerCase());
};

av.isAndroidDevice = function() {
    if (!isBrowser) return false;
    return (navigator.userAgent.toLowerCase().indexOf('android') !== -1);
};

av.isMobileDevice = function() {
    if (!isBrowser) return false;
    return av.isIOSDevice() || av.isAndroidDevice();
};

function isSafari() {
    if (!isBrowser) return false;
    var _ua = navigator.userAgent.toLowerCase();
    return (_ua.indexOf("safari") !== -1) && (_ua.indexOf("chrome") === -1);
}

var rescueFromPolymer = (function() {

    if (isSafari()) {

        return function(object) {

            if (!window.Polymer)
                return object;

            for (var p in object) {
                if (p.indexOf("__impl") !== -1) {
                    return object[p];
                }
            }
            return object;
        };

    } else {

        return function(o) { return o; };

    }

})();

/**
 * Detects if WebGL is enabled.
 *
 * @return { number } -1 for not Supported,
 *                    0 for disabled
 *                    1 for enabled
 */
function detectWebGL()
{
    // Check for the webgl rendering context
    if ( !! window.WebGLRenderingContext) {
        var canvas = document.createElement("canvas"),
            names = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"],
            context = false;

        for (var i = 0; i < 4; i++) {
            try {
                context = canvas.getContext(names[i]);
                context = rescueFromPolymer(context);
                if (context && typeof context.getParameter === "function") {
                    // WebGL is enabled.
                    //
                    return 1;
                }
            } catch (e) {}
        }

        // WebGL is supported, but disabled.
        //
        return 0;
    }

    // WebGL not supported.
    //
    return -1;
};


// Convert touchstart event to click to remove the delay between the touch and
// the click event which is sent after touchstart with about 300ms deley.
// Should be used in UI elements on touch devices.
function touchStartToClick(e) {
    e.preventDefault();  // Stops the firing of delayed click event.
    e.stopPropagation();
    e.target.click();    // Maps to immediate click.
}

//Safari doesn't have the Performance object
//We only need the now() function, so that's easy to emulate.
(function() {
    var global = getGlobal();
    if (!global.performance)
        global.performance = Date;
})();

;
//This file is the first one when creating minified build
//and is used to set certain flags that are needed
//for the concatenated build.

var av = Autodesk.Viewing;

var global = av.getGlobal();

global.IS_CONCAT_BUILD = true;

/** @define {string} */
global.BUILD_LMV_WORKER_URL = "lmvworker.js";
global.LMV_WORKER_URL = global.BUILD_LMV_WORKER_URL;

global.ENABLE_DEBUG = false;
global.ENABLE_TRACE = false;
global.ENABLE_INLINE_WORKER = true;
;/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
typeof window!=="undefined"&&(!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(k(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function i(a,b){return h(a,b,!0)}function j(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&h(d,c)}function k(a,b){return function(){return a.apply(b,arguments)}}function l(a,b){return typeof a==kb?a.apply(b?b[0]||d:d,b):a}function m(a,b){return a===d?b:a}function n(a,b,c){g(r(b),function(b){a.addEventListener(b,c,!1)})}function o(a,b,c){g(r(b),function(b){a.removeEventListener(b,c,!1)})}function p(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function q(a,b){return a.indexOf(b)>-1}function r(a){return a.trim().split(/\s+/g)}function s(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function t(a){return Array.prototype.slice.call(a,0)}function u(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];s(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function v(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ib.length;){if(c=ib[g],e=c?c+f:b,e in a)return e;g++}return d}function w(){return ob++}function x(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function y(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){l(a.options.enable,[a])&&c.handler(b)},this.init()}function z(a){var b,c=a.options.inputClass;return new(b=c?c:rb?N:sb?Q:qb?S:M)(a,A)}function A(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&yb&&d-e===0,g=b&(Ab|Bb)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,B(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function B(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=E(b)),e>1&&!c.firstMultiple?c.firstMultiple=E(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=F(d);b.timeStamp=nb(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=J(h,i),b.distance=I(h,i),C(c,b),b.offsetDirection=H(b.deltaX,b.deltaY),b.scale=g?L(g.pointers,d):1,b.rotation=g?K(g.pointers,d):0,D(c,b);var j=a.element;p(b.srcEvent.target,j)&&(j=b.srcEvent.target),b.target=j}function C(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===yb||f.eventType===Ab)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function D(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Bb&&(i>xb||h.velocity===d)){var j=h.deltaX-b.deltaX,k=h.deltaY-b.deltaY,l=G(i,j,k);e=l.x,f=l.y,c=mb(l.x)>mb(l.y)?l.x:l.y,g=H(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function E(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:lb(a.pointers[c].clientX),clientY:lb(a.pointers[c].clientY)},c++;return{timeStamp:nb(),pointers:b,center:F(b),deltaX:a.deltaX,deltaY:a.deltaY}}function F(a){var b=a.length;if(1===b)return{x:lb(a[0].clientX),y:lb(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:lb(c/b),y:lb(d/b)}}function G(a,b,c){return{x:b/a||0,y:c/a||0}}function H(a,b){return a===b?Cb:mb(a)>=mb(b)?a>0?Db:Eb:b>0?Fb:Gb}function I(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function J(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function K(a,b){return J(b[1],b[0],Lb)-J(a[1],a[0],Lb)}function L(a,b){return I(b[0],b[1],Lb)/I(a[0],a[1],Lb)}function M(){this.evEl=Nb,this.evWin=Ob,this.allow=!0,this.pressed=!1,y.apply(this,arguments)}function N(){this.evEl=Rb,this.evWin=Sb,y.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function O(){this.evTarget=Ub,this.evWin=Vb,this.started=!1,y.apply(this,arguments)}function P(a,b){var c=t(a.touches),d=t(a.changedTouches);return b&(Ab|Bb)&&(c=u(c.concat(d),"identifier",!0)),[c,d]}function Q(){this.evTarget=Xb,this.targetIds={},y.apply(this,arguments)}function R(a,b){var c=t(a.touches),d=this.targetIds;if(b&(yb|zb)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=t(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return p(a.target,i)}),b===yb)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ab|Bb)&&delete d[g[e].identifier],e++;return h.length?[u(f.concat(h),"identifier",!0),h]:void 0}function S(){y.apply(this,arguments);var a=k(this.handler,this);this.touch=new Q(this.manager,a),this.mouse=new M(this.manager,a)}function T(a,b){this.manager=a,this.set(b)}function U(a){if(q(a,bc))return bc;var b=q(a,cc),c=q(a,dc);return b&&c?cc+" "+dc:b||c?b?cc:dc:q(a,ac)?ac:_b}function V(a){this.id=w(),this.manager=null,this.options=i(a||{},this.defaults),this.options.enable=m(this.options.enable,!0),this.state=ec,this.simultaneous={},this.requireFail=[]}function W(a){return a&jc?"cancel":a&hc?"end":a&gc?"move":a&fc?"start":""}function X(a){return a==Gb?"down":a==Fb?"up":a==Db?"left":a==Eb?"right":""}function Y(a,b){var c=b.manager;return c?c.get(a):a}function Z(){V.apply(this,arguments)}function $(){Z.apply(this,arguments),this.pX=null,this.pY=null}function _(){Z.apply(this,arguments)}function ab(){V.apply(this,arguments),this._timer=null,this._input=null}function bb(){Z.apply(this,arguments)}function cb(){Z.apply(this,arguments)}function db(){V.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function eb(a,b){return b=b||{},b.recognizers=m(b.recognizers,eb.defaults.preset),new fb(a,b)}function fb(a,b){b=b||{},this.options=i(b,eb.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=z(this),this.touchAction=new T(this,this.options.touchAction),gb(this,!0),g(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function gb(a,b){var c=a.element;g(a.options.cssProps,function(a,d){c.style[v(c.style,d)]=b?a:""})}function hb(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var ib=["","webkit","moz","MS","ms","o"],jb=b.createElement("div"),kb="function",lb=Math.round,mb=Math.abs,nb=Date.now,ob=1,pb=/mobile|tablet|ip(ad|hone|od)|android/i,qb="ontouchstart"in a,rb=v(a,"PointerEvent")!==d,sb=qb&&pb.test(navigator.userAgent),tb="touch",ub="pen",vb="mouse",wb="kinect",xb=25,yb=1,zb=2,Ab=4,Bb=8,Cb=1,Db=2,Eb=4,Fb=8,Gb=16,Hb=Db|Eb,Ib=Fb|Gb,Jb=Hb|Ib,Kb=["x","y"],Lb=["clientX","clientY"];y.prototype={handler:function(){},init:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(x(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&o(this.element,this.evEl,this.domHandler),this.evTarget&&o(this.target,this.evTarget,this.domHandler),this.evWin&&o(x(this.element),this.evWin,this.domHandler)}};var Mb={mousedown:yb,mousemove:zb,mouseup:Ab},Nb="mousedown",Ob="mousemove mouseup";j(M,y,{handler:function(a){var b=Mb[a.type];b&yb&&0===a.button&&(this.pressed=!0),b&zb&&1!==a.which&&(b=Ab),this.pressed&&this.allow&&(b&Ab&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:vb,srcEvent:a}))}});var Pb={pointerdown:yb,pointermove:zb,pointerup:Ab,pointercancel:Bb,pointerout:Bb},Qb={2:tb,3:ub,4:vb,5:wb},Rb="pointerdown",Sb="pointermove pointerup pointercancel";a.MSPointerEvent&&(Rb="MSPointerDown",Sb="MSPointerMove MSPointerUp MSPointerCancel"),j(N,y,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Pb[d],f=Qb[a.pointerType]||a.pointerType,g=f==tb,h=s(b,a.pointerId,"pointerId");e&yb&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ab|Bb)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Tb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Ub="touchstart",Vb="touchstart touchmove touchend touchcancel";j(O,y,{handler:function(a){var b=Tb[a.type];if(b===yb&&(this.started=!0),this.started){var c=P.call(this,a,b);b&(Ab|Bb)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}});var Wb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Xb="touchstart touchmove touchend touchcancel";j(Q,y,{handler:function(a){var b=Wb[a.type],c=R.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}),j(S,y,{handler:function(a,b,c){var d=c.pointerType==tb,e=c.pointerType==vb;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Ab|Bb)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Yb=v(jb.style,"touchAction"),Zb=Yb!==d,$b="compute",_b="auto",ac="manipulation",bc="none",cc="pan-x",dc="pan-y";T.prototype={set:function(a){a==$b&&(a=this.compute()),Zb&&(this.manager.element.style[Yb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){l(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),U(a.join(" "))},preventDefaults:function(a){if(!Zb){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=q(d,bc),f=q(d,dc),g=q(d,cc);return e||f&&c&Hb||g&&c&Ib?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var ec=1,fc=2,gc=4,hc=8,ic=hc,jc=16,kc=32;V.prototype={defaults:{},set:function(a){return h(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=Y(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=Y(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=Y(a,this),-1===s(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=Y(a,this);var b=s(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(c.options.event+(b?W(d):""),a)}var c=this,d=this.state;hc>d&&b(!0),b(),d>=hc&&b(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=kc)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(kc|ec)))return!1;a++}return!0},recognize:function(a){var b=h({},a);return l(this.options.enable,[this,b])?(this.state&(ic|jc|kc)&&(this.state=ec),this.state=this.process(b),void(this.state&(fc|gc|hc|jc)&&this.tryEmit(b))):(this.reset(),void(this.state=kc))},process:function(){},getTouchAction:function(){},reset:function(){}},j(Z,V,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(fc|gc),e=this.attrTest(a);return d&&(c&Bb||!e)?b|jc:d||e?c&Ab?b|hc:b&fc?b|gc:fc:kc}}),j($,Z,{defaults:{event:"pan",threshold:10,pointers:1,direction:Jb},getTouchAction:function(){var a=this.options.direction,b=[];return a&Hb&&b.push(dc),a&Ib&&b.push(cc),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Hb?(e=0===f?Cb:0>f?Db:Eb,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Cb:0>g?Fb:Gb,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return Z.prototype.attrTest.call(this,a)&&(this.state&fc||!(this.state&fc)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),j(_,Z,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&fc)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),j(ab,V,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[_b]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ab|Bb)&&!f)this.reset();else if(a.eventType&yb)this.reset(),this._timer=e(function(){this.state=ic,this.tryEmit()},b.time,this);else if(a.eventType&Ab)return ic;return kc},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===ic&&(a&&a.eventType&Ab?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=nb(),this.manager.emit(this.options.event,this._input)))}}),j(bb,Z,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&fc)}}),j(cb,Z,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:Hb|Ib,pointers:1},getTouchAction:function(){return $.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Hb|Ib)?b=a.velocity:c&Hb?b=a.velocityX:c&Ib&&(b=a.velocityY),this._super.attrTest.call(this,a)&&c&a.direction&&a.distance>this.options.threshold&&mb(b)>this.options.velocity&&a.eventType&Ab},emit:function(a){var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),j(db,V,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[ac]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&yb&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ab)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||I(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=ic,this.tryEmit()},b.interval,this),fc):ic}return kc},failTimeout:function(){return this._timer=e(function(){this.state=kc},this.options.interval,this),kc},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==ic&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),eb.VERSION="2.0.4",eb.defaults={domEvents:!1,touchAction:$b,enable:!0,inputTarget:null,inputClass:null,preset:[[bb,{enable:!1}],[_,{enable:!1},["rotate"]],[cb,{direction:Hb}],[$,{direction:Hb},["swipe"]],[db],[db,{event:"doubletap",taps:2},["tap"]],[ab]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var lc=1,mc=2;fb.prototype={set:function(a){return h(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?mc:lc},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&ic)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===mc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(fc|gc|hc)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof V)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(s(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return g(r(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return g(r(a),function(a){b?c[a].splice(s(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&hb(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&gb(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},h(eb,{INPUT_START:yb,INPUT_MOVE:zb,INPUT_END:Ab,INPUT_CANCEL:Bb,STATE_POSSIBLE:ec,STATE_BEGAN:fc,STATE_CHANGED:gc,STATE_ENDED:hc,STATE_RECOGNIZED:ic,STATE_CANCELLED:jc,STATE_FAILED:kc,DIRECTION_NONE:Cb,DIRECTION_LEFT:Db,DIRECTION_RIGHT:Eb,DIRECTION_UP:Fb,DIRECTION_DOWN:Gb,DIRECTION_HORIZONTAL:Hb,DIRECTION_VERTICAL:Ib,DIRECTION_ALL:Jb,Manager:fb,Input:y,TouchAction:T,TouchInput:Q,MouseInput:M,PointerEventInput:N,TouchMouseInput:S,SingleTouchInput:O,Recognizer:V,AttrRecognizer:Z,Tap:db,Pan:$,Swipe:cb,Pinch:_,Rotate:bb,Press:ab,on:n,off:o,each:g,merge:i,extend:h,inherit:j,bindFn:k,prefixed:v}),/*Workaround for 'define' being overridden in A360 */ false && typeof define==kb&&define.amd?define(function(){return eb}):"undefined"!=typeof module&&module.exports && false /* Workaround for 'module' being defined by Angular.js in Columbus. */ ?module.exports=eb:a[c]=eb}(window,document,"Hammer"));
//# sourceMappingURL=hammer.min.map
;/*
 * @author mrdoob / http://mrdoob.com/
 */
 
function init_three_dds_loader() { 

THREE.DDSLoader = function () {
	this._parser = THREE.DDSLoader.parse;
};

THREE.DDSLoader.prototype = Object.create( THREE.CompressedTextureLoader.prototype );
THREE.DDSLoader.prototype.constructor = THREE.DDSLoader;

THREE.DDSLoader.parse = function ( buffer, loadMipmaps ) {

	var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

	// Adapted from @toji's DDS utils
	//	https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

	// All values and structures referenced from:
	// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

	var DDS_MAGIC = 0x20534444;

	var DDSD_CAPS = 0x1,
		DDSD_HEIGHT = 0x2,
		DDSD_WIDTH = 0x4,
		DDSD_PITCH = 0x8,
		DDSD_PIXELFORMAT = 0x1000,
		DDSD_MIPMAPCOUNT = 0x20000,
		DDSD_LINEARSIZE = 0x80000,
		DDSD_DEPTH = 0x800000;

	var DDSCAPS_COMPLEX = 0x8,
		DDSCAPS_MIPMAP = 0x400000,
		DDSCAPS_TEXTURE = 0x1000;

	var DDSCAPS2_CUBEMAP = 0x200,
		DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
		DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
		DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
		DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
		DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
		DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
		DDSCAPS2_VOLUME = 0x200000;

	var DDPF_ALPHAPIXELS = 0x1,
		DDPF_ALPHA = 0x2,
		DDPF_FOURCC = 0x4,
		DDPF_RGB = 0x40,
		DDPF_YUV = 0x200,
		DDPF_LUMINANCE = 0x20000;

	function fourCCToInt32( value ) {

		return value.charCodeAt(0) +
			(value.charCodeAt(1) << 8) +
			(value.charCodeAt(2) << 16) +
			(value.charCodeAt(3) << 24);

	}

	function int32ToFourCC( value ) {

		return String.fromCharCode(
			value & 0xff,
			(value >> 8) & 0xff,
			(value >> 16) & 0xff,
			(value >> 24) & 0xff
		);
	}

	function loadARGBMip( buffer, dataOffset, width, height ) {
		var dataLength = width * height * 4;
		var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
		var byteArray = new Uint8Array( dataLength );
		var dst = 0;
		var src = 0;
		for ( var y = 0; y < height; y ++ ) {
			for ( var x = 0; x < width; x ++ ) {
				var b = srcBuffer[src]; src ++;
				var g = srcBuffer[src]; src ++;
				var r = srcBuffer[src]; src ++;
				var a = srcBuffer[src]; src ++;
				byteArray[dst] = r; dst ++;	//r
				byteArray[dst] = g; dst ++;	//g
				byteArray[dst] = b; dst ++;	//b
				byteArray[dst] = a; dst ++;	//a
			}
		}
		return byteArray;
	}

	var FOURCC_DXT1 = fourCCToInt32("DXT1");
	var FOURCC_DXT3 = fourCCToInt32("DXT3");
	var FOURCC_DXT5 = fourCCToInt32("DXT5");

	var headerLengthInt = 31; // The header length in 32 bit ints

	// Offsets into the header array

	var off_magic = 0;

	var off_size = 1;
	var off_flags = 2;
	var off_height = 3;
	var off_width = 4;

	var off_mipmapCount = 7;

	var off_pfFlags = 20;
	var off_pfFourCC = 21;
	var off_RGBBitCount = 22;
	var off_RBitMask = 23;
	var off_GBitMask = 24;
	var off_BBitMask = 25;
	var off_ABitMask = 26;

	var off_caps = 27;
	var off_caps2 = 28;
	var off_caps3 = 29;
	var off_caps4 = 30;

	// Parse header

	var header = new Int32Array( buffer, 0, headerLengthInt );

	if ( header[ off_magic ] !== DDS_MAGIC ) {

		console.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );
		return dds;

	}

	if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

		console.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );
		return dds;

	}

	var blockBytes;

	var fourCC = header[ off_pfFourCC ];

	var isRGBAUncompressed = false;

	switch ( fourCC ) {

		case FOURCC_DXT1:

			blockBytes = 8;
			dds.format = THREE.RGB_S3TC_DXT1_Format;
			break;

		case FOURCC_DXT3:

			blockBytes = 16;
			dds.format = THREE.RGBA_S3TC_DXT3_Format;
			break;

		case FOURCC_DXT5:

			blockBytes = 16;
			dds.format = THREE.RGBA_S3TC_DXT5_Format;
			break;

		default:

			if ( header[off_RGBBitCount] == 32 
				&& header[off_RBitMask]&0xff0000
				&& header[off_GBitMask]&0xff00 
				&& header[off_BBitMask]&0xff
				&& header[off_ABitMask]&0xff000000  ) {
				isRGBAUncompressed = true;
				blockBytes = 64;
				dds.format = THREE.RGBAFormat;
			} else {
				console.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );
				return dds;
			}
	}

	dds.mipmapCount = 1;

	if ( header[ off_mipmapCount ] > 0 && loadMipmaps !== false ) {

		dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

	}

	//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.

	dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;

	dds.width = header[ off_width ];
	dds.height = header[ off_height ];

	var dataOffset = header[ off_size ] + 4;

	// Extract mipmaps buffers

	var width = dds.width;
	var height = dds.height;

	var faces = dds.isCubemap ? 6 : 1;

	for ( var face = 0; face < faces; face ++ ) {

		for ( var i = 0; i < dds.mipmapCount; i ++ ) {

			if ( isRGBAUncompressed ) {
				var byteArray = loadARGBMip( buffer, dataOffset, width, height );
				var dataLength = byteArray.length;
			} else {
				var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
				var byteArray = new Uint8Array( buffer, dataOffset, dataLength );
			}
			
			var mipmap = { "data": byteArray, "width": width, "height": height };
			dds.mipmaps.push( mipmap );

			dataOffset += dataLength;

			width = Math.max( width * 0.5, 1 );
			height = Math.max( height * 0.5, 1 );

		}

		width = dds.width;
		height = dds.height;

	}

	return dds;

};

};/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */
/* Pruned version of THREE.Matrix4, for use in the LMV web worker */

LmvMatrix4 = function (useDoublePrecision) {

	if (useDoublePrecision) {

		this.elements = new Float64Array( [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		] );

	} else {

		this.elements = new Float32Array( [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		] );

	}

};

LmvMatrix4.prototype = {

	constructor: LmvMatrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	multiply: function ( n ) {

		return this.multiplyMatrices( this, n );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	},

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

    //Added for LMV
    transformPoint: function (pt) {

            // input: THREE.Matrix4 affine matrix

            var x = pt.x, y = pt.y, z = pt.z;

            var e = this.elements;

            pt.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
            pt.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
            pt.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

            return pt;
    },

    //Added for LMV
    transformDirection: function(v) {

            // input: THREE.Matrix4 affine matrix
            // vector interpreted as a direction

            var x = v.x, y = v.y, z = v.z;

            var e = this.elements;

            v.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
            v.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
            v.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

            var len = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
            if (len > 0) {
                var ilen = 1.0 / len;
                v.x *= ilen;
                v.y *= ilen;
                v.z *= ilen;
            }

            return v;
    },


	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		return new LmvMatrix4().fromArray( this.elements );

	}

};
;!function(e){/*if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else*/{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.lmv_poly2tri=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports={"version": "1.3.5"}
},{}],2:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @constructor
 * @private
 * @struct
 * @param {!XY} p - Point
 * @param {Triangle=} t triangle (optional)
 */
var Node = function(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
/**
 * @constructor
 * @private
 * @struct
 * @param {Node} head
 * @param {Node} tail
 */
var AdvancingFront = function(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
};

/** @return {Node} */
AdvancingFront.prototype.head = function() {
    return this.head_;
};

/** @param {Node} node */
AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

/** @param {Node} node */
AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

/** @param {Node} node */
AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

/**
 * @param {number} x value
 * @return {Node}
 */
AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

/**
 * @param {!XY} point - Point
 * @return {Node}
 */
AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;


},{}],3:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Function added in the JavaScript version (was not present in the c++ version)
 */

/**
 * assert and throw an exception.
 *
 * @private
 * @param {boolean} condition   the condition which is asserted
 * @param {string} message      the message which is display is condition is falsy
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assert Failed");
    }
}
module.exports = assert;



},{}],4:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_('./xy');

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @example
 *      var point = new poly2tri.Point(150, 150);
 * @public
 * @constructor
 * @struct
 * @param {number=} x    coordinate (0 if undefined)
 * @param {number=} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
};

/**
 * For pretty printing
 * @example
 *      "p=" + new poly2tri.Point(5,42)
 *      // → "p=(5;42)"
 * @returns {string} <code>"(x;y)"</code>
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * JSON output, only coordinates
 * @example
 *      JSON.stringify(new poly2tri.Point(1,2))
 *      // → '{"x":1,"y":2}'
 */
Point.prototype.toJSON = function() {
    return { x: this.x, y: this.y };
};

/**
 * Creates a copy of this Point object.
 * @return {Point} new cloned point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 * @return {Point} this (for chaining)
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param {number} x   coordinate
 * @param {number} y   coordinate
 * @return {Point} this (for chaining)
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 * @return {Point} this (for chaining)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param {number} s   scalar.
 * @return {Point} this (for chaining)
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 * @return {number} distance
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return {number} The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param {number} s - the scalar
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param  {XY|number} a - Point object or scalar.
 * @param  {XY|number} b - Point object or scalar.
 * @return {Point|number} a Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @public
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {number} The dot product
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;

},{"./xy":11}],5:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = _dereq_('./xy');

/**
 * Custom exception class to indicate invalid Point values
 * @constructor
 * @public
 * @extends Error
 * @struct
 * @param {string=} message - error message
 * @param {Array.<XY>=} points - invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;

},{"./xy":11}],6:[function(_dereq_,module,exports){
(function (global){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

"use strict";

/**
 * Public API for poly2tri.js
 * @module poly2tri
 */


/**
 * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library
 * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.
 * @name poly2tri
 * @global
 * @public
 * @type {module:poly2tri}
 */
var previousPoly2tri = global.poly2tri;
/**
 * For Browser + &lt;script&gt; :
 * reverts the {@linkcode poly2tri} global object to its previous value,
 * and returns a reference to the instance called.
 *
 * @example
 *              var p = poly2tri.noConflict();
 * @public
 * @return {module:poly2tri} instance called
 */
// (this feature is not automatically provided by browserify).
exports.noConflict = function() {
    global.poly2tri = previousPoly2tri;
    return exports;
};

/**
 * poly2tri library version
 * @public
 * @const {string}
 */
exports.VERSION = _dereq_('../dist/version.json').version;

/**
 * Exports the {@linkcode PointError} class.
 * @public
 * @typedef {PointError} module:poly2tri.PointError
 * @function
 */
exports.PointError = _dereq_('./pointerror');
/**
 * Exports the {@linkcode Point} class.
 * @public
 * @typedef {Point} module:poly2tri.Point
 * @function
 */
exports.Point = _dereq_('./point');
/**
 * Exports the {@linkcode Triangle} class.
 * @public
 * @typedef {Triangle} module:poly2tri.Triangle
 * @function
 */
exports.Triangle = _dereq_('./triangle');
/**
 * Exports the {@linkcode SweepContext} class.
 * @public
 * @typedef {SweepContext} module:poly2tri.SweepContext
 * @function
 */
exports.SweepContext = _dereq_('./sweepcontext');


// Backward compatibility
var sweep = _dereq_('./sweep');
/**
 * @function
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 */
exports.triangulate = sweep.triangulate;
/**
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead
 */
exports.sweep = {Triangulate: sweep.triangulate};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */

"use strict";

/**
 * This 'Sweep' module is present in order to keep this JavaScript version
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
 * @module
 * @private
 */

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var assert = _dereq_('./assert');
var PointError = _dereq_('./pointerror');
var Triangle = _dereq_('./triangle');
var Node = _dereq_('./advancingfront').Node;


// ------------------------------------------------------------------------utils

var utils = _dereq_('./utils');

/** @const */
var EPSILON = utils.EPSILON;

/** @const */
var Orientation = utils.Orientation;
/** @const */
var orient2d = utils.orient2d;
/** @const */
var inScanArea = utils.inScanArea;
/** @const */
var isAngleObtuse = utils.isAngleObtuse;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @private
 * @param {!SweepContext} tcx - SweepContext object
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param {!SweepContext} tcx - SweepContext object
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

/**
 * @param {!SweepContext} tcx - SweepContext object
 */
function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 * @param {!SweepContext} tcx - SweepContext object
 * @param {!XY} point   Point
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 * @param {!SweepContext} tcx - SweepContext object
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 * @param {!SweepContext} tcx - SweepContext object
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0].
 * @param {Node} node
 * @return {boolean} true if angle < 3*π/4
 */
function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return (ax >= 0 || Math.abs(ax) < ay);
}

/**
 * Returns true if triangle was legalized
 * @param {!SweepContext} tcx - SweepContext object
 * @return {boolean}
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return {boolean} true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");

    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelaunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");

    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;

},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = _dereq_('./pointerror');
var Point = _dereq_('./point');
var Triangle = _dereq_('./triangle');
var sweep = _dereq_('./sweep');
var AdvancingFront = _dereq_('./advancingfront');
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/**
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 * @private
 * @const
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @constructor
 * @struct
 * @private
 * @param {Point} p1
 * @param {Point} p2
 * @throw {PointError} if p1 is same as p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
/**
 * @constructor
 * @struct
 * @private
 */
var Basin = function() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
/**
 * @constructor
 * @struct
 * @private
 */
var EdgeEvent = function() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * SweepContext constructor option
 * @typedef {Object} SweepContextOptions
 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is <code>false</code> : keep a reference to the array arguments,
 *                  who will be modified in place.
 */
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 *
 * @example
 *          var contour = [
 *              new poly2tri.Point(100, 100),
 *              new poly2tri.Point(100, 300),
 *              new poly2tri.Point(300, 300),
 *              new poly2tri.Point(300, 100)
 *          ];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @example
 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @constructor
 * @public
 * @struct
 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
 *          or any "Point like" custom class with <code>{x, y}</code> attributes.
 * @param {SweepContextOptions=} options - constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var hole = [
 *          new poly2tri.Point(200, 200),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addHole(hole);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addHole} instead
 */
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add several holes to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
 *      ];
 *      swctx.addHoles(holes);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
 *      ];
 *      swctx.addHoles(holes);
 * @public
 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addHoles = function(holes) {
    var i, len = holes.length;
    for (i = 0; i < len; i++) {
        this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
};


/**
 * Add a Steiner point to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var point = new poly2tri.Point(150, 150);
 *      swctx.addPoint(point);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoint({x:150, y:150});
 * @public
 * @param {XY} point - any "Point like" object with {x,y}
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addPoint} instead
 */
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var points = [
 *          new poly2tri.Point(150, 150),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addPoints(points);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @public
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @public
 * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation.
 * The output triangles have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @public
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#getTriangles} instead
 */
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

/** @private */
SweepContext.prototype.front = function() {
    return this.front_;
};

/** @private */
SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

/** @private */
SweepContext.prototype.head = function() {
    return this.head_;
};

/** @private */
SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

/** @private */
SweepContext.prototype.tail = function() {
    return this.tail_;
};

/** @private */
SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

/** @private */
SweepContext.prototype.getMap = function() {
    return this.map_;
};

/** @private */
SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

/** @private */
SweepContext.prototype.initEdges = function(polyline, isOpen) {
    var i, len = polyline.length, iEnd = isOpen ? polyline.length-1 : polyline.length;
    for (i = 0; i < iEnd; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

/** @private */
SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

/** @private */
SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

/** @private */
SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

/** @private */
SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

/** @private */
SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

/** @private */
SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

/** @private */
SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @private
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;

},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_("./xy");


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 *
 * @constructor
 * @struct
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 */
var Triangle = function(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
};

var p2s = xy.toString;
/**
 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
 * @public
 * @return {string}
 */
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

/**
 * Get one vertice of the triangle.
 * The output triangles of a triangulation have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @param {number} index - vertice index: 0, 1 or 2
 * @public
 * @returns {XY}
 */
Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode Triangle#getPoint} instead
 */
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

/**
 * Get all 3 vertices of the triangle as an array
 * @public
 * @return {Array.<XY>}
 */
// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

/**
 * @private
 * @param {number} index
 * @returns {?Triangle}
 */
Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
 * Only point references are compared, not values.
 * @public
 * @param {XY} point - point object with {x,y}
 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @private
 * @param {Edge} edge
 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};

/**
 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
 * Only point references are compared, not values.
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {boolean}
 */
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};

/**
 * Has this triangle been marked as an interior triangle?
 * @returns {boolean}
 */
Triangle.prototype.isInterior = function() {
    return this.interior_;
};

/**
 * Mark this triangle as an interior triangle
 * @private
 * @param {boolean} interior
 * @returns {Triangle} this
 */
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @param {Triangle} t Triangle object.
 * @throws {Error} if can't find objects
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @private
 * @param {!Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeighbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelaunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {Triangle}
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

/**
 * @private
 * @param {!Triangle} t Triangle object.
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @private
 * @param {XY} opoint - point object with {x,y}
 * @param {XY} npoint - point object with {x,y}
 * @throws {Error} if oPoint can not be found
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {number} index 0, 1 or 2
 * @throws {Error} if p can not be found
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

/**
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {number} index 0, 1 or 2, or -1 if errror
 */
Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {number} index - edge index
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {Edge} edge instance
 */
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
/**
 * Mark an edge of this triangle as constrained.
 * This method takes two Point instances defining the edge of the triangle.
 * @private
 * @param {XY} p - point object with {x,y}
 * @param {XY} q - point object with {x,y}
 */
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;

},{"./xy":11}],10:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
var EPSILON = 1e-12;
exports.EPSILON = EPSILON;

/**
 * @private
 * @enum {number}
 * @readonly
 */
var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};
exports.Orientation = Orientation;


/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}
exports.orient2d = orient2d;


/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}
exports.inScanArea = inScanArea;


/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return (ax * bx + ay * by) < 0;
}
exports.isAngleObtuse = isAngleObtuse;


},{}],11:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * The following functions operate on "Point" or any "Point like" object with {x,y},
 * as defined by the {@link XY} type
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 * @module
 * @private
 */

/**
 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
 * Any "Point like" object with <code>{x, y}</code> attributes is supported
 * to initialize the SweepContext polylines and points
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 *
 * poly2tri.js might add extra fields to the point objects when computing the
 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
 * with fields in the custom class.
 *
 * @example
 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *
 * @typedef {Object} XY
 * @property {number} x - x coordinate
 * @property {number} y - y coordinate
 */


/**
 * Point pretty printing : prints x and y coordinates.
 * @example
 *      xy.toStringBase({x:5, y:42})
 *      // → "(5;42)"
 * @protected
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}

/**
 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
 * else simply prints x and y coordinates.
 * @example
 *      xy.toString({x:5, y:42})
 *      // → "(5;42)"
 * @example
 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
 *      // → "5:42"
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}


/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};

},{}]},{},[6])
(6)
});;
(function() {

"use strict";

var av = Autodesk.Viewing;

av.EventDispatcher = function() {
};


av.EventDispatcher.prototype = {

    constructor: av.EventDispatcher,


    apply: function(object) {
    
		object.addEventListener = av.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = av.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = av.EventDispatcher.prototype.removeEventListener;
		object.fireEvent = av.EventDispatcher.prototype.fireEvent;
		object.dispatchEvent = av.EventDispatcher.prototype.fireEvent;
    },

    /**
     * Adds an event listener.
     * @param {(string | type)} type
     * @param {function} listener
     */
    addEventListener : function(type, listener)
    {
		if ( this.listeners === undefined ) this.listeners = {};
    
        if (typeof this.listeners[type] == "undefined"){
            this.listeners[type] = [];
        }

        this.listeners[type].push(listener);
    },

    /**
     * Returns true if the specified listener already exists, false otherwise.
     * @param {(string)} type
     * @param {function} listener
     */
    hasEventListener : function (type, listener) {
        
        if (this.listeners === undefined) return false;
        var listeners = this.listeners;
        if (listeners[ type ] !== undefined && listeners[ type ].indexOf(listener) !== -1) {
            return true;
        }

        return false;
    },


    /**
     * @param {(string)} type
     * @param {function} listener
     */
    removeEventListener : function(type, listener)
    {
		if ( this.listeners === undefined ) this.listeners = {};
    
        if (this.listeners[type] instanceof Array){
            var li = this.listeners[type];
            for (var i=0, len=li.length; i < len; i++){
                if (li[i] === listener){
                    li.splice(i, 1);
                    break;
                }
            }
        }
    },


    /**
     * @param {(string | type)} event
     */
    fireEvent : function(event)
    {
		if ( this.listeners === undefined ) this.listeners = {};
    
        if (typeof event == "string"){
            event = { type: event };
        }
        if (!event.target){
            try {
                event.target = this;
            } catch (e) {}
        }

        if (!event.type){
            throw new Error("event type unknown.");
        }

        if (this.listeners[event.type] instanceof Array) {
            var typeListeners = this.listeners[event.type].slice();
            for (var i=0; i < typeListeners.length; i++) {
                    typeListeners[i].call(this, event);
            }
        }
    }

};



})();;
/**
 * Base class for file loaders.
 *
 * It is highly recommended that file loaders use worker threads to perform the actual loading in order to keep the
 * UI thread free. Once loading is complete, the loader should call viewer.impl.onLoadComplete(). During loading,
 * the loader can use viewer.impl.signalProgress(int, string) to indicate how far along the process is.
 *
 * To add geometry to the viewer, viewer.impl.addMeshInstance(geometry, meshId, materialId, matrix) should be used.
 * Geometry must be THREE.BufferGeometry, meshId is a number, materialId is a string, and matrix is the THREE.Matrix4
 * transformation matrix to be applied to the geometry.
 *
 * Remember to add draw calls to the BufferGeometry if the geometry has more than 65535 faces.
 *
 * @param {Autodesk.Viewing.Viewer3D} viewer - The viewer.
 * @constructor
 * @abstract
 */
Autodesk.Viewing.FileLoader = function(viewer) {
    this.viewer = viewer;
};

Autodesk.Viewing.FileLoader.prototype.constructor = Autodesk.Viewing.FileLoader;

/**
 * Initiates the loading of a file from the given URL.
 *
 * This method must be overridden.
 *
 * @param {String} url - The url for the file.
 * @param {Object} [options] - An optional dictionary of options.
 * @param {String} [options.ids] A list of object id to load.
 * @param {String} [options.sharedPropertyDbPath] Optional path to shared property database
 * @param {Function} [onSuccess] - Callback function when the file begins loading successfully. Takes no arguments.
 * @param {Function} [onError] - Callback function when an error occurs. Passed an integer error code and a string description of the error.
 */
Autodesk.Viewing.FileLoader.prototype.loadFile = function(url, options, onSuccess, onError) {
    return false;
};
;
(function() {

"use strict";

/**
 * The FileLoaderManager manages a set of file loaders available to the viewer.
 * Register, retrieve, and unregister your file loaders using the singleton theFileLoader.
 *
 * @constructor
 */
var FileLoaderManager = function () {
    var fileLoaders = {};

    /**
     * Registers a new file loader with the given id.
     *
     * @param {String} fileLoaderId - The string id of the file loader.
     * @param {String[]} fileExtensions - The array of supported file extensions. Ex: ['stl', 'obj']
     * @param {Function} fileLoaderClass - The file loader constructor.
     * @returns {Boolean} - True if the file loader was successfully registered.
     */
    function registerFileLoader(fileLoaderId, fileExtensions, fileLoaderClass) {
        if (!fileLoaders[fileLoaderId]) {
            fileLoaders[fileLoaderId] = {
                loader: fileLoaderClass,
                extensions: fileExtensions
            };
            return true;
        }
        return false;
    }

    /**
     * Returns the file loader for a given ID.
     *
     * @param {String} fileLoaderId - The string id of the file loader.
     * @returns {Function?} - The file loader constructor if one was registered; null otherwise.
     */
    function getFileLoader(fileLoaderId) {
        if (fileLoaders[fileLoaderId]) {
            return fileLoaders[fileLoaderId].loader;
        }
        return null;
    }

    /**
     * Unregisters an existing file loader with the given id.
     *
     * @param {String} fileLoaderId - The string id of the file loader.
     * @returns {Boolean} - True if the file loader was successfully unregistered.
     */
    function unregisterFileLoader(fileLoaderId) {
        if (fileLoaders[fileLoaderId]) {
            delete fileLoaders[fileLoaderId];
            return true;
        }
        return false;
    }

    /**
     * Returns a file loader that supports the given extension.
     *
     * @param {String} fileExtension - The file extension.
     *
     * @returns {Function?} - The file loader constructor if one is found; null otherwise.
     */
    function getFileLoaderForExtension(fileExtension) {
        fileExtension = fileExtension ? fileExtension.toLowerCase() : "";
        for (var fileLoaderId in fileLoaders) {
            var fileLoader = fileLoaders[fileLoaderId];
            if (fileLoader) {
                for (var i = 0; i < fileLoader.extensions.length; i++) {
                    if (fileLoader.extensions[i].toLowerCase() === fileExtension) {
                        return fileLoader.loader;
                    }
                }
            }
        }

        return null;
    }

    return {
        registerFileLoader: registerFileLoader,
        getFileLoader: getFileLoader,
        getFileLoaderForExtension: getFileLoaderForExtension,
        unregisterFileLoader: unregisterFileLoader
    };
};

var av = Autodesk.Viewing;
av.FileLoaderManager = new FileLoaderManager();

})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var fsNames = ['fullscreenchange', 'mozfullscreenchange', 'webkitfullscreenchange', 'MSFullscreenChange'];

function addListener(listener) {
    for (var i=0; i<fsNames.length; ++i)
        document.addEventListener(fsNames[i], listener, false);
}

function removeListener(listener) {
    for (var i=0; i<fsNames.length; ++i)
        document.removeEventListener(fsNames[i], listener, false);
}


/**
 * Enum for screen modes: normal, full browser, and full screen
 * @readonly
 * @enum {number}
 */
av.ScreenMode = {kNormal: 0, kFullBrowser: 1, kFullScreen: 2};


/**
 * ScreenModeDelegate virtual base class
 * Derive from this class and use it to allow viewer to go full screen
 * @constructor
 * @param {Autodesk.Viewing.Viewer} viewer
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.ScreenModeDelegate
 */
function ScreenModeDelegate(viewer) {
    this.viewer = viewer;
    this.bindFullscreenEventListener = this.fullscreenEventListener.bind(this);

    if (this.getMode() === av.ScreenMode.kFullScreen) {
        addListener(this.bindFullscreenEventListener);
    }
}

av.ScreenModeDelegate = ScreenModeDelegate;

/**
 * Perform any cleanup required for a ScreenModeDelegate instance
 */
ScreenModeDelegate.prototype.uninitialize = function () {

    removeListener(this.bindFullscreenEventListener);
    this.viewer = null;
};

/**
 * Is screen mode supported?
 * Returning false for kNormal means no screen mode changes are supported
 * @param {Autodesk.Viewing.ScreenMode} mode
 * @returns {boolean} true if screen mode is supported
 */
ScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return true;
};

/**
 * Set new screen mode
 * @param {Autodesk.Viewing.ScreenMode} mode - New screen mode
 * @returns {boolean} true if screen mode was changed
 */
ScreenModeDelegate.prototype.setMode = function (mode) {
    var currentMode = this.getMode();
    if ((mode !== currentMode) && this.isModeSupported(mode)) {
        this.doScreenModeChange(currentMode, mode);
        this.onScreenModeChanged(currentMode, mode);
        return true;
    }
    return false;
};

/**
 * Override this method to get the current screen mode
 * @returns {Autodesk.Viewing.ScreenMode} Current screen mode
 */
ScreenModeDelegate.prototype.getMode = function () {
    throw 'Implement getMode() in derived class';
};

/**
 * Return next screen mode in sequence
 * Depending upon isModeSupported(), this may be a toggle or a 3-state
 * @returns {Autodesk.Viewing.ScreenMode|undefined} Next screen mode in sequence or undefined if no change
 */
ScreenModeDelegate.prototype.getNextMode = function () {
    var currentMode = this.getMode(),
        newMode;

    var SM = av.ScreenMode;

    if (currentMode === SM.kNormal &&
        this.isModeSupported(SM.kFullBrowser)) {

        newMode = SM.kFullBrowser;

    } else if (currentMode === SM.kNormal &&
        this.isModeSupported(SM.kFullScreen)) {

        newMode = SM.kFullScreen;

    } else if (currentMode === SM.kFullBrowser &&
        this.isModeSupported(SM.kFullScreen)) {

        newMode = SM.kFullScreen;

    } else if (currentMode === SM.kFullBrowser &&
        this.isModeSupported(SM.kNormal)) {

        newMode = SM.kNormal;

    } else if (currentMode === SM.kFullScreen &&
        this.isModeSupported(SM.kNormal)) {

        newMode = SM.kNormal;

    } else if (currentMode === SM.kFullScreen &&
        this.isModeSupported(SM.kFullBrowser)) {

        newMode = SM.kFullBrowser;
    }
    return newMode;
};

/**
 * Return new screen mode on escape
 * @returns {Autodesk.Viewing.ScreenMode|undefined} New screen mode or undefined if no change
 */
ScreenModeDelegate.prototype.getEscapeMode = function () {
    return (this.getMode() !== av.ScreenMode.kNormal) ?
        av.ScreenMode.kNormal : undefined;
};

/**
 * Full screen event listener.
 */
ScreenModeDelegate.prototype.fullscreenEventListener = function () {
    if (inFullscreen()) {
        this.viewer.resize();
    } else {
        var ScreenMode = av.ScreenMode;
        this.doScreenModeChange(ScreenMode.kFullScreen, ScreenMode.kNormal);
        this.onScreenModeChanged(ScreenMode.kFullScreen, ScreenMode.kNormal);
    }
};

/**
 * Override this method to make the screen mode change occur
 * @param {Autodesk.Viewing.ScreenMode} oldMode - Old screen mode
 * @param {Autodesk.Viewing.ScreenMode} newMode - New screen mode
 */
ScreenModeDelegate.prototype.doScreenModeChange = function (oldMode, newMode) {
    throw 'Implement doScreenModeChange() in derived class';
};

/**
 * Called after the screen mode changes
 * @param {Autodesk.Viewing.ScreenMode} oldMode - Old screen mode
 * @param {Autodesk.Viewing.ScreenMode} newMode - New screen mode
 */
ScreenModeDelegate.prototype.onScreenModeChanged = function (oldMode, newMode) {
    if (oldMode === av.ScreenMode.kFullScreen) {
        removeListener(this.bindFullscreenEventListener);
    } else if (newMode === av.ScreenMode.kFullScreen) {
        addListener(this.bindFullscreenEventListener);
    }

    this.viewer.resize();
    this.viewer.fireEvent({type: av.FULLSCREEN_MODE_EVENT, mode: newMode});
};





/**
 * ApplicationScreenModeDelegate class
 * Allows viewer to go full screen. Unlike ViewerScreenModeDelegate class, this delegate
 * doesn't use the full browser state, and it takes the entire page full screen, not just
 * the viewer.
 * @constructor
 * @extends Autodesk.Viewing.ScreenModeDelegate
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.ApplicationScreenModeDelegate
 * @param {Autodesk.Viewing.Viewer} viewer
 */
av.ApplicationScreenModeDelegate = function (viewer) {
    av.ScreenModeDelegate.call(this, viewer);
};

av.ApplicationScreenModeDelegate.prototype = Object.create(av.ScreenModeDelegate.prototype);
av.ApplicationScreenModeDelegate.prototype.constructor = av.ApplicationScreenModeDelegate;

av.ApplicationScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return mode !== av.ScreenMode.kFullBrowser;
};

av.ApplicationScreenModeDelegate.prototype.getMode = function () {
    return inFullscreen() ?
        av.ScreenMode.kFullScreen :
        av.ScreenMode.kNormal;
};

av.ApplicationScreenModeDelegate.prototype.doScreenModeChange = function (oldMode, newMode) {
    var container = this.viewer.container;
    if (newMode === av.ScreenMode.kNormal) {
        container.classList.remove('viewer-fill-browser');
        exitFullscreen();
    } else if (newMode === av.ScreenMode.kFullScreen) {
        container.classList.add('viewer-fill-browser');
        launchFullscreen(container);
    }
};



/**
 * NullScreenModeDelegate class
 * No full screen functionality.
 * @constructor
 * @extends Autodesk.Viewing.ScreenModeDelegate
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.NullScreenModeDelegate
 * @param {Autodesk.Viewing.Viewer} viewer
 */
av.NullScreenModeDelegate = function (viewer) {
    av.ScreenModeDelegate.call(this, viewer);
};

av.NullScreenModeDelegate.prototype = Object.create(av.ScreenModeDelegate.prototype);
av.NullScreenModeDelegate.prototype.constructor = av.ScreenModeDelegate;


av.NullScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return false; // No screen modes supported
};

av.NullScreenModeDelegate.prototype.getMode = function () {
    return av.ScreenMode.kNormal;
};





av.ScreenModeMixin = function() {
};


av.ScreenModeMixin.prototype = {

    /**
     * Set new screen mode delegate
     * @param {Autodesk.Viewing.ScreenModeDelegate} delegate - New screen mode delegate class
     */
    setScreenModeDelegate : function (delegate) {
        if (this.screenModeDelegate) {
            this.screenModeDelegate.uninitialize();
            this.screenModeDelegate = null;
        }

        // null -> Fullscreen not available
        // undefined -> Use default ApplicationScreenModeDelegate
        //
        if (delegate) {
            this.screenModeDelegateClass = delegate;
        } else if (delegate === null) {
            this.screenModeDelegateClass = av.NullScreenModeDelegate;
        } else { // undefined
            this.screenModeDelegateClass = av.ApplicationScreenModeDelegate;
        }
    },

    /**
     * Get current screen mode delegate
     * If no screen mode delegate has been set, then use Autodesk.Viewing.ViewerScreenModeDelegate.
     * @returns {Autodesk.Viewing.ScreenModeDelegate} Current screen mode delegate
     */
    getScreenModeDelegate : function () {
        if (!this.screenModeDelegate) {
            this.screenModeDelegate = new this.screenModeDelegateClass(this);
        }
        return this.screenModeDelegate;
    },


    /**
     * Is specified screen mode supported?
     * @param {Autodesk.Viewing.ScreenMode} mode
     * @returns {boolean} true if screen mode is supported
     */
    isScreenModeSupported : function (mode) {
        return this.getScreenModeDelegate().isModeSupported(mode);
    },

    /**
     * Is changing screen modes supported?
     * @returns {boolean} true if viewer supports changing screen modes
     */
    canChangeScreenMode :  function () {
        return this.isScreenModeSupported(Autodesk.Viewing.ScreenMode.kNormal);
    },

    /**
     * Set new screen mode
     * @param {Autodesk.Viewing.ScreenMode} mode - New screen mode
     * @returns {boolean} true if screen mode was changed
     */
    setScreenMode : function (mode) {

        var logger = avp.logger;
        if (logger) {
            var msg = {
                category: "screen_mode",
                value: mode
            };
            logger.log(msg);
        }

        return this.getScreenModeDelegate().setMode(mode);
    },

    /**
     * Get current screen mode
     * @returns {Autodesk.Viewing.ScreenMode} Current screen mode
     */
    getScreenMode : function () {
        return this.getScreenModeDelegate().getMode();
    },

    /**
     * Set screen mode to next in sequence
     * @returns {boolean} true if screen mode was changed
     */
    nextScreenMode : function () {
        var mode = this.getScreenModeDelegate().getNextMode();
        return (mode !== undefined) ? this.setScreenMode(mode) : false;
    },

    /**
     * Screen mode escape key handler
     * @returns {boolean} true if screen mode was changed
     */
    escapeScreenMode : function () {
        var mode = this.getScreenModeDelegate().getEscapeMode();
        return (mode !== undefined) ? this.setScreenMode(mode) : false;
    },


    apply : function(object) {

        var p = av.ScreenModeMixin.prototype;
        object.setScreenModeDelegate = p.setScreenModeDelegate;
        object.getScreenModeDelegate = p.getScreenModeDelegate;
        object.isScreenModeSupported = p.isScreenModeSupported;
        object.canChangeScreenMode = p.canChangeScreenMode;
        object.setScreenMode = p.setScreenMode;
        object.getScreenMode = p.getScreenMode;
        object.nextScreenMode = p.nextScreenMode;
        object.escapeScreenMode = p.escapeScreenMode;
    }

};



})();;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

(function() {

"use strict";

var av = Autodesk.Viewing;

var ModelUnits = {
    METER       : 'm',
    CENTIMETER  : 'cm',
    MILLIMETER  : 'mm',
    FOOT        : 'ft',
    INCH        : 'in'
};

av.ModelUnits = ModelUnits;

/**
 * This is the core class to represent the geometry.
 * @class
 * @alias Autodesk.Viewing.Model
 */
var Model = function( modelData )
{
    this.myData = modelData;

    this.sharedPath = null;
    this.propWorker = null;
};


av.EventDispatcher.prototype.apply( Model.prototype );
Model.prototype.constructor = Model;

/**
 * Set the geometry data.
 *  @param {Object} data - data that represents the geometry.
 */
Model.prototype.setData = function( data )
{
    this.myData = data;
};

/**
 * Returns the geometry data.
 */
Model.prototype.getData = function()
{
    return this.myData;
};


/**
 * Returns the root of the geometry node graph.
 *
 * @returns {Object?} - The root of the geometry node graph. Null if it doesn't exist.
 */
Model.prototype.getRoot = function()
{
    if (this.myData && this.myData.instanceTree)
        return this.myData.instanceTree.root;
    return null;
};

/**
 * Returns the root of the geometry node graph.
 *
 * @returns {Number?} - The ID of the root or null if it doesn't exist.
 */
Model.prototype.getRootId = function()
{
    if (this.myData && this.myData.instanceTree)
        return this.myData.instanceTree.getRootId();
    return 0;
};


/**
* Returns the bounding box of the model.
*/
Model.prototype.getBoundingBox = function()
{
    if (this.myData)
        return this.myData.bbox;
    return null;
};


/**
 * Returns the scale factor of model's distance unit to meters.
 *
 * @returns {Number} - The scale factor of the model's distance unit to meters or unity if the units aren't known.
 */
Model.prototype.getUnitScale = function()
{
    var unit;

    if (!this.is2d()) {
        unit = this.getMetadata('distance unit', 'value', null);
    }
    else {
        unit = this.getMetadata('page_dimensions', 'model_units', null)
    }

    if (unit)
        unit = unit.toLowerCase();

    //Why are translators not using standard strings for those?!?!?!?
    switch (unit) {
        case 'meter'      :
        case 'meters'     :
        case 'm'          : return 1.0;
        case 'feet and inches':
        case 'foot'       :
        case 'feet'       :
        case 'ft'         : return 0.3048;
        case 'inch'       :
        case 'inches'     :
        case 'in'         : return 0.0254;
        case 'centimeter' :
        case 'centimeters':
        case 'cm'         : return 0.01;
        case 'millimeter' :
        case 'millimeters':
        case 'mm'         : return 0.001;
        default: return 1.0;
    }
};

/**
 * Returns a standard string representation of the model's distance unit.
 *
 * @returns {String?} - Standard representation of model's unit distance or null if it is not known.
 */
Model.prototype.getUnitString = function() {

    var unit;

    if (!this.is2d()) {
        // Check if there's an overridden model units in bubble.json (this happens in Revit 3D files)
        if (this.myData && this.myData.overriddenUnits) {
            unit = this.myData.overriddenUnits;
        }
        else {
            unit = this.getMetadata('distance unit', 'value', null);
        }
    }
    else {
        //We use paper units instead of model units here, because in 2D we measure in paper space
        //in the first place, then get the distance in model space by using the viewport(scale).
        unit = this.getMetadata('page_dimensions', 'page_units', null);
    }

    if (unit)
        unit = unit.toLowerCase();

    //Why are translators not using standard strings for those?!?!?!?
    switch (unit) {
        case 'meter'      :
        case 'meters'     :
        case 'm'          : return ModelUnits.METER;
        case 'feet and inches':
        case 'foot'       :
        case 'feet'       :
        case 'ft'         : return ModelUnits.FOOT;
        case 'inch'       :
        case 'inches'     :
        case 'in'         : return ModelUnits.INCH;
        case 'centimeter' :
        case 'centimeters':
        case 'cm'         : return ModelUnits.CENTIMETER;
        case 'millimeter' :
        case 'millimeters':
        case 'mm'         : return ModelUnits.MILLIMETER;
        default: return null;
    }
};

/**
 * Returns a standard string representation of the model's display unit.
 *
 * @returns {String?} - Standard representation of model's display unit or null if it is not known.
*/
Model.prototype.getDisplayUnit = function() {
    var unit;

    if (!this.is2d()) {

        unit = this.getMetadata('distance unit', 'value', null);
    }
    else {

        // When model units is not set, it should be assumed to be the same as paper units.
        unit = this.getMetadata('page_dimensions', 'model_units', null) || this.getMetadata('page_dimensions', 'page_units', null);
    }

    if (unit)
        unit = unit.toLowerCase();

    //Why are translators not using standard strings for those?!?!?!?
    switch (unit) {
        case 'meter'      :
        case 'meters'     :
        case 'm'          : return ModelUnits.METER;
        case 'feet and inches':
        case 'foot'       :
        case 'feet'       :
        case 'ft'         : return ModelUnits.FOOT;
        case 'inch'       :
        case 'inches'     :
        case 'in'         : return ModelUnits.INCH;
        case 'centimeter' :
        case 'centimeters':
        case 'cm'         : return ModelUnits.CENTIMETER;
        case 'millimeter' :
        case 'millimeters':
        case 'mm'         : return ModelUnits.MILLIMETER;
        default: return null;
    }
};

/**
 * Return metadata value.
 * @param {string} itemName - metadata item name
 * @param {string=} [subitemName] - metadata subitem name
 * @param {*} [defaultValue] - default value
 * @returns {*} metadata value, or defaultValue if no metadata or metadata item/subitem does not exist
 */
Model.prototype.getMetadata = function (itemName, subitemName, defaultValue) {
    if (this.myData) {
        var metadata = this.myData.metadata;
        if (metadata) {
            var item = metadata[itemName];
            if (item !== undefined) {
                if (subitemName) {
                    var subitem = item[subitemName];
                    if (subitem !== undefined) {
                        return subitem;
                    }
                } else {
                    return item;
                }
            }
        }
    }
    return defaultValue;
};

/*
Model.prototype.displayMetadata = function () {
    console.log('metadata:');
    if (this.myData) {
        var metadata = this.myData.metadata;
        if (metadata) {
            for (itemName in metadata) {
                if (metadata.hasOwnProperty(itemName)) {
                    console.log('  ' + itemName);
                    var item = metadata[itemName];
                    if (item) {
                        for (subItemName in item) {
                            if (item.hasOwnProperty(subItemName)) {
                                console.log('    ' + subItemName + '=' + JSON.stringify(item[subItemName]));
                            }
                        }
                    }
                }
            }
        }
    }
};
*/

/**
 * Returns the default camera.
 */
Model.prototype.getDefaultCamera = function() {

    var myData = this.myData;

    if (!myData)
        return null;

    var defaultCamera = null;
    var numCameras = myData.cameras ? myData.cameras.length : 0;
    if (0 < numCameras) {
        // Choose a camera.
        // Use the default camera if specified by metadata.
        //
        var defaultCameraIndex = this.getMetadata('default camera', 'index', null);
        if (defaultCameraIndex !== null && myData.cameras[defaultCameraIndex]) {
            defaultCamera = myData.cameras[defaultCameraIndex];

        } else {

            // No default camera. Choose a perspective camera, if any.
            //
            for (var i = 0; i < numCameras; i++) {
                var camera = myData.cameras[i];
                if (camera.isPerspective) {
                    defaultCamera = camera;
                    break;
                }
            }

            // No perspective cameras, either. Choose the first camera.
            //
            if (!defaultCamera) {
                defaultCamera = myData.cameras[0];
            }
        }
    }

    return defaultCamera;
};

/**
 * Returns up vector as an array of 3
 */
Model.prototype.getUpVector = function() {
    return this.getMetadata('world up vector', 'XYZ', null);
};

/**
 * Returns the polygon count.
 * @returns {?number}
 */
Model.prototype.geomPolyCount = function() {

    if (!this.myData)
        return null;

    return this.myData.geomPolyCount;
};

/**
 * Returns the instanced polygon count.
 * @returns {?number}
 */
Model.prototype.instancePolyCount = function() {

    if (!this.myData)
        return null;

    return this.myData.instancePolyCount;
};


/**
 * Returns the root of the layers tree.
 *
 * Not yet implemented in 3D.
 *
 * @returns {?Object} - The root of the layers tree or null if it doesn't exist.
 */
Model.prototype.getLayersRoot = function () {
    if (!this.is2d()) {
        console.warn("Autodesk.Viewing.Model.getLayersRoot is not yet implemented for 3D");
        return null;
    }

    return this.myData ? this.myData.layersRoot : null;
};

/**
 * Returns true if the model represents a 2D drawings, false otherwise.
 * @returns {boolean}
 */
Model.prototype.is2d = function() {

    return !!(this.myData && this.myData.is2d);
};

/**
 * Returns true if the model with all its geometries has loaded.
 * @returns {boolean}
 */
Model.prototype.isLoadDone = function() {
    return !!(this.myData && this.myData.loadDone);
};

/**
 * Returns true if the frag to node id mapping is done.
 *
 * @returns {boolean}
 */
Model.prototype.isObjectTreeCreated = function() {

    return !!(this.myData.instanceTree);

};


/**
 * Returns object properties.
 *
 *  @param {int} dbId - id of the node to return the properties for.
 *  @param {function} onSuccessCallback - this method that is called when request for property db succeeds.
 *  @param {function} onErrorCallback - this method that is called when request for property db fails.
 */
Model.prototype.getProperties = function( dbId, onSuccessCallback, onErrorCallback )
{
    if (!this.myData)
        return;

    this.myData.propWorker.getProperties( dbId, onSuccessCallback, onErrorCallback );
};

/**
 * Returns properties for multiple objects with an optional filter on which properties to retrieve.
 *
 *  @param {int[]} dbIds - ids of the nodes to return the properties for.
 *  @param {string[]?} propFilter -- Array of property names to return values for. Use null for no filtering.
 *                                   Filter applies to "name" and "externalId" fields also.
 *  @param {function} onSuccessCallback - this method that is called when request for property db succeeds.
 *  @param {function} onErrorCallback - this method that is called when request for property db fails.
 */
Model.prototype.getBulkProperties = function( dbIds, propFilter, onSuccessCallback, onErrorCallback )
{
    if (!this.myData)
        return;

    this.myData.propWorker.getBulkProperties( dbIds, propFilter, onSuccessCallback, onErrorCallback );
};


/**
 * Returns an object with key values being dbNodeIds and values externalIds.
 * Useful to map LMV node ids to Fusion node ids.
 *
 *  @param {function} onSuccessCallback - this method that is called when request for property db succeeds.
 *  @param {function} onErrorCallback - this method that is called when request for property db fails.
 */
Model.prototype.getExternalIdMapping = function( onSuccessCallback, onErrorCallback )
{
    if (!this.myData)
        return;

    this.myData.propWorker.getExternalIdMapping( onSuccessCallback, onErrorCallback );
};

/**
 * Returns object tree.
 *
 *  @param {function} onSuccessCallback - this method that is called when request for object tree succeeds.
 *  @param {function} onErrorCallback - this method that is called when request for object tree fails.
 */
Model.prototype.getObjectTree = function( onSuccessCallback, onErrorCallback )
{
    if (!this.myData && onErrorCallback)
        onErrorCallback();
    else
        this.myData.propWorker.getObjectTree( onSuccessCallback, onErrorCallback );
};

/**
 * Searches the object property database.
 *
 *  @param {string} text - the search term.
 *  @param {function} onSuccessCallback - this method that is called when request for search succeeds.
 *  @param {function} onErrorCallback - this method that is called when request for search fails.
 *  @param {string[]} [attributeNames] - restricts search to specific attribute names
 */
Model.prototype.search = function(text, onSuccessCallback, onErrorCallback, attributeNames)
{
    var self = this;
    if (this.isLoadDone()) {
        this.myData.propWorker.searchProperties(text, attributeNames, onSuccessCallback, onErrorCallback);
    } else {
        this.getObjectTree( function() {
            self.myData.propWorker.searchProperties(text, attributeNames, onSuccessCallback, onErrorCallback);
        });
    }

};


//========================================================
// Utility functions used by page->model conversions below

var repairViewportMatrix = function(elements) {
    // Sometimes the rows of matrix are swapped
    var precision = 1e-3;
    var e = elements;
    if (Math.abs(e[0]) < precision) {
        if (Math.abs(e[4]) > precision) {
            // swap row 1 and row 2
            for (var i = 0; i < 4; i++) {
                var temp = e[i];
                e[i] = e[i + 4];
                e[i + 4] = temp;
            }
        }
        else {
            // swap row 1 and row 3
            for (var i = 0; i < 4; i++) {
                var temp = e[i];
                e[i] = e[i + 8];
                e[i + 8] = temp;
            }
        }
    }
    if (Math.abs(e[5]) < precision) {
        // swap row 2 and row 3
        for (var i = 4; i < 8; i++) {
            var temp = e[i];
            e[i] = e[i + 4];
            e[i + 4] = temp;
        }
    }
};


var pointInContour = function(x, y, cntr, pts) {
    var yflag0, yflag1;
    var vtx0X, vtx0Y, vtx1X, vtx1Y;

    var inside_flag = false;

    // get the last point in the polygon
    vtx0X = pts[cntr[cntr.length-1]].x;
    vtx0Y = pts[cntr[cntr.length-1]].y;

    // get test bit for above/below X axis
    yflag0 = (vtx0Y >= y);

    for (var j= 0, jEnd=cntr.length; j<jEnd; ++j)
    {
        vtx1X = pts[cntr[j]].x;
        vtx1Y = pts[cntr[j]].y;

        yflag1 = (vtx1Y >= y);

        // Check if endpoints straddle (are on opposite sides) of X axis
        // (i.e. the Y's differ); if so, +X ray could intersect this edge.
        // The old test also checked whether the endpoints are both to the
        // right or to the left of the test point.  However, given the faster
        // intersection point computation used below, this test was found to
        // be a break-even proposition for most polygons and a loser for
        // triangles (where 50% or more of the edges which survive this test
        // will cross quadrants and so have to have the X intersection computed
        // anyway).  I credit Joseph Samosky with inspiring me to try dropping
        // the "both left or both right" part of my code.
        if (yflag0 != yflag1)
        {
            // Check intersection of pgon segment with +X ray.
            // Note if >= point's X; if so, the ray hits it.
            // The division operation is avoided for the ">=" test by checking
            // the sign of the first vertex wrto the test point; idea inspired
            // by Joseph Samosky's and Mark Haigh-Hutchinson's different
            // polygon inclusion tests.
            if (((vtx1Y-y)*(vtx0X-vtx1X) >=
                (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)
            {
                    inside_flag = !inside_flag;
            }
        }

        // move to the next pair of vertices, retaining info as possible
        yflag0 = yflag1;
        vtx0X = vtx1X;
        vtx0Y = vtx1Y;
    }

    return inside_flag;
};

Model.prototype.pointInPolygon = function(x, y, contours, points) {
    var inside = false;

    for (var i=0; i<contours.length; i++) {

        if (pointInContour(x, y, contours[i], points))
            inside = !inside;
    }

    return inside;
};




Model.prototype.getPageToModelTransform = function(vpId) {

    var f2d = this.myData;
    var metadata = f2d.metadata;
    var pd = metadata.page_dimensions;

    var vp = f2d.viewports[vpId];
    if (!vp) {
      return new THREE.Matrix4();
    }

    if (!f2d.viewportTransforms)
        f2d.viewportTransforms = new Array(f2d.viewports.length);

    //See if we already cached the matrix
    var cached = f2d.viewportTransforms[vpId];
    if (cached)
        return cached;

    //Do the matrix composition in double precision using LmvMatrix,
    //which supports that optionally
    var pageToLogical = new LmvMatrix4(true).set(
      pd.logical_width/pd.page_width, 0, 0, pd.logical_offset_x,
      0, pd.logical_height/pd.page_height, 0, pd.logical_offset_y,
      0, 0, 1, 0,
      0, 0, 0, 1
    );

    var modelToLogicalArray = vp.transform.slice();

    repairViewportMatrix(modelToLogicalArray);

    var modelToLogical = new LmvMatrix4(true);
    modelToLogical.elements.set(modelToLogicalArray);

    var logicalToModel = new LmvMatrix4(true);
    logicalToModel.getInverse(modelToLogical);

    logicalToModel.multiply(pageToLogical);

    //Cache for future use
    f2d.viewportTransforms[vpId] = logicalToModel;

    return logicalToModel;
};


/**
 * Paper coordinates to Model coordinates
*/
Model.prototype.pageToModel = function( point1, point2, vpId ) {

    var PRECISION = 1e-2;

    var vpXform = this.getPageToModelTransform(vpId);

    var modelPt1 = new THREE.Vector3().set(point1.x, point1.y, 0).applyMatrix4(vpXform);
    var modelPt2 = new THREE.Vector3().set(point2.x, point2.y, 0).applyMatrix4(vpXform);

    //var paperDist = point1.distanceTo(point2);
    //var modelDist = modelPt1.distanceTo(modelPt2);
    //
    //// TODO: If the scale is 1:1, then it's paper viewport. (Still have double for that)
    //if (Math.abs(modelDist - paperDist) < PRECISION) {
    //    // viewport id is matched with clip id
    //    var indices = this.pointInClip(point1, vpId);
    //
    //    var oldModelPt1 = modelPt1.clone();
    //    var oldModelPt2 = modelPt2.clone();
    //
    //    for (var i = 0; i < indices.length; i++) {
    //
    //        var xform = this.getPageToModelTransform(indices[i]);
    //
    //        modelPt1.set(point1.x, point1.y, 0).applyMatrix4(xform);
    //        modelPt2.set(point2.x, point2.y, 0).applyMatrix4(xform);
    //
    //        modelDist = modelPt1.distanceTo(modelPt2);
    //        // TODO: If the scale is not 1:1, then it's model viewport. (Still have double for that)
    //        if (Math.abs(modelDist - paperDist) > PRECISION) {
    //            break;
    //        }
    //    }
    //
    //    // Don't find model viewport, then use its own viewport.
    //    if (i >= indices.length) {
    //        modelPt1 = oldModelPt1;
    //        modelPt2 = oldModelPt2;
    //    }
    //}

    point1.x = modelPt1.x;
    point1.y = modelPt1.y;
    point2.x = modelPt2.x;
    point2.y = modelPt2.y;

};


/**
 * Find the viewports that point lies in its bounds
*/
Model.prototype.pointInClip = function(point, vpId) {

    var clips = this.myData.clips;
    var clipIds = []; // This will store ids of clip where point lies in

    // clip index starts at 1
    for (var i = 1; i < clips.length; i++) {
        // Don't need to check the point's own viewport's clip, it must be in that clip.
        if (i === vpId)
            continue;

        var contour = [];
        var contours = [];
        var contourCounts = clips[i].contourCounts;
        var points = clips[i].points;
        var index = 0;
        var pts = [];

        // Reorganize contour data
        for (var j = 0; j < contourCounts.length; j++) {
            for (var k = 0; k < contourCounts[j]; k++) {
                contour.push(index);
                index++;
            }
            contours.push(contour);
            contour = [];
        }
        for (var j = 0; j < points.length; j += 2) {
            var pt = {x: points[j], y: points[j+1]};
            pts.push(pt);
        }

        var inside = this.pointInPolygon(point.x, point.y, contours, pts);
        if (inside)
            clipIds.push(i);
    }

    return clipIds;
};

Model.prototype.getClip = function(vpId) {

    var clips = this.myData.clips;

    var contour = [];
    var contours = [];
    var contourCounts = clips[vpId].contourCounts;
    var points = clips[vpId].points;
    var index = 0;
    var pts = [];

    // Reorganize contour data
    for (var j = 0; j < contourCounts.length; j++) {
        for (var k = 0; k < contourCounts[j]; k++) {
            contour.push(index);
            index++;
        }
        contours.push(contour);
        contour = [];
    }
    for (var j = 0; j < points.length; j += 2) {
        var pt = {x: points[j], y: points[j+1]};
        pts.push(pt);
    }

    return { "contours" : contours, "points" : pts };
};


/**
 * Return topology index of the fragment.
 * @param {int} fragId - fragment id
 * @returns {int} topology index
 */
Model.prototype.getTopoIndex = function( fragId ) {
    if (this.myData && this.myData.fragments) {
        var topoIndexes = this.myData.fragments.topoIndexes;
        if (topoIndexes) {
            return topoIndexes[fragId];
        }
    }
};

/**
 * Return topology data of one fragment.
 * @param {int} index - topology index
 * @returns {object} topology data
 */
Model.prototype.getTopology = function( index ) {
    if (this.myData) {
        var topology = this.myData.topology;
        if (topology) {
            var item = topology[index];
            if (item) {
                return item;
            }
        }
    }
};

Model.prototype.hasTopology = function() {
    if (this.myData) {
        var topology = this.myData.topology;
        if (topology) {
            return true;
        }
    }
};

Model.prototype.getAttributeToIdMap = function(onSuccessCallback, onErrorCallback)
{
	var self = this;
	if (this.isLoadDone()) {
		this.myData.propWorker.attributeToIdMap(onSuccessCallback, onErrorCallback);
	} else {
		this.getObjectTree( function() {
			self.myData.propWorker.attributeToIdMap(onSuccessCallback, onErrorCallback);
		});
	}
};

av.Model = Model;

})();
;
(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

    avp.inWorkerThread = (typeof self !== 'undefined') && (typeof window === 'undefined');

    var ViewingService = {};

    var warnedGzip = false;

    // Simplify Unix style file path. For example, turn '/a/./b/../../c/' into "/c".
    // Required to deal with OSS crappy URNs where there are embedded '..'.
    function simplifyPath(path) {
        var elements = path.split('/');
        if (elements.length == 0) return path;
        var stack = [];
        for (var index = 0; index < elements.length; ++index) {
            var c = elements[index];
            if (c === '.') {
                continue;
            }  if (c === '..' && stack.length) {
                stack.pop();
            } else {
                stack.push(c);
            }
        }
        // Great, the path commits suicide.
        if (stack.length == 0) return '/';
        var ret = "";
        var i = 0;
        while (i < stack.length) {
            // Don't append forward slash as prefix, as we will append forward slash at caller side.
            ret += (i == 0 ? "" : "/") + stack[i++];
        }
        return ret;
    };

    function textToArrayBuffer(textBuffer, startOffset) {
        var len = textBuffer.length - startOffset;
        var arrayBuffer = new ArrayBuffer(len);
        var ui8a = new Uint8Array(arrayBuffer, 0);
        for (var i = 0, j = startOffset; i < len; i++, j++)
            ui8a[i] = (textBuffer.charCodeAt(j) & 0xff);
        return ui8a;
    }


    ViewingService.OSS_PREFIX = "urn:adsk.objects:os.object:";

    ViewingService.getDirectOSSUrl = function(options, path) {
        // When we see a resource is hosted on OSS (by checking the urn prefix where it contain a specific signature),
        // we'll construct the full OSS url that can be used to call the OSS GET object API.
        // The construction process will extract the OSS bucket name (which is the payload between the signature and the first forward slash first enoutered afterwards),
        // and then the object name (which is the payload left). The object name has to be URL encoded because OSS will choke on forward slash.
        var ossIndex = path.indexOf(ViewingService.OSS_PREFIX);
        if (ossIndex !== -1) {
            var ossPath = path.substr(ossIndex + ViewingService.OSS_PREFIX.length);
            var bucket = ossPath.substr(0, ossPath.indexOf("/"));
            var object = ossPath.substr(ossPath.indexOf("/") + 1);
            object = simplifyPath(object);
            var ret = options.oss_url + "/buckets/" + bucket + "/objects/" + encodeURIComponent(decodeURIComponent(object));
            return ret;
        }
    };

    /**
     * Construct full URL given a potentially partial viewing service "urn:" prefixed resource
     * @returns {string}
     */
    ViewingService.generateUrl = function (baseUrl, api, path) {

        //Check if it's a viewing service item path
        if (path.indexOf('urn:') !== 0)
            return path;

        var res = baseUrl + "/";

        if (api !== 'items') {
            // Remove 'urn:' prefix when calling /items API.
            path = path.substr(4);
        }

        //TODO: WTF... we should not be checking the env parameter like this.
        //Check the endpoint URL for being raw viewing service or something....
        if (api === "bubbles" && avp.env.indexOf('Autodesk') == 0) {
            // The bubbles API for PAAS endpoint (where environment is prefixed with 'Autodesk')
            // has no explicit 'bubble' in the URL path.
            res += path;
        } else {
            res += api + "/" + path;
        }

        return res;
    };

    function loadLocalFile(url, onSuccess, onFailure) {
        //Always use async on Node
        require('fs').readFile(url, function(error, data) {
            if (error) {
                onFailure(error);
            } else {
                if (data[0] == 31 && data[1] == 139) {
                    require('zlib').gunzip(data, null, function(error, data) {
                        if (error)
                            onFailure(error);
                        else
                            onSuccess(data);
                    });
                } else {
                    onSuccess(data);
                }
            }
        });
    }

    /**
     *  Performs a GET/HEAD request to Viewing Service.
     *
     * @param {string} viewingServiceBaseUrl - The base url for the viewing service.
     * @param {string} api - The api to call in the viewing service.
     *  @param {string} url - The url for the request.
     *  @param {function} onSuccess - A function that takes a single parameter that represents the response
     *                                returned if the request is successful.
     *  @param {function} onFailure - A function that takes an integer status code, and a string status, which together represent
     *                                the response returned if the request is unsuccessful, and a third data argument, which
     *                                has more information about the failure.  The data is a dictionary that minimally includes
     *                                the url, and an exception if one was raised.
     *  @param {Object=} [options] - A dictionary of options that can include:
     *                               headers - A dictionary representing the additional headers to add.
     *                               queryParams - A string representing the query parameters
     *                               responseType - A string representing the response type for this request.
     *                               {boolean} [encodeUrn] - when true, encodes the document urn if found.
     *                               {boolean} [noBody] - when true, will perform a HEAD request
     */
    ViewingService.get = function (viewingServiceBaseUrl, api, url, onSuccess, onFailure, options) {

        var options = options ? options : {};

        //NODE
        if (options.useLocalFileSystem) {
            loadLocalFile(url, onSuccess, onFailure);
            return;
        }

        //See if it can be mapped to a direct OSS path
        var ossUrl = ViewingService.getDirectOSSUrl(options, url);

        if (ossUrl)
            url = ossUrl;
        else
            url = ViewingService.generateUrl(viewingServiceBaseUrl, api, url);

        if (options.queryParams) {
            url = url + "?" + options.queryParams;
        }

        var request = new XMLHttpRequest();

        function onError(e) {
            onFailure(request.status, request.statusText, {url: url});
        }

        function onLoad(e) {
            if (request.status === 200) {

                if (request.response
                    && request.response instanceof ArrayBuffer) {
                    var rawbuf = new Uint8Array(request.response);
                    //It's possible that if the Content-Encoding header is set,
                    //the browser unzips the file by itself, so let's check if it did.
                    if (rawbuf[0] == 31 && rawbuf[1] == 139) {
                        if (!warnedGzip) {
                            warnedGzip = true;
                            console.warn("An LMV resource (" + url + ") was not uncompressed by the browser. This hurts performance. Check the Content-Encoding header returned by the server and check whether you're getting double-compressed streams. The warning prints only once but it's likely the problem affects multiple resources.");
                        }
                        try {
                            rawbuf = new Zlib.Gunzip(rawbuf).decompress();
                        } catch (e) {
                            onFailure(av.ErrorCodes.BAD_DATA,
                                      "Malformed data received when requesting file",
                                      { "url": url, "exception": e.toString(), "stack": e.stack });
                        }
                    }

                    onSuccess(rawbuf);
                }
                else {
                    onSuccess(request.response || request.responseText);
                }
            }
            else {
                onError(e);
            }
        }

        try {
            var async = options.hasOwnProperty('asynchronous') ? options.asynchronous : true;
            request.open(options.noBody ? 'HEAD' : 'GET', url, async);

            if (options.hasOwnProperty('responseType')) {
                request.responseType = options.responseType;
            }

            request.withCredentials = true;
            if (options.hasOwnProperty("withCredentials"))
                request.withCredentials = options.withCredentials;

            if (options.headers) {
                for (var header in options.headers) {
                    request.setRequestHeader(header, options.headers[header]);

                    // Disable withCredentials if header is Authorization type
                    // NOTE: using withCredentials attaches cookie data to request
                    if (header.toLocaleLowerCase() === "authorization") {
                        request.withCredentials = false;
                    }
                }
            }

            if (async) {
                request.onload = onLoad;
                request.onerror = onError;
                request.ontimeout = onError;

                if (options.ondata) {

                    //Set up incremental progress notification
                    //if needed. We have to do some magic in order
                    //to get the received data progressively.
                    //https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
                    request.overrideMimeType('text/plain; charset=x-user-defined');
                    options._dlProgress = {
                        streamOffset: 0,
                        counter: 0
                    };

                    request.onreadystatechange = function() {

                        if (request.readyState > 2) {

                            var textBuffer = request.responseText;

                            // No new data coming in.
                            if (options._dlProgress.streamOffset >= textBuffer.length)
                                return;

                            var arrayBuffer = textToArrayBuffer(textBuffer, options._dlProgress.streamOffset);

                            options._dlProgress.streamOffset = textBuffer.length;

                            options.ondata(arrayBuffer);
                        }
                    };
                }
            }

            request.send();

            if (options.skipAssetCallback) {
            } else {
                if (avp.inWorkerThread) {
                    self.postMessage({assetRequest: [url, options.headers, null /* ACM session id, null in this case. */]});
                } else {
                    avp.assets.push([url, options.headers, null /* ACM session id, null in this case. */]);
                }
            }

            if (!async) {
                onLoad();
            }
        }
        catch (e) {
            onFailure(request.status, request.statusText, {url: url, exception: e});
        }
    };


    // Create the default failure callback.
    //
    ViewingService.defaultFailureCallback = function (httpStatus, httpStatusText, data) {
        if (httpStatus == 403) {
            this.raiseError(
                av.ErrorCodes.NETWORK_ACCESS_DENIED,
                "Access denied to remote resource",
                { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
        else if (httpStatus == 404) {
            this.raiseError(
                av.ErrorCodes.NETWORK_FILE_NOT_FOUND,
                "Remote resource not found",
                { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
        else if (httpStatus >= 500 && httpStatus < 600) {
            this.raiseError(
                av.ErrorCodes.NETWORK_SERVER_ERROR,
                "Server error when accessing resource",
                { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
        else if (data.exception) {
            this.raiseError(
                av.ErrorCodes.NETWORK_FAILURE,
                "Network failure",
                { "url": data.url, "exception": data.exception.toString(), "stack": data.exception.stack});
        }
        else {
            this.raiseError(
                av.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE,
                "Unhandled response code from server",
                { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
    };



    function copyOptions(loadContext, options) {

        //Those are the usual defaults when called from the LMV worker
        if (!options.hasOwnProperty("asynchronous"))
            options.asynchronous = true;
        else if (!options.asynchronous)
            console.warn("LMV: Sync XHR used. Performance warning.");

        if (!options.hasOwnProperty("responseType"))
            options.responseType = "arraybuffer";

        //Add options junk we got from the main thread context
        options.withCredentials = !!loadContext.auth;
        options.useLocalFileSystem = loadContext.useLocalFileSystem;
        options.headers = loadContext.headers;
        options.queryParams = loadContext.queryParams;
        options.oss_url = loadContext.oss_url;
    }

    //Utility function called from the web worker to set up the options for a get request,
    //then calling ViewingService.get internally
    ViewingService.getItemWorker = function (loadContext, url, onSuccess, onFailure, options) {

        options = options || {};

        copyOptions(loadContext, options);

        ViewingService.get(loadContext.viewing_url, 'items', url, onSuccess, onFailure, options);

    };

    //Utility function called from the web worker to set up the options for a get request,
    //then calling ViewingService.get internally
    ViewingService.getThumbnailWorker = function (loadContext, url, onSuccess, onFailure, options) {

        options = options || {};

        copyOptions(loadContext, options);

        var role = options.role || "rendered";
        var sz = options.size || 400;
        //This will override any incoming query params, but in this case they are expected to be empty
        options.queryParams = "guid=" + encodeURIComponent(options.guid) + "&role=" + role + "&width=" + sz + "&height=" + sz;

        ViewingService.get(loadContext.viewing_url, 'thumbnails', url, onSuccess, onFailure, options);

    };


    avp.ViewingService = ViewingService;

})();
;// WebRTC adapter (adapter.js) from Google

if (typeof window !== 'undefined')
{

    var RTCPeerConnection = null;
    var getUserMedia = null;
    var attachMediaStream = null;
    var reattachMediaStream = null;
    var webrtcDetectedBrowser = null;
    var webrtcDetectedVersion = null;

    function trace(text) {
        // This function is used for logging.
        if (text[text.length - 1] == '\n') {
            text = text.substring(0, text.length - 1);
        }
        console.log((performance.now() / 1000).toFixed(3) + ": " + text);
    }

    if (navigator.mozGetUserMedia) {
        //console.log("This appears to be Firefox");

        webrtcDetectedBrowser = "firefox";

        webrtcDetectedVersion =
            parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]);

        // The RTCPeerConnection object.
        RTCPeerConnection = mozRTCPeerConnection;

        // The RTCSessionDescription object.
        RTCSessionDescription = mozRTCSessionDescription;

        // The RTCIceCandidate object.
        RTCIceCandidate = mozRTCIceCandidate;

        // Get UserMedia (only difference is the prefix).
        // Code from Adam Barth.
        getUserMedia = navigator.mozGetUserMedia.bind(navigator);

        // Creates iceServer from the url for FF.
        createIceServer = function (url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                // Create iceServer with stun url.
                iceServer = { 'url': url };
            } else if (url_parts[0].indexOf('turn') === 0 &&
                (url.indexOf('transport=udp') !== -1 ||
                    url.indexOf('?transport') === -1)) {
                // Create iceServer with turn url.
                // Ignore the transport parameter from TURN url.
                var turn_url_parts = url.split("?");
                iceServer = { 'url': turn_url_parts[0],
                    'credential': password,
                    'username': username };
            }
            return iceServer;
        };

        // Attach a media stream to an element.
        attachMediaStream = function (element, stream) {
            console.log("Attaching media stream");
            element.mozSrcObject = stream;
            element.play();
        };

        reattachMediaStream = function (to, from) {
            console.log("Reattaching media stream");
            to.mozSrcObject = from.mozSrcObject;
            to.play();
        };

        // Fake get{Video,Audio}Tracks
        MediaStream.prototype.getVideoTracks = function () {
            return [];
        };

        MediaStream.prototype.getAudioTracks = function () {
            return [];
        };
    } else if (navigator.webkitGetUserMedia) {
        //console.log("This appears to be Chrome");

        var match = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);

        webrtcDetectedBrowser = "chrome";

        // need to check because this crashes on Chrome mobile emulation
        // 40 is an arbitrary version which the feature is available
        webrtcDetectedVersion = match ?
            parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2]) : 40;

        // Creates iceServer from the url for Chrome.
        createIceServer = function (url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                // Create iceServer with stun url.
                iceServer = { 'url': url };
            } else if (url_parts[0].indexOf('turn') === 0) {
                if (webrtcDetectedVersion < 28) {
                    // For pre-M28 chrome versions use old TURN format.
                    var url_turn_parts = url.split("turn:");
                    iceServer = { 'url': 'turn:' + username + '@' + url_turn_parts[1],
                        'credential': password };
                } else {
                    // For Chrome M28 & above use new TURN format.
                    iceServer = { 'url': url,
                        'credential': password,
                        'username': username };
                }
            }
            return iceServer;
        };

        // The RTCPeerConnection object.
        RTCPeerConnection = webkitRTCPeerConnection;

        // Get UserMedia (only difference is the prefix).
        // Code from Adam Barth.
        getUserMedia = navigator.webkitGetUserMedia.bind(navigator);

        // Attach a media stream to an element.
        attachMediaStream = function (element, stream) {
            if (typeof element.srcObject !== 'undefined') {
                element.srcObject = stream;
            } else if (typeof element.mozSrcObject !== 'undefined') {
                element.mozSrcObject = stream;
            } else if (typeof element.src !== 'undefined') {
                element.src = URL.createObjectURL(stream);
            } else {
                console.log('Error attaching stream to element.');
            }
        };

        reattachMediaStream = function (to, from) {
            to.src = from.src;
        };

        // The representation of tracks in a stream is changed in M26.
        // Unify them for earlier Chrome versions in the coexisting period.
        if (!webkitMediaStream.prototype.getVideoTracks) {
            webkitMediaStream.prototype.getVideoTracks = function () {
                return this.videoTracks;
            };
            webkitMediaStream.prototype.getAudioTracks = function () {
                return this.audioTracks;
            };
        }

        // New syntax of getXXXStreams method in M26.
        if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
            webkitRTCPeerConnection.prototype.getLocalStreams = function () {
                return this.localStreams;
            };
            webkitRTCPeerConnection.prototype.getRemoteStreams = function () {
                return this.remoteStreams;
            };
        }
    } else {
        console.log("Browser does not appear to be WebRTC-capable");
    }

}

;
(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

    avp.config = {
      userName : ""
    };

    avp.setUserName = function(name) {
      avp.config.userName = name;
    };

    var myio; //delay initialized pointer to socket.io library

    /** @constructor
     *
     *  MessageClient
     *  Constructs a message client object, used for server-mediate publish/subscribe
     *  message passing between connected users.
     *
     */
    function MessageClient(serverUrls, serverPath) {

        //Maps web socket commands to event types
        var MESSAGE_MAP = {
            "camera" :      "cameraChange",
            "pointer":      "pointerMove",
            "joystick" :    "joystick",
            "state" :       "viewerState",
            "txt":          "chatReceived",
            "joinok" :      "userListChange",
            "sessionId" :   "connectSucceeded",
            "joined" :      "userListChange",
            "left" :        "userListChange",
            "private" :     "privateMessage",
            "join_error":   "socketError"
        };


        var _socket;
        var _myID = null;

        var _serverURL = Array.isArray(serverUrls) ? serverUrls : [serverUrls];
        var _currentServer = 0;
        
        var _pendingJoins = {};

        var _channels = {
        };

        var _this = this;

        function getUserName() {
            if (avp.config.userName && avp.config.userName.length)
                return avp.config.userName;

            if (_myID)
                return _myID.slice(0,5);

            return "Unknown";
        }



        function onRecv(msg) {

            //See if the message requires internal processing
            switch(msg.type) {

				case "txt":     onChat(msg);
								break;

				case "joinok":  onJoinOK(msg);
								break;
								
				case "join_error": break;

				case "sessionId":
                                stderr("Connect successful, your id is: " + msg.id);
								_myID = msg.id;
								break;

				case "joined":  msg.userStatus = "joined";
                                onJoined(msg);
                                break;
                case "left":    msg.userStatus = "left";
                                onLeft(msg);
                                break;
                case "camera":
                case "pointer": break;
                default: stderr(msg);
                        break;
            }

            //Determine what channel we are receiving the event on.
            //For example, a user list change can occur on either the collaboration channel (users in current session)
            //or on the presence channel (all users logged in), and the various GUI event handlers have to make decisions based
            //on that.
            var channelId = msg.roomId;

            //And send it to all listeners
            var evt = { type: MESSAGE_MAP[msg.type], data:msg, channelId:channelId };
            _this.dispatchEvent(evt);
        }

        function onJoined(evt) {
            if (!evt.user.name || !evt.user.name.length)
                evt.user.name = evt.user.id.slice(0,5);

            if (evt.roomId) {
                var channel = _channels[evt.roomId];
                if (channel) {
                    channel.users.push(evt.user);
                    stderr(evt.user + " joined room " + evt.roomId);
                } else {
                    stderr("Channel " + evt.roomId + " does not exist for socket " + _myID);
                }
            }
        }

        function onLeft(evt) {
            stderr(evt.user + " left room " + evt.room);
            for (var channelId in _channels) {
                var users = _channels[channelId].users;

                var idx = -1;
                for (var i=0; i<users.length; i++) {
                    if (users[i].id == evt.user) {
                        idx = i;
                        break;
                    }
                }

                if (idx != -1)
                    users.splice(idx, 1);

                delete _channels[channelId].userSet[evt.user];
            }
        }

        function onJoinOK(evt) {

            var channel = _channels[evt.roomId];

            stderr("joined channel " + evt.roomId);

            if (evt.users && evt.users.length) {
                channel.users = evt.users;
            } else {
                channel.users = [];
            }

            for (var i=0; i<channel.users.length; i++) {

                //Make up a user name if one is not known
                if (!channel.users[i].name || !channel.users[i].name.length) {
                    channel.users[i].name = channel.users[i].id.slice(0,5);
                }
            }

            var name = getUserName();
            var you = Autodesk.Viewing.i18n.translate("you");
            var me = { id:_myID, name: name + " (" + you + ")", isSelf : true, status:0 };
            if (!channel.userSet[_myID]) {
                channel.users.push(me);
                channel.userSet[_myID] = me;
            }

            //In case user name is already known, update the server.
            if (me.id.indexOf(name) != 0) {
                _this.sendChatMessage("/nick " + name, evt.roomId);
            }
        }


        function onChat(evt) {
            if (evt.msg.indexOf("/nick ") == 0) {
                var user = _this.getUserById(evt.from, evt.roomId);
                var newname = evt.msg.slice(6);

                if (newname.length) {
                    user.name = newname;
                    if (user.id == _myID) {
                        var you = Autodesk.Viewing.i18n.translate("you");
                        user.name += " (" + you + ")";
                    }
                }

                _this.dispatchEvent({ type: "userListChange", data: evt, channelId: evt.roomId });
            }
        }
        
        function onConnectError(evt) {

            //Attempt to connect to another server in case
            //the primary fails. If they all fail, then we give up.
            if (_currentServer < _serverURL.length) {
                
                stderr("Connect failed, trying another server...");
                
                _socket.disconnect();
                _socket = null;
                _currentServer++;
                _this.connect(_this.sessionID);
            
            } else {

                _this.dispatchEvent({ type: "socketError", data: evt });

            }
        }
        
        function onError(evt) {

            _this.dispatchEvent({ type: "socketError", data: evt });

        }
        
        function onConnect(evt) {
            _currentServer = 0;
            
            //Join any channels that were delayed while the
            //connection is established.
            for (var p in _pendingJoins) {
                _this.join(p);
            }
        }

        /**
         * Establish initial connection to the server specified when constructing the message client.
         */
        this.connect = function (sessionID) {

            //TODO: Maintain multiple sockets to the same server, identifier by sessionID.

            if (_socket)
                return; //already connected to socket server.

            if (typeof window.WebSocket !== "undefined") {

                if (!myio)
                    myio = (typeof lmv_io !== "undefined") ? lmv_io : io;

                this.sessionID = sessionID;

                _socket = myio.connect(_serverURL[_currentServer] + "?sessionID=" + sessionID, {path: serverPath, forceNew:true});
                _socket.on("connect", onConnect);
                _socket.on("message", onRecv);
                _socket.on("connect_error", onConnectError);
                _socket.on("error", onError);

                return true;
            }
            else {
                return false;
            }
        };

        /**
         * Subscribe to a messaging channel. Requires connection to be active (i.e. connect() called before join()).
         */
		this.join = function(channelId) {

            if (!_socket || !_socket.connected) {
                _pendingJoins[channelId] = 1;
                return;
            }
            
            delete _pendingJoins[channelId];

            _channels[channelId] = {
                    id : channelId,
                    users: [],
                    userSet: {}
                };

            _socket.emit('join', { roomId : channelId, name : getUserName() });
		};

        /**
         * Disconnect from message server.
         */
        this.disconnect = function () {
            if (_socket) {
                _socket.disconnect();
                //_socket.close();
                _socket = null;
                _channels = {};
                _myID = null;
            }
        };


        /**
         * Send a message of a specific type, containing given data object to a channel.
         * Subscription (listening) to that channel is not required.
         */
        this.sendMessage = function(type, data, channelId) {

            var evt = { type:type, from:_myID, msg: data, roomId: channelId };

            _socket.emit("message", evt);
        };

        /**
         * Send a message object to an individual user.
         */
        this.sendPrivateMessage = function(targetId, msg) {

            var evt = { type: "private", target: targetId, from:_myID, msg: msg };

            _socket.emit("message", evt);
        };

        /**
         * A convenience wrapper of sendMessage to send a simple text chat message to a channel.
         */
        this.sendChatMessage = function(msg, channelId) {

            var evt = { type:"txt", from: _myID, msg: msg, roomId: channelId };

            _socket.emit("message", evt);

            //This is done to handle /nick commands
            onRecv(evt);
        };

        /**
         * Returns the user info object for a given user on a specific channel.
         * User lists are maintained per channel.
         */
        this.getUserById = function(id, channelId) {
            var users = _channels[channelId].users;
            for (var i=0; i<users.length; i++) {
                if (users[i].id == id)
                    return users[i];
            }
            return null;
        };

        /**
         * Returns the local user's (randomly assigned) connection ID. Can be used to
         * maintain hashmaps of users, since it's unique per server.
         */
        this.getLocalId = function() { return _myID; };

        /**
         * Returns a channel's info object.
         */
        this.getChannelInfo = function(channelId) { return _channels[channelId]; };

        this.isConnected = function() { return _socket; };
    };

    MessageClient.prototype.constructor = MessageClient;
    av.EventDispatcher.prototype.apply( MessageClient.prototype );

    var _activeClients = {};

    MessageClient.GetInstance = function(serverUrls, path) {

        if (!serverUrls)
            serverUrls = avp.EnvironmentConfigurations[avp.env].LMV.RTC;

        if (!Array.isArray(serverUrls))
            serverUrls = [serverUrls];
        
        var mc = _activeClients[serverUrls[0]];
        if (mc)
            return mc;

        mc = new avp.MessageClient(serverUrls, path);
        _activeClients[serverUrls[0]] = mc;
        return mc;
    };


    Autodesk.Viewing.Private.MessageClient = MessageClient;

})();;AutodeskNamespace('Autodesk.Viewing.Private');

(function() {

    var av = Autodesk.Viewing,
        avp = av.Private;

    //==================================================================================

    avp.P2PClient = function(signalClient) {

        var _this = this;

        var _signalClient = signalClient;
        var _pc;
        var _isStarted = false;
        var _targetId;
        var _localStream;
        var _remoteStream;

        var _dataChannel;

        var _iceCandidates = [];

        var pc_config = {'iceServers': [{'url': 'stun:stun.l.google.com:19302'}]};

        var pc_constraints = {'optional': [{'DtlsSrtpKeyAgreement': true}]};

        // Set up audio and video regardless of what devices are present.

        var sdpConstraintsAll = {'mandatory': {
          'OfferToReceiveAudio':true,
          'OfferToReceiveVideo':true }
        };

        var sdpConstraintsNone = {'mandatory': {
          'OfferToReceiveAudio':false,
          'OfferToReceiveVideo':false }
        };


        _signalClient.addEventListener("privateMessage", onMessage);



        function createPeerConnection(wantDataChannel) {
          try {

            _pc = new RTCPeerConnection(pc_config);

            _pc.onicecandidate = function(event) {
                  if (event.candidate) {
                    _signalClient.sendPrivateMessage(_targetId, {
                      type: 'candidate',
                      label: event.candidate.sdpMLineIndex,
                      id: event.candidate.sdpMid,
                      candidate: event.candidate.candidate});
                  } else {
                    stderr('End of candidates.');
                  }
            };

            _pc.ondatachannel = function(event) {
                stderr('Data channel added.');
                _dataChannel = event.channel;
                _dataChannel.onmessage = onDataMessage;
                _this.dispatchEvent({type:"dataChannelAdded", data:event.channel});
            };

            _pc.onaddstream = function(event) {
                stderr('Remote stream added.');
                _remoteStream = event.stream;
                _this.dispatchEvent({type:"remoteStreamAdded", data:event.stream});
            };

            _pc.onremovestream = function(event) {
                stderr('Remote stream removed. Event: ', event);
                _remoteStream = null;
                _this.dispatchEvent({type:"remoteStreamRemoved", data:event.stream});
            };

            if (wantDataChannel) {
                _dataChannel = _pc.createDataChannel("sendDataChannel", {reliable: false, ordered:false});
                _dataChannel.onmessage = onDataMessage;
            }
          } catch (e) {
            stderr('Failed to create PeerConnection, exception: ' + e.message);
            alert('Cannot create RTCPeerConnection object.');
              return;
          }
        }


        function handleCreateOfferError(event){
            stderr('createOffer() error: ', e);
        }

        function setLocalAndSendMessage(sessionDescription) {
            // Set Opus as the preferred codec in SDP if Opus is present.
            //sessionDescription.sdp = preferOpus(sessionDescription.sdp);
            _pc.setLocalDescription(sessionDescription);
            //console.log('setLocalAndSendMessage sending message' , sessionDescription);
            _signalClient.sendPrivateMessage(_targetId, sessionDescription);

            if (_iceCandidates.length) {
                for  (var i=0; i<_iceCandidates.length; i++)
                    _pc.addIceCandidate(_iceCandidates[i]);
                _iceCandidates = [];
            }
        }
/*
        function requestTurn(turn_url) {
          var turnExists = false;
          for (var i in pc_config.iceServers) {
            if (pc_config.iceServers[i].url.substr(0, 5) === 'turn:') {
              turnExists = true;
              turnReady = true;
              break;
            }
          }
          if (!turnExists) {
            console.log('Getting TURN server from ', turn_url);
            // No TURN server. Get one from computeengineondemand.appspot.com:
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
              if (xhr.readyState === 4 && xhr.status === 200) {
                var turnServer = JSON.parse(xhr.responseText);
                console.log('Got TURN server: ', turnServer);
                pc_config.iceServers.push({
                  'url': 'turn:' + turnServer.username + '@' + turnServer.turn,
                  'credential': turnServer.password
                });
                turnReady = true;
              }
            };
            xhr.open('GET', turn_url, true);
            xhr.send();
          }
        }
*/

        this.hangup = function() {
          stderr('Hanging up.');
          if (_isStarted) {
              _signalClient.sendPrivateMessage(_targetId, 'bye');
              stop();
          }
        };


        this.initUserMedia = function(createConnectionCB) {
            function handleUserMedia(stream) {
                stderr('Adding local stream.');
                if (createConnectionCB)
                    createConnectionCB(stream);
                _this.dispatchEvent({type:"localStreamAdded", data:stream});
            }

            function handleUserMediaError(error){
                stderr('getUserMedia error: ', error);
            }

            var constraints = {video: true, audio:true};
            window.getUserMedia(constraints, handleUserMedia, handleUserMediaError);

            stderr('Getting user media with constraints', constraints);
        };

        this.callUser = function(userId, dataOnly) {
            if (_targetId) {
                stderr("Already in a call. Ignoring call request.");
                return;
            }

            _targetId = userId;

            stderr("Calling user " + _targetId);

            if (dataOnly) {
                createPeerConnection(true);

                _isStarted = true;
                stderr('Sending data channel offer to peer');
                _pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
            }
            else {
                this.initUserMedia(function(stream) {
                    _localStream = stream;
                    if (!_isStarted && typeof _localStream != 'undefined') {
                        createPeerConnection(false);

                        _pc.addStream(_localStream);
                        _isStarted = true;
                        stderr('Sending audio/video offer to peer');
                        _pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
                    }
                });
            }
        };

        function isSDPDataOnly(sdp) {
            var lines = sdp.split("\n");
            var haveData = false;
            var haveAudio = false;
            var haveVideo = false;
            for (var i=0; i<lines.length; i++) {
                if (lines[i].indexOf("a=mid:data") == 0) {
                    haveData = true;
                }
                if (lines[i].indexOf("a=mid:video") == 0) {
                    haveVideo = true;
                }
                if (lines[i].indexOf("a=mid:audio") == 0) {
                    haveAudio = true;
                }
            }

            return haveData && !haveVideo && !haveAudio;
        }

        this.receiveCall = function(msg) {
            _targetId = msg.from;
            if (!_targetId)
                _targetId = msg.senderId;

            //Check if the caller wants audio/videio
            var sdp = msg.msg.sdp;
            if (isSDPDataOnly(sdp)) {
                createPeerConnection(true);
                _isStarted = true;

                _pc.setRemoteDescription(new RTCSessionDescription(msg.msg));
                stderr('Sending data-only answer to peer.');
                _pc.createAnswer(setLocalAndSendMessage, null , sdpConstraintsNone);

            } else {
                this.initUserMedia(function(stream) {
                    _localStream = stream;

                    if (!_isStarted && typeof _localStream != 'undefined') {
                        createPeerConnection(false);
                        _pc.addStream(_localStream);
                        _isStarted = true;
                    }

                    _pc.setRemoteDescription(new RTCSessionDescription(msg.msg));
                    stderr('Sending audio+video answer to peer.');
                    _pc.createAnswer(setLocalAndSendMessage, null , sdpConstraintsAll);
                });
            }
        };

        function onDataMessage(evt) {
            var data = JSON.parse(evt.data);

            switch(data.type) {
                case "camera":                  _this.dispatchEvent({ type: "cameraChange",   data: data}); break;
                case "joystick":                _this.dispatchEvent({ type: "joystick",       data: data}); break;
                case "state":                   _this.dispatchEvent({ type: "viewerState",    data: data}); break;
                default: break;
            }
        }


        function onMessage(evt) {
            var message = evt.data.msg;
            stderr('Client received message:' + JSON.stringify(message));
            if (message.type == 'offer' && !_isStarted) {

                stderr("Received offer. Accepting.");
                _this.receiveCall(evt.data);

            } else if (message.type === 'answer' && _isStarted) {

                _pc.setRemoteDescription(new RTCSessionDescription(message));

            } else if (message.type === 'candidate') {

                var candidate = new RTCIceCandidate({
                sdpMLineIndex: message.label,
                candidate: message.candidate
                });

                //If we receive ICE candidates before the local
                //session is started, we have to hold them in a temp list until
                //we create the answer
                if (_isStarted)
                    _pc.addIceCandidate(candidate);
                else
                    _iceCandidates.push(candidate);

            } else if (message === 'bye' && _isStarted) {

               _this.dispatchEvent({type:"remoteHangup", data:null});
                stderr('Session terminated.');
               stop();
              // isInitiator = false;

            }
        }

        function stop() {
          _isStarted = false;
          // isAudioMuted = false;
          // isVideoMuted = false;
          _pc.close();
          _pc = null;
          _localStream = null;
          _remoteStream = null;
          _targetId = null;
        }

        this.getCurrentCallTarget = function() { return _targetId; }

        this.dataChannel = function() { return _dataChannel; }
    };

    avp.P2PClient.prototype.constructor = avp.P2PClient;
    Autodesk.Viewing.EventDispatcher.prototype.apply( avp.P2PClient.prototype );

})();;(function(){

    Autodesk.Viewing.Private.LiveReviewClient = function (viewer) {

        this.viewer = viewer;
        this.messageClient = null;
        this.presenceChannelId = null;
        this.p2p = null;
        this.viewtx = null;
        this.interceptor = null;
    };

    Autodesk.Viewing.Private.LiveReviewClient.prototype.destroy = function() {
        this.leaveLiveReviewSession();
    };

    Autodesk.Viewing.Private.LiveReviewClient.prototype.joinLiveReviewSession = function (sessionId) {

        if (!this.messageClient)
            this.messageClient = avp.MessageClient.GetInstance();
        if (!this.presenceChannelId)
            this.presenceChannelId = window.location.host;
        if (!this.messageClient.isConnected()) {
            this.messageClient.connect(sessionId);
        }

        if (!this.viewtx)
            this.viewtx = new avp.ViewTransceiver(this.messageClient);
        this.viewtx.channelId = sessionId;
        this.viewtx.attach(this.viewer);

        if (!this.p2p)
            this.p2p = new avp.P2PClient(this.messageClient);

        this.messageClient.join(this.viewtx.channelId);

        if (!this.interceptor)
            this.interceptor = new avp.InteractionInterceptor(this.viewtx);
        this.viewer.toolController.registerTool(this.interceptor);
        this.viewer.toolController.activateTool(this.interceptor.getName());
    };

    Autodesk.Viewing.Private.LiveReviewClient.prototype.leaveLiveReviewSession = function () {
        this.p2p && this.p2p.hangup();
        this.viewtx && this.viewtx.detach(this.viewer);
        this.messageClient && this.messageClient.disconnect();
        if (this.interceptor) {
            this.viewer.toolController.deactivateTool(this.interceptor.getName());
        }

        this.p2p = null;
        this.viewtx = null;
        this.messageClient = null;
        this.interceptor = null;
    };




    var av = Autodesk.Viewing,
        avp = av.Private;

    avp.InteractionInterceptor = function(viewtx) {

        this.getNames = function() {
            return ["intercept"];
        };

        this.getName = function() {
            return "intercept";
        };

        this.activate = function(name) { };
        this.deactivate = function(name) { };
        this.update = function(timeStamp) { return false; };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};
        this.handleKeyDown = function( event, keyCode ) {return false;};
        this.handleKeyUp = function( event, keyCode ) {return false;};

        this.handleWheelInput = function(delta) {
            viewtx.takeControl();
            return false;
        };

        this.handleButtonDown = function(event, button) {
            viewtx.takeControl();
            //            stderr("click");
            return false;
        };

        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {
            viewtx.updatePointer(event);
            return false;
        };

        this.handleGesture = function(event) {
            viewtx.takeControl();
            return false;
        };

        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};
    };

    avp.ViewTransceiver = function(client) {

        var _this = this;
        var _viewer = this.viewer = null;
        var _blockEvents = false;
        var _haveControl = false;
        var _isDisconnected = false;
        var _lastInControl;
        var _client = this.client = client;
        var _ray = new THREE.Ray();
        var _pointer = null;
        var _pointerOn = false;

        this.channelId = null;

        var _viewerState;
        var VIEWER_STATE_FILTER = {
            seedURN: false,
            objectSet: true,
            viewport: false,
            cutplanes: true,
            renderOptions: {
                environment: false,
                ambientOcclusion: false,
                toneMap: {
                    exposure: false
                },
                appearance: false
            }
        };


        function onViewerState(evt) {
            _blockEvents = true;
            var state = JSON.parse(evt.data.msg);
            _viewerState.restoreState(state);
            _viewer.impl.invalidate(true, false, true);
            _blockEvents = false;
        }

        function reduceBits(v) {
            return Math.round(v * 1000) / 1000;
        }

        function reduceBitsV(v) {
            for (var i=0; i< v.length; i++)
                v[i] = reduceBits(v[i]);
        }

        function onCamera(e) {
            var v = e.data.msg;

            if (v[1] === true || _isDisconnected)
            {
                return;
            }

            if (v[0] != _lastInControl)
            {
                _lastInControl = v[0];
                e.data.lastInControl = v[0];
                _this.dispatchEvent({type: "controlChange", channelId: _this.channelId, data: e.data });
            }

            //For now, automatically relinquish camera control if we receive a remote command to move the camera
            _haveControl = false;

            /*
             viewer.navigation.setRequestTransitionWithUp(true, new THREE.Vector3().set(v[1+0],v[1+1],v[1+2]),
             new THREE.Vector3().set(v[1+3],v[1+4],v[1+5]),
             _viewer.navigation.getCamera().fov,
             new THREE.Vector3().set(v[1+6],v[1+7],v[1+8]));
             */

            _viewer.navigation.setView(new THREE.Vector3().set(v[2+0],v[2+1],v[2+2]),
                new THREE.Vector3().set(v[2+3],v[2+4],v[2+5]));
            _viewer.navigation.setCameraUpVector(new THREE.Vector3().set(v[2+6],v[2+7],v[2+8]));
        }

        function sendCamera(evt) {
            if (!_haveControl && !_isDisconnected)
                return;

            var c = evt.camera;
            var camParams = [ c.position.x, c.position.y, c.position.z,
                c.target.x, c.target.y, c.target.z,
                c.up.x, c.up.y, c.up.z
            ];

            reduceBitsV(camParams);
            camParams.unshift(_isDisconnected);
            camParams.unshift(client.getLocalId());

            _client.sendMessage("camera", camParams, _this.channelId);

            if (_lastInControl != camParams[0]) {
                _lastInControl = camParams[0];
                _this.dispatchEvent({type: "controlChange", channelId: _this.channelId, data: { lastInControl: _lastInControl } });
            }
        }


        function showPointer(show, x, y) {

            if (show && !_pointer) {
                _pointer = document.createElement("div");
                _pointer.classList.add("collabPointer");
            }

            if (show && !_pointerOn) {
                _viewer.container.appendChild(_pointer);
                _pointerOn = true;
            }
            else if (!show && _pointerOn) {
                _viewer.container.removeChild(_pointer);
                _pointerOn = false;
            }

            if (show) {
                //Note the 4px is half the width/height specified in the CSS,
                //so that the pointer is centered.
                _pointer.style.left = (x-6) + "px";
                _pointer.style.top = (y-6) + "px";
            }

        }

        function onPointer(e) {

            if (_haveControl)
                return; //shouldn't get here in theory, but let's check just in case

            if (_isDisconnected)
                return; //we can't show the pointer if the views don't match

            var v = e.data.msg;
            _ray.origin.set(v[1], v[2], v[3]);
            _ray.direction.set(v[4], v[5], v[6]);

            var pt = _ray.at(_viewer.getCamera().near);
            pt.project(_viewer.getCamera());

            pt = _viewer.impl.viewportToClient(pt.x, pt.y);

            //console.log(pt.x + " " + pt.y);
            showPointer(true, pt.x, pt.y);
        }


        function sendPointer(evt) {
            if (!_haveControl)
                return;

            //Note canvasX/Y are set by the ToolController to clientX/Y - canvas left/top.
            var vpVec = _viewer.impl.clientToViewport(evt.canvasX, evt.canvasY);
            _viewer.impl.viewportToRay(vpVec, _ray);

            var rayParams = [ _ray.origin.x, _ray.origin.y, _ray.origin.z,
                _ray.direction.x, _ray.direction.y, _ray.direction.z ];

            reduceBitsV(rayParams);
            rayParams.unshift(client.getLocalId());

            _client.sendMessage("pointer", rayParams, _this.channelId);
        }


        function sendViewerState(e) {
            //if (!_haveControl)
            //    return;
            if (_blockEvents)
                return;

            var state = _viewerState.getState(VIEWER_STATE_FILTER);

            // TODO: if we kill the socket.io code path, this could be optimized
            // too by removing the JSON.stringify of the state. Pubnub automatically
            // does JSON serialization for us, with optimizations accordingly to their manual.
            client.sendMessage("state", JSON.stringify(state), _this.channelId);
        }


        this.takeControl = function() {
            _haveControl = true;
            showPointer(false);
        };

        this.updatePointer = function(e) {
            sendPointer(e);
        };

        this.connectCamera = function(set) {
            _isDisconnected = !set;
        };

        this.attach = function(viewer) {

            if (_viewer)
                this.detach();

            this.viewer = _viewer = viewer;
            _viewerState = new avp.ViewerState(_viewer);

            _client.addEventListener("cameraChange", onCamera);
            _client.addEventListener("pointerMove", onPointer);
            _client.addEventListener("viewerState", onViewerState);


            if (!_viewer.hasEventListener(av.CAMERA_CHANGE_EVENT, sendCamera))
                _viewer.addEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

            if (!_viewer.hasEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState)) {
                _viewer.addEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.addEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.addEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.addEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.addEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.addEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
                _viewer.addEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);
            }
        };


        this.detach = function() {

            showPointer(false);

            if (_client) {
                _client.removeEventListener("cameraChange", onCamera);
                _client.removeEventListener("viewerState", onViewerState);
            }

            if (_viewer) {
                _viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

                _viewer.removeEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.removeEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);

                this.viewer = _viewer = null;
                _viewerState = null;
            }
        };

    };

    avp.ViewTransceiver.prototype.constructor = avp.ViewTransceiver;
    Autodesk.Viewing.EventDispatcher.prototype.apply( avp.ViewTransceiver.prototype );


})();
;
(function() {

"use strict";

var avp = Autodesk.Viewing.Private;

function Logger(options) {
    this.queue = [];
    this.adp = null;
    this.runtimeStats = {};
    
    if (options.eventCallback) 
        this.callback = options.eventCallback;

    this.sessionId = options.sessionId;
    if (!this.sessionId) {
        var now = Date.now() + "";
        this.sessionId = parseFloat(((Math.random() * 10000) | 0) + "" + now.substring(4));
    }

    this.endpoint = options.endpoint ? (options.endpoint + "/logs") : null;
    this.flushThreshold = options.flushThreshold || 10;

    var self = this;
    self.ready = false;
    self.retries = 0;
    this.lastFlushTime = Date.now();
    this.heartbeat = null;

    //Kick off with a viewer start event
    var startEvent = {
        category: "viewer_start",
        touch: isTouchDevice(),
        env: avp.env,
        referer: window.location.href, //Referer header is not sent by the browser in case of WebSocket HTTP Upgrade request, so do it manually
        version: LMV_VIEWER_VERSION,
        patch: LMV_VIEWER_PATCH,
        build_type: LMV_BUILD_TYPE
    };
    this.log(startEvent);

    setInterval(function() { self.reportRuntimeStats(); }, 60000);
}

Logger.prototype.setupWS = function () {

    var self = this;

    self.reconnectPending = false;

    if (!this.endpoint)
        return;

    stderr("Opening web socket.");

    var openHandler = function() {
        self.ready = true;
        self.lastConnectTime = Date.now();

        stderr("Web socket opened successfully.");

        //Send this so that in case of reconnect the server
        //can again identify the socket with the session.
        if (self.retries > 0)
        {
            //Do not reset the retry counter on open. We can get in a situation
            //where the web server closes the WS connection normally
            //and the viewer tries to reconnect again ad-infinitum.
            //self.retries = 0;
            
            self.socket.send({category:"reconnect", sessionId:this.sessionId});
        }
               
        self.flush();
    };
    
    var tryReconnect = function() {

        //Avoid reentering (e.g. close and error can both call this)
        if (self.reconnectPending)
            return;

        //Once XHR is initialized, we no longer attempt to use web socket.
        if (self.xhr)
            return;

        self.ready = false;

        if (self.retries < 3) {
            stderr("Attempting web socket reconnect.");
            self.retries++;
            self.reconnectPending = true;
            setTimeout(function() { self.setupWS(); }, 5000);
        } else {
            stderr("Giving up on web sockets. Trying POST.");
            self.setupXHR();
        }
    };

    var errorHandler = function(e) {
        console.log(e.message);
        tryReconnect();
    };
    
    var closeHandler = function (e) {
        //We can get closed due to proxy timeout
        //Do not actively try to reconnect unless we
        //have something meaningful to log
        var now = Date.now();

        if (now - self.lastConnectTime > 60000) {
            stderr("Web socket closed due to inactivity.");
            self.socket = null;
            self.ready = false;
            self.retries = 0;
        } else {
            tryReconnect();
        }
    };

    try {

        this.socket = new WebSocket("wss://" + this.endpoint, "lmv-log-v1");
        this.socket.onopen = openHandler;
        this.socket.onerror = errorHandler;
        this.socket.onclose = closeHandler;
        this.socket.onmessage = function(e) {
            console.log(e.data);
        };
    } catch (e) {
        self.setupXHR();
    }
};

Logger.prototype.setupXHR = function () {
    this.socket = null;
    this.xhr = new XMLHttpRequest();
    this.ready = true;
    this.retries = 0;
    this.flush();
    
    var self = this;
   
    if (this.heartbeat)
        clearInterval(this.heartbeat);
    this.heartbeat = setInterval(function() { self.flush(); }, 60000);

    //If we use web socket for logging, we don't need to listen
    //to this event as we are sending everything immediately and we
    //will catch the disconnect on the server side.
    if (typeof window !== "undefined") {
        window.addEventListener("beforeunload", function() {
            self.log({category:"viewer_stop"}, true);
        });
    }
};

Logger.prototype.flush = function () {
    //Don't try to log more if posting logs failed already.
    if (this.retries > 2) return;

    if (!this.queue.length) return;
    
    if (!this.ready) return;
    
    var self = this;

    var toSend = this.queue;
    this.queue = [];

    var log = JSON.stringify(toSend);

    if (this.socket) {
        try {
            this.socket.send(log);
        } catch (e) {

        }
    } else if (this.endpoint) {
    
        try {
            var xhr = this.xhr;
            xhr.open('POST', "https://" + this.endpoint, true);
            xhr.send(log);
            
            xhr.onreadystatechange = function() {   
                if(xhr.readyState == 4) {
                    if (xhr.status !== 200) {
                        self.retries++;
                        self.queue.unshift(toSend);
                    }
                }
            };
            
        } catch (e) {} // Just ignore log post errors for now.
    } else {
        stderr(this.queue);
    }

    this.lastFlushTime = Date.now();
};

Logger.prototype.log = function (entry, forceFlush) {
    this.updateRuntimeStats(entry);

    if (avp.offline) {
        return;
    }

    if (this.callback) 
        this.callback(entry);

    //Don't try to log more if posting logs failed already.
    if (this.retries > 2) return;

    entry.timestamp = Date.now();
    entry.sessionId = this.sessionId;

    // avoid logging fps to websocket --- prod patch
    if (entry && entry.name !== 'fps'){
        this.queue.push(entry);
    }

    //If we had a web socket but it was closed due to
    //inactivity (or never had one open yet), try to open it
    if (!this.socket && !this.ready) {
        this.setupWS();
    } else if (this.socket
        || this.queue.length > this.flushThreshold
        || (entry.timestamp - this.lastFlushTime) > 60000 
        || forceFlush) {
        this.flush();
    }

    this.logToADP(entry);
};

Logger.prototype.logToADP = function(entry) {
    if (!this.adp) {
        return;
    }

    // Map & log legacy events to ADP
    // TODO: move away from the legacy naming and avoid the awkward switch below
    var evType = '';
    var opType = '';
    switch (entry.category) {
        case 'tool_changed':
        case 'pref_changed':
            evType = 'CLICK_OPERATION';
            opType = entry.category + '/' + entry.name;
            break;
        case 'screen_mode':
            evType = 'CLICK_OPERATION';
            opType = 'pref_changed/' + entry.category;
            break;
        case 'metadata_load_stats':
            evType = 'DOCUMENT_START';
            opType = 'stats';
            break;
        case 'model_load_stats':
            evType = 'DOCUMENT_FULL';
            opType = 'stats';
            break;
        case 'error':
            evType = 'BACKGROUND_CALL';
            opType = 'error';
            break;
    }

    if (evType) {
        this.adp.trackEvent(evType, {
            operation: {
                id: entry.sessionId,
                type: opType,
                stage: '',
                status: 'C',
                meta: entry
            }
        });
    }
};

Logger.prototype.updateRuntimeStats = function(entry) {
    if (entry.hasOwnProperty('aggregate')) {
        switch (entry.aggregate) {
            case 'count':
                if (this.runtimeStats[entry.name] > 0) {
                    this.runtimeStats[entry.name]++;
                } else {
                    this.runtimeStats[entry.name] = 1;
                }
                this.runtimeStats._nonempty = true;
                break;
            case 'last':
                this.runtimeStats[entry.name] = entry.value;
                this.runtimeStats._nonempty = true;
                break;
            default:
                stderr('unknown log aggregate type');
        }
    }
};

Logger.prototype.reportRuntimeStats = function(flush) {
    if (this.runtimeStats._nonempty) {
        delete this.runtimeStats._nonempty;

        if (this.adp) {
            this.adp.trackEvent('BACKGROUND_CALL', {
                operation: {
                    id: this.sessionId,
                    type: 'stats',
                    stage: '',
                    status: 'C',
                    meta: this.runtimeStats
                }
            });
        }

        this.runtimeStats.category = 'misc_stats';
        this.log(this.runtimeStats, flush);

        this.runtimeStats = {};
    }
};

Autodesk.Viewing.Private.Logger = Logger;

})();
;/**
 * Autocam is the container for the view cube and steering wheel classes.
 * It contains math for camera transformations and most of the functions are retrieved from SampleCAM.
 * Refer to their documentation for explanation.
 */
var Autocam = Autocam || function(camera, navApi) {

    var cam = this;
    var dropDownMenu = null;
    var cubeContainer = null;
    var _changing = false;

    this.cube = null;
    this.camera = camera;
    this.renderer = 'WEBGL';
    this.startState = {};
    this.navApi = navApi;   // TODO: use this for camera sync.
    this.orthographicFaces = false;

    this.cameraChangedCallback = null;
    this.pivotDisplayCallback = null;
    this.canvas = null;

    //delta Time
    var startTime = Date.now();
    var deltaTime;
    var setHomeDeferred = false;

    function changed(worldUpChanged)
    {
        _changing = true;
        camera.target.copy(cam.center);
        camera.pivot.copy(cam.pivot);

        if( camera.worldup )
            camera.worldup.copy(cam.sceneUpDirection);
        else
            camera.up.copy(cam.sceneUpDirection);

        // stderr("CHANGE: " + cam.center.x.toFixed(3) + ", " + cam.center.y.toFixed(3) + ", " + cam.center.z.toFixed(3));

        if( cam.cameraChangedCallback )
            cam.cameraChangedCallback(worldUpChanged);

        _changing = false;
    }
    
    this.dtor = function() {
        this.cube = null;
        this.cameraChangedCallback = null;
        this.pivotDisplayCallback = null;
        this.canvas = null;
    };

    this.showPivot = function(state)
    {
        if( this.pivotDisplayCallback )
            this.pivotDisplayCallback(state);
    };

        /*
    this.setViewCubeContainer = function( div )
    {
        cubeContainer = div;
    };
    */

    this.setWorldUpVector = function( newUp )
    {
        if( _changing )
            return;

        if( newUp && (newUp.lengthSq() > 0) && !newUp.normalize().equals(this.sceneUpDirection) )
        {
            // stderr("AUTOCAM UP: " + newUp.x.toFixed(3) + ", " + newUp.y.toFixed(3) + ", " + newUp.z.toFixed(3));
            //
            // Changing up resets the front face:
            this.sceneUpDirection.copy( newUp );
            this.sceneFrontDirection.copy( this.getWorldFrontVector() );
            this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
            if( this.cube )
                requestAnimationFrame(this.cube.render);
        }
    };

    this.getWorldUpVector = function()
    {
        return this.sceneUpDirection.clone();
    };

    // Assumes sceneUpDirection is set.
    this.getWorldRightVector = function()
    {
        var vec = this.sceneUpDirection.clone();

        if (Math.abs(vec.z) <= Math.abs(vec.y))
        {
            // Cross(Vertical, ZAxis)
            vec.set(vec.y, -vec.x, 0);
        }
        else if (vec.z >= 0)
        {
            // Cross(YAxis, Vertical)
            vec.set(vec.z, 0, -vec.x);
        }
        else
        {
            // Cross(Vertical, YAxis)
            vec.set(-vec.z, 0, vec.x);
        }
        return vec.normalize();
    };

    // Assumes sceneUpDirection is set.
    this.getWorldFrontVector = function()
    {
        var up = this.getWorldUpVector();
        return up.cross(this.getWorldRightVector()).normalize();
    };

    this.goToView = function( viewVector ) {
        if( this.navApi.isActionEnabled('gotoview') ) {
            var destination = {
                position: viewVector.position.clone(),
                      up: viewVector.up.clone(),
                  center: viewVector.center.clone(),
                   pivot: viewVector.pivot.clone(),
                     fov: viewVector.fov,
                 worldUp: viewVector.worldUp.clone(),
                 isOrtho: viewVector.isOrtho
            };
            cam.elapsedTime = 0;
            this.animateTransition(destination);
        }
    };

    this.getCurrentView = function () {
        return {
            position: camera.position.clone(),
            up: camera.up.clone(),
            center: this.center.clone(),
            pivot: this.pivot.clone(),
            fov: camera.fov,
            worldUp: this.sceneUpDirection.clone(),
            isOrtho: (camera.isPerspective === false)
        };
    };

    this.setCurrentViewAsHome = function( focusFirst ) {
        if( focusFirst ) {
            this.navApi.setRequestFitToView(true);
            setHomeDeferred = true;
        }
        else {
            this.homeVector = this.getCurrentView();
        }
    };

    // This method sets both the "current" home and the "original" home.
    // The latter is used for the "reset home" function.
    this.setHomeViewFrom = function(camera) {
        var pivot   = camera.pivot   ? camera.pivot   : this.center;
        var center  = camera.target  ? camera.target  : this.pivot;
        var worldup = camera.worldup ? camera.worldup : this.sceneUpDirection;

        this.homeVector = {
            position: camera.position.clone(),
                  up: camera.up.clone(),
              center: center.clone(),
               pivot: pivot.clone(),
                 fov: camera.fov,
             worldUp: worldup.clone(),
             isOrtho: (camera.isPerspective === false)
        };

        this.originalHomeVector = {
            position: camera.position.clone(),
                  up: camera.up.clone(),
              center: center.clone(),
               pivot: pivot.clone(),
                 fov: camera.fov,
             worldUp: worldup.clone(),
          worldFront: this.sceneFrontDirection.clone(),  // Extra for reset orientation
             isOrtho: (camera.isPerspective === false)
        };
    };

    this.toPerspective = function() {
        if( !camera.isPerspective ) {
            camera.toPerspective();
            changed(false);
        }
    };

    this.toOrthographic = function() {
        if( camera.isPerspective ) {
            camera.toOrthographic();
            changed(false);
        }
    };

    this.setOrthographicFaces = function(state) {
         this.orthographicFaces = state;
    };

    this.goHome = function() {
        if( this.navApi.isActionEnabled('gotoview') ) {
            this.navApi.setPivotSetFlag(false);
            this.goToView( this.homeVector );
        }
    };

    this.resetHome = function() {
        this.homeVector.position.copy(this.originalHomeVector.position);
        this.homeVector.up.copy(this.originalHomeVector.up);
        this.homeVector.center.copy(this.originalHomeVector.center);
        this.homeVector.pivot.copy(this.originalHomeVector.pivot);
        this.homeVector.fov = this.originalHomeVector.fov;
        this.homeVector.worldUp.copy(this.originalHomeVector.worldUp);
        this.homeVector.isOrtho = this.originalHomeVector.isOrtho;
        this.goHome();
    };

    this.getView = function() {
        return this.center.clone().sub(camera.position);
    };

    this.setCameraUp = function(up) {
        var view = this.dir.clone();
        var right = view.cross(up).normalize();
        if( right.lengthSq() === 0 )
        {
            // Try again after perturbing eye direction:
            view.copy(this.dir);
            if( up.z > up.y )
                view.y += 0.0001;
            else
                view.z += 0.0001;

            right = view.cross(up).normalize();
        }
        // Orthogonal camera up direction:
        camera.up.copy(right).cross(this.dir).normalize();
    };

    /***
    this.render = function(){
        //renderer.render( scene, camera );
        //We need to remove all calls to this render
        console.log("Unrequired call to render within Autocam.js:17")
    };
    ***/

    (function animate() {
        requestAnimationFrame(animate);
        // Is there an assumption here about the order of animation frame callbacks?
        var now = Date.now();
        deltaTime = now - startTime;
        startTime = now;
        // stderr("ANIMATE: delta = " + deltaTime.toFixed(4));
    }());

    //Control variables
    this.ortho = false;
    this.center = camera.target ? camera.target.clone() : new THREE.Vector3(0,0,0);
    this.pivot = camera.pivot ? camera.pivot.clone() : this.center.clone();

    this.sceneUpDirection    = camera.worldup ? camera.worldup.clone() : camera.up.clone();
    this.sceneFrontDirection = this.getWorldFrontVector();

    //
    //dir, up, left vector
    this.dir = this.getView();

    // Compute "real" camera up:
    this.setCameraUp(camera.up);

    this.saveCenter = this.center.clone();
    this.savePivot  = this.pivot.clone();
    this.saveEye    = camera.position.clone();
    this.saveUp     = camera.up.clone();
    var prevEye, prevCenter, prevUp, prevPivot;

    this.cubeFront = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();

    this.setHomeViewFrom(camera);

    var rotInitial = new THREE.Quaternion();
    var rotFinal   = new THREE.Quaternion();
    var rotTwist   = new THREE.Quaternion();
    var rotSpin    = new THREE.Quaternion();
    var distInitial;
    var distFinal;

    /**
     * Holds the default pan speed multiplier of 0.5
     * @type {number}
     */
    this.userPanSpeed = 0.5;

    /**
     * Holds the default look speed multiplier of 2.0
     * @type {number}
     */
    this.userLookSpeed = 2.0;

    /**
     * Holds the default height speed multiplier of 5.0 (used in updown function)
     * @type {number}
     */
    this.userHeightSpeed = 5.0;

    /**
     * Holds the current walk speed multiplier, which can be altered in the steering wheel drop down menu (between 0.24 and 8)
     * @type {number}
     */
    this.walkMultiplier = 1.0;

    /**
     * Holds the default zoom speed multiplier of 1.015
     * @type {number}
     */
    this.userZoomSpeed = 1.015;

    /**
     * Holds the orbit multiplier of 5.0
     * @type {number}
     */
    this.orbitMultiplier = 5.0;
    this.currentlyAnimating = false;

    //look
    camera.keepSceneUpright = true;

    //orbit
    this.preserveOrbitUpDirection = true;
    this.alignOrbitUpDirection = true;
    this.constrainOrbitHorizontal = false;
    this.constrainOrbitVertical = false;
    this.doCustomOrbit = false;
    this.snapOrbitDeadZone = 0.045;
    this.snapOrbitThresholdH = this.snapOrbitThresholdV = THREE.Math.degToRad(15.0);
    this.snapOrbitAccelerationAX = this.snapOrbitAccelerationAY = 1.5;
    this.snapOrbitAccelerationBX = this.snapOrbitAccelerationBY = 2.0;
    this.snapOrbitAccelerationPointX = this.snapOrbitAccelerationPointY = 0.5;
    this.alignDirTable = new Array(26);
    this.alignDirTable[0] = new THREE.Vector3(-1,0,0);
    this.alignDirTable[1] = new THREE.Vector3(1,0,0);
    this.alignDirTable[2] = new THREE.Vector3(0,-1,0);
    this.alignDirTable[3] = new THREE.Vector3(0,1,0);
    this.alignDirTable[4] = new THREE.Vector3(0,0,-1);
    this.alignDirTable[5] = new THREE.Vector3(0,0,1);

    // fill edges
    this.alignDirTable[6] = new THREE.Vector3(-1,-1,0);
    this.alignDirTable[7] = new THREE.Vector3(-1,1,0);
    this.alignDirTable[8] = new THREE.Vector3(1,-1,0);
    this.alignDirTable[9] = new THREE.Vector3(1,1,0);
    this.alignDirTable[10] = new THREE.Vector3(0,-1,-1);
    this.alignDirTable[11] = new THREE.Vector3(0,-1,1);
    this.alignDirTable[12] = new THREE.Vector3(0,1,-1);
    this.alignDirTable[13] = new THREE.Vector3(0,1,1);
    this.alignDirTable[14] = new THREE.Vector3(-1,0,-1);
    this.alignDirTable[15] = new THREE.Vector3(1,0,-1);
    this.alignDirTable[16] = new THREE.Vector3(-1,0,1);
    this.alignDirTable[17] = new THREE.Vector3(1,0,1);

    // fill corners
    this.alignDirTable[18] = new THREE.Vector3(-1,-1,-1);
    this.alignDirTable[19] = new THREE.Vector3(-1,-1,1);
    this.alignDirTable[20] = new THREE.Vector3(-1,1,-1);
    this.alignDirTable[21] = new THREE.Vector3(-1,1,1);
    this.alignDirTable[22] = new THREE.Vector3(1,-1,-1);
    this.alignDirTable[23] = new THREE.Vector3(1,-1,1);
    this.alignDirTable[24] = new THREE.Vector3(1,1,-1);
    this.alignDirTable[25] = new THREE.Vector3(1,1,1);

    this.combined = false;

    //variables used for snapping
    this.useSnap = false;
    this.lockDeltaX = 0.0;
    this.lockedX = false;
    this.lastSnapRotateX = 0.0;
    this.lockDeltaY = 0.0;
    this.lockedY = false;
    this.lastSnapRotateY = 0.0;
    this.lastSnapDir = new THREE.Vector3(0,0,0);

    //up-down
    this.topLimit = false;
    this.bottomLimit = false;
    this.minSceneBound = 0;
    this.maxSceneBound = 0;

    //shot
    var shotParams = { destinationPercent:1.0, duration:1.0, zoomToFitScene:true, useOffAxis:false };
    this.shotParams = shotParams;   // Expose these for modification
    var camParamsInitial, camParamsFinal;

    //zoom
    this.zoomDelta = new THREE.Vector2();
    var unitAmount = 0.0;

    //walk
    var m_resetBiasX, m_resetBiasY, m_bias;

    //info about model object we need to save for fit to window
    var boundingBoxMin = new THREE.Vector3();
    var boundingBoxMax = new THREE.Vector3();

    /**
     * Parameters to control the saving and displaying of the rewind timeline
     * @example <caption> Changing the maximum number of stored rewind cameras from 25(default) to 50 </caption>
     * cam.rewindParams.maxHistorySize = 50;
     */
    this.rewindParams = {
        history:[],
        startTime:undefined,
        thumbnailSize:56.0,
        thumbnailGapSize:12.0,
        maxHistorySize:25,
        snappingEnabled:true,
        timelineIndex:0,
        timelineIndexSlide:0,
        open:false,
        openLocation:new THREE.Vector2(0,0),
        openBracket:new THREE.Vector2(0,0),
        openBracketA:new THREE.Vector2(0,0),
        openBracketB:new THREE.Vector2(0,0),
        openLocationOrigin:new THREE.Vector2(0,0),
        locationOffset:new THREE.Vector2(0,0),
        snapOffset:new THREE.Vector2(0,0),
        slideOffset:new THREE.Vector2(0,0),
        snapped:true,
        resetWeights:false,
        recordEnabled:false,
        elementIsRecording:false
    };

    this.viewCubeMenuOpen = false;
    this.menuSize = new THREE.Vector2(0,0);
    this.menuOrigin = new THREE.Vector2(0,0);

    camera.lookAt(this.center);

    // function windowResize(){
        // refresh camera on size change

        // We handle this elsewhere
        /*
            renderer.setSize( window.innerWidth, window.innerHeight );
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.topFov = camera.bottomFov = camera.fov/2;
            camera.leftFov = camera.rightFov = (camera.aspect * camera.fov)/2;
            camera.updateProjectionMatrix();
        */
    // }

    /***
    windowResize();
    window.addEventListener('resize', windowResize, false);
    ***/

    this.setCube = function(viewcube)
    {
        this.cube = viewcube;    // DOH!!!
    };

    /**
     * Function which loads the JSON object to the scene
     * @param {JSONObject} model - The correctly formatted JSON model
     * @param {Vector3} scale - The scale multiplier for the input model
     * @param {Vector3} position - Where to load the model
     * @example <caption>Load an object called car.json to (0,0,0) with a scale of 50 </caption>
     * cam.loadObject('Objects/car.json', new THREE.Vector3(50,50,50), new THREE.Vector3(0,0,0));
     */
    this.loadObject = function(model, scale, position){
        loader = new THREE.JSONLoader();
        loader.load( model, function( geometry, materials ) {
            var faceMaterial = new THREE.MeshPhongMaterial( materials );
            mesh = new THREE.Mesh( geometry, faceMaterial );
            mesh.scale = scale;
            mesh.position.copy(position);
            mesh.geometry.computeBoundingBox();
            var bBox = mesh.geometry.boundingBox.clone();
            boundingBoxMax.set(bBox.max.x,bBox.max.y,bBox.max.z);
            boundingBoxMin.set(bBox.min.x,bBox.min.y,bBox.min.z);
            boundingBoxMax.multiply(scale);
            boundingBoxMin.multiply(scale);
            scene.add( mesh );
            objects.push( mesh );
        });
    };


    // Sync our local data from the given external camera:
    this.sync = function(clientCamera) {
        if( clientCamera.isPerspective !== camera.isPerspective ) {
            if( clientCamera.isPerspective ) {
                camera.toPerspective();
            }
            else {
                camera.toOrthographic();
                if( clientCamera.saveFov )
                    camera.saveFov = clientCamera.saveFov;
            }
        }
        camera.fov = clientCamera.fov;
        camera.position.copy(clientCamera.position);

        if( clientCamera.target ) {
            this.center.copy(clientCamera.target);
            camera.target.copy(clientCamera.target);
        }
        if( clientCamera.pivot ) {
            this.pivot.copy(clientCamera.pivot);
            camera.pivot.copy(clientCamera.pivot);
        }
        this.dir.copy(this.center).sub(camera.position);

        this.setCameraUp(clientCamera.up);

        var worldUp = clientCamera.worldup ? clientCamera.worldup : clientCamera.up;
        if( worldUp.distanceToSquared(this.sceneUpDirection) > 0.0001 ) {
            this.setWorldUpVector(worldUp);
        }

        if( setHomeDeferred && !this.navApi.getTransitionActive() ) {
            setHomeDeferred = false;
            this.setCurrentViewAsHome(false);
        }
        if( this.cube )
            requestAnimationFrame(this.cube.render);
    };


    this.refresh = function() {
        if( this.cube )
            this.cube.refreshCube();
    };

    /*        Prototyped Functions          */

    //extending Box2 to be used like AutoCam::Box2
    THREE.Box2.prototype.setCenter = function (center){
        var halfSize = new THREE.Vector2((Math.abs(this.max.x - this.min.x)/2.0),(Math.abs(this.max.y - this.min.y))/2.0);
        this.min.copy( center ).sub( halfSize );
        this.max.copy( center ).add( halfSize );
        return this;
    };

    //Using Box2 like an AutoCam::Icon2D
    THREE.Box2.prototype.getIcon2DCoords = function(Pscreen,PIcon2D){
        var zero = this.center;
        PIcon2D.set((Pscreen.x - zero.x)/(this.size().x/2.0) , (Pscreen.y - zero.y)/(this.size().y / 2.0));
    };

    //so we dont need a matrix4 as an intermediate
    THREE.Matrix3.prototype.makeRotationFromQuaternion = function ( q ) {
        var te = this.elements;

        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;

        te[0] = 1 - ( yy + zz );
        te[3] = xy - wz;
        te[6] = xz + wy;

        te[1] = xy + wz;
        te[4] = 1 - ( xx + zz );
        te[7] = yz - wx;

        te[2] = xz - wy;
        te[5] = yz + wx;
        te[8] = 1 - ( xx + yy );

        return this;
    };

    // changed to accept a matrix3
    THREE.Quaternion.prototype.setFromRotationMatrix3 = function ( m ) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        var te = m.elements,
            m11 = te[0], m12 = te[3], m13 = te[6],
            m21 = te[1], m22 = te[4], m23 = te[7],
            m31 = te[2], m32 = te[5], m33 = te[8],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {
            s = 0.5 / Math.sqrt( trace + 1.0 );
            this.w = 0.25 / s;
            this.x = ( m32 - m23 ) * s;
            this.y = ( m13 - m31 ) * s;
            this.z = ( m21 - m12 ) * s;
        } else if ( m11 > m22 && m11 > m33 ) {
            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
            this.w = (m32 - m23 ) / s;
            this.x = 0.25 * s;
            this.y = (m12 + m21 ) / s;
            this.z = (m13 + m31 ) / s;
        } else if ( m22 > m33 ) {
            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
            this.w = (m13 - m31 ) / s;
            this.x = (m12 + m21 ) / s;
            this.y = 0.25 * s;
            this.z = (m23 + m32 ) / s;
        } else {
            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
            this.w = ( m21 - m12 ) / s;
            this.x = ( m13 + m31 ) / s;
            this.y = ( m23 + m32 ) / s;
            this.z = 0.25 * s;
        }
        return this;
    };

    // NOTE: This modifies the incoming vector!!
    // TODO: Change all calls to use Vector3.applyQuaternion instead.
    THREE.Quaternion.prototype.rotate = function (vector){
        //From AutoCamMath.h file
        var kRot = new THREE.Matrix4().makeRotationFromQuaternion(this);
        var e = kRot.elements;

        //converting 4d matrix to 3d
        var viewRot = new THREE.Matrix3().set( e[0],e[1],e[2], e[4],e[5],e[6], e[8],e[9],e[10] );

        return vector.applyMatrix3(viewRot);
    };

    THREE.Vector3.prototype.findAngleWith = function(b, axis){
        var angle = 0.0;
        var cosAngle = this.clone().normalize().clone().dot(b.clone().normalize());

        var axisCheck = (this.clone().cross(b)).clone().normalize();
        if (axisCheck.clone().length() < Number.MIN_VALUE){
            if(cosAngle > 0.0){
                angle = 0.0;
            }else{
                angle = 180.0;
            }
        }else{

            var cosCheck = axisCheck.clone().dot(axis.clone().normalize());

            //check to make sure user specified axis is orthogonal to vectors.
            //If it isn't we take the closer of the two choices.
            axis = cosCheck > 0.0 ? axisCheck : -axisCheck;

            var cosAngleNextQuadrant = new THREE.Quaternion().setFromAxisAngle( axis, 90.0 * THREE.Math.degToRad );
            cosAngleNextQuadrant = ((cosAngleNextQuadrant.clone().rotate(b)).clone().normalize()).clone().dot(this);
            angle = Math.acos(cosAngle) * THREE.Math.radToDeg;

            if(Math.abs(angle - 90.0) < Number.MIN_VALUE)
                angle = 90.0;

            if ((angle < 90.0 && cosAngle * cosAngleNextQuadrant > 0.0)||
                (angle > 90.0 && cosAngle * cosAngleNextQuadrant < 0.0)||
                (angle == 90.0 && cosAngleNextQuadrant > 0.0))
                angle = -1.0 * angle;	//figure out whether we need to turn left or right
        }

        angle = THREE.Math.degToRad(angle);
        return angle;
    };

    if(!('contains' in String.prototype))
        String.prototype.contains = function(str, startIndex) { return -1 !== String.prototype.indexOf.call(this, str, startIndex); };

    Math.linearClamp = function( x, a, b ){
        if ( x <= a ) { return 0.0; }
        if ( x >= b ) { return 1.0; }

        return ( x - a ) / ( b - a );
    };

    Math.easeClamp = function( x, a, b ){
        if ( x <= a ) { return 0.0; }
        if ( x >= b ) { return 1.0; }

        var t = ( x - a ) / ( b - a );
        return 0.5 * ( Math.sin( (t - 0.5) * Math.PI ) + 1.0 );
    };

    Math.linearInterp = function( t, a, b ){
        return a * (1.0 - t) + b * t;
    };

    Math.equalityClamp = function (x,a,b){
        if ( x <= a ) { return a; }
        if ( x >= b ) { return b; }

        return x;
    };

    Math.round2 = function (x){
        return (Math.round(x*100))/100;
    };

    Math.round1 = function (x){
        return (Math.round(x*10))/10;
    };


    /*      SHOT OPERATION      */

    //transitions smoothly to destination
    this.animateTransition = function ( destination ) {

        if ( !destination ) { return; }

        var worldUpChanged = false;
        var unitTime = 0.0;

        this.setCameraOrtho(destination.isOrtho);

        if ( cam.elapsedTime >= shotParams.duration ) {
            unitTime = 1.0;

            cam.center.copy(destination.center);
            cam.pivot.copy(destination.pivot);
            camera.position.copy(destination.position);
            camera.up.copy(destination.up);
            if( !destination.isOrtho )
                camera.fov = destination.fov;

            worldUpChanged = !destination.worldUp.equals(this.sceneUpDirection);
            if( worldUpChanged )
                this.setWorldUpVector(destination.worldUp);

            this.currentlyAnimating = false;
            changed(worldUpChanged);
            this.showPivot(false);
            if( this.cube )
                requestAnimationFrame(this.cube.render);

            this.addHistoryElement();
            this.navApi.setTransitionActive(false);
            return;
        }
        this.currentlyAnimating = true;
        this.showPivot(true);
        this.navApi.setTransitionActive(true);

        var tMax = shotParams.destinationPercent;
        unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
        var oneMinusTime = 1.0 - unitTime;
        cam.elapsedTime += deltaTime/500;

        var center = (cam.center.clone().multiplyScalar(oneMinusTime)).add( destination.center.clone().multiplyScalar( unitTime ));
        var position = (camera.position.clone().multiplyScalar(oneMinusTime)).add(destination.position.clone().multiplyScalar( unitTime ));
        var up = (camera.up.clone().multiplyScalar(oneMinusTime)).add(destination.up.clone().multiplyScalar( unitTime ));
        var pivot = (camera.pivot.clone().multiplyScalar(oneMinusTime)).add(destination.pivot.clone().multiplyScalar( unitTime ));
        var worldUp = (this.sceneUpDirection.clone().multiplyScalar(oneMinusTime)).add(destination.worldUp.clone().multiplyScalar( unitTime ));
        var fov = camera.fov * oneMinusTime + destination.fov * unitTime;

        cam.center.copy(center);
        cam.pivot.copy(pivot);
        camera.position.copy(position);
        camera.up.copy(up);
        if( !destination.isOrtho )
            camera.fov = fov;

        worldUpChanged = (worldUp.distanceToSquared(this.sceneUpDirection) > 0.0001);
        if( worldUpChanged )
            this.setWorldUpVector(worldUp);

        camera.lookAt(cam.center);
        changed(worldUpChanged);

        if( this.cube )
            requestAnimationFrame(this.cube.render);

        requestAnimationFrame(function() { cam.animateTransition(destination); });
    };

    //used for view cube transforms, to see difference between this and linear interpolation watch
    //http://www.youtube.com/watch?v=uNHIPVOnt-Y
    this.sphericallyInterpolateTransition = function( completionCallback )
    {
        var center, position, up;
        var unitTime = 0.0;
        this.currentlyAnimating = true;
        this.navApi.setTransitionActive(true);

        if ( cam.elapsedTime >= shotParams.duration ){
            unitTime = 1.0;
            this.currentlyAnimating = false;
        }
        else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/500;
        }

        // This seems to avoid some error in the rotation:
        if( unitTime === 1.0 ) {
            position = camParamsFinal.position;
            center   = camParamsFinal.center;
            up       = camParamsFinal.up;
        }
        else {
            var M = new THREE.Matrix3();
            var rot = rotInitial.clone();
            rot.slerp(rotFinal,(unitTime));
            M.makeRotationFromQuaternion(rot);
            var dist = Math.linearInterp(unitTime, distInitial, distFinal);

            var e = M.elements;

            center = camParamsInitial.center.clone().multiplyScalar(1.0 - unitTime).add(camParamsFinal.center.clone().multiplyScalar(unitTime));
            position = center.clone().sub(new THREE.Vector3(e[0],e[1],e[2]).multiplyScalar(dist));
            up = new THREE.Vector3(e[3],e[4],e[5]);
        }
        cam.center.copy(center);
        camera.position.copy(position);
        camera.up.copy(up);

        // The above code will have to change if we want the proper rotation
        // to occur about the pivot point instead of the center.
        if( !cam.navApi.getUsePivotAlways() )
            cam.pivot.copy(center);

        camera.lookAt(cam.center);

        if( this.currentlyAnimating === true ) {
            this.showPivot(true);
            requestAnimationFrame(function() { cam.sphericallyInterpolateTransition(completionCallback); });
        }
        else {
            this.navApi.setTransitionActive(false);
            this.showPivot(false);
            this.addHistoryElement();

            if( this.orthographicFaces && this.isFaceView() )
                this.setCameraOrtho(true);

            if( completionCallback )
                completionCallback();
        }
        changed(false);
        if( this.cube )
            requestAnimationFrame(this.cube.render);
    };

    //This is used to determine the relation between camera up vector and scene direction, used to determine which
    //face to translate to when clicking on a viewcube arrow
    this.getOrientation = function(){
        if( !this.cube )
            return;

        var camX = Math.round1(camera.up.x);
        var camY = Math.round1(camera.up.y);
        var camZ = Math.round1(camera.up.z);
        var sceneFront = this.sceneFrontDirection.clone();
        var sceneUp = this.sceneUpDirection.clone();
        var sceneRight = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
        sceneFront.x = Math.round1(sceneFront.x);
        sceneFront.y = Math.round1(sceneFront.y);
        sceneFront.z = Math.round1(sceneFront.z);
        sceneUp.x = Math.round1(sceneUp.x);
        sceneUp.y = Math.round1(sceneUp.y);
        sceneUp.z = Math.round1(sceneUp.z);
        sceneRight.x = Math.round1(sceneRight.x);
        sceneRight.y = Math.round1(sceneRight.y);
        sceneRight.z = Math.round1(sceneRight.z);
        var sceneLeft = sceneRight.clone().multiplyScalar(-1);
        var sceneDown = sceneUp.clone().multiplyScalar(-1);
        var sceneBack = sceneFront.clone().multiplyScalar(-1);

        switch (this.cube.currentFace){
            case "front":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
            case "right":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "left";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "right"
                break;
            case "left":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "left";
                else if (sceneBack.x ==camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "right"
                break;
            case "back":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "right";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "left"
                break;
            case "top":
                if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "down";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "up";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
            case "bottom":
                if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "down";
                else if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "up";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
        }
    };

    this.setCameraOrtho = function(yes) {
        if( yes && camera.isPerspective )
            camera.toOrthographic();

        if( !yes && !camera.isPerspective )
            camera.toPerspective();
    };

    this.resetOrientation = function(){
        this.setCameraOrtho(this.originalHomeVector.isOrtho);
        this.sceneUpDirection.copy(this.originalHomeVector.worldUp);
        this.sceneFrontDirection.copy(this.originalHomeVector.worldFront);
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        this.setCameraUp(this.sceneUpDirection);
        changed(true);
    };

    this.setCurrentViewAsFront = function(){
        if( this.cube )
            this.cube.currentFace = "front";

        this.sceneUpDirection.copy(camera.up.clone());
        this.sceneFrontDirection.copy(this.getView()).normalize();
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();

        if( this.orthographicFaces )
            this.setCameraOrtho(true);

        changed(true);
    };

    this.setCurrentViewAsTop = function(){
        if( this.cube )
            this.cube.currentFace = "top";

        this.sceneUpDirection.copy(this.getView()).multiplyScalar(-1).normalize();
        this.sceneFrontDirection.copy(camera.up);
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        changed(true);
    };

    this.calculateCubeTransform = function(faceString){
        var worldUp = this.sceneUpDirection.clone();
        var worldFront = this.sceneFrontDirection.clone();
        var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection).normalize();

        camParamsInitial = camera.clone();
        camParamsInitial.center = cam.center.clone();
        camParamsInitial.pivot = cam.pivot.clone();

        camParamsFinal = camera.clone();
        camParamsFinal.center = cam.center.clone();
        camParamsFinal.pivot = cam.pivot.clone();

        // find movement offset based on given boolean flags
        var offset = new THREE.Vector3( 0, 0, 0 );
        if ( faceString.contains('back')){
            offset = offset.add(worldFront);
        }
        if ( faceString.contains('front')){
            offset = offset.sub(worldFront);
        }
        if ( faceString.contains('top')){
            offset = offset.add(worldUp);
        }
        if ( faceString.contains('bottom')){
            offset = offset.sub(worldUp);
        }
        if ( faceString.contains('right')){
            offset = offset.add(worldRight);
        }
        if ( faceString.contains('left')){
            offset = offset.sub(worldRight);
        }
        var upDir = worldUp;

        // view looking at top or bottom chosen
        var test = offset.clone().normalize();

        if ( ( 1.0 - Math.abs(test.dot(worldUp)) ) < Number.MIN_VALUE ) {
            //( offset == worldUp || offset == -worldUp )
            // find the principal view direction other than top/bottom closest to
            // the current view direction and use it as an up vector

            var viewDir = this.getView().normalize();
            var optUpDir = [ worldFront.clone(), worldFront.clone().negate(), worldRight.clone(), worldRight.clone().negate() ];

            // use both view and up vectors for test vector because transitioning from
            // top and bottom views, view direction is the same (but up direction is different)

            var sign = (test.dot(worldUp) > 0.0) ? +1.0 : -1.0; //( offset == worldUp ) ? +1.0 : -1.0;
            var testDir = viewDir.clone().add(camera.up.clone().multiplyScalar(sign)).normalize();

            var optValue = -2.0;

            for ( var i = 0; i < 4; i++ ){
                var value = testDir.dot( optUpDir[i] );

                if ( value > optValue ){
                    optValue = value;
                    upDir = optUpDir[i].multiplyScalar(sign);
                }
            }
        }

        distFinal = distInitial = this.getView().length();
        // WHY? camParamsFinal.center = this.originalCenter;
        camParamsFinal.position.copy(camParamsFinal.center.clone().add(offset.multiplyScalar(distFinal/offset.length())));
        camParamsFinal.up.copy(upDir);

        var D = camParamsInitial.center.clone().sub(camParamsInitial.position).normalize();
        var R = D.clone().cross(camParamsInitial.up).normalize();
        var U = R.clone().cross(D).normalize();
        var M = new THREE.Matrix3();
        M.set(D.x, U.x, R.x, D.y, U.y, R.y, D.z, U.z, R.z);
        rotInitial.setFromRotationMatrix3(M);

        D = camParamsFinal.center.clone().sub(camParamsFinal.position).normalize();
        R = D.clone().cross(camParamsFinal.up).normalize();
        U = R.clone().cross(D).normalize();
        M.set(D.x, U.x, R.x, D.y, U.y, R.y, D.z, U.z, R.z);
        //TODO: figure out when these angles aren't supposed to be 0, works for now
        rotTwist.setFromAxisAngle(D,0.0);
        rotSpin.setFromAxisAngle(U,0.0);
        rotFinal.setFromRotationMatrix3(M);
        rotFinal.multiply(rotTwist).multiply(rotSpin).normalize();

    };

    //used for center operation from steering wheel and steering wheel menu
    this.centerShot = function(fromWheelMenu){
        //TODO: investigate the problem where it is not animating sometimes (due to lag)

        if (!camParamsInitial || fromWheelMenu){
            cam.elapsedTime = 0;
            camParamsInitial = camParamsFinal = camera.clone();
            camParamsInitial.center = cam.center;
        }

        var pWorld = cam.pivot.clone();
        var P = pWorld.clone().sub(camParamsInitial.position);
        var D = (camParamsInitial.center.clone().sub(camParamsInitial.position)).normalize();
        var U = camParamsInitial.up.clone();
        var R = (D.clone().cross(U)).normalize();
        U = (R.clone().cross(D)).normalize();


        var PprojR = R.clone().multiplyScalar(R.dot(P));
        var PprojU = U.clone().multiplyScalar(U.dot(P));
        var PprojRU = PprojR.clone().add(PprojU);

        camParamsFinal.position.copy(camParamsInitial.position.clone().add(PprojRU));

        camParamsFinal.center = pWorld;
        camParamsFinal.pivot = pWorld;

        var unitTime = 0.0;
        if ( cam.elapsedTime >= shotParams.duration ) {
            unitTime = 1.0;
        } else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/2000;
        }

        var position = (camera.position.clone().multiplyScalar( 1.0 - unitTime)).add(camParamsFinal.position.clone().multiplyScalar( unitTime ));
        var center = (cam.center.clone().multiplyScalar( 1.0 - unitTime)).add( camParamsFinal.center.clone().multiplyScalar( unitTime ));
        var pivot = (cam.pivot.clone().multiplyScalar( 1.0 - unitTime)).add( camParamsFinal.pivot.clone().multiplyScalar(unitTime));
        camera.position.copy(position);
        cam.center.copy(center);
        cam.pivot.copy(pivot);

        camera.lookAt(cam.center);
        changed(false);

        if( unitTime === 1.0 )
            this.addHistoryElement();
        else
            requestAnimationFrame(function() { cam.centerShot(false); });
    };

    //This is for the level camera operation in steering wheel menu
    //Integrated from ViewManager::LevelCamera
    this.levelShot = function(){

        var view = this.getView();
        var dist = view.length();
        var worldUp = this.sceneUpDirection.clone();
        var vUp  = camera.up.clone().normalize();
        var vView = view.normalize();
        var dotView = vView.dot(worldUp);

        if ((1.0 - Math.abs(dotView)) > Number.MIN_VALUE){
            var vRight = vView.clone().cross(worldUp);
            vView = worldUp.clone().cross(vRight);
            vView.normalize();
        }else{
            vView = vUp.clone();
        }
        vView.multiplyScalar(dist);

        var destination = {
            center: vView.add(camera.position),
            up: worldUp,
            position: camera.position,
            pivot: cam.center.clone().add(vView),
            fov: camera.fov,
            worldUp: worldUp
        };
        cam.elapsedTime = 0;
        cam.animateTransition(destination);
    };

    //This is for the fit to window operation in the steering wheel drop down menu
    //Integrated from CameraOperations::FitBoundingBoxToView
    //Right now since we only load one mesh we can use the bounding box property of it, if multiple meshes loaded
    //we will need to find the bounding box around them
    this.fitToWindow = function(){

        var viewDir = this.getView();
        var upDir = camera.up.clone();
        viewDir.normalize();
        upDir.normalize();
        camParamsFinal = camera.clone();
        camParamsFinal.center = cam.center;

        upDir = getUpDirection(upDir,viewDir);
        upDir.normalize();
        camParamsFinal.up.copy(upDir);

        var rightDir = viewDir.clone().cross(upDir);
        rightDir.normalize();

        var boxMin = boundingBoxMin.clone();
        var boxMax = boundingBoxMax.clone();
        var boxPoints = [boxMin,boxMax];
        var boxMidpoint = new THREE.Vector3(boxMax.x-boxMin.x, boxMax.y-boxMin.y,boxMax.z-boxMin.z);

        boxPoints[2] = new THREE.Vector3(boxMax.x,boxMin.y,boxMax.z);
        boxPoints[3] = new THREE.Vector3(boxMax.x,boxMin.y,boxMin.z);
        boxPoints[4] = new THREE.Vector3(boxMax.x,boxMax.y,boxMin.z);
        boxPoints[5] = new THREE.Vector3(boxMin.x,boxMax.y,boxMax.z);
        boxPoints[6] = new THREE.Vector3(boxMin.x,boxMax.y,boxMin.z);
        boxPoints[7] = new THREE.Vector3(boxMin.x,boxMin.y,boxMax.z);

        //Move the box into camParams frame coordinates
        for(var j=0; j<8; j++){
            var testVector = boxPoints[j].clone().sub(camera.position);

            boxPoints[j].setX(testVector.clone().dot(rightDir));
            boxPoints[j].setY(testVector.clone().dot(upDir));
            boxPoints[j].setZ(testVector.clone().dot(viewDir));
        }

        //This is to be used when ortho camera is implemented
        /*
        var minPointH = boxPoints[0], maxPointH = boxPoints[0], minPointV = boxPoints[0],maxPointV = boxPoints[0];

        //Solve for the eye position in ortho.  We take the position as the center point
        //Of the 2D projection.
        for(var k=0; k<8; k++){
            var testVertex = boxPoints[k];
            if(testVertex.x < minPointH.x){
                minPointH = testVertex;
            }else if(testVertex.x > maxPointH.x){
                maxPointH = testVertex;
            }

            if(testVertex.y < minPointV.y){
                minPointV = testVertex;
            }else if(testVertex.y > maxPointV.y){
                maxPointV = testVertex;
            }
        }

        var geomWidth = maxPointH.x - minPointH.x;
        var geomHeight = maxPointV.y - minPointV.y;

        //Set ortho width and height
        if (geomWidth/geomHeight > camera.aspect){
            camParams.orthoWidth = geomWidth;
            camParams.orthoHeight = geomWidth/viewAspect;
        }else{
            camParams.orthoWidth = geomHeight * viewAspect;
            camParams.orthoHeight = geomHeight;
        }
        var orthoOffset = new THREE.Vector3((minPointH.x + maxPointH.x)/2.0,(minPointV.y + maxPointV.y)/2.0,0.0);
        */

        //Find the eye position in perspective.
        //While working in 2D, find the equation of the line passing through each box corner of form z = mx + b
        //that is parallel to the sides of the viewing frustum.  Note that all of the coordinates of the box
        //are still defined in the camParams frame.  Compare the z intercept values (ie. b) to figure out which two lines
        //represent the outer edges of the bounding box, and solve for their intersection to find the desired eye (x,z) position
        //that would be required to make the object touch the left and right edges of the viewport (ie. the closest we can get
        //without losing horizontal view of the object).  Repeat with z = my + b to find the eye (y,z) position for the vertical frustum.

        //TODO:fovTop and fovBottom are ALWAYS the same b/c of camera declaration, this needs to change
        var fovTop = THREE.Math.degToRad(camera.topFov);
        var fovBottom = THREE.Math.degToRad(camera.bottomFov);
        var fovLeft = THREE.Math.degToRad(camera.leftFov);
        var fovRight = THREE.Math.degToRad(camera.rightFov);

        var BLeft, BRight, BTop,BBottom;

        BLeft = (fovLeft >= 0) ? Number.MAX_VALUE : Number.MIN_VALUE;
        BRight = (fovRight >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;
        BTop = (fovTop >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;
        BBottom = (fovBottom >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;

        var slopeRight = 1.0/Math.tan(fovRight);
        var slopeLeft = -1.0/Math.tan(fovLeft);
        var slopeTop = 1.0/Math.tan(fovTop);
        var slopeBottom = -1.0/Math.tan(fovBottom);

        for (var i = 0; i<8; i++){
            var testCorner = boxPoints[i].clone();
            var b = testCorner.z - (slopeLeft * testCorner.x);
            BLeft = (fovLeft >= 0)? Math.min(BLeft,b) : Math.max(BLeft,b);

            b = testCorner.z - (slopeRight * testCorner.x);
            BRight = (fovRight >=0) ? Math.min(BRight, b) : Math.max(BRight, b);

            //For vertical frustum
            b = testCorner.z - (slopeTop *testCorner.y);
            BTop = (fovTop >=0) ? Math.min(BTop, b) : Math.max(BTop, b);

            b = testCorner.z - (slopeBottom * testCorner.y);
            BBottom = (fovBottom >=0) ? Math.min(BBottom, b) : Math.max(BBottom, b);
        }

        //Solve for intersection of horizontal frustum
        var eyeX = (BRight - BLeft)/(slopeLeft - slopeRight);
        var eyeZH = (slopeLeft * eyeX) + BLeft;

        //Solve for intersection of vertical frustum
        var eyeY = (BBottom - BTop)/(slopeTop - slopeBottom);
        var eyeZV = slopeTop * eyeY + BTop;

        var eyeZ = 0.0;

        //With the two frustums solved, compare the two frustums to see which one is currently closer to the object based on z value.
        //Slide the closer frustum back along its median line (to ensure that the points stay within the frustum) until it's Z value
        //matches that of the further frustum. Take this as the final eye position.

        if (eyeZH <= eyeZV){
            var medianAngleV = (fovTop - fovBottom) / 2.0;
            if (Math.abs(medianAngleV) > Number.MIN_VALUE){
                var medianSlopeV = 1.0/Math.tan(medianAngleV);
                eyeY = eyeY - eyeZV/medianSlopeV + eyeZH/medianSlopeV; //derived from z1 - my1 = z2 - my2
            }
            eyeZ = eyeZH;
        }else{
            var medianAngleH = (fovRight - fovLeft) / 2.0;
            if (Math.abs(medianAngleH) > Number.MIN_VALUE){
                var medianSlopeH = 1.0/Math.tan(medianAngleH);
                eyeX = eyeX - eyeZH/medianSlopeH + eyeZV/medianSlopeH;
            }
            eyeZ = eyeZV;
        }

        var eyeOffset = new THREE.Vector3(eyeX,eyeY,eyeZ);

        //Transform eyeoffset back into world frame
        var interim1 = (rightDir.clone().multiplyScalar(eyeOffset.x));
        var interim2 = (upDir.clone().multiplyScalar(eyeOffset.y));
        var interim3 = (viewDir.clone().multiplyScalar(eyeOffset.z));
        eyeOffset = interim1.clone().add(interim2.clone().add(interim3));

        camParamsFinal.position.add(eyeOffset);
        var interim = (boxMidpoint.clone().sub(camParamsFinal.position)).dot(viewDir);
        camParamsFinal.center = camParamsFinal.position.clone().add(viewDir.multiplyScalar(interim));
        camParamsFinal.pivot = boxMidpoint.clone();

        var destination = {
              center: camParamsFinal.center,
                  up: camParamsFinal.up,
            position: camParamsFinal.position,
               pivot: camParamsFinal.pivot,
                 fov: camera.fov,
             worldUp: cam.sceneUpDirection.clone()
        };
        cam.elapsedTime = 0;
        cam.animateTransition(destination);
    };

    /*         Functions for operation         */

    //used in fit to window
    function getUpDirection(upDir, viewDir){
        var upp = upDir.clone();

        if((Math.abs(upp.clone().dot(viewDir))) < Number.MIN_VALUE){
            upp.normalize();
            return upp;
        }

        upp = getProjectionOnPlane(upDir,viewDir);
        if (upp.length() < Number.MIN_VALUE){
            upp = getEmpiricalUpDirection(viewDir);
        }
        upp.normalize();
        return upp;
    }

    //used in getUpDirection
    function getProjectionOnPlane(vector,normal){
        normal.normalize();
        var projToNormal = vector.clone().dot(normal);
        var projection = normal.clone().multiplyScalar(projToNormal);
        projection = vector.clone().sub(projection);
        return projection;
    }

    //used in getUpDirection
    function getEmpiricalUpDirection(normal){
        var zeros = new THREE.Vector3(0,0,0);
        var directions = [new THREE.Vector3(0,1,0),
            new THREE.Vector3(1,0,0),
            new THREE.Vector3(0,0,1),
            new THREE.Vector3(0,1,1),
            new THREE.Vector3(1,0,1),
            new THREE.Vector3(1,1,0),
            new THREE.Vector3(1,1,1)
            ];

        for (var i = 0; i <7; i++){
            if (Math.abs(directions[i].dot(normal)) < Number.MIN_VALUE){
                zeros = directions[i];
                break;
            }
        }
        return zeros;
    }

    //convert screen coords to window coords
    function convertCoordsToWindow( pixelX, pixelY ){
        var delta = new THREE.Vector2(0,0);

        delta.x = pixelX / window.innerWidth;
        delta.y = pixelY / window.innerHeight;

        return delta;
    }

    //picking ray intersection with the empty scene(not on object)
    function getScreenRay( mouse ){
        mouse.y = Math.abs(mouse.y - window.innerHeight);
        var rayOrigin, rayDirection;
        var eye = camera.position;
        var center = cam.center;
        var eyeToCenter = center.clone().sub(eye);
        var up = camera.up;
        var right = eyeToCenter.clone().cross(up);
        var dist = eyeToCenter.clone().length();

        var frustumLeft = dist * Math.tan(THREE.Math.degToRad(camera.leftFov));
        var frustumRight = dist * Math.tan(THREE.Math.degToRad(camera.rightFov));
        var frustumTop = dist * Math.tan(THREE.Math.degToRad(camera.topFov));
        var frustumBottom = dist * Math.tan(THREE.Math.degToRad(camera.bottomFov));
        var frustumWidth = (frustumLeft + frustumRight);
        var frustumHeight = (frustumTop + frustumBottom);

        var rightLength = mouse.x * frustumWidth / window.innerWidth;
        var centerToRightLength = rightLength - frustumLeft;

        var upLength = mouse.y * frustumHeight / window.innerHeight;
        var centerToUpLength = upLength - frustumBottom;

        up = up.clone().normalize().clone().multiplyScalar(centerToUpLength);
        right = right.clone().normalize().clone().multiplyScalar(centerToRightLength);

        /*
        // PRH -- account for difference in aspect ratio between camera FOV and viewport --
        AutoCam::AdjustForAspectRatio( params, screenWidth, screenHeight, mouseXunit, mouseYunit );
        */

        if ( cam.ortho ){
            rayOrigin = eye.clone().add(right).clone().add(up);
            rayDirection = eyeToCenter;
        }else{
            rayOrigin = eye;
            rayDirection = eyeToCenter.clone().add(up).clone().add(right);
        }

        return {
            'rayO': rayOrigin,
            'rayD': rayDirection
        };
    }

    //get ray intersection point and set pivot
    this.updatePivotPosition = function( mouse ){
        //TODO: update pivot only when mouse down

        var raycaster;
        var intersects;
        //formula from online
        var direction = new THREE.Vector3((mouse.x / window.innerWidth) * 2 - 1, -(mouse.y / window.innerHeight) * 2 + 1, 0.5);

        direction = direction.unproject(camera);
        raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());
        intersects = raycaster.intersectObjects(objects);

        if (cam.mode == 'zoom'){
            if (intersects[0] !== undefined){
                var point = intersects[0].point;
                cam.pivot.copy(point);
            }else{
                var result = getScreenRay( mouse );
                cam.pivot.copy(result.rayO.clone().add(result.rayD));
            }

        }else if (intersects[0] !== undefined){
            wheel.cursorImage('pivot');
            var point = intersects[0].point;
            if (!cam.isMouseDown){
                cam.pivot.copy(point);
            }
        }else{
            wheel.cursorImage('SWInvalidArea');
        }
    };

    function getNextRotation(rotationType, snapAngle, lastDelta){
        var threshold, accelerationA, accelerationB, shiftZone;
        threshold = accelerationA = accelerationB = shiftZone = 0.0;

        var next = 0.0;
        var lockedAxis = null;
        var lockDelta = null;

        var deadZone = cam.snapOrbitDeadZone;
        var orbitMultiplier = cam.orbitMultiplier;

        if (rotationType == 'h'){
            threshold = cam.snapOrbitThresholdH;
            accelerationA = cam.snapOrbitAccelerationAX;
            accelerationB = cam.snapOrbitAccelerationBX;
            shiftZone = 1.0 -cam.snapOrbitAccelerationPointX;
            lockDelta = cam.lockDeltaX;
            lockedAxis = cam.lockedX;
        }else{
            threshold = cam.snapOrbitThresholdV;
            accelerationA = cam.snapOrbitAccelerationAY;
            accelerationB = cam.snapOrbitAccelerationBY;
            shiftZone = 1.0 -cam.snapOrbitAccelerationPointY;
            lockDelta = cam.lockDeltaY;
            lockedAxis = cam.lockedY;
        }

        if(!lockedAxis){
            if(Math.abs(snapAngle) > threshold){
                next = lastDelta * orbitMultiplier;
            }else if (Math.abs(snapAngle) > shiftZone * threshold){
                if(lastDelta * snapAngle > 0.0){
                    next = lastDelta * orbitMultiplier * accelerationA;
                }else{
                    next = lastDelta * orbitMultiplier * 1.0/accelerationA;
                }

            }else{
                if(lastDelta * snapAngle > 0.0){
                    next = lastDelta * orbitMultiplier * accelerationB;
                }else{
                    next = lastDelta * orbitMultiplier * 1.0/accelerationB;
                }

            }

            if(next * snapAngle > 0.0 && Math.abs(next) > Math.abs(snapAngle)){
                this.lockDeltaX = this.lockDeltaY = 0.0;	//want to reset both regardless of rotation axis
                lockedAxis = true;
                next = snapAngle;
            }

        }else{
            lockDelta += lastDelta;

            if(lockDelta < -deadZone){
                next =  (lockDelta + deadZone) * orbitMultiplier * 1.0/accelerationB;
                lockedAxis = false;
            }else if(lockDelta > deadZone){
                next =  (lockDelta - deadZone) * orbitMultiplier * 1.0/accelerationB;
                lockedAxis = false;
            }
        }
        return next;
    }


    function getClosestAlignDir(Dv, searchPrincipal){
        var maxAngle = -Number.MAX_VALUE;
        var maxIndex = 0;

        for ( var i = 0; i < (searchPrincipal ? 6 : 26); i++ ){
            var Di = cam.alignDirTable[i].clone().multiplyScalar(-1);
            Di.normalize();

            var angle = Di.dot(Dv);

            if ( angle > maxAngle ){
                maxAngle = angle;
                maxIndex = i;
            }
        }
        return cam.alignDirTable[maxIndex];
    }

    function snapToClosestView (up, snapAngleh, snapAnglev){
        if ( !cam.useSnap )
            return;

        if (cam.preserveOrbitUpDirection ){
            // Find closest view direction
            var lastViewDir = (cam.saveCenter.clone().sub(cam.saveEye)).clone().normalize();
            var snapDir = (getClosestAlignDir(lastViewDir, false)).clone().multiplyScalar(-1).clone().normalize();

            if(Math.abs(Math.abs(lastViewDir.clone().dot(up)) - 1.0) < Number.MIN_VALUE){
                //topdown or bottom up case
                snapAnglev = 0.0;
                var snapUp = (getClosestAlignDir(cam.saveUp, true)).clone().multiplyScalar(-1).clone().normalize();
                snapAngleh = cam.saveUp.findAngleWith(snapUp,up);
            } else {
                var lastViewDirProj = lastViewDir.clone().sub(up).multiplyScalar(up.clone().dot(lastViewDir));
                var snapDirProj = snapDir.clone().sub(up).multiplyScalar(up.clone().dot(snapDir));
                snapAngleh = lastViewDirProj.clone().findAngleWith(snapDirProj, up);
                var testRotate = new THREE.Quaternion().setFromAxisAngle( up,snapAngleh );
                var transitionDir = testRotate.clone().rotate(lastViewDir);
                var transitionRight = testRotate.clone().rotate(lastViewDir.clone().cross(cam.saveUp));
                snapAnglev = transitionDir.clone().findAngleWith(snapDir, transitionRight);
            }

            if(snapDir != cam.lastSnapDir){
                //If last and current snapDirs are not on the same plane, unlock vertical orbit
                if (Math.abs(snapDir.clone().dot(up) - cam.lastSnapDir.clone().dot(up)) > Number.MIN_VALUE){
                    cam.lockedY = false;
                }
                cam.lastSnapDir = snapDir;
            }
        } else {
            //Find closest view direction
            /*  var vDirView = cam.saveCenter.clone().sub(cam.saveEye);
            var vRight = vDirView.clone().cross( cam.saveUp );
            var snapDir = -getClosestAlignDir(vDirView, false).clone().normalize();
            var snapDirProj = snapDir.clone.sub(up.clone().multiplyScalar(up.clone().dot(snapDir)));
            snapAngleh = vDirView.findAngleWith(snapDirProj, up);

            var testRotate = new THREE.Quaternion().setFromAxisAngle(up,snapAngleh );
            var transitionDir = testRotate.clone().rotate(vDirView);
            var transitionRight = testRotate.clone().rotate(vRight);
            snapAnglev = transitionDir.findAngleWith(snapDir, transitionRight);

            if(snapDir != cam.lastSnapDir) {
                cam.cam.lockedY = false;
                cam.lockedX = false;
                cam.lastSnapDir = snapDir;
            }*/
        }
    }

/// Returns true if the operation belongs to a chain of combined operations; otherwise returns false.
    function IsCombined(){
        return cam.combined;
    }

    function isInDeadZone(currentCursor, startCursor){

        var deadZone = 30;
        var res = false;

        var w = window.innerWidth;
        var x = currentCursor.x % w;

        var h = window.innerHeight;
        var y = currentCursor.y % h;


        var diffX = (x > 0) ? (x - startCursor.x) : (w + x - startCursor.x);
        var diffY = (y > 0) ? (y - startCursor.y) : (h + y - startCursor.y);

        if((Math.abs(diffX) < deadZone) &&  (Math.abs(diffY) < deadZone))
            res = true;

        return res;
    }

    function GetXYAndWrapCounts(currentCursor, startCursor, wrapCount ){
        wrapCount.x = (currentCursor.x - startCursor.x) / window.innerWidth;
        currentCursor.x = startCursor.x + (currentCursor.x - startCursor.x) % window.innerWidth;

        wrapCount.y = (currentCursor.y - startCursor.y) / window.innerHeight;
        currentCursor.y = startCursor.y + (currentCursor.y - startCursor.y) % window.innerHeight;
    }

    function setBias( set, currentCursor, startCursor ){
        if (m_bias && set){
            return;

        }else if (set){
            var deadZone = 30;
            var wrapCount = new THREE.Vector2();

            var x = currentCursor.x;
            var y = currentCursor.y;

            GetXYAndWrapCounts(currentCursor, startCursor, wrapCount);

            m_resetBiasX = window.innerWidth * wrapCount.x;
            m_resetBiasY = window.innerHeight * wrapCount.y;

            if (x < startCursor.x)
                x = x - 2 * deadZone;
            else
                x = x + 2 * deadZone;

            if (y < startCursor.y)
                y = y - 2 * deadZone;
            else
                y = y + 2 * deadZone;
        }
        m_bias = set;
    }

    function checkBoundaryConditions(amount, cursorOffset, m_amount){
        if (cursorOffset === 0)
            return 0;

        var deltaAmount = amount;
        var eye = cam.saveEye.clone().sub(worldUp.clone().multiplyScalar(m_amount + deltaAmount));
        var prevEye = cam.saveEye.clone().sub(worldUp.clone().multiplyScalar(m_amount));

        var eyeHeight = 0.0;
        var epsilon = (cam.maxSceneBound - cam.minSceneBound) / 1000;

        //console.log(m_amount);
        //console.log(deltaAmount);


        if (cam.topLimit && (cursorOffset > 0)){
            // Cursor was on the top of the slider, but now is moving down.
            // Bring eyeHeight below maxSceneBound.
            eyeHeight = cam.maxSceneBound - epsilon;
            cam.topLimit = false;
        }else if (cam.bottomLimit && (cursorOffset < 0)){
            // Cursor was on the bottom of the slider, but now is moving up.
            // Bring eyeHeight above minSceneBound.
            eyeHeight = cam.minSceneBound + epsilon;
            cam.bottomLimit = false;
        }else{
            eyeHeight = eye.dot(worldUp);
        }

        var prevEyeHeight =	prevEye.dot(worldUp);

        //console.log(eyeHeight);

        if ( eyeHeight < cam.minSceneBound ) {
            if ( prevEyeHeight < cam.minSceneBound) {
                // this limits how far under the min we can go
                cam.bottomLimit = true;
                deltaAmount = 0.0;
            }
        }else if ( eyeHeight > cam.maxSceneBound ) {
            if ( prevEyeHeight > cam.maxSceneBound ) {
                // This limits how far over the max we can go
                cam.topLimit = true;
                deltaAmount = 0.0;
            }
        }

        return deltaAmount;
    }

    function getMoveAmountFromCursorOffset(offset){
        // Manipulating with power of 2 of cursor offset allows to amplify the visible change in the offset
        // when the offset is big to achieve the effect ofhigher sensitivity of the tool on small offsets
        // and lower sensitivity on big offsets.
        var derivedOffset = Math.pow (offset, 2.0);
        if (offset < 0){
            derivedOffset = -derivedOffset;
        }

        //delta.y = derivedOffset;
        var delta = convertCoordsToWindow( 0, derivedOffset );
        var sceneHeight = cam.maxSceneBound - cam.minSceneBound;

        // This empirical step provides a good motion of the scene when moving up/down.
        var p = sceneHeight * 0.01;
        delta.y *= p;

        var deltaAmount = cam.userHeightSpeed * delta.y;
        deltaAmount = checkBoundaryConditions(deltaAmount, offset, cam.m_amount);

        return deltaAmount;
    }

    //draw UI for up-down operation during mouse move
    this.onDrawHeight = function(mouse, pX, pY, dragged, path){
        var sliderHeight = 86;
        var upDir = new THREE.Vector3(0,1,0);
        var h = camera.position.clone().dot(upDir);
        var unitHeight = Math.linearClamp( h, cam.minSceneBound, cam.maxSceneBound );
        var height = unitHeight - 0.5 ;
        if( cubeContainer ) {
            cubeContainer.find("img#updownImageA").remove();
            cubeContainer.prepend('<img src="'+path+'SWheighthandleA.png" id="updownImageA" style="position:fixed; z-index:9999; top:'+(pY - sliderHeight * height)+'px; left:'+pX+'px;"/>');

            if (!dragged){
                cubeContainer.prepend('<img src="'+path+'SWheighthandleI.png" id="updownImageI" style="position:fixed; z-index:9998; top:'+(pY - sliderHeight * height)+'px; left:'+(pX)+'px;"/>');
            }
        }
    };

    /**
     * Draws a menu by appending an unordered list to the given container element.
     * @param {Array} menuOptions - string array of menu options, null meaning seperator
     * @param {Array} menuEnables - boolean array of menu enable flags indicating which corresponding menu entry in menuOptions should be enabled or disabled.
     * @param {Number} mousex - the x coordinate of the menu trigger point, used to position menu
     * @param {Number} mousey - the y coordinate of the menu trigger point, used to position menu
     * @param {HTMLElement} container - the container element to add the menu to.
     * @param {Object} position - object with x, y, w, h of the container element.
     */
    this.drawDropdownMenu = function(menuOptions, menuEnables, menuCallbacks, mousex, mousey, container, position) {
        var itemID = 0;

        if( !dropDownMenu ) {

            dropDownMenu = document.createElement('div');
            dropDownMenu.className = 'dropDownMenu';

            // Initialize the top and left with some approximate values
            // so that the correct width can be returned by gerBoudningClientRect().
            dropDownMenu.style.top    = '100px';
            dropDownMenu.style.left   = '-400px';

            var menuHeight = 0;
            var menuMinWidth = 0;
            for (var i = 0; i<menuOptions.length; i++){
                var listItem;
                if (menuOptions[i] === null) {                       // menu separator
                    listItem = document.createElement("li");
                    listItem.style.height = '1px';
                    menuHeight += 1;
                    listItem.style.backgroundColor="#E0E0E0";
                } else {
                    var content = Autodesk.Viewing.i18n.translate(menuOptions[i]);
                    menuMinWidth = content.length > menuMinWidth ? content.length : menuMinWidth;

                    if( menuCallbacks[i] ) {
                        listItem = document.createElement("div");
                        var check = document.createElement("input");
                        var text  = document.createElement("label");
                        check.type = "radio";
                        check.className = "dropDownMenuCheck";
                        text.innerHTML = content;
                        text.className = "dropDownMenuCheckText";
                        listItem.appendChild(check);
                        listItem.appendChild(text);
                        listItem.className = "dropDownMenuCheckbox";
                    }
                    else {
                        listItem = document.createElement("li");
                        listItem.textContent = content;
                        listItem.className = menuEnables[i] ? "dropDownMenuItem" : "dropDownMenuItemDisabled";
                    }

                    listItem.id = "menuItem" + itemID;
                    itemID++;
                    menuHeight += 25;       // HACK!!!

                    listItem.setAttribute( "data-i18n", menuOptions[i] );
                }
                dropDownMenu.appendChild(listItem);
            }

            // Add the menu to the DOM before asking for boundingClientRect.
            // Otherwise, it will be zero.
            container.appendChild(dropDownMenu);

            dropDownMenu.style.minWidth = Math.max(256, menuMinWidth * 7.4) + 'px'; // approximate min width
            var menuWidth = dropDownMenu.getBoundingClientRect().width;

            this.menuSize.x = menuWidth;
            this.menuSize.y = menuHeight;
        }
        else {
            // Just add the drop down menu, It already exists.
            container.appendChild(dropDownMenu);
        }
        itemID = 0;
        for (var i = 0; i<menuOptions.length; i++) {
            if( menuOptions[i] === null )
                continue;

            if( menuCallbacks[i] ) {
                var id = "menuItem" + itemID;
                var element = document.getElementById(id);
                if( element ) {
                    element.children[0].checked = menuCallbacks[i]();
                }
            }
            itemID++;
        }
        var top  = mousey - 15;        // 15 offset so list appears @ button
        var left = mousex + 1;

        var rect = this.canvas.getBoundingClientRect();

        // stderr("LEFT: " + left + " mousex: " + mousex);
        // stderr("TOP: " + top + " mousey: " + mousey);
        // stderr("canvas: " + rect.right + ", " + rect.bottom);

        if( (left + this.menuSize.x) > rect.right )
            left = mousex - this.menuSize.x - 1;
        if( (top + this.menuSize.y) > rect.bottom )
            top = rect.bottom - this.menuSize.y;

        // Make relative to container:
        top  -= position.y;
        left -= position.x;

        dropDownMenu.style.top  = top + 'px';
        dropDownMenu.style.left = left + 'px';

        this.menuOrigin.x = left;
        this.menuOrigin.y = top;
    };


    this.removeDropdownMenu = function(container) {
        container.removeChild(dropDownMenu);
    };

    function isAxisAligned(vec) {
        var sceneRight  = cam.sceneFrontDirection.clone().cross(cam.sceneUpDirection);
        var checkUp    = Math.abs(Math.abs(vec.dot(cam.sceneUpDirection)) - 1.0);
        var checkFront = Math.abs(Math.abs(vec.dot(cam.sceneFrontDirection)) - 1.0);
        var checkRight = Math.abs(Math.abs(vec.dot(sceneRight)) - 1.0);

        return (checkUp < 0.00001 || checkFront < 0.00001 || checkRight < 0.00001);
    }

    this.isFaceView = function() {
        var dir = this.center.clone().sub(camera.position).normalize();
        return isAxisAligned(dir) && isAxisAligned(camera.up);
    };

    this.startInteraction = function (x, y) {
        this.startCursor = new THREE.Vector2(x, y);

        this.startState = {
            saveCenter: this.center.clone(),
            saveEye:    this.camera.position.clone(),
            savePivot:  this.pivot.clone(),
            saveUp:     this.camera.up.clone()
        };

        this.lockDeltaX = 0.0;
        this.lockedX = false;
        this.lastSnapRotateX = 0.0;
        this.lockDeltaY = 0.0;
        this.lockedY = false;
        this.lastSnapRotateY = 0.0;
        this.lastSnapDir = new THREE.Vector3(0,0,0);
    };

    this.orbit = function (currentCursor, startCursor, distance, startState){
        if( !this.navApi.isActionEnabled('orbit') || this.currentlyAnimating === true )
            return;

        var mode = 'wheel';

        // If orthofaces is enabled, and camera is ortho
        // then switch to perspective
        if(cam.orthographicFaces && !camera.isPerspective) {
            camera.toPerspective();

            // Hack: update the start state with the new position:
            if( startState )
                startState.saveEye.copy(this.camera.position);
        }
        if (startState){
            mode = 'cube';
        }
        if (mode == 'cube'){
            this.saveCenter.copy(startState.saveCenter);
            this.saveEye.copy(startState.saveEye);
            this.savePivot.copy(startState.savePivot);
            this.saveUp.copy(startState.saveUp);
            this.useSnap = true;
            this.doCustomOrbit = true;
        } else {
            this.saveCenter.copy(this.center);
            this.savePivot.copy(this.pivot);
            this.saveEye.copy(camera.position);
            this.saveUp.copy(camera.up);
            this.useSnap = false;
            this.doCustomOrbit = false;
        }

        if (IsCombined() && prevCenter == undefined) {
            prevCenter = this.saveCenter.clone();
            prevEye    = this.saveEye.clone();
            prevPivot  = this.savePivot.clone();
            prevUp     = this.saveUp.clone();
        }

        // TODO: fold the two cases into one and prevent duplicate code
        if (this.preserveOrbitUpDirection ) {

            var delta = convertCoordsToWindow( currentCursor.x - startCursor.x, currentCursor.y - startCursor.y );
            var lastDelta = convertCoordsToWindow(distance.x, distance.y);

            var worldUp = this.sceneUpDirection.clone();
            var worldFront = this.sceneFrontDirection.clone();
            var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection).normalize();

            /* ????? WTF:
            var worldFront = new THREE.Vector3(1,0,0);
            var worldUp = new THREE.Vector3(0,1,0);
            */

            //viewcube
            // if (this.doCustomOrbit ) {
            //     worldUp = new THREE.Vector3(0,1,0);
            //     worldFront = new THREE.Vector3(1,0,0);
            // }

            /* ?????? WTF:
            var worldR = worldFront.clone().cross( worldUp );
            worldUp = worldR.clone().cross(worldFront);
            worldUp.clone().normalize();
            */

            var pivot  = IsCombined() ? prevPivot  : this.savePivot;
            var eye    = IsCombined() ? prevEye    : this.saveEye;
            var center = IsCombined() ? prevCenter : this.saveCenter;
            var camUp  = IsCombined() ? prevUp     : this.saveUp;

            var initViewDir  = pivot.clone().sub(eye).normalize();
            var initViewDirV = center.clone().sub(eye).normalize();
            var initRightDir = initViewDirV.clone().cross( camUp );

            var fTargetDist  = eye.clone().sub(pivot).length();
            var fTargetDistV = eye.clone().sub(center).length();

            var vLookUpdate  = initViewDir.clone().multiplyScalar(-1);
            var vLookUpdateV = initViewDirV.clone().multiplyScalar(-1);
            var vRightUpdate = initRightDir;
            var vUpUpdate = camUp.clone();

            var snapAngleh = 0.0;
            var snapAnglev = 0.0;

            //viewcube

            // DOESN'T DO ANYTHING: snapToClosestView(worldUp, snapAngleh, snapAnglev);

            if ( !this.constrainOrbitHorizontal ) {
                // Need to check if:
                //  1. camera is "upside-down" (angle between world up and camera up is obtuse) or
                //  2. camera is in top view (camera up perpendicular to world up and view angle acute to world up)
                // These cases required a reversed rotation direction to maintain consistent mapping of tool:
                //  left->clockwise, right->counter-clockwise
                //
                //  PHB June 2014 - #2 above makes no sense to me. If the camera up is perpendicular to the
                //  world up then the view is parallel to world up (view dot up == 1). So the second test is
                //  meaningless. There is no good way to determine the rotation direction in this case. If you
                //  want it to feel like direct manipulation then it would be better to determine if the cursor
                //  is above or below the pivot in screen space.

                var worldUpDotCamUp = worldUp.dot(this.saveUp);
                // var worldUpDotView  = worldUp.dot(this.saveCenter.clone().sub(this.saveEye).normalize());
                // stderr("worldUpDotCamUp = " + worldUpDotCamUp.toFixed(3));

                // if ((worldUpDotCamUp < -Number.MIN_VALUE) ||
                //     ((Math.abs(worldUpDotCamUp) < Number.MIN_VALUE) && (worldUpDotView > 0.0)))
                //
                var kFlipTolerance = 0.009;     // Must be flipped by more than about 0.5 degrees
                if( worldUpDotCamUp < -kFlipTolerance ) {
                    delta.x = -delta.x;
                    lastDelta.x = -lastDelta.x;
                }

                var dHorzAngle = 0.0;
                if (IsCombined()) {
                    dHorzAngle = lastDelta.x * this.orbitMultiplier;
                } else {
                    dHorzAngle = this.useSnap ? this.lastSnapRotateX + getNextRotation('h', snapAngleh, -lastDelta.x) :
                        delta.x * this.orbitMultiplier;
                }

                this.lastSnapRotateX = dHorzAngle;
                // Define rotation transformation

                var quatH = new THREE.Quaternion().setFromAxisAngle( worldUp, -dHorzAngle );

                vLookUpdate.applyQuaternion(quatH);
                vLookUpdateV.applyQuaternion(quatH);
                vRightUpdate.applyQuaternion(quatH);
                vUpUpdate.applyQuaternion(quatH);
            }

            if ( !this.constrainOrbitVertical ) {
                var vRightProjF = worldFront.clone().multiplyScalar(worldFront.dot(vRightUpdate));
                var vRightProjR = worldRight.clone().multiplyScalar(worldRight.dot(vRightUpdate));
                var vRightProj = vRightProjF.clone().add(vRightProjR);
                vRightProj.clone().normalize();

                var dVertAngle = 0.0;

                if (IsCombined()){
                    dVertAngle = lastDelta.y * this.orbitMultiplier;
                }else{
                    var next = getNextRotation('v', snapAnglev, lastDelta.y);
                    dVertAngle = this.useSnap ? this.lastSnapRotateY + next : delta.y * this.orbitMultiplier;
                }
                var quatV = new THREE.Quaternion().setFromAxisAngle( vRightProj, -dVertAngle );

                if( !this.navApi.getOrbitPastWorldPoles() ) {

                    var vUpUpdateTemp = vUpUpdate.clone();
                    vUpUpdateTemp.applyQuaternion(quatV).normalize();

                    // Check if we've gone over the north or south poles:
                    var wDotC = worldUp.dot(vUpUpdateTemp);
                    if( wDotC < 0.0 )
                    {
                        var vLookUpdateVtemp = vLookUpdateV.clone();
                        vLookUpdateVtemp.applyQuaternion(quatV).normalize();

                        // How far past Up are we?
                        var dVertAngle2 = vLookUpdateVtemp.angleTo(worldUp);
                        if( Math.abs(dVertAngle2) > (Math.PI * 0.5) )
                            dVertAngle2 -= (dVertAngle2 > 0.0) ? Math.PI : -Math.PI;

                        // stderr('OVER!! delta=' + dVertAngle.toFixed(3) + " => " + (dVertAngle - dVertAngle2).toFixed(3));

                        dVertAngle -= dVertAngle2;

                        quatV.setFromAxisAngle( vRightProj, -dVertAngle );
                        vLookUpdate.applyQuaternion(quatV).normalize();
                        vLookUpdateV.applyQuaternion(quatV).normalize();
                        vUpUpdate.applyQuaternion(quatV).normalize();

                    }
                    else
                    {
                        vLookUpdate.applyQuaternion(quatV).normalize();
                        vLookUpdateV.applyQuaternion(quatV).normalize();
                        vUpUpdate.applyQuaternion(quatV).normalize();
                    }
                }
                else
                {
                    vLookUpdate.applyQuaternion(quatV).normalize();
                    vLookUpdateV.applyQuaternion(quatV).normalize();
                    vUpUpdate.applyQuaternion(quatV).normalize();
                }
                this.lastSnapRotateY = dVertAngle;
            }

            // figure out new eye point
            var vNewEye = vLookUpdate.multiplyScalar(fTargetDist).add(pivot);

            camera.position.copy(vNewEye);
            camera.up.copy(vUpUpdate);
            this.center.copy(vNewEye);
            this.center.sub(vLookUpdateV.multiplyScalar(fTargetDistV));

            if( IsCombined() )
            {
                prevCenter.copy(this.center);
                prevEye.copy(camera.position);
                prevPivot.copy(this.pivot);
                prevUp.copy(camera.up);
            }
        }
        else {
            /*var lastDelta = convertCoordsToWindow(distance.x, distance.y);
            var vDir = prevPivot.clone().sub(prevEye);
            var vDirView = prevCenter.clone().sub(prevEye);
            var vRight = vDirView.clone().cross(prevUp);
            var vUp = vRight.clone().cross(vDirView);
            vUp.clone().normalize();

            var dist = (prevPivot.clone().sub(prevEye)).clone().length();
            var distView = (prevCenter.clone().sub(prevEye)).clone().length();

            var snapAngleh = 0.0;
            var snapAnglev = 0.0;

            //viewcube
            //snapToClosestView(vUp, snapAngleh, snapAnglev);

            if ( !this.constrainOrbitHorizontal ){

            var dHorzAngle = this.useSnap ? getNextRotation(HORIZONTAL, snapAngleh, lastDelta.x):
            lastDelta.x *this.orbitMultiplier;

            var quatH = new THREE.Quaternion().setFromAxisAngle( vUp.clone().normalize(), dHorzAngle );
            vDir = quatH.clone().rotate(vDir);
            vDirView = quatH.clone().rotate(vDirView);
            }

            if ( !this.constrainOrbitVertical ){
            var dVertAngle = this.useSnap ? getNextRotation(VERTICAL, snapAnglev, lastDelta.y) :
            lastDelta.y *this.orbitMultiplier;

            var quatV = new THREE.Quaternion().setFromAxisAngle( vRight.clone().normalize(), dVertAngle );
            vDir = quatV.clone().rotate(vDir);
            vDirView = quatV.clone().rotate(vDirView);
            vUp = quatV.clone().rotate(vUp);
            }

            camera.eye = this.pivot.clone().sub((vDir.clone().normalize()).clone().multiplyScalar(dist));
            this.center.copy(camera.eye.clone().add((vDirView.clone().normalize()).clone().multiplyScalar(distView)));
            camera.up.copy(vUp.clone().normalize());

            prevCenter = this.center;
            prevEye = camera.position;
            prevPivot = this.pivot;
            prevUp = camera.up;*/
        }
        camera.lookAt(this.center);
        changed(false);

        /*console.log("Camera Position: ( "+camera.position.x +", "+camera.position.y+", "+camera.position.z+" )");
        console.log("Up Vector: ( "+camera.up.x +", "+camera.up.y+", "+camera.up.z+" )");
        console.log("Center: ( "+this.center.x +", "+this.center.y+", "+this.center.z+" )");
        */
    };

    this.endInteraction = function() {
    };

    this.look = function( distance ){
        if( !this.navApi.isActionEnabled('walk') )
            return;

        var delta = convertCoordsToWindow(distance.x, distance.y);
        var multiplier = this.userLookSpeed;

        //if ( m_manager->GetApplicationParameters().lookInvertVerticalAxis ) { deltaY = -deltaY; }

        var eyeToCenter = this.getView();

        var camUp = camera.up;
        var camRight = eyeToCenter.clone().cross(camUp).normalize();
        var worldUp = this.sceneUpDirection.clone();

        // TODO: scale look by camera's FOV
        // vertical rotation around the camera right vector
        var angle = delta.clone();
        angle.x *= Math.PI;
        angle.y *= Math.PI / camera.aspect;
        angle.multiplyScalar(multiplier);
        var qRotY = new THREE.Quaternion().setFromAxisAngle( camRight, -angle.y);

        if (camera.keepSceneUpright && !this.navApi.getOrbitPastWorldPoles()) {
            var futureUp = camUp.clone();
            futureUp.applyQuaternion(qRotY).normalize();

            if (futureUp.dot(worldUp) < 0) {
                var futureEyeToCenter = eyeToCenter.clone();
                futureEyeToCenter.applyQuaternion(qRotY);

                var deltaAngle = futureEyeToCenter.angleTo(worldUp);

                if(Math.abs(deltaAngle) > (Math.PI * 0.5))
                    deltaAngle -= (deltaAngle > 0.0) ? Math.PI : -Math.PI;

                angle.y -= deltaAngle;

                qRotY.setFromAxisAngle(camRight, -angle.y);
            }
        }

        eyeToCenter = qRotY.clone().rotate(eyeToCenter);
        camUp = qRotY.clone().rotate(camUp);
        camUp.normalize();

        var vertAxis = camera.keepSceneUpright ? worldUp : camUp;
        var qRotX = new THREE.Quaternion().setFromAxisAngle( vertAxis, -angle.x );

        eyeToCenter = qRotX.clone().rotate( eyeToCenter );
        camUp = qRotX.clone().rotate( camUp );

        this.center.copy(eyeToCenter.add(camera.position));
        camera.up.copy(camUp);

        camera.lookAt(this.center);
        changed(false);
    };

    this.pan = function ( distance ) {
        if( !this.navApi.isActionEnabled('pan') )
            return;

        distance = convertCoordsToWindow(distance.x, distance.y);

        var W = this.getView();
        var U = camera.up.clone().cross(W);
        var V = W.clone().cross(U);

        U.normalize();
        V.normalize();
        W.normalize();

        var Pscreen = this.pivot.clone().sub(camera.position);
        var screenW = W.clone().dot(Pscreen);
        var screenU = screenW * (Math.tan( THREE.Math.degToRad(camera.leftFov)) + Math.tan(THREE.Math.degToRad(camera.rightFov)));
        var screenV = screenW * (Math.tan( THREE.Math.degToRad(camera.topFov)) + Math.tan(THREE.Math.degToRad(camera.bottomFov)));

        var offsetU = distance.x * Math.abs(screenU);
        var offsetV = distance.y * Math.abs(screenV);

        var offset = new THREE.Vector3();
        var u = U.clone().multiplyScalar(offsetU);
        var v = V.clone().multiplyScalar(offsetV);

        offset = (u.clone().add(v)).clone().multiplyScalar(this.userPanSpeed);

        camera.position.add(offset);
        this.center.add(offset);

        camera.lookAt(this.center);
        changed(false);
    };

    this.zoom = function(zoomDelta){
        if( !this.navApi.isActionEnabled('zoom') )
            return;

        //TODO: bug - when pivot is set outside the object, object zooms past the pivot point
        var zoomMin = 0.05;
        var zoomBase = this.userZoomSpeed;
        var distMax = Number.MAX_VALUE;
        var deltaXY = zoomDelta.x + zoomDelta.y;
        var dist = Math.pow ( zoomBase, deltaXY);

        var zoomPosition = (this.pivot.clone().sub((this.pivot.clone().sub(this.saveEye).clone()).multiplyScalar(dist)));
        var zoomCenter = zoomPosition.clone().add(cam.D.clone().multiplyScalar(cam.D.clone().dot((this.pivot.clone().sub(zoomPosition)).clone())));

        if (dist >= distMax)
            return;

        if (deltaXY > 0.0){
            var snapSize = 0;
            var dist2 = Math.pow(zoomBase, deltaXY - snapSize);

            // PERSP zoom out
            if ( deltaXY < snapSize ){
                // inside the zoomout speedbump region
                unitAmount = 0.0;
                return;

            } else {
                camera.position.copy(zoomPosition);
                this.center.copy(zoomCenter);

                var EprojD = (zoomPosition.clone().sub(this.saveEye)).dot(cam.D);

                if ( EprojD > distMax ) {
                    camera.position.copy((this.saveEye.sub(cam.D)).clone().multiplyScalar(distMax));
                    unitAmount = (distMax > 0.0) ? -1.0 : 0.0;
                } else {
                    unitAmount = -(EprojD / distMax);
                }
            }
        } else {


            camera.position.copy(zoomPosition);
            this.center.copy(zoomCenter);

            //Zoom In
            /*if ( dist < zoomMin) {
                //exponential zoom moved in as far as it can
                var zoomMinLinear = ( Math.log(zoomMin) / Math.log(zoomBase) );
                var distLinearXY = Math.abs(deltaXY) - Math.abs(zoomMinLinear);
                var snapSize = 0;

                // do linear zoomin
                if ( distLinearXY > snapSize ) {

                    var distLinearXY = distLinearXY - snapSize/window.innerHeight;
                    var amount = -distLinearXY;

                    var multiplier = this.userZoomSpeed;
                    var dist2 = amount * multiplier;

                    var Esnap = this.pivot.clone().sub((this.pivot.clone().sub(this.saveEye)).clone().multiplyScalar(zoomMin));
                    var E = Esnap.clone().sub((this.pivot.clone().sub(this.saveEye)).clone().multiplyScalar(dist2));

                    this.center.copy(E.clone().add(cam.D.clone().multiplyScalar(zoomMin)));
                    camera.position.copy(E);
                }
            } else {
                cam.D = (this.saveCenter.clone().sub(this.saveEye)).clone().normalize();
                camera.position.copy(zoomPosition);
                this.center.copy(zoomCenter);
            }*/
        }
        camera.lookAt(this.center);
        changed(false);
    };

    this.walk = function(currentCursor, startCursor, movementX, movementY, deltaTime){
        if( !this.navApi.isActionEnabled('walk') )
            return;

        var worldUp = this.sceneUpDirection.clone();
        var worldFront = this.sceneFrontDirection.clone();
        var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection);
        //TODO: figure out what deltaTime does

        var flyPlanarMotion = true;
        var flyUpDownSensitivity = 0.01;

        if (isInDeadZone(currentCursor, startCursor)){
            wheel.cursorImage('SWWalk');
            setBias(true, currentCursor, startCursor);
            x = startCursor.x;
            y = startCursor.y;
        }else{
            setBias(false, currentCursor, startCursor);
        }

        //x = currentCursor.x - m_resetBiasX;
        //y = currentCursor.y - m_resetBiasY;
        x = currentCursor.x;
        y = currentCursor.y;

        var delta = convertCoordsToWindow( x - startCursor.x, y - startCursor.y );

        var fInitialMoveX = -delta.x;
        var fInitialMoveY = -delta.y;
        var fSignX = (fInitialMoveX < 0.0) ? -1.0 : 1.0;
        var fSignY = (fInitialMoveY < 0.0) ? -1.0 : 1.0;
        var fMoveX = Math.abs(fInitialMoveX);
        var fMoveY = Math.abs(fInitialMoveY);

        var deadzoneRadius = new THREE.Vector2(30, 30);
        deadzoneRadius = convertCoordsToWindow (deadzoneRadius.x, deadzoneRadius.y);

        fMoveX = ( isInDeadZone(currentCursor, startCursor)) ? 0.0 : Math.abs(fInitialMoveX) - deadzoneRadius.x;
        fMoveY = ( isInDeadZone(currentCursor, startCursor)) ? 0.0 : Math.abs(fInitialMoveY) - deadzoneRadius.y;

        var rampRadius = 0.25;
        fMoveX /= rampRadius;
        fMoveY /= rampRadius;

        fMoveX = ( fMoveX < 1.0 ) ? Math.easeClamp( fMoveX, 0.0, 1.0 ) : Math.pow(fMoveX, 1.0);
        fMoveY = ( fMoveY < 1.0 ) ? Math.easeClamp( fMoveY, 0.0, 1.0 ) : Math.pow(fMoveY, 1.0);


        // scale by time
        //fMoveX *= deltaTime;
        //fMoveY *= deltaTime;

        var fDeltaX = (fMoveX > 0.0) ? fMoveX * fSignX : 0.0;
        var fDeltaY = (fMoveY > 0.0) ? fMoveY * fSignY : 0.0;

        var vViewDir = this.getView();
        var fViewDist = vViewDir.length();
        vViewDir.normalize();

        var vRightDir = vViewDir.clone().cross( camera.up );
        vRightDir.normalize();

        // project vViewDir onto plane perpendicular to up direction to get
        // better walking inside houses, etc
        // (but prevents flying down to model from 3/4 view...)

        var vYViewDirRight = worldRight.clone().multiplyScalar(worldRight.clone().dot(vViewDir));
        var vYviewDirFront = worldFront.clone().multiplyScalar(worldFront.clone().dot(vViewDir));
        var vYViewDir = vYviewDirFront.clone().add(vYViewDirRight);

        vYViewDir = (vYViewDir.clone().length() > Number.MIN_VALUE) ? vYViewDir.normalize() : camera.up;

        var scale = 1.0;
        var fDollyDist = fDeltaY * (this.walkMultiplier * scale );

        var dir = flyPlanarMotion ? vYViewDir : vViewDir;


        // Free-flying or constrained walk?
        if (flyPlanarMotion) {
            // Constrained Walk
            // To avoid perceptually confusing motion, force a reversal of flying direction along a shifted axis

           // Angle to offset threshold from up-axis
           // TODO: make cos(0.65) into an AutoCam Parameter
           var dDirThreshold = Math.cos(0.65);

           if ((dDirThreshold != 1) &&
               (((worldUp.clone().dot(camera.up) < -Number.MIN_VALUE) && (worldUp.clone().dot(vViewDir) < -dDirThreshold)) ||
                   ((worldUp.clone().dot(camera.up) > Number.MIN_VALUE) && (worldUp.clone().dot(vViewDir) > dDirThreshold)))) {
               dir = -dir;
           }
        }


        var fSpinAngle = -fDeltaX *this.walkMultiplier*0.05;

        // rotate around world-up vector instead of CameraOperations up vector (more like head movement!)
        //Quaternion quat( m_cameraParams.up, (float)fSpinAngle );

        // Define rotation axis direction
        var vRotAxis = camera.up;

        // Free-flying or constrained walk?
        if (flyPlanarMotion) {
            // Constrained Walk
            // Need to check if:
            //  1. camera is "upside-down" (angle between world up and camera up is obtuse) or
            //  2. camera is in top view (camera up perpendicular to world up and view angle acute to world up)
            // These cases require a reversed rotation direction to maintain consistent mapping of tool:
            //  left->clockwise, right->counter-clockwise
            if ((worldUp.clone().dot(camera.up) < -Number.MIN_VALUE) ||
                ((Math.abs(worldUp.clone().dot(camera.up)) < Number.MIN_VALUE)
                    && (worldUp.clone().dot(vViewDir) > Number.MIN_VALUE))) {
                fSpinAngle = -fSpinAngle;
            }
            vRotAxis = worldUp;
        }

        // Define rotation transformation

        var quat = new THREE.Quaternion().setFromAxisAngle( vRotAxis, fSpinAngle );
        quat.normalize();

        vViewDir = quat.clone().rotate( vViewDir );
        vViewDir.normalize();
        camera.up.copy(quat.clone().rotate( camera.up ));
        camera.up.normalize();

        camera.position.add(dir.clone().multiplyScalar(fDollyDist));
        this.center.copy(camera.position.clone().add(vViewDir.clone().multiplyScalar(fViewDist)));

        dir = flyPlanarMotion ? worldUp : camera.up;
        dir.normalize();

        if(fDollyDist === 0)
            fDollyDist = flyUpDownSensitivity;

        camera.lookAt(this.center);
        changed(false);
    };

    this.updown = function(movementY){
        if( this.navApi.getIsLocked() )
            return;

        var deltaCursor = movementY;
        var deltaAmount = getMoveAmountFromCursorOffset(deltaCursor);

        cam.m_amount += deltaAmount;

        var upDir = new THREE.Vector3(0,1,0);

        var eye = cam.saveEye.clone().sub(upDir.clone().multiplyScalar(cam.m_amount));
        var eyeHeight = eye.clone().dot(upDir);

        camera.position.copy(eye);

        if ( eyeHeight < cam.minSceneBound ) {
            camera.position.add(upDir.clone().multiplyScalar(cam.minSceneBound - eyeHeight));
        }

        if ( eyeHeight > cam.maxSceneBound ) {
            camera.position.add(upDir.clone().multiplyScalar(cam.maxSceneBound - eyeHeight));
        }

        this.center.copy(camera.position.clone().add(cam.saveCenter.clone().sub(cam.saveEye)));
        camera.lookAt(this.center);
        changed(false);
    };


    /*      REWIND FUNCTIONS */

    /**
     * This takes a snapshot of the current camera passed into Autocam and saves it to the history. A screenshot
     * is taken of the sceneContainer canvas
     */
    this.addHistoryElement = function(){

        // --- We don't require history being saved ---

        // if (cam.rewindParams.maxHistorySize > 0 && cam.rewindParams.history.length >= cam.rewindParams.maxHistorySize){
        //     this.rewindParams.history.shift();
        // }

        // //reset previous 1 or 2 weights to 0
        // if (cam.rewindParams.history.length == 1){
        //     cam.rewindParams.history[0].weight = 0.0;
        // }else if (cam.rewindParams.history.length > 1){
        //     cam.rewindParams.history[cam.rewindParams.history.length -1].weight = 0.0;
        //     cam.rewindParams.history[cam.rewindParams.history.length -2].weight = 0.0;
        // }

        // var element = {};
        // element.thumbnail = document.getElementById("sceneContainer").toDataURL("image/png");
        // element.thumbnailBounds = new THREE.Box2(new THREE.Vector2(0,0),new THREE.Vector2(56,56));
        // element.camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
        // element.camera.position = camera.position.clone();
        // element.camera.up = camera.up.clone();
        // element.camera.rotation = camera.rotation.clone();
        // element.camera.leftFov = camera.leftFov;
        // element.camera.rightFov = camera.rightFov;
        // element.camera.topFov = camera.topFov;
        // element.camera.bottomFov = camera.bottomFov;
        // element.camera.center = cam.center.clone();
        // element.camera.pivot = cam.pivot.clone();
        // element.weight = 1.0;
        // element.isEmptyScene = false;

        // //IF SCENE OUTSIDE VIEW SET ISEMPTYSCENE TO TRUE

        // cam.rewindParams.history.push(element);
        // cam.rewindParams.snapped = true;
        // cam.rewindParams.slideOffset.x=0;
        // cam.rewindParams.timelineIndex = cam.rewindParams.history.length - 1;
        // cam.rewindParams.timelineIndexSlide = cam.rewindParams.timelineIndex;
    }

    /**
     * This handles any case where the user rewinds and then does any transformations, the history is sliced depending
     * on where the user rewinds to
     */
    this.addIntermediateHistoryElement = function(){

        if (this.rewindParams.snapped){
            this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex);
        }else{
            if (this.rewindParams.slideOffset.x > 0){
                this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex);
            } else{
                this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex+1);
            }
        }
        this.addHistoryElement();
    };

    this.clearHistory = function(){
        this.rewindParams.history.length = 0;
        this.rewindParams.timelineIndex = 0;
        this.rewindParams.timelineIndexSlide = 0;
        this.rewindParams.resetWeights = true;
    };

    this.openTimeline = function (location){
        this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;

        if (this.rewindParams.resetWeights){
            this.rewindParams.slideOffset.x = 0;
            this.rewindParams.snapped = this.rewindParams.snappingEnabled;
        }

        //if haven't applied any transformations before clicking rewind
        if (this.rewindParams.history.length === 0) this.addHistoryElement();

        for ( var i = 0; i < this.rewindParams.history.length; i++ )
        {
            var index = i - this.rewindParams.timelineIndex;
            var size = this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize;

            this.rewindParams.history[i].thumbnailBounds.setCenter(new THREE.Vector2(location.x + index * size, location.y).add(this.rewindParams.slideOffset));

            if (this.rewindParams.resetWeights)
            {
                this.rewindParams.history[i].weight = (i==this.rewindParams.timelineIndex)? 1.0:0.0;
            }
        }

        if ( this.rewindParams.resetWeights )
        {
            this.rewindParams.resetWeights = false;
        }

        var size = (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) *2.0;
        this.rewindParams.open = true;
        this.rewindParams.openLocation = location.clone();
        this.rewindParams.openLocationOrigin = location.clone();
        this.rewindParams.openBracket = location.clone();
        this.rewindParams.openBracketA = new THREE.Vector2(size, location.y);
        this.rewindParams.openBracketB = new THREE.Vector2(window.innerWidth - size, location.y);
        // make sure dead-zone is well formed ... i.e. A.x < B.x
        if (this.rewindParams.openBracketA.x > this.rewindParams.openBracketB.x) {
            var swap = this.rewindParams.openBracketA.x;
            this.rewindParams.openBracketA.x = this.rewindParams.openBracketB.x;
            this.rewindParams.openBracketB.x = swap;
        }
        this.rewindParams.locationOffset = new THREE.Vector2(0,0);
        this.rewindParams.snapOffset = new THREE.Vector2(0,0);
    };

    this.slideTimeline = function(location_){
        /*
         Basic Idea:
         Behaviour of the current rewind timeline is similar to a tracking menu. There is a "deadzone"
         region where cursor movement does not slide the thumbnails. As the cursor goes outside the
         region, thumbnails slide to align the closest edge of the timeline to the cursor ('extent'
         variable is this sliding amount). The edges of the deadzone region are stored in
         'm_openBracketA/B' variables, and slide around with the timeline. Draw some icons at bracket
         positions to visualize the process.
         */

        if ( !this.rewindParams.open || this.rewindParams.history.length === 0  ) { return; }

        var location =  location_.clone().add(this.rewindParams.locationOffset);

        var size = (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0;
        var bracketA = size;
        var bracketB = window.innerWidth - size;

        var edgeA = this.rewindParams.history[0].thumbnailBounds.center().x;
        var edgeB = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;

        var extent = 0.0;

        if ( location.x < this.rewindParams.openBracketA.x )
        {
            extent = location.x - this.rewindParams.openBracketA.x;

            // don't slide thumbnails past the edge of the timeline
            var edgeAnew = edgeA - extent;

            if ( bracketA < edgeAnew )
            {
                // only want to limit the influence of extent, not overshoot the other way
                extent = Math.min( extent + (edgeAnew - bracketA), 0.0);
            }
        }
        if ( location.x > this.rewindParams.openBracketB.x )
        {
            extent = location.x - this.rewindParams.openBracketB.x;

            // don't slide thumbnails past the edge of the timeline
            var edgeBnew = edgeB - extent;

            if ( bracketB > edgeBnew )
            {
                // only want to limit the influence of extent, not overshoot the other way
                extent = Math.max( extent + (edgeBnew - bracketB), 0.0);
            }
        }

        this.rewindParams.openLocation.x += extent;
        this.rewindParams.openBracketA.x += extent;
        this.rewindParams.openBracketB.x += extent;

        this.rewindParams.openBracket.x = location.x - ( this.rewindParams.openLocation.x - this.rewindParams.openLocationOrigin.x );

        var iconOffset = new THREE.Vector2( -extent, 0.0 );

        var L = location.clone().sub( this.rewindParams.openLocation.clone().sub(this.rewindParams.openLocationOrigin));

        // snapping

        iconOffset.x += this.rewindParams.snapOffset.x;
        this.rewindParams.snapOffset.x = 0.0;

        var snapped = false;

        if ( this.rewindParams.snappingEnabled )
        {
            var kEnterSnapDistance = 4.0;
            var kLeaveSnapDistance = 16.0;

            for ( var i = 0; i < this.rewindParams.history.length; i++ )
            {
                var P = this.rewindParams.history[i].thumbnailBounds.center().add(iconOffset);
                if ( Math.abs(P.x - L.x) < kEnterSnapDistance || (this.rewindParams.snapped && Math.abs(P.x - L.x) < kLeaveSnapDistance) )
                {
                    snapped = true;
                    if (extent !== 0.0)
                    {
                        this.rewindParams.snapOffset.x = P.x - L.x;
                        iconOffset.x -= this.rewindParams.snapOffset.x;
                    }
                    else
                    {
                        this.rewindParams.openBracket.x += P.x - L.x;
                    }
                    L.x = P.x;
                    break;
                }
            }
        }

        this.rewindParams.snapped = snapped;

        var weightMax = -1.0;
        var weightTotal = 0.0;
        for ( var j = 0; j < this.rewindParams.history.length; j++ )
        {
            var tempBox = this.rewindParams.history[j].thumbnailBounds.clone();

            // slide the thumbnails
            this.rewindParams.history[j].thumbnailBounds.setCenter(this.rewindParams.history[j].thumbnailBounds.center().add(iconOffset));

            if (this.rewindParams.history[j].thumbnail )
            {
                var leftEdge = this.rewindParams.history[j].thumbnailBounds.center().x - this.rewindParams.thumbnailSize/2.0;
                $('#rewindFrame' + j).css('left', leftEdge);
                $('#rewindBorder' + j).css('left', (leftEdge-4));
            }

            // grow the copied Icon2D to touch the center of its neighbor
            //think about adding offset for frames here
            var newSize = new THREE.Vector2((this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0, (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0 );
            tempBox.setFromCenterAndSize(tempBox.center(),newSize);

            var Icon2DCoords = new THREE.Vector2(0,0);
            tempBox.getIcon2DCoords(L,Icon2DCoords);

            var weight = 1.0 - Math.abs( Math.equalityClamp(Icon2DCoords.x, -1.0, 1.0 ));
            this.rewindParams.history[j].weight = weight;

            // check for out-of-range cases
            if ( j === 0 && L.x < tempBox.center().x)
            { this.rewindParams.history[j].weight = 1.0; }

            if ( j === this.rewindParams.history.length - 1 && L.x > tempBox.center().x)
            { this.rewindParams.history[j].weight = 1.0; }

            weightTotal = weightTotal + this.rewindParams.history[j].weight;

            // find dominant thumbnail
            if ( this.rewindParams.history[j].weight > weightMax )
            {
                weightMax = this.rewindParams.history[j].weight;
                if ( this.rewindParams.snappingEnabled && this.rewindParams.history[j].weight == 1.0 ){
                    // snap to this element
                    this.rewindParams.slideOffset.x = 0;
                    this.rewindParams.snapped = true;
                }else{
                    this.rewindParams.slideOffset.x = this.rewindParams.history[j].thumbnailBounds.center().x - L.x;
                }
                this.rewindParams.timelineIndexSlide = j;
            }
        }

        // normalize the weights just in case
        for ( var k = 0; k < this.rewindParams.history.length; k++ )
        {
            this.rewindParams.history[k].weight = this.rewindParams.history[k].weight / weightTotal;
        }

        // prevent the bracket from moving off the ends of the timeline
        var xBracketMin = this.rewindParams.history[0].thumbnailBounds.center().x;
        var xBracketMax = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;
        if ( this.rewindParams.openBracket.x < xBracketMin )
        {
            this.rewindParams.locationOffset.x += xBracketMin - this.rewindParams.openBracket.x;
            this.rewindParams.openBracket.x = xBracketMin;
        }
        else if ( this.rewindParams.openBracket.x > xBracketMax )
        {
            this.rewindParams.locationOffset.x += xBracketMax - this.rewindParams.openBracket.x;
            this.rewindParams.openBracket.x = xBracketMax;
        }
    };

    this.shiftBackOneElement = function(){
        if ( this.rewindParams.history.length !== 0 && (this.rewindParams.timelineIndex > 0 || this.rewindParams.slideOffset.x !== 0)){
            if (this.rewindParams.snapped || this.rewindParams.slideOffset.x > 0){
                this.rewindParams.timelineIndex--;
            }
            this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;
            this.rewindParams.resetWeights = true;
            cam.elapsedTime = 0;
            this.animateToRewindIndex();
        }
    };

    this.animateToRewindIndex = function ()    {
        var currentTimelineIndex = this.rewindParams.timelineIndex;
        var unitTime = 0.0;
        if ( cam.elapsedTime >= shotParams.duration ){
            unitTime = 1.0;
        } else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/500;
        }

        cam.center.copy((cam.center.clone().multiplyScalar( 1.0 - unitTime)).clone().add( this.rewindParams.history[currentTimelineIndex].camera.center.clone().multiplyScalar( unitTime )));
        camera.position.copy((camera.position.clone().multiplyScalar( 1.0 - unitTime)).clone().add(this.rewindParams.history[currentTimelineIndex].camera.position.clone().multiplyScalar( unitTime )));
        camera.up.copy(this.rewindParams.history[currentTimelineIndex].camera.up);
        cam.pivot.copy(cam.center);

        camera.lookAt(cam.center);
        changed(false);

        if( this.cube )
            requestAnimationFrame(this.cube.render);

        if( unitTime !== 1.0 )
            requestAnimationFrame(function() { cam.animateToRewindIndex();});
    };

    this.closeTimeline = function(){
        if (this.rewindParams.timelineIndex != this.rewindParams.timelineIndexSlide){
            this.rewindParams.timelineIndex = this.rewindParams.timelineIndexSlide;
        }
        this.rewindParams.open = false;
    };

    this.getInterpolatedCamera = function (){
        var interpolatedCam = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
        interpolatedCam.center = new THREE.Vector3(0,0,0);
        interpolatedCam.pivot = new THREE.Vector3(0,0,0);
        interpolatedCam.leftFov = 0;
        interpolatedCam.rightFov = 0;
        interpolatedCam.topFov = 0;
        interpolatedCam.bottomFov = 0;
        interpolatedCam.up.set(0,0,0);

        for (var i = 0; i < this.rewindParams.history.length; i++){
            var frameCam = this.rewindParams.history[i].camera;
            var wi = this.rewindParams.history[i].weight;

            interpolatedCam.center.add(frameCam.center.clone().multiplyScalar(wi));
            interpolatedCam.position.add(frameCam.position.clone().multiplyScalar(wi));
            interpolatedCam.up.add(frameCam.up.clone().multiplyScalar(wi));
            interpolatedCam.rotation.add(frameCam.rotation.clone().multiplyScalar(wi));
            interpolatedCam.pivot.add(frameCam.pivot.clone().multiplyScalar(wi));
            interpolatedCam.leftFov+=(frameCam.leftFov*wi);
            interpolatedCam.rightFov +=(frameCam.rightFov*wi);
            interpolatedCam.topFov+=(frameCam.topFov*wi);
            interpolatedCam.bottomFov+=(frameCam.bottomFov*wi);
        }

        camera.position.copy(interpolatedCam.position);
        camera.up.copy(interpolatedCam.up);
        camera.rotation = interpolatedCam.rotation;
        camera.leftFov = interpolatedCam.leftFov;
        camera.rightFov = interpolatedCam.rightFov;
        camera.topFov = interpolatedCam.topFov;
        camera.bottomFov = interpolatedCam.bottomFov;
        cam.center.copy(interpolatedCam.center);
        cam.pivot.copy(interpolatedCam.pivot);
        camera.lookAt(cam.center);
        camera.up.normalize();
        changed(false);
    };

};
;/* All coordinates in three.js are right handed
 * when looking at the Front of the Cube in the regular upright position: */
/**
 * This is the view cube class subset of Autocam
 * this class renders and provides all functionality for the view cube
 * @class
 * @param {string} tagId - html tag id where you want the view cube to render - OBSOLETE
 * @param {Object} autocam - the autocam controller object
 * @param {HTMLDivElement} cubeContainer - the HTML element to contain the view cube
 * @param {string} localizeResourcePath - relative path to localized texture images
 * */
Autocam.ViewCube = function (tagId, autocam, cubeContainer, localizeResourcePath ) {

    var avp = Autodesk.Viewing.Private;

    var self = this;
    var cam = autocam;
    var camera = autocam.camera;
    autocam.setCube(this);

    // $("body").prepend("<div id='"+tagId+"' style='position: absolute; z-index: 1000; border: 2px solid red;'></div>");

    self.currentFace = "front";

    var edgeNames = ["top,front","top right", "top,left", "top,back", "bottom,front", "bottom,right", "bottom,left", "bottom,back", "left,front", "front,right", "right,back", "back,left"];
    var cornerNames = ["front,top,right","back,top,right","front,top,left","back,top,left","front,bottom,right","back,bottom,right","front,bottom,left","back,bottom,left"];

   /**
     *  A string array which contains the options for the view cube menu. Use null to indicate a section separator
     * @type {Array}
     */
    var menuOptionList = [
        "Go Home",                          // localized by call to drawDropdownMenu
        null,
        "Orthographic",                     // localized by call to drawDropdownMenu
        "Perspective",                      // localized by call to drawDropdownMenu
        "Perspective with Ortho Faces",     // localized by call to drawDropdownMenu
        null,
        "Set current view as Home",         // localized by call to drawDropdownMenu
        "Focus and set as Home",            // localized by call to drawDropdownMenu
        "Reset Home",                       // localized by call to drawDropdownMenu
        null,
        "Set current view as Front",        // localized by call to drawDropdownMenu
        "Set current view as Top",          // localized by call to drawDropdownMenu
        "Reset orientation"                 // localized by call to drawDropdownMenu
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];
    var menuEnableList = [
        true,
        null,
        true,
        true,
        true,
        null,
        true,
        true,
        true,
        null,
        true,
        true,
        true
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];
    var menuStateCallbackList = [
        null,
        null,
        function() { return !cam.orthographicFaces && !camera.isPerspective; },
        function() { return !cam.orthographicFaces &&  camera.isPerspective; },
        function() { return cam.orthographicFaces; },
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];

    // THREE.js Scenes
    var shadowScene, cubeScene, gridScene, lineScene, controlScene;

    var controlCamera;
    // self.camera = new THREE.PerspectiveCamera( camera.fov, window.innerWidth / window.innerHeight, 1, 10000 );
    self.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
    self.camera.position.copy(camera.position);
    self.center = new THREE.Vector3(0,0,0);
    self.camera.lookAt(self.center);
    // var length = camera.position.length();

    // THREE.js Meshes
    var cube, line, home, shadow, context;
    var gridMeshes = [];
    var arrowGroup;

    // Sizes for Three.js renderers
    var windowHalfX;
    var windowHalfY;

    // Buffers and past INTERSECTS used for mouse picking
    var arrowBuffer = [];
    var intersectsFace = [];
    var controlBuffer = [];
    var cubeBuffer = [];
    var INTERSECTED = null;
    var INTERSECTED_F = null;
    var INTERSECTED_C = null;
    var rollLeftOffset, rollRightOffset, rollOffset;
    var homeOffset, menuOffset;

    // Size of cube in relation to HTML tag
    var cubeSize = 0;

    // Position of HTML element
    var position;

    // Used to wait for textures to load before rendering the View Cube
    var loadedTextureCount = 0;

    // Flags
    var _orthogonalView = true;
    var _havePointerLockFeature = false;
    var _havePointerLock = false;
    var _pointerLockMoveBugSPK865 = false;
	var _isChrome = (navigator.userAgent.search("Chrome") != -1);
	var _isWindows = (navigator.platform.search("Win32") != -1);
    var _dragged = false;
    var _transparent = false;

    // store all loaded textures here so we are not constantly re-downloading them
    var changingTextures = [];

    // Height and Width of the renderer
    // may be referred to as self.width and self.height
    this.width = 0;
    this.height = 0;

    // Public changeable values
    /**
     * view cube animation speed (not 0 or negative),
     * specified in time (milliseconds) to complete an animation
     * @type {Number}
     */
    this.animSpeed = 500;
    /**
     * turn on and off animation
     * @type {Boolean}
     */
    this.animate = true;
    /**
     * turn on and off ability to drag the view cube
     * @type {Boolean}
     */

    this.compass = false;
    this.viewScaleFactorCompass = 1.5;
    this.viewScale = 1; // Set in Init based on cubeSize

    this.draggable = true;

    /**
     * turn on and off the availability of the home button
     * @type {Boolean}
     */
    this.wantHomeButton = false;

    /**
     * turn on and off the availability of the roll arrows
     * @type {Boolean}
     */
    this.wantRollArrows = true;

    /**
     * turn on and off the availability of the menu icon
     * @type {Boolean}
     */
    this.wantContextMenu = true;

    /**
     * opacity when inactive (transparency must be enabled)
     * @type {Number}
     */
    this.inactiveOpacity = 0.5;

    /** Function to get position of html element on screen
     *
     * @param element - HTML DOM element to find position of
     * @return {Object} - object which specifies x and y screen coordinates of location of input element
     */
    var getPosition = function (element) {
        var rect = element.getBoundingClientRect();
        return { x: rect.left, y: rect.top, w: rect.width, h: rect.height };

        /*
        var xPosition = window.pageXOffset;
        var yPosition = window.pageYOffset;

        while (element) {
            xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
            yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
            element = element.offsetParent;
        }
        return { x:xPosition, y:yPosition };
        */
    };

    /** Used by pointer lock API
     *
     * @param {Object} e - event object
     */
    var pointerLockChange = function(e) {
        e.preventDefault();
        e.stopPropagation();

        _havePointerLock = (document.pointerLockElement === cubeContainer ||
                            document.mozPointerLockElement === cubeContainer ||
                            document.webkitPointerLockElement === cubeContainer);
        // stderr("POINTER LOCK: " + _havePointerLock);
    };


    /** Create ViewCube and set up renderer and camera
     * sets up all Three.js meshes for the View Cube
     * and initializes all event handlers such as mousemove
     * and mousedown and mouseup and pointerlock
     */
    var Init = function () {

        // parentTag = document.getElementById(tagId);

        // var element = $('#'+tagId); // ?? Is this different than the above?
        // element.width(300);
        // element.height(300);

        var bounds = cubeContainer.getBoundingClientRect();
        self.width  = bounds.width;
        self.height = bounds.height;

        position = getPosition(cubeContainer);

        windowHalfX = self.width / 2;
        windowHalfY = self.height / 2;

        //camera for home and arrow
        controlCamera = new THREE.PerspectiveCamera(70, self.height / self.width, 1, 10000);
        controlCamera.position.set(0, 0, 500);

        shadowScene = new THREE.Scene();
        cubeScene = new THREE.Scene();
        gridScene = new THREE.Scene();
        lineScene = new THREE.Scene();
        controlScene = new THREE.Scene();
        _orthogonalView = true;

        // This size means that the cube is (cubeSize)x(cubeSize)x(cubeSize) big
        cubeSize = 200;
        self.viewScale = cubeSize * 3.5;

        /******************************************Create the View Cube***********************************************/
        var filteringType = THREE.LinearFilter;

        // Load in the faceMap textures for 6 faces

        var getResourceUrl = Autodesk.Viewing.Private.getResourceUrl;
        var resRoot = 'res/textures/';

        //The face names texture is localized:
        var locTexPath = localizeResourcePath || resRoot;

        var texture = new THREE.DDSLoader().load(getResourceUrl(locTexPath + 'VCcrossRGBA8small.dds'));
        texture.minFilter = texture.maxFilter = filteringType;

        var shader = THREE.ShaderLib[ "cube" ];

        var material = new THREE.ShaderMaterial( {
            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: THREE.UniformsUtils.clone(shader.uniforms),
            depthWrite: false
        } );

        material.uniforms[ "tCube" ].value = texture;

        var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 4, 4, 4);
        var cubeLine = new THREE.BoxGeometry(cubeSize+1 , cubeSize+1 , cubeSize+1, 4, 4, 4);

        // Create a cube object mesh with specified geometry and faceMap materials
        cube = new THREE.Mesh(cubeGeometry, material);
        cube.position.set(0.0, 0, 0);
        cubeScene.add(cube);

        // Set up a line segment for the cube border
        var borderTexture = loadTexture(getResourceUrl(resRoot + 'VCedge1.png'));

        borderTexture.minFilter = borderTexture.maxFilter = filteringType;

        line = new THREE.Mesh(cubeLine, new THREE.MeshBasicMaterial({ map: borderTexture, overdraw: false, transparent: true, shading: THREE.SmoothShading }));
        line.position.set(0.0, 0, 0);
        lineScene.add(line);

        /********************************************Set up the controls**********************************************/

        // Orthogonal Arrows

        var arrowDist = cubeSize;

        var arrowGeo = new THREE.Geometry();

        var v1 = new THREE.Vector3(-30, 0, 0);
        var v2 = new THREE.Vector3(30, 0, 0);
        var v3 = new THREE.Vector3(0, -30, 0);

        arrowGeo.vertices.push(v1);
        arrowGeo.vertices.push(v2);
        arrowGeo.vertices.push(v3);

        arrowGeo.faces.push(new THREE.Face3(1, 0, 2));
        arrowGeo.computeFaceNormals();

        var arrowMaterial1 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial2 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial3 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial4 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });

        var arrowSelection = new THREE.PlaneBufferGeometry(cubeSize * 0.5, cubeSize * 0.3, 2, 2);
        var arrowSelectionMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});

        var upArrow = new THREE.Mesh(arrowGeo, arrowMaterial1);
        var upArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        upArrow.position.set(0, arrowDist, 0.0);
        upArrowSelect.position.set(0, arrowDist * 0.9, 0.1);

        var downArrow = new THREE.Mesh(arrowGeo, arrowMaterial2);
        var downArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        downArrow.position.set(0, -arrowDist, 0.0);
        downArrowSelect.position.set(0, -arrowDist * 0.9, 0.1);
        downArrow.rotation.z += Math.PI;
        downArrowSelect.rotation.z += Math.PI;

        var rightArrow = new THREE.Mesh(arrowGeo, arrowMaterial3);
        var rightArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        rightArrow.position.set(arrowDist, 0, 0.0);
        rightArrowSelect.position.set(arrowDist * 0.9, 0, 0.1);
        rightArrow.rotation.z -= Math.PI / 2;
        rightArrowSelect.rotation.z -= Math.PI / 2;

        var leftArrow = new THREE.Mesh(arrowGeo, arrowMaterial4);
        var leftArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        leftArrow.position.set(-arrowDist, 0, 0.0);
        leftArrowSelect.position.set(-arrowDist * 0.9, 0, 0.1);
        leftArrow.rotation.z += Math.PI / 2;
        leftArrowSelect.rotation.z += Math.PI / 2;

        arrowGroup = new THREE.Object3D();
        arrowGroup.position.set(0, 0, 0);
        arrowGroup.add(upArrow);
        arrowGroup.add(downArrow);
        arrowGroup.add(rightArrow);
        arrowGroup.add(leftArrow);

        controlScene.add(upArrowSelect);
        controlScene.add(downArrowSelect);
        controlScene.add(rightArrowSelect);
        controlScene.add(leftArrowSelect);
        controlScene.add(arrowGroup);

        arrowBuffer.push(upArrowSelect);
        arrowBuffer.push(downArrowSelect);
        arrowBuffer.push(rightArrowSelect);
        arrowBuffer.push(leftArrowSelect);

        // Home icon
        var homeGeo = new THREE.PlaneBufferGeometry(cubeSize / 3, cubeSize / 3, 2, 2);
        var homeMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VChome.png')),
            transparent: true, shading: THREE.FlatShading });
        //homeMaterial.needsUpdate = true;
        home = new THREE.Mesh(homeGeo, homeMaterial);
        home.position.set(-cubeSize, cubeSize, 0);

        homeOffset = controlBuffer.length;
        controlScene.add(home);
        controlBuffer.push(home);

        // Arrows for rolling
        var rollArrows = new THREE.PlaneBufferGeometry(cubeSize * 1.5, cubeSize * 1.5, 2, 2);
        var rollMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VCarrows.png')), shading: THREE.FlatShading, transparent: true});
        var roll = new THREE.Mesh(rollArrows, rollMaterial);
        roll.position.set(cubeSize * 0.5 + 20, cubeSize * 0.5 + 20, 0);

        var rollSelectionLeft = new THREE.PlaneBufferGeometry(cubeSize * 0.6, cubeSize * 0.45, 2, 2);
        var rollSelectionLeftMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});
        var rollLeft = new THREE.Mesh(rollSelectionLeft, rollSelectionLeftMat);
        rollLeft.position.set(cubeSize * 0.5 + 20, cubeSize + 20, 0.1);

        var rollSelectionRight = new THREE.PlaneBufferGeometry(cubeSize * 0.45, cubeSize * 0.6, 2, 2);
        var rollSelectionRightMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});
        var rollRight = new THREE.Mesh(rollSelectionRight, rollSelectionRightMat);
        rollRight.position.set(cubeSize + 20, cubeSize * 0.5 + 20, 0.1);

        controlScene.add(roll);
        controlScene.add(rollLeft);
        controlScene.add(rollRight);

        rollLeftOffset = controlBuffer.length;
        controlBuffer.push(rollLeft);
        rollRightOffset = controlBuffer.length;
        controlBuffer.push(rollRight);
        rollOffset = controlBuffer.length;
        controlBuffer.push(roll);

        //Menu Icon
        var contextGeo = new THREE.PlaneBufferGeometry(cubeSize / 2.3, cubeSize / 2.3, 2, 2);
        var contextMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VCcontext.png')),
            transparent: true, shading: THREE.FlatShading });
        //homeMaterial.needsUpdate = true;
        context = new THREE.Mesh(contextGeo, contextMaterial);
        context.position.set(cubeSize, -cubeSize, 0);

        menuOffset = controlBuffer.length;
        controlScene.add(context);
        controlBuffer.push(context);

        // Cube Shadow (Plane)

        var shadowGeo = new THREE.Geometry();

        shadowGeo.vertices.push(new THREE.Vector3(0, 0, 0));

        shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - 20, -cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - 20, -cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - 20, cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - 20, cubeSize / 2));

        shadowGeo.faces.push(new THREE.Face3(4, 3, 2));
        shadowGeo.faces.push(new THREE.Face3(4, 2, 1));


        var shadowMat;

        // if(cam.renderer === 'WEBGL') {
        //     var vertexShader = "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}";
        //     var fragmentShader = "void main() {gl_FragColor = vec4(0, 0, 0, 0.5);}";
        //     shadowMat = new THREE.ShaderMaterial({vertexShader: vertexShader, fragmentShader: fragmentShader});
        // }else{
        //     shadowMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity: 0.5});
        // }
        shadowMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity: 0.5});

        shadow = new THREE.Mesh(shadowGeo, shadowMat);
        shadowScene.add(shadow);

        createCubeGrid();

        if (cam.renderer.toUpperCase() === 'CANVAS'){
            self.renderer = new THREE.CanvasRenderer();

        }else if (cam.renderer.toUpperCase() === 'WEBGL'){
            self.renderer = new FireflyWebGLRenderer({ alpha: true, antialias:true });

        }else {
            console.log("Incorrect use of Autocam.renderer property");
            self.renderer = new THREE.CanvasRenderer();
        }

        self.useTransparency(true);
        self.setSize(self.width,self.height);

        self.camera.topFov = self.camera.bottomFov = self.camera.fov/2;
        self.camera.leftFov = self.camera.rightFov = (self.camera.aspect * self.camera.fov)/2;

        // Auto clear needed because of multiple scenes
        self.renderer.autoClear = false;
        self.renderer.setSize(self.width, self.height);
        self.renderer.sortObjects = false;
        cubeContainer.appendChild(self.renderer.domElement);

        // Initialize all event handlers
        cubeContainer.addEventListener('touchstart', onDocumentMouseDown, false);
        cubeContainer.addEventListener('mousedown', onDocumentMouseDown, false);
        cubeContainer.addEventListener('mousemove', onDocumentMouseMove, false);

/*
        _havePointerLockFeature = 'pointerLockElement' in document ||
                                  'mozPointerLockElement' in document ||
                                  'webkitPointerLockElement' in document;
*/
        //Disabling this because it causes an intrusive browser pop-up asking
        //whether I want to allow full screen mode to happen (huh?)
        _havePointerLockFeature = false;

        // stderr("HAVE LOCK FEATURE: " + _havePointerLockFeature);

        if(_havePointerLockFeature) {
            document.exitPointerLock = document.exitPointerLock ||
                                       document.mozExitPointerLock ||
                                       document.webkitExitPointerLock;

            cubeContainer.requestPointerLock = cubeContainer.requestPointerLock ||
                                               cubeContainer.mozRequestPointerLock ||
                                               cubeContainer.webkitRequestPointerLock;

            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerLockChange, false);
            document.addEventListener('mozpointerlockchange', pointerLockChange, false);
            document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
        }

        // Changing textures (blue highlighting for home and roll arrows)
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VChomeS.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrowsS0.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrowsS1.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VChome.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrows.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCcontext.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCcontextS.png')));
    };

    /** Used to make cube visible again when using the transparency option   */
    var mouseOverCube = function() {
        if( cam.navApi.isActionEnabled('orbit') ) {
            cubeContainer.style.opacity = "1.0";
            _transparent = false;
        }
        requestAnimationFrame(self.render);
    };

    /** Used to fade in and out the cube when using the transparency option */
    var mouseMoveOverCube = function(event) {
        if (!_transparent && !cam.viewCubeMenuOpen && cam.navApi.isActionEnabled('orbit') ) {
            var x = Math.max(Math.abs((event.clientX - position.x) / position.w - 0.5) * 4.0 - 1.0, 0);
            var y = Math.max(Math.abs((event.clientY - position.y) / position.h - 0.5) * 4.0 - 1.0, 0);
            var d = Math.max(0, Math.min(Math.sqrt(x*x + y*y), 1.0));
            cubeContainer.style.opacity = 1.0 - d * (1.0 - self.inactiveOpacity);
        }
        else if( cam.navApi.isActionEnabled('orbit') ) {
            cubeContainer.style.opacity = 1.0;
        }
    };

    /** Used to make cube transparent when using the transparency option */
    var mouseOutCube = function() {
        if(cam.viewCubeMenuOpen){
            return;
        }
        cubeContainer.style.opacity = self.inactiveOpacity;
        _transparent = true;
        requestAnimationFrame(self.render);
    };


    /** Takes in a image url and outputs a THREE.texture to be used
     * by Three.js materials
     * @param {string} url - path to the image you want to load as a texture
     * @return {THREE.Texture}
     */
    var loadTexture = function(url) {
        var image = new Image();
        var useCredentials = auth && (url.indexOf('://') === -1 || url.indexOf(window.location.host) !== -1);
        if (useCredentials) {
            image.crossOrigin = "use-credentials";
        } else {
            image.crossOrigin = "anonymous";
        }
        var texture = new THREE.Texture(image);
        image.onload = function() {
            texture.needsUpdate = true;
            loadedTextureCount++;
            if(loadedTextureCount >= 11){
                // all textures are now loaded
                requestAnimationFrame(self.render);
            }
        };

        image.src = url;
        return texture;
    };

    /** Creates the click-able grid around the View Cube
     *  by running functions to create Three.js meshes
     */
    var createCubeGrid = function () {
        var currentGridLength;
        var cubeCorners = [];
        var cubeEdges = [];

        cubeCorners[0] = buildCubeCorner(0, 0);
        cubeCorners[1] = buildCubeCorner(0, Math.PI / 2);
        cubeCorners[2] = buildCubeCorner(0, -Math.PI / 2);
        cubeCorners[3] = buildCubeCorner(0, Math.PI);
        cubeCorners[4] = buildCubeCorner(Math.PI / 2, 0);
        cubeCorners[5] = buildCubeCorner(Math.PI / 2, Math.PI / 2);
        cubeCorners[6] = buildCubeCorner(Math.PI / 2, -Math.PI / 2);
        cubeCorners[7] = buildCubeCorner(Math.PI / 2, Math.PI);

        cubeEdges[0] = buildCubeEdge(0, 0, 0);
        cubeEdges[1] = buildCubeEdge(0, Math.PI / 2, 0);
        cubeEdges[2] = buildCubeEdge(0, -Math.PI / 2, 0);
        cubeEdges[3] = buildCubeEdge(0, Math.PI, 0);
        cubeEdges[4] = buildCubeEdge(Math.PI / 2, 0, 0);
        cubeEdges[5] = buildCubeEdge(Math.PI / 2, Math.PI / 2, 0);
        cubeEdges[6] = buildCubeEdge(Math.PI / 2, -Math.PI / 2, 0);
        cubeEdges[7] = buildCubeEdge(Math.PI / 2, Math.PI, 0);
        cubeEdges[8] = buildCubeEdge(0, 0, Math.PI / 2);
        cubeEdges[9] = buildCubeEdge(0, 0, -Math.PI / 2);
        cubeEdges[10] = buildCubeEdge(-Math.PI / 2, 0, -Math.PI / 2);
        cubeEdges[11] = buildCubeEdge(-Math.PI, 0, -Math.PI / 2);

        // Draw the front square on the grid
        gridMeshes.push(buildCubeFace(0, 0));
        gridMeshes[0].name = 'front';
        intersectsFace.push(gridMeshes[0]);
        cubeBuffer.push(gridMeshes[0]);
        gridScene.add(gridMeshes[0]);

        // Draw the right square on the grid
        gridMeshes.push(buildCubeFace(0, Math.PI / 2));
        gridMeshes[1].name = 'right';
        intersectsFace.push(gridMeshes[1]);
        cubeBuffer.push(gridMeshes[1]);
        gridScene.add(gridMeshes[1]);

        // Draw the back square on the grid
        gridMeshes.push(buildCubeFace(0, Math.PI));
        gridMeshes[2].name = 'back';
        intersectsFace.push(gridMeshes[2]);
        cubeBuffer.push(gridMeshes[2]);
        gridScene.add(gridMeshes[2]);

        // Draw the left grid
        gridMeshes.push(buildCubeFace(0, -Math.PI / 2));
        gridMeshes[3].name = 'left';
        intersectsFace.push(gridMeshes[3]);
        cubeBuffer.push(gridMeshes[3]);
        gridScene.add(gridMeshes[3]);

        // Draw the bottom grid
        gridMeshes.push(buildCubeFace(Math.PI / 2, 0));
        gridMeshes[4].name = 'bottom';
        intersectsFace.push(gridMeshes[4]);
        cubeBuffer.push(gridMeshes[4]);
        gridScene.add(gridMeshes[4]);

        // Draw the top grid
        gridMeshes.push(buildCubeFace(-Math.PI / 2, 0));
        gridMeshes[5].name = 'top';
        intersectsFace.push(gridMeshes[5]);
        cubeBuffer.push(gridMeshes[5]);
        gridScene.add(gridMeshes[5]);

        currentGridLength = gridMeshes.length;

        var i;
        for (i = 0; i < cubeCorners.length; i++) {
            gridMeshes.push(cubeCorners[i]);
            gridMeshes[currentGridLength + i].name = cornerNames[i];
            gridScene.add(gridMeshes[currentGridLength + i]);
            intersectsFace.push(gridMeshes[currentGridLength + i]);
            cubeBuffer.push(gridMeshes[currentGridLength + i]);
        }

        currentGridLength = gridMeshes.length;

        for (i = 0; i < cubeEdges.length; i++) {
            gridMeshes.push(cubeEdges[i]);
            gridMeshes[currentGridLength + i].name = edgeNames[i];
            gridScene.add(gridMeshes[currentGridLength + i]);
            intersectsFace.push(gridMeshes[currentGridLength + i]);
            cubeBuffer.push(gridMeshes[currentGridLength + i]);
        }
    };


    /**
     * Get intersections between a mesh and mouse position (mouse picking)
     * @param {THREE.Vector3} pickingVector - direction vector to find intersections
     * @param {THREE.Camera} camera
     * @param {THREE.Mesh[]} intersectionBuffer - an array of three.js meshes to check for intersections with these specific meshes
     * @return {Object[]} - objects which were intersected
     */
    var findPickingIntersects = function(pickingVector, camera, intersectionBuffer) {
        var raycaster;
        var intersects;

        var direction = new THREE.Vector3();
        direction.copy(pickingVector);

        direction = direction.unproject(camera);
        raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());

        intersects = raycaster.intersectObjects(intersectionBuffer);

        return intersects;

    };

    var getPickVector = function(event, position) {
        var x = event.clientX - position.x;
        var y = event.clientY - position.y;

        x = (x / position.w * 2.0) - 1.0;
        y = ((position.h - y) / position.h * 2.0) - 1.0;

        return new THREE.Vector3(x, y, 0.5);
    };

    function isFullscreen() {
        return document.fullscreenElement ||
               document.webkitFullscreenElement ||
               document.mozFullScreenElement ||
               document.msFullscreenElement;
    }

    function getEventCoords(event, self) {
        var coords = {}

        if( event.type.indexOf("touch") === 0 ) {
            if( event.touches.length > 0 ) {
                coords.clientX   = event.touches[0].clientX;
                coords.clientY   = event.touches[0].clientY;
                coords.pageX     = event.touches[0].pageX;
                coords.pageY     = event.touches[0].pageY;
                coords.screenX   = event.touches[0].screenX;
                coords.screenY   = event.touches[0].screenY;
                coords.movementX = coords.screenX - self.prevX;
                coords.movementY = coords.screenY - self.prevY;
                coords.which     = cam.navApi.getUseLeftHandedInput() ? 3 : 1;
            }
            else {
                coords = self.prevCoords;
            }
        }
        else {
            coords.clientX   = event.clientX;
            coords.clientY   = event.clientY;
            coords.pageX     = event.pageX;
            coords.pageY     = event.pageY;
            coords.screenX   = event.screenX;
            coords.screenY   = event.screenY;
            coords.which     = event.which;

            if ( _havePointerLockFeature ) {
                coords.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                coords.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            }
            else {
                coords.movementX = coords.screenX - self.prevX;
                coords.movementY = coords.screenY - self.prevY;
            }
        }
        self.prevX = coords.screenX;
        self.prevY = coords.screenY;
        self.prevCoords = coords;

        return coords;
    }

    /** All functionality regarding cube clicks starts here
     *
     * @param {Object} event - event when mouse down occurs
     */
    var onDocumentMouseDown = function (event) {
        event.preventDefault();
        event.stopPropagation();

        if( !cam.navApi.isActionEnabled('orbit') ) 
            return;

        if (cam.currentlyAnimating) { return; }

        var coords = getEventCoords(event, self);

        // Make sure our position is up to date...
        position = getPosition(cubeContainer);

        cubeContainer.removeEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
        document.addEventListener('touchend', onDocumentMouseUp, false);
        // Not needed: document.addEventListener('mousemove', onDocumentMouseMove, false);

        if( !cam.navApi.getUsePivotAlways() ) {
            // If the usePivot option is not on, we pivot around the center of the view:
            cam.pivot.copy(cam.center);
            cam.navApi.setPivotPoint(cam.center);
            // This also clears the pivot set flag:
            cam.navApi.setPivotSetFlag(false);
        }

        cam.startInteraction(coords.pageX, coords.pageY);

        // Since this mouse down is for dragging the cube we should not be able do this if the cube is animating already
        var intersectsWithCube;
        var pickingVector;

        //If cube is first thing clicked, add the current shot to rewind history
        if (cam.rewindParams.history.length == 0) cam.addHistoryElement();

        //If clicking cube from anywhere other then end of timeline update history accordingly
        if (!cam.rewindParams.snapped || cam.rewindParams.timelineIndex +1 != cam.rewindParams.history.length) cam.addIntermediateHistoryElement();

        var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;
        if (coords.which === rightMouse) // Right mouse click, handled on mouse up
            return;

        if(self.animSpeed <= 0){
            console.error("animSpeed cannot be 0 or less, use ViewCube.animate flag to turn on and off animation");
            return;
        }

        // get mouse picking intersections
        pickingVector = getPickVector(coords, position);
        intersectsWithCube = findPickingIntersects(pickingVector, self.camera, cubeBuffer);


        if (intersectsWithCube.length > 0) {

            hideArrows();
            if(self.draggable){
                document.addEventListener('mousemove', onDocumentMouseMoveCube, false);
                document.addEventListener('touchmove', onDocumentMouseMoveCube, false);

                // Check if browser has pointer lock support
                if ( _havePointerLockFeature ) {
                    // Ask the browser to lock the pointer
                    cubeContainer.requestPointerLock();
					_pointerLockMoveBugSPK865 = (_isChrome && _isWindows);
                }
            }
        }
    };

    /** Used for dragging the cube,
     * @param {Object} event - event when mouse move occurs (contains information about pointer position)
     */
    var onDocumentMouseMoveCube = function (event) {

		// stderr("MOUSE MOVE CUBE: " + event.clientX + ", " + event.clientY + ", " + event.button);
        event.preventDefault();
        event.stopPropagation();

        // This is an error if user puts in self.animSpeed = 0 or less
        if(self.animSpeed <= 0){
            document.removeEventListener("mousemove", onDocumentMouseMoveCube, false);
            document.removeEventListener("touchmove", onDocumentMouseMoveCube, false);
            console.error("animSpeed cannot be 0 or less");
            return;
        }

        if(cam.currentlyAnimating) {
			return;
		}
        var coords = getEventCoords(event, self);

        if ( _havePointerLockFeature ) {
			// We skip the first movement event after requesting pointer lock
			// because Chrome on Windows sends out a bogus motion value.
			if( _pointerLockMoveBugSPK865 ) {
				_pointerLockMoveBugSPK865 = false;
				coords.movementX = coords.movementY = 0;
			}
        }

        if(_havePointerLock) {

            // Ignore erroneous data sent from pointer lock
            // not sure why erroneous data gets received
            // could be bug in pointer lock
            if(coords.movementX > 300 || coords.movementY > 300) {
                coords.movementX = 0;
                coords.movementY = 0;
            }
        }

        // If the mouse hasn't moved ignore this current movement (not sure why the mouse move event gets called)
        // Also used for ignoring erroneous data
        if(coords.movementX === coords.movementY && coords.movementX === 0) {
            cam.currentlyAnimating = false;
            return;
        }
        _orthogonalView = false;
        _dragged = true;
        cam.showPivot(true);
        cam.currentCursor = new THREE.Vector2(coords.pageX, coords.pageY);
        cam.orbit(cam.currentCursor, cam.startCursor, new THREE.Vector3( - coords.movementX, coords.movementY, 0 ), cam.startState);

        self.camera.lookAt(self.center);

        requestAnimationFrame(self.render);
    };


    var endMouseUp = function (stillNeedUp) {
        if( !stillNeedUp ) {
            document.removeEventListener('mouseup', onDocumentMouseUp, false);
            document.removeEventListener('touchend', onDocumentMouseUp, false);
        }

        document.removeEventListener('mousemove', onDocumentMouseMoveCube, false);
        document.removeEventListener('touchmove', onDocumentMouseMoveCube, false);
        cubeContainer.addEventListener('mousemove', onDocumentMouseMove, false);

        if ( _havePointerLock ) {
            document.exitPointerLock();
        }

    };

    /** Rotates the cube when a division of the cube grid is clicked,
     * also provides functionality for home button interaction, orthogonal arrows interaction,
     * and roll arrows interaction
     * @param {Object} event - event contains information about mouse position which is used in this function
     */
    var onDocumentMouseUp = function (event) {
        event.preventDefault();
        event.stopPropagation();

        var cubeIntersects;
        var arrowIntersects;
        var controlIntersects;

        if (cam.currentlyAnimating || _dragged) {
            cam.endInteraction();
            cam.showPivot(false);
            _dragged = false;

            endMouseUp(false);
            return;
        }
        var coords = getEventCoords(event, self);

        if (cam.viewCubeMenuOpen) {
            var x = coords.clientX - position.x;
            var y = coords.clientY - position.y;

            //if clicked on the menu
            if ((cam.menuOrigin.x <= x) && (x <= (cam.menuOrigin.x + cam.menuSize.x)) &&
                (cam.menuOrigin.y <= y) && (y <= (cam.menuOrigin.y + cam.menuSize.y))){

                // HACK!!
                // TODO: make this a bit more robust. It doesn't take the menu separators
                // into account and makes a gross assumption about the menu entry size.
                var menuItemNumber = Math.floor(((y-5) - cam.menuOrigin.y)/25);

                var log = function(action) {
                    if (avp.logger) {
                        avp.logger.log({ name: 'navigation/' + action, aggregate: 'count' });
                    }
                };

                // stderr("HIT ITEM: " + menuItemNumber + " Y=" + coords.clientY + " Menu Y=" + cam.menuOrigin.y);

                switch(menuItemNumber){
                    case 0:                 //home
                        log('home');
                        cam.goHome();
                        break;
                    case 1:                 //orthographic
                        log('setortho');
                        cam.setOrthographicFaces(false);
                        cam.toOrthographic();
                        break;
                    case 2:                 //perspective
                        log('setpersp');
                        cam.setOrthographicFaces(false);
                        cam.toPerspective();
                        break;
                    case 3:                 //perspective with ortho faces
                        cam.setOrthographicFaces(true);
                        if( _orthogonalView )
                            cam.toOrthographic();
                        else
                            cam.toPerspective();
                        break;
                    case 4:                 //set current view as home
                        log('sethome');
                        cam.setCurrentViewAsHome(false);
                        break;
                    case 5:                 //focus and set current view as home
                        log('focushome');
                        cam.setCurrentViewAsHome(true);
                        break;
                    case 6:                 //reset home
                        log('resethome');
                        cam.resetHome();
                        break;
                    case 7:                 //set current view as front
                        log('setfront');
                        cam.setCurrentViewAsFront();
                        break;
                    case 8:                 //set current view as top
                        log('settop');
                        cam.setCurrentViewAsTop();
                        break;
                    case 9:                 //reset orientation
                        cam.resetOrientation();
                        break;
                }
            }

            cam.viewCubeMenuOpen = false;
            cam.removeDropdownMenu(cubeContainer);

            //if clicked off the cube canvas
            if( coords.clientX < position.x || coords.clientX > (position.w + position.x)
             || coords.clientY < position.y || coords.clientY > (position.h + position.y)) {
                mouseOutCube();
            }

            // In case something needs a highlight change:
            if( self.mouseMoveSave )
                self.processMouseMove(self.mouseMoveSave);

            endMouseUp(false);
            return;
        }
        var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;
        if (coords.which === rightMouse) {
            cam.viewCubeMenuOpen=true;
            cam.drawDropdownMenu(menuOptionList, menuEnableList, menuStateCallbackList, coords.clientX, coords.clientY, cubeContainer, position);
            endMouseUp(true);
            return;
        }
        var pickingVector = getPickVector(coords, position);
        cubeIntersects    = findPickingIntersects(pickingVector, self.camera, cubeBuffer);
        arrowIntersects   = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);
        controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);

        // Apply logic for clicking on arrows
        if (arrowIntersects.length > 0 && _orthogonalView) {
            var orientation = cam.getOrientation();

            switch (self.currentFace){
                case "front":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "right":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                        }
                    break;

                case "left":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "back":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "top":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                    }
                    break;

                case "bottom":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                    }
                    break;
            }
            cam.elapsedTime =0;
            cam.sphericallyInterpolateTransition();
        }

        if (controlIntersects.length > 0) {
            cam.elapsedTime = 0;

            if (self.wantHomeButton && controlIntersects[0].object === controlBuffer[homeOffset]) {
                cam.goHome();
                endMouseUp(false);
                return;
            }
            if (self.wantContextMenu && controlIntersects[0].object === controlBuffer[menuOffset]) {
                cam.viewCubeMenuOpen=true;
                cam.drawDropdownMenu(menuOptionList, menuEnableList, menuStateCallbackList, coords.clientX, coords.clientY, cubeContainer, position);
                endMouseUp(true);
                return;
            }
            if (self.wantRollArrows && _orthogonalView && (controlIntersects[0].object === controlBuffer[rollLeftOffset] || controlIntersects[0].object === controlBuffer[rollRightOffset])) {
                //TODO: when panning, dir changes -> position
                var clockwise = (controlIntersects[0].object === controlBuffer[rollRightOffset]);
                var destination = {
                    center: cam.center.clone(),
                    position: camera.position.clone(),
                    pivot: camera.pivot.clone(),
                    fov: camera.fov,
                    worldUp: cam.sceneUpDirection.clone(),
                    isOrtho: (camera.isPerspective === false)
                };
                var dir = cam.center.clone().sub(camera.position).normalize();

                if (clockwise){
                    destination.up = camera.up.clone().cross(dir);
                }else{
                    destination.up = camera.up.clone().multiplyScalar(-1);
                    destination.up.cross(dir);
                }
                destination.up.normalize();

                cam.elapsedTime = 0.0;
                cam.animateTransition(destination)
            }
        }
        if (cubeIntersects.length > 0) {
            self.currentFace = cubeIntersects[0].object.name;

            // If ortho faces is on and the target is not another face,
            // switch to perspective mode:
            if( cam.orthographicFaces && (self.currentFace.indexOf(',') !== -1) ) {
                cam.setCameraOrtho(false);
            }
            cam.calculateCubeTransform(self.currentFace);

            // stderr("MOUSE UP, hit: " + self.currentFace);
            cam.elapsedTime =0;
            self.mouseMoveSave = event;

            // After interpolating to the new target we may have to simulate
            // a mouse move event at the final location so that the appropriate
            // part of the cube is highlighted:
            cam.sphericallyInterpolateTransition(function(){
                if( self.mouseMoveSave )
                    self.processMouseMove(self.mouseMoveSave);
            });
        }
        endMouseUp(false);
    };

    /** Used to highlight cube grid divisions/arrows/home
     * @param {Object} event - event contains information about mouse position which is used in this function
     */
    this.processMouseMove = function (event) {
        var intersectsFaces;
        var arrowIntersects;
        var controlIntersects;

        if (cam.viewCubeMenuOpen || cam.currentlyAnimating) {
            self.mouseMoveSave = event;
            return;
        }
        self.mouseMoveSave = null;

        var coords = getEventCoords(event, self);

        var pickingVector = getPickVector(coords, position);

        intersectsFaces = findPickingIntersects(pickingVector, self.camera, intersectsFace);
        arrowIntersects = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);
        controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);

        /**********Highlight arrows when hovered over************/

        if (INTERSECTED && !_dragged) {
            INTERSECTED.material.color.setHex(0xDDDDDD);
            INTERSECTED = null;
            requestAnimationFrame(self.render);
        }

        if (arrowIntersects.length > 0 && !_dragged) {
                INTERSECTED = arrowIntersects[0].object;
                for( var i=arrowGroup.children.length;  --i >= 0; ) {
                    if (INTERSECTED === arrowBuffer[i]) {
                        INTERSECTED = arrowGroup.children[i];
                        INTERSECTED.material.color.setHex(0x00afff);
                        break;
                    }
                }
                requestAnimationFrame(self.render);
        }

        /**************Highlight faces on cube******************/

        if (INTERSECTED_F && !_dragged) {
            // Make the previously selected face opacity: 0.0
                INTERSECTED_F.material.opacity = 0.0;
                INTERSECTED_F = null;
                requestAnimationFrame(self.render);
        }

        if (intersectsFaces.length > 0 && !_dragged) {
            // Make the currently selected face opacity: 0.3
                INTERSECTED_F = intersectsFaces[0].object;
                INTERSECTED_F.material.opacity = 0.3;
                requestAnimationFrame(self.render);
        }

        if (controlIntersects.length > 0 && !_dragged){
            if(INTERSECTED_C !== controlIntersects[0].object){
                // home mouse over
                if(self.wantHomeButton && controlIntersects[0].object === controlBuffer[homeOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[homeOffset].material.map = changingTextures[0];
                }

                // Left roll arrow mouse over
                else if(self.wantRollArrows && controlIntersects[0].object === controlBuffer[rollLeftOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[rollOffset].material.map = changingTextures[1];
                }

                // Right roll arrow mouse over
                else if(self.wantRollArrows && controlIntersects[0].object === controlBuffer[rollRightOffset]) {
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[rollOffset].material.map = changingTextures[2];
                }

                // Menu Icon
                else if(self.wantContextMenu && controlIntersects[0].object === controlBuffer[menuOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[menuOffset].material.map = changingTextures[6];
                }

                else{
                    // home mouse over
                    if(self.wantHomeButton && INTERSECTED_C === controlBuffer[homeOffset]) {
                        INTERSECTED_C = null;
                        controlBuffer[homeOffset].material.map = changingTextures[3];
                    }

                    // Left roll and Right roll arrow
                    else if(self.wantRollArrows && (INTERSECTED_C === controlBuffer[rollLeftOffset] ||
                        INTERSECTED_C === controlBuffer[rollRightOffset] || INTERSECTED_C === controlBuffer[rollOffset])){
                        INTERSECTED_C = null;
                        controlBuffer[rollOffset].material.map = changingTextures[4];
                    }

                    // menu icon
                    else if(self.wantContextMenu && INTERSECTED_C === controlBuffer[menuOffset]){
                        INTERSECTED_C = null;
                        controlBuffer[menuOffset].material.map = changingTextures[5];
                    }
                }
                requestAnimationFrame(self.render);
            }
        }else if(INTERSECTED_C !== null && !_dragged){
            // home mouse over
            if(self.wantHomeButton && INTERSECTED_C === controlBuffer[homeOffset]) {
                INTERSECTED_C = null;
                controlBuffer[homeOffset].material.map = changingTextures[3];
            }

            // Left roll and Right roll arrow
            else if(self.wantRollArrows && (INTERSECTED_C === controlBuffer[rollLeftOffset] ||
                INTERSECTED_C === controlBuffer[rollRightOffset] || INTERSECTED_C === controlBuffer[rollOffset])){
                INTERSECTED_C = null;
                controlBuffer[rollOffset].material.map = changingTextures[4];
            }

            // menu icon
            else if(self.wantContextMenu && INTERSECTED_C === controlBuffer[menuOffset]){
                INTERSECTED_C = null;
                controlBuffer[menuOffset].material.map = changingTextures[5];
            }

            requestAnimationFrame(self.render);
        }
    };

    var onDocumentMouseMove = function (event) {
        if( cam.navApi.isActionEnabled('orbit') ) 
            self.processMouseMove(event);
    };

    /** Refreshes values so that renderer is correct size (in pixels) **/
    var onWindowResize = function () {
        position = getPosition(cubeContainer);

        // cubeContainer.style.width = self.width.toString() + "px";
        // cubeContainer.style.height = "inherit";

        self.width  = cubeContainer.offsetWidth;
        self.height = cubeContainer.offsetHeight;

        windowHalfX = self.width / 2;
        windowHalfY = self.height / 2;

        self.camera.aspect = self.width / self.height;
        self.camera.updateProjectionMatrix();

        // PHB added. See Autocam.js windowResize
        self.camera.topFov = self.camera.bottomFov = self.camera.fov/2;
        self.camera.leftFov = self.camera.rightFov = (self.camera.aspect * self.camera.fov)/2;

        self.renderer.setSize(self.width, self.height);
        requestAnimationFrame(self.render);
    };

    /** Builds one square mesh of the grid (located on each face of the cube)
     *
     * @param {Number} rotationX - rotate shape by this amount in X
     * @param {Number} rotationY - rotate shape by this amount in Y
     * @return {THREE.Mesh} - mesh of the cube face (square part) rotated by params
     */
    var buildCubeFace = function (rotationX, rotationY) {

        // These sizes may be changed if cube size is changed
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;

        var geo = new THREE.Geometry();

        // Center of the cube
        var v0 = new THREE.Vector3(0, 0, 0);

        /******************FRONT OF CUBE********************/
        var v1 = new THREE.Vector3(square, -square, masterCubeSize);
        var v2 = new THREE.Vector3(square, square, masterCubeSize);
        var v3 = new THREE.Vector3(-square, square, masterCubeSize);
        var v4 = new THREE.Vector3(-square, -square, masterCubeSize);

        geo.vertices.push(v0);

        geo.vertices.push(v1);
        geo.vertices.push(v2);
        geo.vertices.push(v3);
        geo.vertices.push(v4);

        /******************FRONT FACE********************/

            // Front square
        geo.faces.push(new THREE.Face3(1, 2, 3));
        geo.faces.push(new THREE.Face3(1, 3, 4));


        // Apply matrix rotations for sides which are not the front
        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        return new THREE.Mesh(geo, material);
    };

    /** Builds one edge mesh of the grid
     *
     * @param rotationX - rotate shape by this amount X
     * @param rotationY - rotate shape by this amount Y
     * @param rotationZ - rotate shape by this amount Z
     * @return {THREE.Mesh} - mesh of the cube edge rotated by params
     */
    var buildCubeEdge = function (rotationX, rotationY, rotationZ) {
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;
        var meshReturn;

        var geo = new THREE.Geometry();

        var e0 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
        var e1 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);
        var e2 = new THREE.Vector3(-square, square, masterCubeSize);
        var e3 = new THREE.Vector3(square, square, masterCubeSize);

        var e4 = new THREE.Vector3(square, masterCubeSize, square);
        var e5 = new THREE.Vector3(-square, masterCubeSize, square);
        var e6 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);
        var e7 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);

        geo.vertices.push(e0);
        geo.vertices.push(e1);
        geo.vertices.push(e2);
        geo.vertices.push(e3);

        geo.vertices.push(e4);
        geo.vertices.push(e5);
        geo.vertices.push(e6);
        geo.vertices.push(e7);

        geo.faces.push(new THREE.Face3(0, 1, 2));
        geo.faces.push(new THREE.Face3(0, 2, 3));

        geo.faces.push(new THREE.Face3(4, 5, 6));
        geo.faces.push(new THREE.Face3(4, 6, 7));


        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));
        geo.applyMatrix(new THREE.Matrix4().makeRotationZ(rotationZ));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        meshReturn = new THREE.Mesh(geo, material);
        return meshReturn;
    };

    /** Builds one corner mesh of the grid
     *
     * @param {Number} rotationX - rotate shape by this amount in X
     * @param {Number} rotationY - rotate shape by this amount in Y
     * @return {THREE.Mesh} - the cube corner mesh rotated by params
     */
    var buildCubeCorner = function (rotationX, rotationY) {
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;
        var meshReturn;

        var geo = new THREE.Geometry();

        var c0 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c1 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
        var c2 = new THREE.Vector3(square, square, masterCubeSize);
        var c3 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);

        var c4 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);
        var c5 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c6 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);
        var c7 = new THREE.Vector3(masterCubeSize, square, square);

        var c8 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c9 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);
        var c10 = new THREE.Vector3(square, masterCubeSize, square);
        var c11 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);

        geo.vertices.push(c0);
        geo.vertices.push(c1);
        geo.vertices.push(c2);
        geo.vertices.push(c3);

        geo.vertices.push(c4);
        geo.vertices.push(c5);
        geo.vertices.push(c6);
        geo.vertices.push(c7);

        geo.vertices.push(c8);
        geo.vertices.push(c9);
        geo.vertices.push(c10);
        geo.vertices.push(c11);

        geo.faces.push(new THREE.Face3(0, 1, 2));
        geo.faces.push(new THREE.Face3(0, 2, 3));

        geo.faces.push(new THREE.Face3(4, 5, 6));
        geo.faces.push(new THREE.Face3(4, 6, 7));

        geo.faces.push(new THREE.Face3(8, 9, 10));
        geo.faces.push(new THREE.Face3(8, 10, 11));


        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        meshReturn = new THREE.Mesh(geo, material);
        return meshReturn;
    };

    var changeBasisWorldToStandard = function (V) {
        var worldD = cam.cubeFront.clone();
        var worldU = cam.sceneUpDirection.clone();
        var worldR = worldD.clone().cross(worldU);
        worldU.copy(worldR).cross(worldD);

        worldD.normalize();
        worldU.normalize();
        worldR.normalize();

        var answer = new THREE.Vector3(worldD.x,worldU.x,worldR.x).multiplyScalar(V.x);
        answer.add(new THREE.Vector3(worldD.y,worldU.y,worldR.y).multiplyScalar(V.y));
        answer.add(new THREE.Vector3(worldD.z,worldU.z,worldR.z).multiplyScalar(V.z));

        return answer;
    };

    /** Render the View Cube scenes and perform checks for control visibility **/
    this.render = function () {
        var scale = self.compass ? self.viewScaleFactorCompass * self.viewScale : self.viewScale;
        var viewDir = cam.center.clone().sub(camera.position).normalize();
        var upDir   = camera.up.normalize();

        viewDir = changeBasisWorldToStandard(viewDir);
        upDir   = changeBasisWorldToStandard(upDir);

        self.camera.position.copy(viewDir);
		self.camera.position.multiplyScalar(-scale / self.camera.position.length());
        self.camera.up = upDir.normalize();
        self.camera.lookAt(self.center);

        checkControlVisibility();

        var renderer = self.renderer;
        if (renderer) {
            renderer.clear();
            // There are 3 scenes: the first is the shadow, then the cube with textures, then the grid is on top
            renderer.render(shadowScene, self.camera);
            renderer.render(cubeScene, self.camera);
            renderer.render(lineScene, self.camera);
            renderer.render(gridScene, self.camera);
            // Different camera since these shouldn't move with the View Cube
            renderer.render(controlScene, controlCamera);
        }
    };

    /**
     * checks whether arrows (orthogonal and roll), drop down menus, and home button should be visible or not at
     * this current time
     */
    var checkControlVisibility = function(){
        // Arrow Visibility

        _orthogonalView = cam.isFaceView();

        (_orthogonalView && !_transparent && !cam.currentlyAnimating) ? showArrows() : hideArrows();

        // Menu Visibility
        _transparent ? hideContext() : showContext();

        // Home Visibility
        _transparent ? hideHome() : showHome();
    };

    /** Hide View Cube Arrows **/
    var hideArrows = function() {
        controlScene.remove(arrowGroup);

        controlBuffer[rollOffset].material.opacity = 0.0;
        controlBuffer[menuOffset].material.opacity = 0.0;
    };

    /** Show View Cube Arrows **/
    var showArrows = function() {
        controlScene.add(arrowGroup);

        var opacity = self.wantRollArrows ? 1.0 : 0.0;
        controlBuffer[rollOffset].material.opacity = opacity;
        controlBuffer[menuOffset].material.opacity = opacity;
    };

    /** Hide the view cube menu button **/
    var hideContext = function() {
        context.material.opacity = 0.0;
    };

    /** Show the view cube menu button **/
    var showContext = function() {
        context.material.opacity = self.wantContextMenu ? 1.0 : 0.0;
    };

    /** Hide the home button **/
    var hideHome = function() {
        home.material.opacity = 0.0;
    };

    /** Show the home button **/
    var showHome = function() {
        home.material.opacity = self.wantHomeButton ? 1.0 : 0.0;
    };

    /* Public Methods */
    /** Update the View Cube camera to a new camera view
     * @public
     * @this ViewCube
     * @param {int[]} eye - client provided camera position (in their world coordinates)
     * @param {int[]} centre - client provided pivot point or centre (where the camera is looking at in their world coordinates)
     * @param {int[]} upVector - client provided up vector
     */

    /** Refresh height and width renderer sizes
     * @public
     * @this ViewCube
     */
    this.refreshCube = function () {
        onWindowResize();
    };

    /** Set the size of the View Cube
     * @public
     * @this ViewCube
     * @param {int} width - in pixels
     * @param {int} height - in pixels
     */
    this.setSize = function (width, height) {
        self.width = width;
        self.height = height;

        if(cubeContainer.children.length > 1){
            for(var i = 1; i < cubeContainer.children.length; i++)
                cubeContainer.children[i].style.bottom = (self.height/5).toString() + "px";
        }

        onWindowResize();
    };

    /** Option to turn on and off transparency on mouse out for the view cube
     * @public
     * @this ViewCube
     * @param {boolean} transparent - true to use transparency, false to turn it off
     */
    this.useTransparency = function (transparent){
        _transparent = transparent;
        if(transparent) {
            cubeContainer.onmouseover = mouseOverCube;
            cubeContainer.onmousemove = mouseMoveOverCube;
            cubeContainer.onmouseout = mouseOutCube;
            mouseOutCube();
        }
        else {
            cubeContainer.onmouseover = null;
            cubeContainer.onmouseout = null;
            cubeContainer.onmousemove = null;
            cubeContainer.style.opacity = "1.0";
        }
    };


    this.dtor = function() {
        this.renderer = null;
    };


    /* Build the cube */
    Init();
};
;AutodeskNamespace('Autodesk.Viewing');

Autodesk.Viewing.KeyCode = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CONTROL: 17,
        ALT: 18,
        ESCAPE: 27,
        SPACE: 32,
        PAGEUP: 33,
        PAGEDOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        INSERT: 45,
        DELETE: 46,
        ZERO: 48,
        SEMICOLONMOZ: 59,
        EQUALSMOZ: 61,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        LCOMMAND: 91,
        RCOMMAND: 93,
        DASHMOZ: 109,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        DASHMOZNEW: 173,
        SEMICOLON: 186,
        EQUALS: 187,
        COMMA: 188,
        DASH: 189,
        PERIOD: 190,
        SLASH: 191,
        LBRACKET: 219,
        RBRACKET: 221,
        SINGLEQUOTE: 222,
        COMMANDMOZ: 224
};


/**
 * This is the core interface to add and remove canvas interactions to the viewer. This class is created internally by the Viewer api and is available via the "toolController" property of the Viewer3D api object. Client implementations should not normally instantiate this class directly.
 *  @class
 *  @param {Object} viewerImpl - The viewer implementation object.
 *  @param {Object} viewerApi - The viewer api object.
 *  @param {Object} autocam - The Autocam interface object
 *  @param {Object} utilities - The ViewingUtilities object
 *  @param {Object} defaultHandler - The default event handling tool.
 *  @constructor
 *  @see Autodesk.Viewing.Viewer3D
 */
Autodesk.Viewing.ToolController = function( viewerImpl, viewerApi, autocam, utilities, defaultHandler )
{
    this.domElement = viewerApi.canvasWrap;
    this.selector = viewerImpl.selector;
    this.autocam = autocam;
    this.lastClickX = -1;
    this.lastClickY = -1;
    this.scrollInputEnabled = true;

    var isMac = (navigator.userAgent.search("Mac OS") != -1);
    var isFirefox = (navigator.userAgent.search("Firefox") != -1);
    var isChrome = (navigator.userAgent.search("Chrome") !== -1);
    var isSafari = (navigator.userAgent.search("Safari") !== -1 && !isChrome); // Chrome has both Safari and Chrome in the string

    var kTwo_PI  = 2.0 * Math.PI; // 360 degrees.

    var kMouseLeft = 0;
    var kMouseMiddle = 1;
    var kMouseRight = 2;

    var kClickThreshold = 2;        // Pixels
    var kTapThreshold = 8;          // Pixel threshold to accept a tap
    var kDoubleTapThreshold = 32;   // Pixel threshold to accept a double tap
    var kTapLength = 300.0;         // Maximum hold time to accept a tap (milliseconds)
    var kDoubleTapDelay = 300.0;    // Maximum time between taps for double-tap (milliseconds)
    var kDoubleClickDelayThreshold = 500; // ms
    var kTouchSwapThreshold = 2.9;

    var _tools = {};
    var _toolStack = [];
    var _lock = false;
    var _downX = -1;
    var _downY = -1;

    var _tapBeginX = -1;
    var _tapBeginY = -1;
    var _tapBeginTime = -1;
    var _taps = [];
    var _doubleTapTimer = null;
    var _firefoxLMBfix = false;
    var _currentCursor = null;
    var _lastTouchedElement = undefined;
    var _mouseEnabled = false;

    // Save click parameters when clicking with right mouse button
    // and "Left handed mouse setup" is enabled so that we can
    // simulate a double-click with the right mouse button.
    //
    var _checkMouseDoubleClick = {};

    var _this = this;

    var _keys = Autodesk.Viewing.KeyCode;

    this.__registerToolByName = function(tool, toolName)
    {
        _tools[toolName] = tool;
    };

    /**
     * This method registers an event handling tool with the controller. This makes the tool available for activation and deactivation. Tools are registered under one or more names which must be provided via their "getNames" method. The tools "getNames" method must return an array of one or more names. Typically a tool will only have one name but if it wishes to operate in different modes it can use different names to activate the modes. Registered tools have the properties named "utilities" and "controller" added to them which refer to the ViewingUtilities object and this controller respectively. Tools may not use the name "default" which is reserved.
     *  @param {Object} tool - the tool to be registered.
     */
    this.registerTool = function(tool)
    {
        var names = tool.getNames();

        if( !names || names.length == 0 )
        {
            console.log("Cannot register tool with no name.");
            return false;
        }
        var registered = false;
        for( var i = 0; i < names.length; ++i )
        {
            if( names[i] !== "default" )
            {
                this.__registerToolByName(tool, names[i]);
                registered = true;
            }
        }

        tool.utilities = utilities;
        tool.controller = this;
        if (tool.register) tool.register();

        return registered;
    };

    /**
     * This method deregisters an event handling tool with the controller afterwhich it will no longer be available for activation and deactivation. All names that the tool is registered under will be deregistered. If any tool is active at the time of deregistration will first be deactivated and it's "deactivate" method will be called.
     *  @param {Object} tool - the tool to be deregistered.
     */
    this.deregisterTool = function(tool)
    {
        this.deactivateTool(tool.getName());

        var names = tool.getNames();

        if( !names || names.length == 0 )
        {
            return false;
        }
        for( var i = names.length; --i >= 0; )
            this.__deregisterToolName(names[i]);

        if (tool.deregister) tool.deregister();
        tool.utilities = null;
        tool.controller = null;
        return true;
    };

    this.__deregisterToolName = function(name)
    {
        function cleanStack(name)
        {
            for( var i = _toolStack.length;  --i >= 0;  )
                if( _toolStack[i].activeName === name )
                {
                    _tools[name].deactivate(name);
                    _toolStack.splice(i, 1);
                }
        }
        if( name in _tools )
        {
            cleanStack(name);
            delete _tools[name];
        }
    };

    /**
     * This method returns the tool registered under the given name.
     *  @param {string} name - the tool name to look up
     *  @returns {Object} - The tool registered under the given name or undefined if not found.
     */
    this.getTool = function(name)
    {
        return _tools[name];
    };

    /**
     * This method returns the name of the topmost tool on the tool stack. If no tools are active the name of the default tool is returned (which is "default").
     *  @returns {string} name - the tool name to look up
     */
    this.getActiveToolName = function()
    {
        var l = _toolStack.length;
        return (l > 0) ? _toolStack[l-1].activeName : "default";
    };

    /**
     * This method returns the name of the topmost tool on the tool stack. If no tools are active the name of the default tool is returned (which is "default").
     *  @returns {string} name - the tool name to look up
     */
    this.getActiveTool = function()
    {
        return (_toolStack.length) ? _toolStack[l-1] : _tools["default"];
    };

    /**
     * Activates the tool registered under the given name. Activation implies pushing the tool on a stack of "active" tools, each of which (starting from the top of the stack) is given the opportunity to handle incoming events. Tools may "consume" events by returning true from their event handling methods, or they may allow events to be passed down to the next tool on the stack by returning false from the handling methods. Upon activation the tools "activate" method is called with the name under which it has been activated. Activation is not allowed while the controller is in a "locked" state (see the methods "setIsLocked" and "getIsLocked"). Tools must be registered prior to activation (see the methods "registerTool" and "deregisterTool").
     *  @param {string} toolName - the name of the tool to be activated.
     *  @returns {boolean} - true if activation was successful
     */
    this.activateTool = function(toolName)
    {
        if( _lock )
            return false;

        var tool = _tools[toolName];
        if( tool )
        {
            var interceptor = null;
            if (_toolStack.length && _toolStack[_toolStack.length - 1].activeName === "intercept") {
                interceptor = _toolStack.pop();
            }
            tool.activeName = toolName;
            _toolStack.push(tool);
            tool.activate(toolName, viewerApi);
            if (interceptor) {
                _toolStack.push(interceptor);
            }

            viewerApi.fireEvent(
                {
                    type: Autodesk.Viewing.TOOL_CHANGE_EVENT,
                    toolName: toolName,
                    tool: tool,
                    active: true
                });

            viewerImpl.log({category: 'tool_changed', name: toolName});

            //stderr("push: [" + _toolStack.length + "] = " + toolName);
            return true;
        }
        stderr("activateTool not found: " + toolName);
        return false;
    };

    /**
     * The first tool found on the active stack with the given name is removed and its "deactivate" method is called. Once deactivated the tool will no longer receive events via its handler methods. Deactivation is not allowed while the controller is in a "locked" state (see the methods "setIsLocked" and "getIsLocked").
     *  @param {string} toolName - the name of the tool to be deactivated.
     *  @returns {boolean} - true if deactivation was successful
     */
    this.deactivateTool = function(toolName)
    {
        if( _lock )
            return false;

        for( var i = _toolStack.length;  --i >= 0;  )
        {
            if( _toolStack[i].activeName === toolName )
            {
                _toolStack.splice(i, 1);
                _tools[toolName].deactivate(toolName);

                viewerApi.fireEvent(
                    {
                        type: Autodesk.Viewing.TOOL_CHANGE_EVENT,
                        toolName: toolName,
                        tool: _toolStack[i],
                        active: false
                    });

                // stderr(" pop: [" + _toolStack.length + "] = " + this.getActiveToolName());
                return true;
            }
        }
        stderr("deactivateTool not found: " + toolName);
        return false;
    };

    /**
     * Obtain a list of all the currently registered tool names.
     *  @returns {Array} - list of all registered tool names.
     */
    this.getToolNames = function()
    {
        return Object.keys(_tools);
    };

    /**
     * Set the tool which will be requested to handle events if no other active tool handles them.
     *  @param {Object} tool - The tool to be registered as the default.
     */
    this.setDefaultTool = function(tool)
    {
        var current = this.getDefaultTool();
        if( tool && tool !== current )
        {
            this.__registerToolByName(tool, "default");
            if( current )
                current.deactivate("default");
            tool.activate("default");
            return true;
        }
        return false;
    };

    /**
     * Get the tool which handle events if no other active tool handles them.
     *  @returns {Object} - The tool to be registered as the default.
     */
    this.getDefaultTool = function()
    {
        return _tools["default"];
    };

    this.setDefaultTool(defaultHandler);

    /**
     * Set the controller into a locked or unlocked state. While locked, tool activation and deactivation is not allowed. Locking the controller is sometimes necessary to force an interaction to remain active until it is fully completed.
     *  @param {boolean} state - The state of the controller lock.
     *  @returns {boolean} - The previous state of the lock (this may be used to restore the lock to it's previous state).
     */
    this.setIsLocked = function(state)
    {
        // if( _lock != !!state )
        //     stderr("lock: " + !!state);

        var prev = _lock;
        _lock = !!state;
        return prev;
    };

    /**
     * Get the current state of the controller lock.
     *  @returns {boolean} - The state of the lock.
     */
    this.getIsLocked = function()
    {
        return _lock;
    };

    this.__checkCursor = function()
    {
        var cursor = null;
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _toolStack[n];
            if( tool.getCursor )
            {
                cursor = tool.getCursor();
                if( cursor )
                    break;
            }
        }
        if( !cursor )
            cursor = "auto";

        if( _currentCursor != cursor )
        {
            viewerApi.canvas.style.cursor = cursor;
            _currentCursor = cursor;
        }
    };

    this.update = function(highResTimestamp)
    {
        this.__checkCursor();

        var refresh = false;

        if( utilities && utilities.update() )
            refresh = true;

        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _toolStack[n];
            if( tool.update && tool.update(highResTimestamp) )
                refresh = true;
        }
        if( viewerApi.navigation.getCamera().dirty )
        {
            viewerApi.navigation.updateCamera();
            refresh = true;
            this.cameraUpdated = true;
        } else {
            this.cameraUpdated = false;
        }

        //Delay reporting stationary
        if( refresh )
        {
            viewerApi.navigation.updateCamera();
            this.moveDelay = Date.now() + 150;   // Milliseconds
        }
        else if( this.moveDelay !== 0 )
        {
            var delta = this.moveDelay - Date.now();
            if( delta > 0 )
                refresh = true;
            else
                this.moveDelay = 0;
        }
        return refresh;
    };


    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this.__clientToCanvasCoords = function (event, normalized, screen)
    {
        var rect = viewerImpl.canvas.getBoundingClientRect();
        var width  = rect.width;
        var height = rect.height;

        // Canvas coordinates: relative to the canvas element.
        // 0 = top left, +ve right and down.
        //
        var canvasX = event.clientX - rect.left;
        var canvasY = event.clientY - rect.top;
        event.canvasX = canvasX;
        event.canvasY = canvasY;

        // Normalized coordinates: [-1, +1].
        // 0 = center, +ve = right and up.
        //
        event.normalizedX = (canvasX / width) * 2.0 - 1.0;
        event.normalizedY = ((height - canvasY) / height) * 2.0 - 1.0;

        // Vector: [0, 1].
        // 0 = top left, +ve right and down.
        //
        if (normalized)
            normalized.set(canvasX / width, canvasY / height, 0.0);

        if (screen)
            screen.set(canvasX, canvasY);
    };

    this.__invokeStack = function( method, arg1, arg2 )
    {
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _toolStack[n];

            if( tool[method] && tool[method](arg1, arg2) )
            {
                //console.log(method + " consumed by " + tool.getName() + " = " + arg1.type);
                return true;
            }
        }
        var last = this.getDefaultTool();
        if( last[method] && last[method](arg1, arg2) )
        {
            //console.log(method + " consumed by " + last.getName() + " = " + arg1.type);
            return true;
        }
        return false;
    };

    this.distributeEvent = function(methodName, arg1, arg2)
    {
        return this.__invokeStack(methodName, arg1, arg2);
    };

    this.handleResize = function()
    {
        viewerApi.navigation.setScreenViewport( viewerApi.container.getBoundingClientRect() );

        // Call handleResize on all tools in case they need it:
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _toolStack[n];

            if( tool.handleResize )
                tool.handleResize();
        }
    };

    this.handleSingleClick = function( event )
    {
        var button = this.applyButtonMappings( event );
        this.lastClickX = event.clientX;
        this.lastClickY = event.clientY;

        if( this.__invokeStack("handleSingleClick", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleDoubleClick = function( event )
    {
        var button = this.applyButtonMappings( event );

        if( this.__invokeStack("handleDoubleClick", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleSingleTap = function( event )
    {
        this.lastClickX = event.canvasX;
        this.lastClickY = event.canvasY;

        if( this.__invokeStack("handleSingleTap", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleDoubleTap = function( event )
    {
        this.lastClickX = event.canvasX;
        this.lastClickY = event.canvasY;

        if( this.__invokeStack("handleDoubleTap", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleWheelInput = function(delta, event)
    {
        if( this.__invokeStack("handleWheelInput", delta) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.applyButtonMappings = function( event )
    {
        var button = event.button;

        // Check for Firefox spoof: Control+LMB converted to RMB.
        // The "buttons" property in Firefox will include 1 for LMB and 2 for RMB.
        if( "buttons" in event )
        {
            // This method sometimes gets called more than once with
            // the same event:
            if( event.firefoxSpoof )
            {
                button = kMouseLeft;
            }
            // For button down the 1 bit will be on indicating LMB.
            // For button up it's off so check the flag to see if we
            // switched the down event.
            else if( _firefoxLMBfix && !(event.buttons & 1) ) // Button up?
            {
                event.firefoxSpoof = true;
                _firefoxLMBfix = false;
                button = kMouseLeft;
            }
            else if( (button === kMouseRight) && (event.buttons & 1) )
            {
                button = kMouseLeft;    // Convert back to reality.
                event.firefoxSpoof = _firefoxLMBfix = true;
            }
        }
        if( viewerApi.navigation.getUseLeftHandedInput() )
        {
            button = (button === kMouseLeft)  ? kMouseRight :
                     (button === kMouseRight) ? kMouseLeft  : button
        }
        return button;
    };

    this.applyKeyMappings = function( event, state )
    {
        switch( event.keyCode )
        {
            case _keys.LCOMMAND:
            case _keys.RCOMMAND:
            case _keys.COMMANDMOZ:
                // Most likely is a Mac but check anyway.
                // We need to ignore Command + Shift combo:
                return ( isMac && event.metaKey && event.shiftKey ) ? null : _keys.CONTROL;

            case _keys.SHIFT:
                // We need to ignore Command + Shift combo:
                return ( state && isMac && event.metaKey ) ? null : _keys.SHIFT;

            case _keys.EQUALSMOZ:   return _keys.EQUALS;

            case _keys.DASHMOZNEW:
            case _keys.DASHMOZ:     return _keys.DASH;
        }
        return event.keyCode;
    };

    this.handleKeyDown = function( event )
    {
        var keyCode = this.applyKeyMappings( event, true );

        if( keyCode && this.__invokeStack("handleKeyDown", event, keyCode) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleKeyUp = function( event )
    {
        var keyCode = this.applyKeyMappings( event, true );

        if( keyCode && this.__invokeStack("handleKeyUp", event, keyCode) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleButtonDown = function( event, button )
    {
        if( this.__invokeStack("handleButtonDown", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleButtonUp = function( event, button )
    {
        if( this.__invokeStack("handleButtonUp", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleMouseMove = function( event )
    {
        if( this.__invokeStack("handleMouseMove", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    function isValidTap(tap)
    {
        var deltaX = Math.abs(tap.endX - tap.startX);
        var deltaY = Math.abs(tap.endY - tap.startY);
        var deltaT = tap.endTime - tap.startTime;

        var passThreshold = deltaX <= kTapThreshold && deltaY <= kTapThreshold;
        var passLength = deltaT <= kTapLength;
        var pass = passThreshold && passLength;

        // if ( !pass ) {
        //     stderr("INVALID TAP: deltaX="+deltaX+" deltaY="+deltaY+" deltaT="+deltaT);
        // }

        return pass;
    }

    function isSingleTap(tap)
    {
        var delay = Date.now() - tap.endTime;
        return delay >= kDoubleTapDelay;
    }

    function isDoubleTap(tap1, tap2)
    {
        var delay = tap2.startTime - tap1.endTime;
        var deltaX = Math.abs(tap2.endX - tap1.startX);
        var deltaY = Math.abs(tap2.endY - tap1.startY);

        var passThreshold = deltaX <= kDoubleTapThreshold && deltaY <= kDoubleTapThreshold;
        var passDelay = delay <= kDoubleTapDelay;
        var pass = passThreshold && passDelay;

        // if ( !pass ) {
        //     stderr("REJECT DOUBLE TAP: deltaX="+deltaX+" deltaY="+deltaY+" delay="+delay);
        // }

        return pass;
    }

    this.handleBlur = function( event )
    {
        if( this.__invokeStack("handleBlur", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    // ====================================================
    // Event handlers: (only use "_this" in these methods):

    this.keydown = function( event )
    {
        if (!_this.domElement.contains(_lastTouchedElement) ||
            document.activeElement instanceof HTMLInputElement ||
            document.activeElement instanceof HTMLTextAreaElement) return;

        // Support for HTML5 editable divs
        if (document.activeElement) {
            var divIsEditable = document.activeElement.getAttribute('contenteditable');
            if (divIsEditable ===  'true' || divIsEditable === '') {
                // TODO: Proper handle of value 'inherit'
                return;
            }
        }

        // stderr("KEYDOWN: " + event.keyCode);

        // Ignore command key shortcuts on the mac.
        // We don't seem to get key up events for these keys.
        if( isMac && event.metaKey && (event.keyCode != _keys.LCOMMAND) && (event.keyCode != _keys.RCOMMAND) )
            return;

        _this.handleKeyDown(event);
    };

    this.keyup = function( event )
    {
        // stderr("KEYUP: " + event.keyCode);

        if( isMac && event.metaKey && (event.keyCode != _keys.LCOMMAND) && (event.keyCode != _keys.RCOMMAND) )
            return;

        _this.handleKeyUp(event);
    };

    function shouldCheckDoubleClick(button, event) {
        return (viewerApi.navigation.getUseLeftHandedInput() && button === 0) || (isFirefox && button === 1) ||
            (isMac && !isSafari && button === 0 && event.ctrlKey);
    }

    this.mousedown = function( event )
    {
        // Don't do blur in full screen (IE issue)
        if (!(_isIE11 && inFullscreen())) {
            document.activeElement && document.activeElement.blur();
        }

        _this.__clientToCanvasCoords(event);

        var buttonDown = _this.applyButtonMappings( event );
        _this.handleButtonDown( event, buttonDown );

        _downX = event.canvasX;
        _downY = event.canvasY;

        if( shouldCheckDoubleClick(buttonDown, event) )
        {
            var cmdc = _checkMouseDoubleClick;

            var delayOK = ((cmdc.time !== undefined) &&
                ((event.timeStamp - cmdc.time) < kDoubleClickDelayThreshold));

            var positionOK = ((cmdc.x !== undefined && cmdc.y !== undefined) &&
                (Math.abs(cmdc.x - event.canvasX) <= kClickThreshold) &&
                (Math.abs(cmdc.y - event.canvasY) <= kClickThreshold));

            if (!delayOK || !positionOK || (cmdc.clickCount && 2 <= cmdc.clickCount)) {
                cmdc.clickCount = 0;
            }

            if (!cmdc.clickCount) {
                cmdc.clickCount = 1;
                cmdc.x = event.canvasX;
                cmdc.y = event.canvasY;
                cmdc.time = event.timeStamp;

            } else if (cmdc.clickCount === 1) {
                cmdc.clickCount = 2;
            }
        }

        function handleUp(event)
        {
            var buttonUp = _this.applyButtonMappings( event );
            if( buttonUp === buttonDown )
            {
                document.removeEventListener( 'mouseup', handleUp );
                _this.mouseup(event);
            }
        }

        document.addEventListener( 'mouseup', handleUp, false );

        _this.registerWindowMouseMove();
    };

    this.mousemove = function( event )
    {
        _this.__clientToCanvasCoords(event);

        var deltaX = _downX - event.canvasX;
        var deltaY = _downY - event.canvasY;
        if( Math.abs(deltaX) > kClickThreshold || Math.abs(deltaY) > kClickThreshold )
        {
            _downX = -1;
            _downY = -1;
        }
        _this.handleMouseMove(event);
    };

    this.mouseup = function( event )
    {
        _this.__clientToCanvasCoords(event);

        var buttonUp = _this.applyButtonMappings( event );
        _this.handleButtonUp( event, buttonUp );

        var deltaX = _downX - event.canvasX;
        var deltaY = _downY - event.canvasY;

        _downX = -1;
        _downY = -1;

        if( Math.abs(deltaX) <= kClickThreshold && Math.abs(deltaY) <= kClickThreshold )
            _this.handleSingleClick( event );

        if( shouldCheckDoubleClick(buttonUp, event) )
        {
            var cmdc = _checkMouseDoubleClick;
            if (cmdc.clickCount === 2) {
                _this.handleDoubleClick(event);

                cmdc.clickCount = 0;
                cmdc.x = undefined;
                cmdc.y = undefined;
                cmdc.time = undefined;
            }
        }

        _this.unregisterWindowMouseMove();
    };

    this.doubleclick = function( event )
    {
         _this.__clientToCanvasCoords(event);

        _downX = event.canvasX;
        _downY = event.canvasY;

        _this.handleDoubleClick( event );
    };

    this.mousewheel = function( event )
    {
        if (!_this.scrollInputEnabled) {
            return;
        }

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9
            delta = event.wheelDelta / 40;
        }
        else if ( event.detail ) { // Firefox
            delta = - event.detail;
        }
        _this.handleWheelInput( delta, event );
    };

    this.blur = function(event)
    {
        _this.handleBlur(event);
    };

    // ??? this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

    this.mouseover = function(e)
    {
        _lastTouchedElement = e.target;
        // ??? if (_lastTouchedElement != viewerImpl.canvas) _this.autoMove(-1, false)
    };

    // to maintain drag continuity outside the canvas element
    // move mousemove/over listeners from canvas to window
    this.registerWindowMouseMove = function() {
        window.addEventListener( 'mousemove', _this.mousemove );
        window.addEventListener( 'mouseover', _this.mouseover );
        _this.domElement.removeEventListener( 'mousemove', _this.mousemove );
        _this.domElement.removeEventListener( 'mouseover', _this.mouseover );
    };

    this.unregisterWindowMouseMove = function() {
        window.removeEventListener( 'mousemove', _this.mousemove );
        window.removeEventListener( 'mouseover', _this.mouseover );
        _this.domElement.addEventListener( 'mousemove', _this.mousemove );
        _this.domElement.addEventListener( 'mouseover', _this.mouseover );
    };

    this.enableMouseButtons = function(state)
    {
        if( state && !_mouseEnabled )
        {
            this.domElement.addEventListener( 'mousedown', this.mousedown );
            this.domElement.addEventListener( 'dblclick',  this.doubleclick );
            this.domElement.addEventListener( 'mousemove', this.mousemove );
            this.domElement.addEventListener( 'mouseover', this.mouseover );
        }
        else if( !state && _mouseEnabled )
        {
            this.domElement.removeEventListener( 'mousedown', this.mousedown );
            this.domElement.removeEventListener( 'dblclick',  this.doubleclick );
            this.domElement.removeEventListener( 'mousemove', this.mousemove );
            this.domElement.removeEventListener( 'mouseover', this.mouseover );
        }
        var returnValue = _mouseEnabled;
        _mouseEnabled = state;

        return returnValue;
    };

    this.enableMouseButtons(true);

    // If we want to continue listenting to mouse movements outside of the window
    // we need to tie our event listener to the window

    this.domElement.addEventListener( 'mousewheel',     this.mousewheel, false );
    this.domElement.addEventListener( 'DOMMouseScroll', this.mousewheel, false ); // firefox

    //** this.domElement.addEventListener( 'touchstart', function( event ) { _this.touchstart( event )}, false );
    //** this.domElement.addEventListener( 'touchmove', function( event ) { _this.touchmove( event )}, false );

    window.addEventListener( 'keydown', this.keydown, false );
    window.addEventListener( 'keyup',   this.keyup,   false );
    window.addEventListener( 'blur', this.blur, false );

    this.uninitialize = function () {
        if( _mouseEnabled ) {
            // remove them all just to be sure, doesn't hurt
            this.domElement.removeEventListener('mousemove', this.mousemove);
            this.domElement.removeEventListener('mouseover', this.mouseover);
            window.removeEventListener( 'mousemove', _this.mousemove );
            window.removeEventListener( 'mouseover', _this.mouseover );
        }
        window.removeEventListener('keydown', this.keydown);
        window.removeEventListener('keyup', this.keyup);
        window.removeEventListener('blur', this.blur);

        this.domElement = null;
        this.selector = null;
        this.autocam = null;
        _tools = null;
        _toolStack = null;
        _this = null;
        utilities = null;
        viewerApi = null;
        viewerImpl = null;
        _lastTouchedElement = null;
    };

    // Compatibility methods. TODO: eliminate these
    this.set2DMode = function(state) {};
    this.setAutocam = function(autocam) {};
    this.syncCamera = function() {};

    // TODO: implement this in navapi - then set autocam home from navapi values
    this.recordHomeView = function()
    {
        var camera = viewerApi.navigation.getCamera();
        autocam.sync( camera );
        autocam.setHomeViewFrom( camera );
    };

    /**
     * Whether mouse scroll wheel (and/or two-finger vertical swipe) will trigger
     * a camera zoom operation.
     *
     * @param {Boolean} isEnabled
     */
    this.setMouseWheelInputEnabled = function(isEnabled) {
        this.scrollInputEnabled = isEnabled;
    };
};
;AutodeskNamespace('Autodesk.Viewing');

/**
 * This class provides a variety of utilities convenient to navigation and tool development. This class is instantiated internally and made available to all registered interaction tools via their "utilities" property.
 *  @see Autodesk.Viewing.ToolController
 *  @class
 *  @param {Object} viewerImpl - The viewer implementation object.
 *  @param {Object} autocam - The Autocam interface object
 *  @param {Object} navigation - The Navigation interface object
 *  @constructor
 */
Autodesk.Viewing.ViewingUtilities = function( viewerImplIn, autocam, navapi )
{
    this.autocam = autocam;
    this.viewerImpl = viewerImplIn;

    var kIndicatorPixelSize = 5;    // Pixels
	var _camera = navapi.getCamera();
    var _savePivot = {};
    var _savePivotSet = {};
    
    function PivotIndicator( viewerImpl )
    {
        var kFadeTimeMilliseconds = 500;
        var kIndicatorColor   = 0x007F00;
        var kIndicatorOpacity = 0.6;        // Not working for some reason!!!

        var myFadeTime = 0;
        var myGeometry = new THREE.SphereGeometry( 1.0 );
        var myMaterial = new THREE.MeshPhongMaterial({color:kIndicatorColor, ambient:kIndicatorColor, opacity:kIndicatorOpacity, transparent:true});
        var myMesh = new THREE.Mesh( myGeometry, myMaterial );
        var myViewerImpl = viewerImpl;

        myViewerImpl.createOverlayScene("pivot");
        myMesh.visible = false;

        this.shown = function()
        {
			// return myMesh.parent !== undefined;
			return myMesh.visible;
        };

        this.show = function( position, scale, fade )
        {
            myMesh.scale.x = scale;
            myMesh.scale.y = scale;
            myMesh.scale.z = scale;

            myMesh.position.set(position.x, position.y, position.z);
            myMaterial.opacity  = kIndicatorOpacity;

            myMesh.visible = true;
            myViewerImpl.addOverlay("pivot", myMesh);
            myViewerImpl.invalidate(false, false, true);

            if( fade )
            {
                myFadeTime = Date.now() + kFadeTimeMilliseconds;
            }
            else
                myFadeTime = 0;
        };

        this.hide = function()
        {
            if( myMesh.visible )
            {
                myMesh.visible = false;
                myViewerImpl.removeOverlay("pivot", myMesh);
                myViewerImpl.invalidate(false, false, true);
                myFadeTime = 0;
            }
        };

        this.fade = function()
        {
            if( myFadeTime > 0 )
            {
                var fadeDelta = myFadeTime - Date.now();

                if( fadeDelta <= 0 )
                {
                    this.hide();
                    return true;
                }
                var opacity = (fadeDelta / kFadeTimeMilliseconds) * kIndicatorOpacity;
                myMaterial.opacity  = opacity;
                return true;
            }
            return false;
        };

        this.fading = function()
        {
            return (myFadeTime > 0);
        };
    }

    var _pivotIndicator  = new PivotIndicator(this.viewerImpl);

    function computeOrthogonalUp(pos, coi, worldUp)
    {
        var eye = coi.clone().sub(pos);
        if( eye.lengthSq() === 0.0 )    // Invalid view?
            return eye.copy(worldUp);

        var right = eye.clone().cross(worldUp);
        if( right.lengthSq() === 0 )
        {
            // If eye and up are colinear, perturb eye
            // to get a valid result:
            if( worldUp.z > worldUp.y )
                eye.y -= 0.0001;
            else
                eye.z -= 0.0001;

            right.crossVectors( eye, worldUp );
        }
        return right.cross(eye).normalize();
    }

    /**
     * This method triggers a camera view transition as specified by the parameters.
     *  @param {THREE.Vector3} pos - The new world space position of the camera.
     *  @param {THREE.Vector3} coi - The new center of interest (look at point).
     *  @param {Number} fov - The new field of view for the camera in degrees.
     *  @param {THREE.Vector3} up - The new camera up direction.
     *  @param {THREE.Vector3} worldUp - The new world up direction.
     *  @param {boolean} reorient - If true the given camera up parameter is ignored and a new up direction will be calculated to be aligned with the given world up direction.
     */
    this.transitionView = function( pos, coi, fov, up, worldUp, reorient )
    {
        worldUp = worldUp || navapi.getWorldUpVector();

        var upVec = reorient ? computeOrthogonalUp(pos, coi, worldUp) : up;
        if( !upVec )
            upVec = _camera.up;

        var targetView = {
            position: pos,
              center: coi,
               pivot: coi,
                 fov: fov,
                  up: upVec,
             worldUp: worldUp,
             isOrtho: (_camera.isPerspective === false)
        };
        autocam.goToView(targetView);
    };

    /**
     * This method triggers a camera view transition to the registered home view for the current scene.
     */
    this.goHome = function()
    {
        this.viewerImpl.log({ name: 'navigation/home', aggregate: 'count' });
        autocam.goHome();
    };

    /**
     * This method performs a hit test with the current model using a ray cast from the given screen coordinates.
     *  @param {Number} x - The normalized screen x coordinate in [0, 1].
     *  @param {Number} y - The normalized screen y coordinate in [0, 1].
     *  @returns {THREE.Vector3} the world space hit position or null if no object was hit.
     */
    this.getHitPoint = function(x, y)
    {
        y = 1.0 - y;    // Invert Y so 0 == bottom.

        // Map to [-1, 1]
        x = x * 2.0 - 1.0;
        y = y * 2.0 - 1.0;

        var vpVec = new THREE.Vector3(x, y, 1);

        var result = this.viewerImpl.hitTestViewport(vpVec, false);
        return result ? result.intersectPoint : null;
    };

    /**
     * This method activates the in scene pivot indicator. The pivot is positioned at the current camera's pivot point.
     *  @param {boolean} fadeIt - If true the indicator will be displayed and then fade away after a short period.
     *  @see Autodesk.Viewing.Navigation
     */
    this.activatePivot = function(fadeIt)
    {
        var distance = _camera.isPerspective ? navapi.getPivotPlaneDistance()
                                             : navapi.getEyeVector().length();
        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var indicatorSize = kIndicatorPixelSize * worldHeight / (viewport.height * devicePixelRatio);

        _pivotIndicator.show( navapi.getPivotPoint(), indicatorSize, fadeIt );
    };

    /**
     * This method changes the display state of the in scene pivot indicator. If the current scene is 2D this method has no effect.
     *  @param {boolean} state - The requested display state for the indicator.
     *  @param {boolean} fadeIt - If true and "state" is also true, the indicator will be displayed and then fade away after a short period.
     *  @see Autodesk.Viewing.Navigation
     */
    this.pivotActive = function( state, fadeIt )
    {
        state = state && !navapi.getIs2D();  // Currently disabled in 2D mode.

        fadeIt = fadeIt || false;

        if( !state && _pivotIndicator.shown() )
        {
            _pivotIndicator.hide();
            return;
        }
        if( state )
            this.activatePivot(fadeIt);
    };

    /**
     * Invoke this method to refresh the pivot indicator and continue its fading action if required.
     */
    this.pivotUpdate = function()
    {
        if( _pivotIndicator.shown() && _pivotIndicator.fade() )
            this.viewerImpl.invalidate(false, false, true);
    };

    /**
     * Set the current pivot point and pivot set flag. If the pivot indicator is active its position will be updated accordingly. If a temporary pivot was previously applied, its saved state will be cleared.
     *  @param {THREE.Vector3} newPivot - The world space position of the new pivot point.
     *  @param {boolean} preserveView - If false the camera's view direction will change to look at the new pivot point. If true the camera's view will not be changed.
     *  @param {boolean} isset - The new state of the pivot set flag.
     *  @see Autodesk.Viewing.Navigation
     */
    this.setPivotPoint = function( newPivot, preserveView, isset )
    {
        navapi.setPivotPoint(newPivot);

        if( !preserveView )
            navapi.setTarget(newPivot);

        if( isset )
            navapi.setPivotSetFlag(true);

        this.setTemporaryPivot(null);

        // Disallow showing the pivot when in 2D.
        if (navapi.getIs2D())
            return;

        if( _pivotIndicator.shown() ) // The pivot indicator location may need updating:
            this.activatePivot(_pivotIndicator.fading());
    };

    /**
     * Save a copy of the current pivot point and pivot set flag.
     *  @param {string} name - Optional unique name of the saved location.
     */
    this.savePivot = function(name)
    {
        if( !name )
            name = "default";

        _savePivot[name]    = navapi.getPivotPoint();
        _savePivotSet[name] = navapi.getPivotSetFlag();
    };

    /**
     * Restore the saved copy of the current pivot point and pivot set flag. Once restored the saved value is erased.
     *  @param {string} name - Optional unique name of the saved location.
     */
    this.restorePivot = function(name)
    {
        if( !name )
            name = "default";

        if( _savePivot[name] )
        {
            var set =_savePivotSet[name]; // Get value before calling setPivotPoint
            this.setPivotPoint( _savePivot[name], true, set );
            if( !set )
            {
                // Force the flag off, setPivotPoint only turns it on.
                navapi.setPivotSetFlag(false);
            }
            delete(_savePivot[name]);
            delete(_savePivotSet[name]);
        }
    };

    /**
     * Allows the caller to save the current pivot and replace it with a new location. If while the temporary pivot is active a new pivot is set via the setPivotPoint method, the saved pivot will be cleared to avoid restoring an out of date pivot location.
     *  @param {THREE.Vector3} newPivot - The new pivot to be assigned or null to clear any previously saved pivot.
     */
    this.setTemporaryPivot = function( newPivot )
    {
        if( newPivot )
        {
            var pivot    = navapi.getPivotPoint();
            var pivotSet = navapi.getPivotSetFlag();

            this.setPivotPoint(newPivot, true, pivotSet);

            _savePivot["TEMP"]    = pivot;
            _savePivotSet["TEMP"] = pivotSet;
        }
        else
        {
            delete(_savePivot["TEMP"]);
            delete(_savePivotSet["TEMP"]);
        }
    };

    /**
     * Restore a pivot value that was saved by a call to setTemporary Pivot.
     */
    this.removeTemporaryPivot = function()
    {
        this.restorePivot("TEMP");
    };

    /**
     * Return the bounding box of the current model or model selection.
     *  @param {boolean} ignoreSelection - If true the current selection is ignored and the model bounds is returned.
     *  @returns {THREE.Box3}
     */
    this.getBoundingBox = function( ignoreSelection )
    {
        return this.viewerImpl.getFitBounds(ignoreSelection);
    };

    /**
     * Request a camera transition to fit the current model or model selection into the view frustum.
     *  @param {boolean} immediate - If true the transition will be immediate, otherwise animated over a short time period.
     *  @returns {Object} - fit positioning information with properties "position" and "target".
     */
    this.fitToView = function(immediate)
    {
        this.viewerImpl.log({ name: 'navigation/fit', aggregate: 'count' });
        var fit = navapi.fitBounds(immediate, this.viewerImpl.getFitBounds(false));
        // Show the pivot on a fit:
        this.activatePivot(true);

        return fit;
    };

    this.update = function()
    {
        if( navapi.getRequestFitToView() && !navapi.getTransitionActive() )
        {
            navapi.setRequestFitToView(false);
            this.fitToView();
        }
        if( navapi.getRequestHomeView() && !navapi.getTransitionActive() )
        {
            navapi.setRequestHomeView(false);
            this.goHome();
        }
        var request = navapi.getRequestTransition();
        if( request && !navapi.getTransitionActive() )
        {
            navapi.setRequestTransition(false);
            this.transitionView( request.position, request.coi, request.fov, request.up, request.worldUp, request.reorient );
        }
        return false;
    };
};
;AutodeskNamespace('Autodesk.Viewing');
//
// This object handles the default click behaviour, some of which is controlled
// via the "setClickBehavior" configuration.
//
Autodesk.Viewing.DefaultHandler = function( viewerImpl, navapi, utilities )
{
    this.clickConfig = null;

    this.getNames = function()
    {
        return [ "default" ];
    };

    this.getName = function()
    {
        return this.getNames()[0];
    };

    this.setClickBehavior = function(config)
    {
        this.clickConfig = config;
    };

    this.getClickBehavior = function()
    {
        return this.clickConfig;
    };

    this.activate = function(name) {};
    this.deactivate = function(name) {};

    this.handleAction = function(actionArray, rayData)
    {
        for (var i=0; i < actionArray.length; ++i) {
            switch(actionArray[i]) {
            case "selectOnly":
                if (viewerImpl.selector) {
                    if (rayData) {
                        viewerImpl.selector.setSelection([rayData.dbId], rayData.model);
                    }
                }
                break;
            case "deselectAll":
                if (viewerImpl.selector) {
                   viewerImpl.selector.setSelection([]);
                }
                break;
            case "selectToggle":
                if (viewerImpl.selector) {
                    if (rayData) {
                        viewerImpl.selector.toggleSelection(rayData.dbId, rayData.model);
                    }
                }
                break;
            case "isolate":
                if (rayData) {
                    viewerImpl.isolate(rayData.dbId);
                }
                break;
            case "showAll":
                viewerImpl.showAll();
                break;
            case "setCOI":
                if (rayData && rayData.intersectPoint) {
                    utilities.setPivotPoint( rayData.intersectPoint, true, true );
                    utilities.pivotActive(true, true);
                }
                break;
            case "hide":
                if (rayData) {
                    viewerImpl.hide(rayData.dbId);
                }
                break;
			case "show":
                if (rayData) {
                    viewerImpl.show(rayData.dbId);
                }
                break;
			case "toggleVisibility":
                if (rayData) {
                    viewerImpl.toggleVisibility(rayData.dbId);
                }
                break;
            case "focus":
                // As a side effect of focus we also select
                if (viewerImpl.selector) {
                    if (rayData) {
                        viewerImpl.selector.setSelection([rayData.dbId], rayData.model);
                    } else {
                        viewerImpl.selector.setSelection([]);
                    }
                    utilities.fitToView();
                }
                break;
            }
        }
    };

    this.handleSingleClick = function( event, button )
    {
        var control = event.ctrlKey || event.metaKey;
        var shift   = event.shiftKey;
        var alt     = event.altKey;

        if (button === 0) {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            var key = "click";

            if (control) key += "Ctrl";
            if (shift)   key += "Shift";
            if (alt)     key += "Alt";

            var objectKey = result ? "onObject" : "offObject";

            if (this.clickConfig && this.clickConfig[key] && this.clickConfig[key][objectKey]) {
                this.handleAction(this.clickConfig[key][objectKey], result);
                return true;
            }
        }
        else if (button === 1 && shift && !alt && !control) {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            if( result && result.intersectPoint )
            {
                utilities.setPivotPoint( result.intersectPoint, true, true );
                utilities.pivotActive(true, true);
                return true;
            }
        }
        return false;
    };

    this.handleDoubleClick = function( event, button )
    {
        if( viewerImpl.selector && button === 0 )
        {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            if (result) {
                viewerImpl.selector.setSelection([result.dbId], result.model);
            }
            else {
                viewerImpl.selector.clearSelection();
            }
            utilities.fitToView();
            return true;
        }
        if( button === 1 )
        {
            navapi.fitBounds(false, utilities.getBoundingBox(true));
            navapi.setPivotSetFlag(false);
            return true;
        }
        return false;
    };

    this.handleSingleTap = function( event )
    {
        event.clientX = event.pointers[0].clientX;
        event.clientY = event.pointers[0].clientY;
        viewerImpl.api.triggerSingleTapCallback(event);

        if( event.hasOwnProperty("pointers") && event.pointers.length === 2 )
        {
            navapi.setRequestHomeView(true);
            return true;
        }
        if( viewerImpl.selector)
        {
            var vp = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(vp, false);

            if (result) {
                viewerImpl.selector.setSelection([result.dbId], result.model);
				viewerImpl.api.triggerSelectionChanged([result.dbId]);
            }
            else {
                viewerImpl.selector.clearSelection();
                viewerImpl.api.triggerSelectionChanged(null);
            }
            return true;
        }
        return false;
    };

    this.handleDoubleTap = function( event )
    {
        event.clientX = event.pointers[0].clientX;
        event.clientY = event.pointers[0].clientY;
        viewerImpl.api.triggerDoubleTapCallback(event);

        var result = this.handleSingleTap(event, 0);
        utilities.fitToView();
        return result;
    };

    this.handlePressHold = function( event )
    {
        if( event.type === "press" )
        {
            event.clientX = event.pointers[0].clientX;
            event.clientY = event.pointers[0].clientY;

            return viewerImpl.api.triggerContextMenu(event);
        }
        return false;
    }
}
;AutodeskNamespace('Autodesk.Viewing');


Autodesk.Viewing.GestureHandler = function(viewerApi)
{
    var _navapi = viewerApi.navigation;
    var _names = [ "gestures" ];
    var _this = this;
    var _mouseEnabled = true;
    var _twoPointerSwipeEnabled = true;
    var hammer = null;

    var isTouch = isTouchDevice();

    _navapi.setIsTouchDevice(isTouch);
    if( isTouch )
    {
        hammer = new Hammer.Manager(viewerApi.canvasWrap, {
            recognizers: [
                // RecognizerClass, [options], [recognizeWith, ...], [requireFailure, ...]
                [Hammer.Pan, { event: 'drag', pointers: 1 } ],
                [Hammer.Tap, { event: 'doubletap', taps: 2, interval: 300, threshold: 6, posThreshold: 30 } ],
                [Hammer.Tap, { event: 'doubletap2', pointers: 2, taps: 2, interval: 300, threshold: 6, posThreshold: 40 } ],
                [Hammer.Tap, { event: 'singletap2', pointers: 2, threshold: 3 } ],
                [Hammer.Tap, { event: 'singletap', threshold: 2 } ],
                [Hammer.Press, { event: 'press', time: 500 } ],
                [Hammer.Pan, { event: 'drag3', pointers: 3, threshold: 15 } ],

                // Note: These recognizers are active only when _twoPointerSwipeEnabled is true
                [Hammer.Pan, { event: 'pan', pointers: 2, threshold: 20 } ],
                [Hammer.Pinch, { enable: true, threshold: 0.05 }],
                [Hammer.Rotate, { enable: true, threshold: 7.0 }]
            ],
            inputClass: Hammer.TouchInput
        });
        viewerApi.canvasWrap.addEventListener( 'touchstart', this.onTouchStart, false );
    }

    this.onTouchStart = function(event) {
        event.preventDefault();
    };

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    /**
    function dirToString(obj) {
        var output = [];
        for(var key in obj) {
            if(obj.hasOwnProperty(key)) {
                var value = obj[key];
                if(Array.isArray(value)) {
                    value = "Array("+ value.length +"):"+ value;
                } else if(value instanceof HTMLElement) {
                    value = value +" ("+ value.outerHTML.substring(0, 50) +"...)";
                }
                output.push(key +": "+ value);
            }
        }
        return output.join("\n")
    };
    **/


    this.__clientToCanvasCoords = function (event)
    {
        var viewport = _navapi.getScreenViewport();
        var width  = viewport.width;
        var height = viewport.height;

        // Canvas coordinates: relative to the canvas element.
        // 0 = top left, +ve right and down.
        //
        var canvasX, canvasY;

        if( event.hasOwnProperty("center") )
        {
            canvasX = event.center.x - viewport.left;
            canvasY = event.center.y - viewport.top;
        }
        else
        {
            canvasX = event.pointers[0].clientX - viewport.left;
            canvasY = event.pointers[0].clientY - viewport.top;
        }
        event.canvasX = canvasX;
        event.canvasY = canvasY;

        // Normalized coordinates: [-1, +1].
        // 0 = center, +ve = right and up.
        //
        event.normalizedX = (canvasX / width) * 2.0 - 1.0;
        event.normalizedY = ((height - canvasY) / height) * 2.0 - 1.0;
    };


    this.distributeGesture = function(event)
    {
        function endsWith(str, suffix)
        {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        }
        // console.log("====\n" + dirToString(event));

        _this.__clientToCanvasCoords(event);

        if( _this.controller.distributeEvent("handleGesture", event) )
            event.preventDefault();

        if( endsWith(event.type, "end") )
            hammer.stop();  // Don't allow chained gestures.
    };

    this.onSingleTap = function(event)
    {
        // console.log("====\n" + dirToString(event));

        _this.__clientToCanvasCoords(event);

        if( _this.controller.distributeEvent("handleSingleTap", event) )
            event.preventDefault();
    };

    this.onDoubleTap = function(event)
    {
        // console.log("====\n" + dirToString(event));

        _this.__clientToCanvasCoords(event);

        if( _this.controller.distributeEvent("handleDoubleTap", event) )
            event.preventDefault();
    };

    this.onPressHold = function(event)
    {
        // console.log("====\n" + dirToString(event));

        _this.__clientToCanvasCoords(event);

        // Slight hack to stop the mouse down event that the browser
        // generates during a press hold:
        if( event.type === "press" )
            _mouseEnabled = _this.controller.enableMouseButtons(false);
        else
            _this.controller.enableMouseButtons(_mouseEnabled);

        if( _this.controller.distributeEvent("handlePressHold", event) )
            event.preventDefault();
    };

    this.activate = function(name)
    {
        if( hammer )
        {
            hammer.on("dragstart dragmove dragend", this.distributeGesture);
            hammer.on("singletap", this.onSingleTap);
            hammer.on("singletap2", this.onSingleTap);
            hammer.on("doubletap", this.onDoubleTap);
            hammer.on("doubletap2", this.onDoubleTap);
            hammer.on("press pressup", this.onPressHold);
            hammer.on("drag3start drag3move drag3end", this.distributeGesture);

            if (_twoPointerSwipeEnabled) {
                hammer.on("panstart panmove panend", this.distributeGesture);
                hammer.on("pinchstart pinchmove pinchend", this.distributeGesture);
                hammer.on("rotatestart rotatemove rotateend", this.distributeGesture);
            }

            // we only want to trigger a tap, when we don't have detected a doubletap
            hammer.get('doubletap2').recognizeWith('doubletap');
            hammer.get('singletap2').recognizeWith('singletap');
            hammer.get('singletap').requireFailure('doubletap');
        }
    };

    this.deactivate = function(name)
    {
        if( hammer )
        {
            hammer.off("dragstart dragmove dragend", this.distributeGesture);
            hammer.off("singletap", this.onSingleTap);
            hammer.off("singletap2", this.onSingleTap);
            hammer.off("doubletap", this.onDoubleTap);
            hammer.off("doubletap2", this.onDoubleTap);
            hammer.off("press pressup", this.onPressHold);
            hammer.off("drag3start drag3move drag3end", this.distributeGesture);

            if (_twoPointerSwipeEnabled) {
                hammer.off("panstart panmove panend", this.distributeGesture);
                hammer.off("pinchstart pinchmove pinchend", this.distributeGesture);
                hammer.off("rotatestart rotatemove rotateend", this.distributeGesture);
            }
        }
    };


    this.update = function()
    {
        return false;
    };


    this.handleBlur = function(event) {
        return false;
    };

    /**
     * Disables two finger swipe functionality (pan, rotate, zoom) so that a
     * mobile user can scroll the page where the viewer is being embedded.
     */
    this.disableTwoFingerSwipe = function() {
        _twoPointerSwipeEnabled = false;
        if (hammer) {
            hammer.remove(Hammer.Pan);
            hammer.remove(Hammer.Pinch);
            hammer.remove(Hammer.Rotate);
            hammer.off("panstart panmove panend", this.distributeGesture);
            hammer.off("pinchstart pinchmove pinchend", this.distributeGesture);
            hammer.off("rotatestart rotatemove rotateend", this.distributeGesture);
        }
    }
};
;AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.OrbitDollyPanTool = function( viewerImpl, viewerApi )
{
    var _this = this;
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;
    var kAutoDeltaZ  = 1.5;         // Dolly increment
    var kAutoDeltaXY = 0.01;
    var kAutoScreenXY = 20;
    var kDollyDragScale = 100.0;
    var kDollyPinchScale = 0.5;
    var kOrbitScale = 2.0;

    var isMac = (navigator.userAgent.search("Mac OS") != -1);

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["orbit", "freeorbit", "dolly", "pan"];

    var _activeMode = _names[0];
    var _activations = [ _activeMode ];   // Safeguard
    var _activatedMode = _activeMode;

    var _touchType = null;
    var _pinchScale = 1.0;
    var _prevPinchScale = 1.0;
    var _prevPinchLength = 0;
    var _pinchLength = 0;
    var _deltaRoll = 0.0;
    var _prevRoll = 0.0;

    var _activeModeLocked = false;
    var _autoCamStartXY = null;
    var _interactionActive = false;
    var _lastMouseX, _lastMouseY;
    var _wheelAccum = 0;
    var _wheelOldest = null;
    var _wheelNewest = null;

    var _keys = {
              SHIFT: 16,
            CONTROL: 17,
                ALT: 18,
              SPACE: 32,
             PAGEUP: 33,
           PAGEDOWN: 34,
               LEFT: 37,
                 UP: 38,
              RIGHT: 39,
               DOWN: 40,
               ZERO: 48,
             EQUALS: 187,
               DASH: 189
    };

    // Interaction Triggers:
    var kNone = -5;
    var kKeyboard = -4;
    var kWheel = -1;
    var kMouseLeft = 0;
    var kMouseMiddle = 1;
    var kMouseRight = 2;
    var kTouch = 3;

    var _activeTrigger = kNone;
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _touchStartXY  = new THREE.Vector2();
    var _startXY  = new THREE.Vector2();
    var _moveXY   = new THREE.Vector2();
    var _deltaXY  = new THREE.Vector2();
    var _motionDelta = new THREE.Vector3();

    var _rotateStart = new THREE.Vector3();
    var _rotateEnd = new THREE.Vector3();
    var _pivotToEye = new THREE.Vector3();
    var _targetToEye = new THREE.Vector3();
    var _projVector = new THREE.Vector3();
    var _objectUp = new THREE.Vector3();
    var _mouseOnBall = new THREE.Vector3();
    var _rotateNormal = new THREE.Vector3();
    var _quaternion = new THREE.Quaternion();
    var _noRoll = false;
    var _staticMoving = true;
    var _dynamicDampingFactor = 0.2;

    var _autoMove = [false, false, false, false, false, false];  // left, right, up, down, in, out
    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0, SPACE: 0 };

    var kDampingFactor = 0.6;
    var kLookSpeedDefault = 5.0;
    var kDollySpeedDefault = 0.025;
    var kMinDollySpeed = 0.01;
    var kDollyScale = 0.6;

    var _trackingDistance = 1.0;
    var myLookSpeed = kLookSpeedDefault;
    var myDollySpeed = kDollySpeedDefault;

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        // console.log("ACTIVATE: " + _activatedMode + " => " + name);
        _activations.push(name);
        _activatedMode = name;
    };

    this.deactivate = function(name)
    {
        var end = _activations.length - 1;
        if( end > 0 && _activations[end] === name )
        {
            _activations.pop();
            _activatedMode = _activations[end-1];
            // console.log("DEACTIVATE: " + name + " => " + _activatedMode );
        }
    };

    this.adjustDollyLookSpeed = function( direction )
    {
        if( direction === 0 )
        {
            myDollySpeed = kDollySpeedDefault;
            myLookSpeed  = kLookSpeedDefault;
        }
        else
        {
            myDollySpeed *= (direction > 0) ?  1.10 : 0.90;
            myLookSpeed  *= (direction > 0) ?  1.10 : 0.90;

            // May need more appropriate minimums (and maximums) here.
            if( myDollySpeed < 0.000001 )
                myDollySpeed = 0.000001;

            if( myLookSpeed < 0.000001 )
                myLookSpeed = 0.000001;
        }
    };

    this.getDollySpeed = function(dollyTarget)
    {
        // Calculate the distance that one unit of virtual dolly will move:
        var view     = _navapi.getEyeVector();
        var position = _navapi.getPosition();
        var projectedLength = dollyTarget.clone().sub(position).dot(view.normalize());
        var distance = projectedLength * myDollySpeed;
        return (Math.abs(distance) < kMinDollySpeed) ? ((distance < 0) ? -kMinDollySpeed : kMinDollySpeed) : distance;
    };

    this.getLookSpeed = function()
    {
        return myLookSpeed;
    };

    this.coiIsActive = function()
    {
        return _navapi.getPivotSetFlag() && _navapi.isPointVisible(_navapi.getPivotPoint());
    };

    this.adjustSpeed = function( direction )
    {
        this.adjustDollyLookSpeed( direction );

        if( this.utilities.autocam )
            this.utilities.autocam.orbitMultiplier = this.getLookSpeed();
    };

    // TO DO: Where/when do we push/pop tool state?
    function isTrack()
    {
        var mod = _modifierState;
        return ((_activeTrigger === kMouseRight)  && !mod.SHIFT && !(mod.ALT ^ mod.CONTROL))
            || ((_activeTrigger === kMouseRight)  && mod.SHIFT && mod.CONTROL)
            || ((_activeTrigger === kMouseMiddle) && !mod.SHIFT && !mod.CONTROL)
            || ((_activeTrigger === kMouseMiddle) && mod.ALT)
            || ((_activeTrigger === kMouseMiddle) && mod.CONTROL && !mod.ALT)
            || ((_activeTrigger === kMouseLeft) && mod.SHIFT && !mod.CONTROL && !mod.ALT)
            || ((_activatedMode === "pan") && (_activeTrigger !== kMouseMiddle) && !mod.ALT && !(_touchType === "pinch"))
            || (mod.SPACE);
    }

    function isDolly()
    {
        var mod = _modifierState;
        return ((_activeTrigger === kMouseRight)  && mod.SHIFT && !mod.ALT && !mod.CONTROL)
            || ((_activeTrigger === kMouseRight)  && mod.ALT && !mod.SHIFT && !mod.CONTROL)
            || ((_activatedMode === "dolly") && !mod.ALT && !(_touchType === "pinch"))
    }

    function shouldPanOverrideDolly()
    {
        var mod = _modifierState;
        return !mod.CONTROL && !mod.ALT && !mod.SHIFT && (_activeTrigger === kMouseRight || _activeTrigger === kMouseMiddle);
    }

    function getTriggeredMode()
    {
        // Fusion wants Shift+Middle to go back to orbit
        if ((_activeTrigger === kMouseMiddle) && _modifierState.SHIFT)
            return _activations[1]; // TODO_NOP: return to chosen orbit behavior, don't use _activations

        return (isDolly() || _motionDelta.z !== 0.0) ? shouldPanOverrideDolly() ? "pan" : "dolly"
             : isTrack() ? "pan"
             : (_touchType === 'pan' || _touchType === 'pinch') ? "dollypan"
             : _activatedMode;
    }

    this.initTracking = function(x, y)
    {
        var distance;

        if( !_camera.isPerspective )
        {
            distance = _navapi.getEyeVector().length();
        }
        else
        {
            // Decide what point in world space defines the plane
            // orthogonal to the view that will be used to track
            // the camera. If we get an intersection point use it,
            // otherwise if the pivot point is set use that. The
            // fallback is to use the mid-point of the view frustum.

            distance = (_camera.near + _camera.far) * 0.5;

            var p = this.utilities.getHitPoint(x, y);
            var position = _navapi.getPosition();
            if( p && p.sub )
            {
                // Calculate orthogonal distance along view vector:
                var hitToEye = p.sub(position);
                var view = _navapi.getEyeVector().normalize();
                distance = Math.abs(view.dot(hitToEye));
            }
            else
            {
                var usePivot = _navapi.getPivotSetFlag() && _navapi.isPointVisible(_navapi.getPivotPoint());
                if( usePivot )
                {
                    var pivotDistance = _navapi.getPivotPlaneDistance();
                    if( pivotDistance > kEpsilon )
                    {
                        distance = pivotDistance;
                    }
                }
            }
        }
        _trackingDistance = distance;
    };

    function pivotIsBehind()
    {
        var pivotVector = _navapi.getPivotPoint().sub(_navapi.getPosition());
        return (pivotVector.dot(_navapi.getEyeVector()) <= 0.0);
    }

    this.initOrbit = function()
    {
        // If the pivot point is behind us we pivot around the center of the view:
        this.utilities.setTemporaryPivot(pivotIsBehind() ?  _navapi.getTarget() : null);
    }

    this.getCursor = function()
    {
        switch( _activeMode )
        {
            case "freeorbit":
            case "orbit":
                return 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAt1BMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8AAAAzMzP6+vri4uISEhKKioqtra2dnZ2EhIR9fX10dHRkZGQdHR3t7e3Hx8e5ubm1tbWoqKhWVlZKSko4ODgICAjv7+/o6OjMzMyxsbFOTk4pKSkXFxcEBAT29vbW1tZ6enpISEgLCwvhzeX+AAAAGXRSTlMANRO0nHRJHfnskIxQRKh89syDVwTWZjEJxPFEswAAAOFJREFUKM+1j+lygkAQhIflEAJe0Rw9u4CCeKKoSTTX+z9XoMJWWeX+ssrvZ3f19DQ5zOw/0DUMQPlmQ72bE2adBp8/Rp3CQUi3ILx+bxj4fjDs9T1Bmo6bbPPN8aDU4bjJt4nb+de789kSFyxn826jW3ICLNZZKU8nWWbrBTCRVm04U8TpjquRFf1Go0d7l8aYOrUR7FGEFr1S9LGymwthgX2gE/Kl0cHPOtF2xOWZ5QpIC93RflW4InkDoPRXesd5LJIMQPzV7tCMa7f6BvhJL79AVDmYTNQ1NhnxbI/uwB8H5Bjd4zQPBAAAAABJRU5ErkJggg==), auto';

            case "dolly":
                return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAgVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8mJiYAAADNzc2/v7+fn59paWlPT08MDAwICAj6+vqpqak7Ozv29vby8vLp6em2traAgIBkZGRZWVlAQEAaGhpISEgkS7tbAAAAFHRSTlMAOvhpZD8mkQWegMy9qY1YVE01EYiqlE0AAADZSURBVCjPbY9ZloMgEAAbEbfsmRZZXbJn7n/AAX2RQVN/VD26AXLOeZLDGo6IbfI9tHq8cdxuj1HwvgCoaiHqKoRk+M3hB9jueUW8PnfsE/bJ3vms7nCkq7NoE3s99AXxoh8vFoXCpknrn5faAuJCenT0xPkYqnxQFJaU0gdZrsKm8aHZrAIffBj40mc1jsTfIJRWegq6opTMvlfqLqYg7kr1ZB7jFgeaMC59N//8O4WZ1IiPF8b5wMHcJn8zB4g4mc77zpxgAbMSUVoGK4iV0hL4wrksz+H0Bw5+E+HrniDQAAAAAElFTkSuQmCC), auto";

            case "pan":
                return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAABHVBMVEUAAABPTk4AAAAAAAAJCQkRERE0MzQQEBAODg4QEBB4d3dbWlo9PDw/Pj4vLy8sLCwZGBgWFhYcHBwKCgoSEhIAAAAKCgoICAgKCgoQEBAODg4EBAQICAgPDw8REREMDAx2dnY0NDQvLy9QUFAaGhomJSYjIyM7OjokJCQNDA0mJiYNDQ0AAAAUFBQJCQkQEBAEBAQNDQ0PDw8VFRX///+amJkAAAD5+fnz8/PKycn9/f339vbi4eLR0dDNzMyAgIB8e3xycHH7+/vw7+/o6OjX1ta7urq4t7iwsLCnp6eioqKbmppva21OTk74+Pjl5eXc3Nzb29vLy8vDw8PDwsKrqqqdnZ2WlpaSkpKTkZKMiouEg4NkZGRISEgxLzBpgbsEAAAANHRSTlMA+fiQXgngKSYG/vX17uvBuqackpCNg3BpUkpAPBwTDvj18+vl0s/NwrOwoZZ+TDg4NBkBGrzX8QAAAP5JREFUKM99j9Vuw0AQRdeuKZyGkyZNmbnXDLHDVGb8/8/oy7paK1bO0+oc7WiGnGiaxq+QRTQAOh8f9Jv4H/Ge8PZPrCdlvkxfYluUT2WyyCq3mZ7unwlKVLcqOzA/Mf71j0TWJ/Ym6rPeca05Ni4iIevYc7yoUD2zQFhq71BdI9nvBeBabFDSPe8DswlUc1Riw3VxbH0NHBUPQ0jrbDnPYDjALQBMq9E7nkC5y7VDKTZlUg8Q0lmjvl74zlYErgvKa42GPKf3/a0kQmYCDY1SYMDosqMoiWrGwz/uAbNvc/fNon4kXRKGq+PUo2Mb96afV0iUxqGU2s4VBbKUP65NL/LKF+7ZAAAAAElFTkSuQmCC), auto";
        }
        return null;
    };

    this.getMotionDelta = function(dxyz, dxy)
    {
        // Add any offset triggered by key controls:
        // TODO: Change these to scale based on real time so fast frame
        // rate doesn't cause super fast motion.

        var autoDeltaZ = (_navapi && _navapi.getReverseZoomDirection()) ? -kAutoDeltaZ : kAutoDeltaZ;
        if( isMac )
            autoDeltaZ *= -1;   // Match the "natural" scroll direction on Mac.

        if( _autoMove[0] ) { _moveXYZ.x += kAutoDeltaXY; _moveXY.x += kAutoScreenXY; }
        if( _autoMove[1] ) { _moveXYZ.x -= kAutoDeltaXY; _moveXY.x -= kAutoScreenXY; }
        if( _autoMove[2] ) { _moveXYZ.y += kAutoDeltaXY; _moveXY.y += kAutoScreenXY; }
        if( _autoMove[3] ) { _moveXYZ.y -= kAutoDeltaXY; _moveXY.y -= kAutoScreenXY; }
        if( _autoMove[4] ) { _moveXYZ.z += autoDeltaZ; }
        if( _autoMove[5] ) { _moveXYZ.z -= autoDeltaZ; }

        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);

        if( dxy )
        {
            dxy.set(_moveXY.x - _startXY.x, _moveXY.y - _startXY.y);
        }
    };

    this.stepMotionDelta = function(delta, damped)
    {
        if( damped )
        {
            _startXYZ.x += delta.x * kDampingFactor;
            _startXYZ.y += delta.y * kDampingFactor;
            _startXYZ.z += delta.z * kDampingFactor;
        }
        else
            _startXYZ.copy(_moveXYZ);

        _startXY.copy(_moveXY);
    };

    function getMouseProjectionOnBall(pageX, pageY)
    {
        var viewport = {left: 0, top: 0, width: window.innerWidth, height: window.innerHeight};

        _mouseOnBall.set(
            (pageX - viewport.width * 0.5 - viewport.left) / (viewport.width * 0.5),
            (viewport.height * 0.5 + viewport.top - pageY) / (viewport.height * 0.5),
            0.0
        );

        var length = _mouseOnBall.length();
        if (_noRoll)
        {
            if (length < Math.SQRT1_2)
            {
                _mouseOnBall.z = Math.sqrt(1.0 - length*length);
            }
            else
            {
                _mouseOnBall.z = .5 / length;
            }
        }
        else if (length > 1.0)
        {
            _mouseOnBall.normalize();
        }
        else
        {
            _mouseOnBall.z = Math.sqrt(1.0 - length * length);
        }
        _pivotToEye.copy(_camera.position).sub(_camera.pivot);
        _projVector.copy(_camera.up).setLength(_mouseOnBall.y)
        _projVector.add(_objectUp.copy(_camera.up).cross(_pivotToEye).setLength(_mouseOnBall.x));
        _projVector.add(_pivotToEye.setLength(_mouseOnBall.z));
        return _projVector;
    }

    function freeOrbit()
    {
        if (!_navapi.isActionEnabled('orbit')) {
            return;
        }

        _pivotToEye.subVectors(_camera.position, _camera.pivot);
        _targetToEye.subVectors(_camera.position, _camera.target);
        var targetDist = _targetToEye.length();
        _targetToEye.normalize();

        var angle = Math.acos(_rotateStart.dot(_rotateEnd) / _rotateStart.length() / _rotateEnd.length());
        if (angle)
        {
            angle *= kOrbitScale;
            _rotateNormal.crossVectors(_rotateStart, _rotateEnd).normalize();
            _quaternion.setFromAxisAngle(_rotateNormal, -angle);

            _pivotToEye.applyQuaternion(_quaternion);
            _camera.up.applyQuaternion(_quaternion);
            _rotateEnd.applyQuaternion(_quaternion);
            _targetToEye.applyQuaternion(_quaternion);

            if (_staticMoving)
            {
                _rotateStart.copy(_rotateEnd);
            }
            else
            {
                _quaternion.setFromAxisAngle(_rotateNormal, angle * (_dynamicDampingFactor - 1.0));
                _rotateStart.applyQuaternion(_quaternion);
            }
        }

        _camera.position.addVectors(_camera.pivot, _pivotToEye);
        _camera.target.subVectors(_camera.position, _targetToEye.multiplyScalar(targetDist));
        _camera.dirty = true;
    }

    this.update = function()
    {
        var wheelEnded = false;
        var updatePivot = false;
        var viewport;

        this.getMotionDelta(_motionDelta, _deltaXY);

        var deltaX = _motionDelta.x;
        var deltaY = _motionDelta.y;
        var deltaZ = _motionDelta.z;

        if( !_activeModeLocked )
            this.checkInteractionMode();

        _activeModeLocked = (_activeTrigger > kWheel);

        if( _activeModeLocked )
            this.controller.setIsLocked(true);

        if( deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0 )
        {
            switch( _activeMode )
            {
                case "orbit":
                    if( this.utilities.autocam && this.utilities.autocam.startState )
                    {
                        _deltaXY.x = -_deltaXY.x;
                        if( _autoCamStartXY )
                            this.utilities.autocam.orbit(_moveXY, _autoCamStartXY, _deltaXY.multiplyScalar(kOrbitScale), this.utilities.autocam.startState);
                    }
                    break;

                case "freeorbit":
                    freeOrbit();
                    break;

                case "dolly":
                    var dollyTarget, screenX, screenY;

                    deltaZ *= kDollyScale;

                    if( _activeTrigger >= kMouseLeft )
                    {
                        // Map XY movement to Z:
                        deltaY = -deltaY;   // Invert Y
                        deltaZ = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
                        deltaZ *= kDollyDragScale;
                        deltaX = 0.0;
                        deltaY = 0.0;

                        // Towards center of screen:
                        screenX = screenY = 0.5;
                    }
                    else
                    {
                        // Towards cursor position:
                        viewport = _navapi.getScreenViewport();
                        screenX = _lastMouseX / viewport.width;
                        screenY = _lastMouseY / viewport.height;
                    }
                    if( !_navapi.getIs2D() && _navapi.getZoomTowardsPivot() )
                    {
                        if( !this.coiIsActive() )
                        {
                            // Center of screen if pivot is not active
                            dollyTarget = _navapi.getWorldPoint(0.5, 0.5);
                        }
                        else
                            dollyTarget = _navapi.getPivotPoint();
                    }
                    else
                        dollyTarget = _navapi.getWorldPoint(screenX, screenY);

                    _navapi.dollyFromPoint(deltaZ * this.getDollySpeed(dollyTarget), dollyTarget);
                    break;

                case "pan":
                    // Moving camera down/left moves the model up/right:
                    _navapi.panRelative(-deltaX, deltaY, _trackingDistance);
                    break;

                case "dollypan":
                    if( deltaX !== 0.0 || deltaY !== 0.0 )
                        _navapi.panRelative(-deltaX, deltaY, _trackingDistance);

                    // Towards cursor position:
                    viewport = _navapi.getScreenViewport();
                    screenX = _lastMouseX / viewport.width;
                    screenY = _lastMouseY / viewport.height;

                    dollyTarget = _navapi.getWorldPoint(screenX, screenY);
                    var position = _navapi.getPosition();
                    var distance = _navapi.getIs2D() ? position.sub(dollyTarget).length() : _trackingDistance;
                    var touchScale = _prevPinchLength / _pinchLength - 1;

                    var distanceDelta = touchScale * distance;
                    _navapi.dollyFromPoint(distanceDelta, dollyTarget);

                    var vview   = new THREE.Vector3();
                    var qrotate = new THREE.Quaternion();

                    var up = _navapi.getCameraUpVector();
                    var view = vview.copy(_camera.position).sub(_camera.target).normalize();
                    qrotate.setFromAxisAngle( view, _deltaRoll * 1.2 );
                    up.applyQuaternion( qrotate );
                    if (!_navapi.getIs2D()) 
                        _navapi.setCameraUpVector(up);

                    _prevPinchLength = _pinchLength;
                    _prevPinchScale = _pinchScale;
                    _trackingDistance = distance + distanceDelta;
                    break;
            }
            updatePivot = true;
        }
        this.stepMotionDelta(_motionDelta, (_activeMode !== "pan" && _activeMode !== 'dollypan'));

        // If a wheel event triggered this we've now handled it,
        if( _activeTrigger === kWheel && Math.abs(deltaZ) < kEpsilon )
        {
            this.interactionEnd(kWheel);
            wheelEnded = true;
            updatePivot = true;
        }

        // Show pivot if a clutch key is being held.
        if( (_modifierState.SHIFT || _modifierState.ALT) && (_names.indexOf(viewerApi.getActiveNavigationTool()) !== -1)) {
            updatePivot = true;
        }

        // stderr("mode: " + _activeMode + " locked: " + _activeModeLocked + " active: " + _interactionActive + " trigger: " + _activeTrigger);

        // If the interaction has "ended" we can now forget the trigger.
        if( !_interactionActive && (wheelEnded || (_activeTrigger > kNone)) )
        {
            if( _activeTrigger > kWheel )
            {
                // Kill any ongoing damped motion if we aren't using
                // the wheel.
                _startXYZ.copy(_moveXYZ);

                this.utilities.removeTemporaryPivot();
            }
            this.utilities.autocam.endInteraction();
            _activeTrigger = kNone;
            if( _activeModeLocked )
                this.controller.setIsLocked(false);
            _activeModeLocked = false;
            _autoCamStartXY = null;
            _touchType = null;
        }
        if( updatePivot )
            this.utilities.pivotActive(_navapi.getPivotSetFlag(), (_activeTrigger <= kWheel));
        else
            this.utilities.pivotUpdate();

        return _camera.dirty;
    };


    this.checkInteractionMode = function()
    {
        var newMode = getTriggeredMode();

        if( newMode !== _activeMode )
        {
			_activeMode = newMode;

            if( (_activeMode === "pan" && _activeTrigger > kWheel) || (_activeMode === "dollypan") )
                this.initTracking(_startXYZ.x, _startXYZ.y);
        }
    };

    this.interactionStart = function(trigger, force)
    {
        // Just a simple way to give device input a sort of priority
        // so we don't have to track all active triggers. Just remember
        // the most recent with highest "priority".
        if( force || trigger > _activeTrigger )
        {
            // Perhaps we need to remember the modifier keys now.
            _activeTrigger = trigger;
            _interactionActive = true;

            if( trigger > kWheel )
            {
                if( _activeMode === "pan" )
                    this.initTracking(_startXYZ.x, _startXYZ.y);

                if( _activeMode === "orbit" )
                    this.initOrbit();
            }
            this.utilities.pivotActive(_navapi.getPivotSetFlag(), (trigger === kWheel));

            if( this.utilities.autocam )
            {
                this.utilities.autocam.sync(_camera);
                this.utilities.autocam.startInteraction(_startXY.x, _startXY.y);
                _autoCamStartXY = _startXY.clone();
            }
            // stderr("START INTERACTION: " + _activeTrigger);
        }
    };

    this.interactionCheck = function()
    {
        // Restart keyboard interaction if certain keys are still down:
        //
        if( _autoMove[0]
         || _autoMove[1]
         || _autoMove[2]
         || _autoMove[3]
         || _autoMove[4]
         || _autoMove[5]
         || _modifierState.SHIFT
         || _modifierState.CONTROL
         || _modifierState.ALT
         || _modifierState.SPACE ) this.interactionStart(kKeyboard, true);
    };

    this.interactionEnd = function(trigger)
    {
        if( trigger === _activeTrigger )
        {
            // stderr("END INTERACTION: " + _activeTrigger);
            if( trigger !== kWheel )
                this.utilities.pivotActive(false);

            // We have to leave the _activeTrigger set until the
            // next update occurs so the update will apply the correct
            // operation.
            _interactionActive = false;
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".


    this.handleWheelInput = function(delta)
    {
        if( this.isDragging )
            return false;

        //Auto-update the center of zoom (pivot) to center on the cursor
        //on mouse wheel.
        if( _navapi.getIs2D() ) {
            // TODO: Perhaps this should be in the update method
            // to avoid unnecessary calls.
            var viewport = _navapi.getScreenViewport();
            var point = viewerImpl.intersectGround(_lastMouseX + viewport.width, _lastMouseY + viewport.height);
            this.utilities.setPivotPoint( point, true, true );
        }

        if( _navapi.getReverseZoomDirection() )
            delta *= -1;

        _moveXYZ.z += delta;

        _wheelAccum += delta;
        var now = Date.now();
        if ( !_wheelOldest ) {
            _wheelOldest = now;
        }
        _wheelNewest = now;

        if( delta != 0.0 )
            this.interactionStart(kWheel);

        return true;
    };

    this.resetKeys = function()
    {
        // Turn off any auto motion that may be stuck due to lost focus
        this.autoMove(-1, false);

        // Clear modifier states:
        _modifierState.SHIFT = 0;
        _modifierState.CONTROL = 0;
        _modifierState.ALT = 0;
        _modifierState.SPACE = 0;
    };

    this.autoMove = function(index, state)
    {
        if( !state || !this.isDragging )
        {
            if( index < 0 )
                _autoMove[0] =
                _autoMove[1] =
                _autoMove[2] =
                _autoMove[3] =
                _autoMove[4] =
                _autoMove[5] = state;
            else
                _autoMove[index] = state;

            if( !state )
                this.interactionEnd(kKeyboard);

            this.interactionCheck();
        }
    };

    this.updateModifierState = function( event )
    {
        /* See SPK-930 and SPK-928
        _modifierState.CONTROL = ((isMac && event.metaKey) || (!isMac && event.ctrlKey)) ? 1 : 0;
         */
        _modifierState.CONTROL = ((isMac && event.metaKey) || event.ctrlKey) ? 1 : 0;
        _modifierState.SHIFT = (event.shiftKey) ? 1 : 0;
        _modifierState.ALT = (event.altKey) ? 1 : 0;
    };

    this.handleKeyDown = function( event, keyCode )
    {
        this.updateModifierState(event);
        var handled = false;

        switch( keyCode )
        {
            case _keys.EQUALS: this.adjustSpeed(1);  handled = true; break;
            case _keys.DASH:   this.adjustSpeed(-1); handled = true; break;
            case _keys.ZERO:   this.adjustSpeed(0);  handled = true; break; // Reset dolly speed to default

            case _keys.LEFT:     this.autoMove(0, true); handled = true; break;
            case _keys.RIGHT:    this.autoMove(1, true); handled = true; break;
            case _keys.PAGEUP:   this.autoMove(2, true); handled = true; break;
            case _keys.PAGEDOWN: this.autoMove(3, true); handled = true; break;
            case _keys.UP:       this.autoMove(4, true); handled = true; break;
            case _keys.DOWN:     this.autoMove(5, true); handled = true; break;

            default:
                return false;
        }
        if( !this.isDragging )
            this.interactionStart(kKeyboard);

        return handled;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        this.updateModifierState(event);
        var handled = false;

        switch( keyCode )
        {
            case _keys.LEFT:     this.autoMove(0, false); handled = true; break;
            case _keys.RIGHT:    this.autoMove(1, false); handled = true; break;
            case _keys.PAGEUP:   this.autoMove(2, false); handled = true; break;
            case _keys.PAGEDOWN: this.autoMove(3, false); handled = true; break;
            case _keys.UP:       this.autoMove(4, false); handled = true; break;
            case _keys.DOWN:     this.autoMove(5, false); handled = true; break;

            default:
                return false;
        }
        if( handled )
        {
            this.interactionEnd(kKeyboard);

            if( !_interactionActive )
                this.interactionCheck();
        }
        return handled;
    };

    function endsWith(str, suffix)
    {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    function fingerSeparation(event)
    {
        var dx = event.pointers[1].clientX - event.pointers[0].clientX;
        var dy = event.pointers[1].clientY - event.pointers[0].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    this.handleDollyPan = function(event)
    {
        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        var viewport = _navapi.getScreenViewport();
        _moveXY.x  = _touchStartXY.x + event.deltaX;
        _moveXY.y  = _touchStartXY.y + event.deltaY;
        _moveXYZ.x = _moveXY.x / viewport.width;
        _moveXYZ.y = _moveXY.y / viewport.height;

        _pinchLength = fingerSeparation(event);

        var roll = THREE.Math.degToRad(event.rotation);
        _deltaRoll = roll - _prevRoll;
        if (Math.abs(_deltaRoll) > 1.0)
            _deltaRoll = 0;
        _prevRoll = roll;

        if( endsWith(event.type, "start") )
        {
            _prevPinchLength = _pinchLength;
            _prevPinchScale = 1.0;
            _deltaRoll = 0;
            _prevRoll = roll;
        }

        _pinchScale = event.scale;
    };

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                // We seem to often get a lone dragend after a multi-touch.
                if( _touchType === "drag" )
                {
                    this.handleButtonUp(event, 0);
                    _touchType = null;
                    return true;
                }
                return false;


            case "panstart":
                _touchType = "pan";
                this.isDragging = true;

                _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
                _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

                _touchStartXY.set(event.canvasX, event.canvasY);
                _startXY.set(event.canvasX, event.canvasY);

                this.interactionStart(kTouch);
                this.handleDollyPan(event);
                return true;

            case "panmove":
                return (_touchType === "pan") ?  this.handleDollyPan(event) : false;

            case "panend":
                if( _touchType === "pan" )
                {
                    this.isDragging = false;
                    this.handleDollyPan(event);
                    this.interactionEnd(kTouch);
                    return true;
                }
                return false;


            case "pinchstart":
                this.isDragging = true;
                _touchType = "pinch";

                _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
                _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

                _touchStartXY.set(event.canvasX, event.canvasY);
                _startXY.set(event.canvasX, event.canvasY);

                this.interactionStart(kTouch);
                this.handleDollyPan(event);
                return true;

            case "pinchmove":
                return (_touchType === "pinch") ? this.handleDollyPan(event) : false;

            case "pinchend":
                if( _touchType === "pinch" )
                {
                    this.isDragging = false;
                    this.handleDollyPan(event);
                    this.interactionEnd(kTouch);
                    return true;
                }
                return false;
        }
        return false
    };

    this.handleButtonDown = function( event, button )
    {
        this.updateModifierState(event);

        _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _startXY.set(event.canvasX, event.canvasY);
        _moveXYZ.copy(_startXYZ);
        _moveXY.copy(_startXY);

        _rotateStart.copy(getMouseProjectionOnBall(event.canvasX, event.canvasY));
        _rotateEnd.copy(_rotateStart);

        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        this.isDragging = true;

        this.interactionStart(button);
        return true;
    };

    this.handleButtonUp = function( event, button )
    {
        this.updateModifierState(event);

        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        _moveXY.set(event.canvasX, event.canvasY);

        _rotateEnd.copy(getMouseProjectionOnBall(event.canvasX, event.canvasY));
        _rotateStart.copy(_rotateEnd);

        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        this.interactionEnd(button);

        this.isDragging = false;
        return true;
    };

    this.handleMouseMove = function( event )
    {
        this.updateModifierState(event);

        //Handles non-dragging mouse move over the canvas.
        //Updates the last known mouse point for
        //using during mouse wheel (as zoom center) and
        //will eventually be needed for mouse over highlighting
        if( !this.isDragging )
        {
            _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
            _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

            _startXY.set(event.canvasX, event.canvasY);
            _moveXYZ.x = _startXYZ.x;
            _moveXYZ.y = _startXYZ.y;
            _moveXY.copy(_startXY);

            _lastMouseX = event.canvasX;
            _lastMouseY = event.canvasY;

            //mouse over highlighting
            // TODO: Perhaps this should be in the update method
            // to avoid unnecessary calls.
            viewerImpl.rolloverObject(_lastMouseX, _lastMouseY);

            return false;
        }
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        _moveXY.set(event.canvasX, event.canvasY);

        _rotateEnd.copy(getMouseProjectionOnBall(event.canvasX, event.canvasY));

        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        return true;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.resetKeys();
        this.interactionEnd(_activeTrigger);
    };

    viewerApi.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function(event) {
        _this.handleBlur(event);
    });
};
;AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.HotGestureTool = function( viewerApi )
{
    var isMac = (navigator.userAgent.search("Mac OS") != -1);
    var isActive = false;

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["hottouch"];

    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0 };
    var _commandKeyDown = false;
    var _setMode = null;
    var _saveMode = null;
    var _fovActive = false;
    var _rollActive = false;
    var _startEvent = null;

    var _keys = {
              SHIFT: 16,
            CONTROL: 17,
                ALT: 18,
             ESCAPE: 27,
           LCOMMAND: 91,
           RCOMMAND: 93,
         COMMANDMOZ: 224
    };

    var ORBIT   = "orbit";
    var ROLL    = "worldup";
    var FOV     = "fov";

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
    };

    this.deactivate = function(name)
    {
    };
    
    this.__checkStart = function()
    {
        // Since the start event triggers the tool change we re-send the
        // start event so that the new tool can trigger from it.
        if( _startEvent )
        {
            this.controller.distributeEvent("handleGesture", _startEvent);
            _startEvent = null;
        }
    };

    this.update = function()
    {
        if( this.controller.getIsLocked() )
            return false;

        var got = viewerApi.getActiveNavigationTool();
        var wantRoll = (_fovActive === false && _rollActive === true);
        var wantFov  = (_fovActive === true && _rollActive === false);

        if( wantRoll || wantFov )
        {
            var want = wantRoll ? ROLL : FOV;

            if( got === want )
                return false;

            if( got === _setMode )  // We set it we can change it
            {
                viewerApi.setActiveNavigationTool(want);
                _setMode = want;
                this.__checkStart();
                // stderr("HOT: " + got + " => " + want);
                return false;
            }
            _saveMode = got;
            viewerApi.setActiveNavigationTool(want);
            _setMode = want;
            this.__checkStart();
            // stderr("HOT: " + got + " => " + want);
        }
        else if( _setMode )
        {
            // stderr("HOT: " + got + " => " + _saveMode);
            viewerApi.setActiveNavigationTool(_saveMode);
            _setMode = null;
            _saveMode = null;
        }
        return false;
    };

    this.resetKeys = function()
    {
        // Clear modifier states:
        _modifierState.SHIFT = 0;
        _modifierState.CONTROL = 0;
        _modifierState.ALT = 0;
    };

    this.updateModifierState = function( event )
    {
        _modifierState.CONTROL = event.ctrlKey  ? 1 : 0;
        _modifierState.SHIFT   = event.shiftKey ? 1 : 0;
        _modifierState.ALT     = event.altKey   ? 1 : 0;
    };

    this.handleGesture = function( event )
    {
        if( event === _startEvent )
            return false;

        switch( event.type )
        {
            case "drag3start":
                _startEvent = event;
                _fovActive = true;
                break;

            case "drag3move":
                break;

            case "drag3end":
                _fovActive = false;
                break;

            case "rotatestart":
                _startEvent = event;
                _rollActive = true;
                break;

            case "rotatemove":
                break;

            case "rotateend":
                _rollActive = false;
                break;
        }
        return false
    };

    this.handleKeyDown = function( event, keyCode )
    {
        this.updateModifierState(event);

        switch( keyCode )
        {
            // Do we need to consume these events?
            case _keys.SHIFT:   _modifierState.SHIFT = 1;   break;
            case _keys.CONTROL: _modifierState.CONTROL = 1; break;
            case _keys.ALT:     _modifierState.ALT = 1;     break;
        }
        return false;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        this.updateModifierState(event);

        switch( keyCode )
        {
            // Do we need to consume these events?
            case _keys.SHIFT:   _modifierState.SHIFT = 0;   break;
            case _keys.CONTROL: _modifierState.CONTROL = 0; break;
            case _keys.ALT:     _modifierState.ALT = 0;     break;
        }
        return false;
    };

    this.handleButtonDown = function( event, button )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleButtonUp = function( event, button )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleMouseMove = function( event )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.resetKeys();
        return false;
    };
}
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * @callback Autodesk.Viewing.HotkeyManager~onHotkeyPressCallback
 * @param {number[]} keycodes - The key combination that triggered this callback
 * @returns {boolean} - True if the press event was handled, false otherwise.
 */

/**
 * @callback Autodesk.Viewing.HotkeyManager~onHotkeyReleaseCallback
 * @param {number[]} keycodes - The key combination that triggered this callback
 * @returns {boolean} - True if the release event was handled, false otherwise.
 */

/**
 * @typedef {Object} Autodesk.Viewing.HotkeyManager~Hotkey
 * @property {number[]} keycodes - The keycode combination (order doesn't matter).
 * @property {Autodesk.Viewing.HotkeyManager~onHotkeyPressCallback} [onPress] - The callback used when the combination is engaged.
 * @property {Autodesk.Viewing.HotkeyManager~onHotkeyReleaseCallback} [onRelease] - The callback used when the combination is disengaged.
 */

/**
 * The HotkeyManager manages the hotkeys for the viewer.
 * Access the members and methods via the singleton theHotkeyManager.
 *
 * @constructor
 */
Autodesk.Viewing.HotkeyManager = function () {
    var stack = []; // The hotkey stack

    var keys = []; // The keys that are currently held

    // Pending items
    var onPressQueue = [];
    var onReleaseQueue = [];

    /**
     * Enum for keycodes
     * @readonly
     * @enum {number}
     */
    var KEYCODES = Autodesk.Viewing.KeyCode;

    var _names = ["hotkeys"];

    function getNames()
    {
        return _names;
    }

    function getName()
    {
        return _names[0];
    }

    // Apparently javascript sorts by string values by default so we need
    // our own sort function.
    function compare(a, b) {
        return a - b;
    }

    /**
     * Pushes new hotkeys onto the stack
     *
     * @param {String} id - The id for this hotkey set.
     * @param {Autodesk.Viewing.HotkeyManager~Hotkey[]} hotkeys - The list of hotkeys.
     * @param {Object} [options] - An optional dictionary of options for this hotkey set.
     * @param {boolean} [options.tryUntilSuccess] - When true, the onPress callback will be called until it returns true
     *                                              or the hotkey state changes. The onRelease callback will be called
     *                                              until it returns true or until the combination is reengaged. Stops
     *                                              propagation through the stack. Non-blocking.
     * @returns {boolean} - True if the hotkeys were successfully pushed.
     */
    function pushHotkeys(id, hotkeys, options) {
        var idAlreadyUsed = stack.some(function(element) {
            return element.id === id;
        });

        if (idAlreadyUsed) {
            return false;
        }

        for (var i = 0; i < hotkeys.length; i++) {
            stack.push({
                id: id,
                keys: hotkeys[i].keycodes.sort(compare).join(),
                onPress: hotkeys[i].onPress,
                onRelease: hotkeys[i].onRelease,
                options: options || {}
            });
        }

        return true;
    }

    /**
     * Removes hotkeys associated with an ID from the stack.
     *
     * @param {String} id - The id associated with the hotkeys.
     * @returns {boolean} - True if the hotkeys were successfully popped.
     */
    function popHotkeys(id) {
        var found = false;
        for (var i = stack.length - 1; i >= 0; i--) {
            if (stack[i].id === id) {
                stack.splice(i, 1);
                found = true;
            }
        }

        return found;
    }

    function cleanQueues() {
        var index = keys.join();

        var item;
        var i;

        for (i = 0; i < onReleaseQueue.length;) {
            item = onReleaseQueue[i];
            if (item.keys === index) {
                onReleaseQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        for (i = 0; i < onPressQueue.length;) {
            item = onPressQueue[i];
            if (item.keys !== index) {
                onPressQueue.splice(i, 1);
            } else {
                i++;
            }
        }
    }

    function handleKeyDown(event, keyCode) {
        if (keys.indexOf(keyCode) !== -1) {
            // Ignore duplicate key down events. (see ToolController.applyKeyMappings())
            return;
        }

        var currentIndex = keys.join();
        var currentKeys = keys.slice(0);

        var i = 0;
        while (i < keys.length && keys[i] < keyCode) {
            i++;
        }
        keys.splice(i, 0, keyCode);

        var newIndex = keys.join();
        var newKeys = keys.slice(0);

        cleanQueues();

        // Make sure onRelease is called before onPress
        var releaseHandlers = [];
        var pressHandlers = [];
        var item;

        for (i = stack.length - 1; i >= 0; i--) {
            item = stack[i];
            if (item.keys === currentIndex && item.onRelease) {
                releaseHandlers.unshift(item);
            } else if (item.keys === newIndex && item.onPress) {
                pressHandlers.unshift(item);
            }
        }

        for (i = releaseHandlers.length - 1; i >= 0; i--) {
            item = releaseHandlers[i];
            if (item.onRelease(currentKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onReleaseQueue.unshift(item);
            }
        }

        for (i = pressHandlers.length - 1; i >= 0; i--) {
            item = pressHandlers[i];
            if (item.onPress(newKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onPressQueue.unshift(item);
            }
        }
    }

    function handleKeyUp(event, keyCode) {
        var currentIndex = keys.join();
        var currentKeys = keys.slice(0);

        var i = keys.indexOf(keyCode);
        if (i > -1) {
            keys.splice(i, 1);
        }

        var newIndex = keys.join();
        var newKeys = keys.slice(0);

        cleanQueues();

        // Make sure onRelease is called before onPress
        var releaseHandlers = [];
        var pressHandlers = [];
        var item;

        for (i = stack.length - 1; i >= 0; i--) {
            item = stack[i];
            if (item.keys === currentIndex && item.onRelease) {
                releaseHandlers.unshift(item);
            } else if (item.keys === newIndex && item.onPress) {
                pressHandlers.unshift(item);
            }
        }

        for (i = releaseHandlers.length - 1; i >= 0; i--) {
            item = releaseHandlers[i];
            if (item.onRelease(currentKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onReleaseQueue.unshift(item);
            }
        }

        for (i = pressHandlers.length - 1; i >= 0; i--) {
            item = pressHandlers[i];
            if (item.onPress(newKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onPressQueue.unshift(item);
            }
        }
    }

    function update() {
        var item;
        var i;

        for (i = 0; i < onReleaseQueue.length;) {
            item = onReleaseQueue[i];
            if (item.onRelease(item.keys.split()) === true) {
                onReleaseQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        for (i = 0; i < onPressQueue.length;) {
            item = onPressQueue[i];
            if (item.onPress(item.keys.split()) === true) {
                onPressQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        return false;
    }

    function handleBlur() {
        // Release all keys.
        for (var i = keys.length - 1; i >= 0; i--) {
            handleKeyUp(null, keys[i]);
        }
    }

    return {
        pushHotkeys: pushHotkeys,
        popHotkeys: popHotkeys,
        handleKeyDown: handleKeyDown,
        handleKeyUp: handleKeyUp,
        handleBlur: handleBlur,
        getName: getName,
        getNames: getNames,
        activate: function(){},
        deactivate: function(){},
        update: update,
        KEYCODES: KEYCODES
    };
};

Autodesk.Viewing.theHotkeyManager = new Autodesk.Viewing.HotkeyManager();
;AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.FovTool = function( viewerApi )
{
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;
    var kFovDragScale = -1.0;
    var kDampingFactor = 0.6;
    var kWheelThresholdMs = 100;

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["fov"];

    var _interactionActive = false;

    var _wheelAccum = 0;
    var _wheelOldest = null;
    var _wheelNewest = null;
    var _wheelContinuous = false;

    var _mouseButtons = 0; // Track mouse buttons that are held

    // Interaction Triggers:
    var kNone = -5;
    var kWheel = -1;
    var kMouseLeft = 0;
    var kMouseMiddle = 1;
    var kMouseRight = 2;

    var _activeTrigger = kNone;
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _motionDelta = new THREE.Vector3();
    var _touchType = null;
    
    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        _mouseButtons = 0;
    };

    this.deactivate = function(name)
    {
        _activeTrigger = kNone;
    };
    
    this.getCursor = function()
    {
        return _mouseButtons !== 0 && _activeTrigger === kNone ? null : "url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAACEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnAwMD/yEhIf8AAABmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAGknJyf/goKC/8/Pz/8aGhr/AAAALQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAABTFBQU/2lpaf/MzMz///////////+Wlpb/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAOAAAAKFTU1P/t7e3////////////8PDw////////////AQEB/wAAAAEAAAAAAAAAFAAAAH0KCgr/AAAAYwAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAjCwsL/6Ghof/t7e3///////Dw8P9MTEz/LS0t//Pz8///////Ghoa/wAAABoAAAANDQ0N/319ff+rq6v/Y2Nj/wAAAK8AAABGAAAA////////////AAAA/wAAAF0hISH/jIyM////////////sLCw/xEREf8AAACHAAAArKysrP//////V1dX/wAAAFcAAABSUlJS//f39///////8PDw/6+vr/86Ojr/LS0t////////////FRUV/1xcXP/Gxsb/+Pj4//Hx8f9MTEz/AAAAsAAAAEcAAAAAAAAAZ2dnZ///////pKSk/wAAAKQAAACtra2t///////////////////////m5ub/kZGR/wAAAP8AAAD/q6ur//Hx8f//////vb29/x0dHf8AAACIAAAAAAAAAAAAAAAAAAAAOjo6Ov//////5+fn/wAAAOcAAADd3d3d////////////////////////////+/v7/9bW1v/i4uL//v7+//Pz8/9hYWH/AAAAvQAAAFQAAAAAAAAAAAAAAAAAAAAAAAAAJycnJ//6+vr//////wMDA/8AAADv7+/v/////////////////////////////////////////////////7y8vP8ODg7/AAAAKwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJiYmJv/6+vr//////wkJCf8AAADv7+/v//////////////////////////////////f39//9/f3//////+np6f+UlJT/GBgY/wAAAH0AAAACAAAAAAAAAAAAAAAAAAAAKSkpKf///////v7+/w0NDf8AAADd3d3d////////////////////////////29vb/39/f/+Xl5f/5+fn////////////5ubm/1RUVP8CAgL/AAAAPwAAAAAAAAAAAAAAOTk5Of//////8PDw/wgICP8AAAChoaGh/////////////////+np6f+YmJj/QkJC/wAAAP8AAAD/UFBQ/7e3t//39/f///////////+oqKj/EBAQ/wAAAIgAAAAAAAAAZ2dnZ///////29vb/wEBAf8AAAA4NTU1/9zc3P/t7e3/tbW1/01NTf8AAACYAAAA////////////AwMD/wsLC/9oaGj/y8vL////////////8fHx/zg4OP8AAACWAAAApaWlpf//////n5+f/wAAAJ8AAAAAAAAAczg4OP9LS0v/EhIS/wAAAE0AAAAAAAAA////////////FRUV/wAAABUAAABoJSUl/4GBgf/i4uL///////////9+fn7/Pz8///b29v//////SkpK/wAAAEoAAAAAAAAAAAAAADgAAABLAAAAEgAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAJQAAAIE8PDz/np6e//z8/P/////////////////8/Pz/CQkJ/wAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAA8DAwM/09PT/+7u7v///////////+QkJD/AAAAkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////Dw8P/wAAAA8AAAAAAAAAAAAAAAAAAAAAAAAADAAAAFIYGBj/aGho/729vf8WFhb/AAAAJwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////FRUV/wAAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAQEB/w8PD/8AAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////DAwM/wAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x/h/nO/4fw1D+HwFy/h4BRu4YAHOGEABkAAAAXAAAIFwAAOBnAAHgIAAD4GUAAOB4AABgXAAAIGMAAABtggAAVMYYAHT+HgE7/g8BcP4Pw2/+D+dc/h//XP///2c=), auto";
    };

    this.getMotionDelta = function(dxyz)
    {
        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);
    };

    this.stepMotionDelta = function(delta, damped)
    {
        if( damped )
        {
            _startXYZ.x += delta.x * kDampingFactor;
            _startXYZ.y += delta.y * kDampingFactor;
            _startXYZ.z += delta.z * kDampingFactor;
        }
        else
            _startXYZ.copy(_moveXYZ);
    };

    function promoteDelta(delta)
    {
        // promote a wheel delta to a full wheel stop (3)
        if ( delta < 0 && delta > -3 ) {
            return -3;
        }
        return ( delta > 0 && delta < 3 ) ? 3 : delta;
    }

    this.getAccumulatedWheelDelta = function()
    {
        var now = Date.now();
        var delta = 0;

        if ( _wheelNewest && now - _wheelNewest > kWheelThresholdMs ) {
            // Newest event in accumulator has aged out; assume wheel motion has stopped.
            delta = promoteDelta(_wheelAccum);
            _wheelAccum = 0;
            _wheelOldest = null;
            _wheelNewest = null;
            _wheelContinuous = false;
        }
        else if ( _wheelOldest && (now - _wheelOldest) > kWheelThresholdMs ) {
            // Oldest event in accumulator has aged out; process continuously.
            if ( _wheelContinuous ) {
                if( Math.abs(_wheelAccum) >= 3 ) {
                    delta = _wheelAccum;
                    _wheelAccum = 0;
                }
            } else {
                delta = promoteDelta(_wheelAccum);
                _wheelContinuous = true;
                _wheelAccum = 0;
            }
        }
        return delta;
    };

    this.update = function()
    {
        var wheelEnded = false;
        var updatePivot = _activeTrigger > kNone;

        if( _activeTrigger > kNone )
        {
            this.controller.setIsLocked(true);
            this.getMotionDelta(_motionDelta);

            var deltaX = _motionDelta.x;
            var deltaY = _motionDelta.y;
            var deltaZ = _motionDelta.z;

            if( deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0 )
            {
                updatePivot = true;
                if( _activeTrigger >= kMouseLeft )
                {
                    // Map XY movement to Z:
                    deltaY = -deltaY;   // Invert Y
                    deltaZ = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
                    if( deltaZ !== 0.0 )
                    {
                        deltaZ *= kFovDragScale;
                        _navapi.setVerticalFov(_navapi.getVerticalFov() * (1.0 + deltaZ), true);
                    }
                }
                else 
                {
                    // Translate wheelAccum backwards to determine the number of wheel stops.
                    var deltaFocalLength = this.getAccumulatedWheelDelta() / 3;
                    if( deltaFocalLength !== 0.0 )
                        _navapi.setFocalLength(_navapi.getFocalLength() + deltaFocalLength, true);
                }
            }
            this.stepMotionDelta(_motionDelta, true);

            // If a wheel event triggered this we've now handled it,
            if( _activeTrigger === kWheel && Math.abs(deltaZ) < kEpsilon )
            {
                this.interactionEnd(kWheel);
                wheelEnded = true;
            }
        }

        if( updatePivot )
            this.utilities.pivotActive(_navapi.getPivotSetFlag(), true);
        else
            this.utilities.pivotUpdate();

        // If the interaction has "ended" we can now forget the trigger.
        if( !_interactionActive && (wheelEnded || (_activeTrigger > kNone)) )
        {
            if( _activeTrigger > kWheel )
            {
                // Kill any ongoing damped motion if we aren't using
                // the wheel.
                _startXYZ.copy(_moveXYZ);
            }
            _activeTrigger = kNone;
            this.controller.setIsLocked(false);
        }
        return _camera.dirty;
    };

    this.interactionStart = function(trigger, force)
    {
        // Just a simple way to give device input a sort of priority 
        // so we don't have to track all active triggers. Just remember
        // the most recent with highest "priority".
        if( force || trigger > _activeTrigger )
        {
            // Perhaps we need to remember the modifier keys now.
            _activeTrigger = trigger;
            _interactionActive = true;
        }

        // Switch to perspective
        _navapi.toPerspective();
    };

    this.interactionEnd = function(trigger)
    {
        if( trigger === _activeTrigger )
        {
            // stderr("END INTERACTION: " + _activeTrigger);
            if( trigger !== kWheel )
                this.utilities.pivotActive(false);

            // We have to leave the _activeTrigger set until the
            // next update occurs so the update will apply the correct
            // operation.
            _interactionActive = false;
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    
    this.handleWheelInput = function(delta)
    {
        if( _activeTrigger > kWheel )
            return false;

        // Match original reverse behaviour:
        if( _navapi.getReverseZoomDirection() )
            delta *= -1;

        _moveXYZ.z += delta;
        _wheelAccum += delta;
        var now = Date.now();
        if ( !_wheelOldest ) {
            _wheelOldest = now;
        }
        _wheelNewest = now;

        if( delta != 0.0 )
            this.interactionStart(kWheel);

        return true;
    };

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            case "dragstart":
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return this.handleMouseMove(event);

            case "dragend":
                return this.handleButtonUp(event, 0);

            case "drag3start":
                _touchType = "drag";
                // Fake the mouse for now. Coord should be centroid.
                return this.handleButtonDown(event, 0);

            case "drag3move":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "drag3end":
                if( _touchType === "drag" )
                    this.handleButtonUp(event, 0);

                _touchType = null;
                // Sigh... minor hack
                // Can't consume the end event because the hot gesture
                // tool needs to see it to end the interaction.
                return false;
        }
        return false;
    };


    this.handleButtonDown = function( event, button )
    {
        _mouseButtons += 1 << button;

        if (button !== kMouseRight) {
            _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
            _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

            _moveXYZ.copy(_startXYZ);

            this.interactionStart(button);
            return true;
        }

        return false;
    };

    this.handleButtonUp = function( event, button )
    {
        _mouseButtons -= 1 << button;

        if (button !== kMouseRight) {
            _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
            _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

            this.interactionEnd(button);
            return true;
        }

        return false;
    };

    this.handleMouseMove = function( event )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        return (_activeTrigger > kWheel);
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.interactionEnd(_activeTrigger);
        return false;
    };

};
;AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.WorldUpTool = function( viewerImpl, viewerApi )
{
    var kRingSizeMin = 0.35; // Proportion of screen height
    var kRingSizeMax = 0.80; // Proportion of screen height
    var kRingSizeDefault = 0.65; // Proportion of screen height

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["worldup"];
    var self = this;

    // Returns the projection of (x,y,z) onto the plane with this unit normal
    var projectAxis = function()
    {
        var projectionVec = new THREE.Vector3();

        return function (x, y, z, normal)
        {
            var vec = new THREE.Vector3(x, y, z);
            var projectionLength = normal.dot(vec);
            projectionVec.copy(normal);
            projectionVec.multiplyScalar(projectionLength);
            return vec.sub(projectionVec);
        }
    }();

    // /** @constructor */
    function RollInteraction( viewerImpl, camera )
    {
        var kRollColor = 0xBBBBBB;
        var kHudFov = 30;
        var kHudWorldScale = 2.0 * Math.tan(THREE.Math.degToRad(kHudFov * 0.5));

        var myMaterial  = new THREE.MeshPhongMaterial({
            color:       kRollColor,
            ambient:     kRollColor,
            opacity:     0.5,
            transparent: true,
            depthTest:   false,
            depthWrite:  false,
        });

        // Preallocate these as work objects:
        var myVec1   = new THREE.Vector3();
        var myVec2   = new THREE.Vector3();
        var myRotate = new THREE.Quaternion();

        // Use our own camera for the Roll HUD:
        // var myCamera = camera.clone();   // There's a bug in Object3D.clone()
        var myCamera = new THREE.PerspectiveCamera(kHudFov, camera.aspect, camera.near, camera.far);
        var mySceneCamera = camera;
        var myRingScale = 1.0;
        var myRingSize = 1.0;
        var myLookAtPoint = null;
        var myReferenceCircle = null;
        var myReferenceXaxis = null;
        var myReferenceYaxis = null;
        var myReferenceZaxis = null;
        var myReferenceGeometry = null;
        var myReferenceUp = null;
        var mySnapPoints = null;
        var mySnapFlags = null;
        var mySnapAngles = new Array(6);
        var myClosestAngle = 0.0;
        var myRollAngle = 0.0;
        var myAnglesFlipped = false;
        var myCurrentlySnapped = true;  // Assume initially true
        var mySnappedRoll = 0.0;
        var kSnapInThreshold  = 5.0 * Math.PI / 180.0;
        var kSnapOutThreshold = 7.0 * Math.PI / 180.0;
        var myDistance = 1.0;

        var kNOSNAP = 1e3;
        var kAliasLengthThreshold = 0.1;

        viewerImpl.createOverlayScene("roll", null, null, myCamera);

        function angleDiff(a, b)
        {
            var diff = Math.abs(a - b);
            if( diff > kTwo_PI )
                return diff;

            return Math.min(kTwo_PI - diff, diff);
        }

        function isThisAxis(index, worldUp)
        {
            var snapVec = getSnapVector(index);
            if( snapVec.distanceToSquared(worldUp) < kEpsilon )
                return true;

            myVec2.set(-worldUp.x, -worldUp.y, -worldUp.z);
            return (snapVec.distanceToSquared(myVec2) < kEpsilon);
        }

        function filterSnapAngles(snapLengths, worldUp)
        {
            // For some rotation axes the snap angles for two axes can be close together.
            // Snapping to one or the other doesn't give expected results. This filters
            // the snap angles and removes one of the close angles. When two angles are
            // withing AliasSnapThreshold, one of the angles is removed. The one we keep
            // is the one with the longest projection length unless it happens to be the
            // current up direction.

            // This threshold should be greater than the snap out threshold plus the snap
            // in threshold so that when two snap points are close together there is room
            // to snap out of one and into the other.
            var kAliasSnapThreshold = kSnapInThreshold + kSnapOutThreshold + (2.0 * Math.PI / 180.0);

            for (var i = 0; i < 6; ++i)
            {
                if( mySnapAngles[i] === kNOSNAP )
                    continue;

                for (var j = i + 1; j < 6; ++j)
                {
                    if( mySnapAngles[j] === kNOSNAP )
                        continue;

                    var diff = angleDiff(mySnapAngles[i], mySnapAngles[j]);
                    // stderr("Angle diff: (" + i + ", " + j + ") " + diff);
                    // stderr("Angles: " + mySnapAngles[i] + " - " + mySnapAngles[j]);

                    if (diff < kAliasSnapThreshold)
                    {
                        if( (snapLengths[i] < snapLengths[j] && !isThisAxis(i, worldUp))
                        ||  isThisAxis(j, worldUp) )
                        {
                            mySnapAngles[i] = kNOSNAP;
                            break;  // angle i is removed stop checking
                        }
                        else
                            mySnapAngles[j] = kNOSNAP;
                    }
                }
            }
        }

        // Calculate the opposite angle from angle. angle should be
        // from -PI to PI, or kNOSNAP
        function oppositeAngle(angle)
        {
            if( angle > kTwo_PI )
                return angle;
            if( angle <= 0.0 )
                return angle + Math.PI;
            return angle - Math.PI;
        }

        function updateSnapPoints(viewVec, cameraUp, worldUp)
        {
            var normal = viewVec.clone().normalize();
            var snaps   = new Array(3);
            var lengths = new Array(6);

            // Project the 6 axis vectors onto the view plane:
            snaps[0] = projectAxis(1.0, 0.0, 0.0, normal);
            snaps[1] = projectAxis(0.0, 1.0, 0.0, normal);
            snaps[2] = projectAxis(0.0, 0.0, 1.0, normal);

            var i;
            var left = cameraUp.clone().cross(normal).normalize();

            for( i=0; i < 3; ++i )
            {
                var snap = snaps[i];
                lengths[i] = snap.length();

                // A short projection length means the axis was too close to
                // the view vector:
                if( lengths[i] < kAliasLengthThreshold )
                {
                    mySnapAngles[i] = kNOSNAP;
                }
                else
                {
                    snap.multiplyScalar(1.0 / lengths[i]);
                    mySnapAngles[i] = Math.atan2(left.dot(snap), cameraUp.dot(snap));
                }
            }
            mySnapAngles[3] = oppositeAngle(mySnapAngles[0]);
            mySnapAngles[4] = oppositeAngle(mySnapAngles[1]);
            mySnapAngles[5] = oppositeAngle(mySnapAngles[2]);
            lengths[3] = lengths[0];
            lengths[4] = lengths[1];
            lengths[5] = lengths[2];

            filterSnapAngles(lengths, worldUp);

            for( i=0; i < 6; ++i )
            {
                // stderr("SNAP[" + i + "] = " + mySnapAngles[i].toFixed(3) + " (" + lengths[i].toFixed(3) + ")");

                if( mySnapAngles[i] !== kNOSNAP )
                {
                    var z = myVec2.set(0.0, 0.0, 1.0);
                    myRotate.setFromAxisAngle( z, mySnapAngles[i] );
                    // The radius of the circle is 0.5 so place the points
                    // just outside the circle:
                    var pos = myVec2.set(0.0, 0.54, 0.0);
                    pos.applyQuaternion( myRotate );
                    mySnapPoints[i].position.copy(pos);
                    mySnapPoints[i].visible = true;
                }
                else
                    mySnapPoints[i].visible = false;
            }
        }

        function buildReferenceGeometry()
        {
            myReferenceGeometry = new THREE.Object3D();

            // The roll hud geometry is built with unit diameter and then scaled
            // to world space later.
            var geom   = new THREE.RingGeometry( 0.5 - 0.01 * myRingScale, 0.5, 60 );
            var circle = new THREE.Mesh( geom, myMaterial );

            myReferenceCircle = circle;

            var thick = 0.007 * myRingScale;
            var geomX = new THREE.BoxGeometry( 0.930, thick, thick );
            var geomY = new THREE.BoxGeometry( thick, 0.930, thick );
            var geomZ = new THREE.BoxGeometry( thick, thick, 0.930 );

            myReferenceXaxis = new THREE.Mesh( geomX, myMaterial );
            myReferenceYaxis = new THREE.Mesh( geomY, myMaterial );
            myReferenceZaxis = new THREE.Mesh( geomZ, myMaterial );

            myReferenceGeometry.add( myReferenceXaxis );
            myReferenceGeometry.add( myReferenceYaxis );
            myReferenceGeometry.add( myReferenceZaxis );

            myReferenceUp = new THREE.Mesh( new THREE.CircleGeometry( 0.005 ), myMaterial );
            myReferenceGeometry.add(myReferenceUp);

            mySnapPoints = new Array(6);
            mySnapFlags  = new Array(6);
            for( var i = 0;  i < 6;  ++i )
            {
                var r1 = 0.0050 * myRingScale;
                var r2 = 0.0025 * myRingScale;
                mySnapPoints[i] = new THREE.Mesh( new THREE.CircleGeometry( r1, 16 ), myMaterial );
                mySnapFlags[i]  = new THREE.Mesh( new THREE.CircleGeometry( r2, 16 ), myMaterial );
                mySnapFlags[i].visible = false;
                mySnapPoints[i].add(mySnapFlags[i]);
                circle.add(mySnapPoints[i]);
            }
            myReferenceGeometry.add( circle );

            return myReferenceGeometry;
        }

        function getReferenceGeometry(scale, lookAtPoint, viewVec, worldUp, cameraUp)
        {
            if( !myReferenceGeometry )
                myReferenceGeometry = buildReferenceGeometry();

            _navapi.orient(myReferenceCircle, lookAtPoint, myCamera.position, worldUp);

            updateSnapPoints(viewVec, cameraUp, worldUp);

            myReferenceGeometry.scale.x = scale;
            myReferenceGeometry.scale.y = scale;
            myReferenceGeometry.scale.z = scale;

            myReferenceGeometry.position.copy(lookAtPoint);

            return myReferenceGeometry;
        }

        function getSnapVector(index)
        {
            myVec1.set(0.0, 0.0, 0.0);
            if( index >= 0 )
            {
                var v = (index >= 3) ? -1 : 1;
                index %= 3;
                if( index === 0 ) myVec1.x = v;
                if( index === 1 ) myVec1.y = v;
                if( index === 2 ) myVec1.z = v;
            }
            if( myAnglesFlipped )
                myVec1.multiplyScalar(-1);

            return myVec1;
        }

        function closestSnap(dtheta, snapThresh)
        {
            var diff = angleDiff(mySnapAngles[0], dtheta);
            var closest = 0;
            for (var i = 1; i < 6; ++i)
            {
                var d = angleDiff(mySnapAngles[i], dtheta);
                if (d < diff)
                {
                    diff = d;
                    closest = i;
                }
            }
            myClosestAngle = diff;
            return (diff < snapThresh) ? closest : -1;
        }

        function setWorldUp(upvec)
        {
            _navapi.setWorldUpVector(upvec, true);
        }

        function applyRoll(angle)
        {
            if( angle === 0.0 )
                return;

            var kStableRollThreshold = 30.0 * Math.PI / 180.0;
            var view = myVec2.copy(myCamera.position).sub(myLookAtPoint).normalize();

            // Create a quaterion rotation about the roll axis by the angle:
            myRotate.setFromAxisAngle( view, angle );

            // Check the angle between the view vector and the world up.
            // When we get close the roll about the view vector becomes unstable
            // so we jump the up vector to the camera's current vertical.
            // This should be OK because if we're here we know we aren't snapped.
            var up = _navapi.getWorldUpVector();
            var viewUpAngle = Math.abs(view.angleTo(up));
            if( viewUpAngle < kStableRollThreshold || (Math.PI - viewUpAngle) < kStableRollThreshold )
            {
                // stderr("JUMP angle " + viewUpAngle.toFixed(3));
                up.copy(_navapi.getCameraUpVector());  // This is the actual camera up
            }
            // Rotate the current up vector by that quaternion:
            up.applyQuaternion( myRotate );

            // stderr("New UP: " + up.x.toFixed(2) + ", " + up.y.toFixed(2) + ", " + up.z.toFixed(2) );
            setWorldUp(up);
        }

        function justNowSnapped()
        {
            if( !myCurrentlySnapped )
            {
                var closest = closestSnap(myRollAngle, kSnapInThreshold);
                if( closest >= 0 )
                {
                    myClosestAngle = 0.0;
                    myCurrentlySnapped = true;
                    myRollAngle = mySnapAngles[closest];
                    return getSnapVector(closest);
                }
            }
            return false;
        }

        function justNowUnsnapped()
        {
            if( myCurrentlySnapped )
            {
                var closest = closestSnap(myRollAngle, kSnapOutThreshold);
                if( closest < 0 )
                {
                    // stderr("UNSNAP");
                    myCurrentlySnapped = false;
                    return true;
                }
                myClosestAngle = 0.0;
            }
            return false;
        }

        function isReallySnapped(angle, threshold, i, worldUp)
        {
            var circleSnapped = (angle < threshold);
            if( circleSnapped )
            {
                // Check if the up direction really is the same:
                var snapUp = getSnapVector(i);
                return (snapUp.distanceToSquared(worldUp) < kEpsilon);
            }
            return false;
        }

        function updateIndicators(worldUp, cameraUp)
        {
            // Check if the camera is upside down. If so, up is down.
            var wDotC = worldUp.dot(cameraUp);
            var flipped = (wDotC < 0.0);
            if( flipped )
                cameraUp = cameraUp.clone().multiplyScalar(-1);

            // Need to re-orient and position the UP indicator.
            // The scalar is the middle radius of the ring geometry.
            _navapi.orient(myReferenceUp, myLookAtPoint, myCamera.position, cameraUp);
            myReferenceUp.position.copy(cameraUp.multiplyScalar(0.495));

            var isSnapped = false;
            var threshold = myCurrentlySnapped ? kSnapOutThreshold : kSnapInThreshold;
            for (var i = 0; i < 6; ++i)
            {
                var angle = angleDiff(mySnapAngles[i], myRollAngle);
                var snapped = isReallySnapped(angle, threshold, i, worldUp);
                if( snapped )
                    isSnapped = true;
                var proximityScale = snapped ? 4.0 : (1.0 - 3.0 * angle / Math.PI) * 3.0;
                if( proximityScale < 1.0 )
                    proximityScale = 1.0;

                // Keep the snap point sizes independent of the ring size:
                proximityScale *= myRingScale;

                // This turns off/on the inner snap indicator circle within
                // each of the snap points:
                mySnapFlags[i].visible = snapped;
                var snap = mySnapPoints[i];
                snap.scale.x = proximityScale;
                snap.scale.y = proximityScale;
                snap.scale.z = proximityScale;
            }
            myReferenceXaxis.visible = isSnapped;
            myReferenceYaxis.visible = isSnapped;
            myReferenceZaxis.visible = isSnapped;

            return isSnapped;
        }

        this.updateRollCamera = function(size, distance)
        {
            myCamera.position.copy(mySceneCamera.position);
            myCamera.quaternion.copy(mySceneCamera.quaternion);
            myCamera.up.copy(mySceneCamera.up);
            myCamera.aspect = mySceneCamera.aspect;

            if( size && distance )
            {
                myCamera.near = distance - size;
                myCamera.far  = distance + size;
            }
            myCamera.updateProjectionMatrix();
        };

        this.isSnapped = function()
        {
            return myCurrentlySnapped;
        };

        this.resize = function()
        {
            var worldHeight = myDistance * kHudWorldScale;
            var worldWidth  = worldHeight * mySceneCamera.aspect;
            var worldSize   = ((mySceneCamera.aspect < 1.0) ? worldWidth : worldHeight) * myRingSize;

            myReferenceGeometry.scale.x = worldSize;
            myReferenceGeometry.scale.y = worldSize;
            myReferenceGeometry.scale.z = worldSize;
        };

        // TODO: Check for rolled camera and re-orient to up before setting up HUD.
        this.start = function(lookAtPoint, ringSize)
        {
            this.updateHUD(lookAtPoint, ringSize);
            viewerImpl.addOverlay("roll", myReferenceGeometry);
        };

        this.updateHUD = function(lookAtPoint, ringSize)
        {
            myLookAtPoint = lookAtPoint;

            if( ringSize < kRingSizeMin )
                ringSize = kRingSizeMin;
            else if( ringSize > kRingSizeMax )
                ringSize = kRingSizeMax;

            myRingSize  = ringSize;
            myRingScale = kRingSizeMax / ringSize;

            var viewVec = myVec1.copy(lookAtPoint).sub(mySceneCamera.position);
            myDistance = viewVec.length();

            var worldHeight = myDistance * kHudWorldScale;
            var worldWidth  = worldHeight * mySceneCamera.aspect;
            var worldSize   = ((mySceneCamera.aspect < 1.0) ? worldWidth : worldHeight) * ringSize;

            this.updateRollCamera(worldSize, myDistance);

            var worldUp  = _navapi.getWorldUpVector();
            var cameraUp = _navapi.getCameraUpVector();
            getReferenceGeometry(worldSize, lookAtPoint, viewVec, worldUp, cameraUp);
            myRollAngle = 0.0;
            mySnappedRoll = 0.0;

            var wDotC = worldUp.dot(cameraUp);
            myAnglesFlipped = (wDotC < 0.0);

            myCurrentlySnapped = updateIndicators(worldUp, cameraUp);
        };

        this.handleRoll = function( dx, dy, p2 )
        {
            this.updateRollCamera();

            updateIndicators(_navapi.getWorldUpVector(), _navapi.getCameraUpVector());

            if( dx !== 0.0 || dy !== 0.0 )
            {
                // 2D vectors from the center of the screen (0.5, 0.5)
                var v1x = p2.x - dx - 0.5;
                var v1y = p2.y - dy - 0.5;
                var v2x = p2.x - 0.5;
                var v2y = p2.y - 0.5;

                // Angle between those to vectors is the rotation of the mouse
                // around the center of the screen:
                return handleRollByAngle(Math.atan2(v2y, v2x) - Math.atan2(v1y, v1x));
            }
            return false;
        };

        this.handleRollTouch = function ( angle )
        {
            this.updateRollCamera();

            updateIndicators(_navapi.getWorldUpVector(), _navapi.getCameraUpVector());

            var delta = angle - myRollAngle;
            return (Math.abs(delta) > 0.001) ? handleRollByAngle(delta) : false;
        };

        function handleRollByAngle ( angle )
        {
            // Make sure it's in the right range for comparison with the
            // snap angles:
            myRollAngle += angle;
            if( myRollAngle > Math.PI )
                myRollAngle = myRollAngle - kTwo_PI;
            else if( myRollAngle <= -Math.PI )
                myRollAngle = kTwo_PI + myRollAngle;

            // stderr("ROLL: " + myRollAngle.toFixed(3));

            var snappedUp = justNowSnapped();
            if( snappedUp )
            {
                // stderr("SNAP: " + snappedUp.x + ", " + snappedUp.y + ", " + snappedUp.z );
                mySnappedRoll = myRollAngle;
                setWorldUp(snappedUp);
            }
            else if( justNowUnsnapped() )
            {
                // Because the snap points are "sticky" the roll amount
                // in this case is the distance from the snap point:
                var deltaRoll = myRollAngle - mySnappedRoll;
                applyRoll(deltaRoll);
                mySnappedRoll = 0.0;
            }
            else if( !myCurrentlySnapped )
            {
                applyRoll(angle);
            }
            else
                return false;

            return true;
        }

        this.end = function()
        {
            viewerImpl.removeOverlay("roll", myReferenceGeometry);
        };
    }

    var kTwo_PI  = 2.0 * Math.PI; // 360 degrees.
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;

    var _isDragging = false;
    var _needNextRefresh = false;
    var _started = false;

    var _rollInteraction = new RollInteraction(viewerImpl, _camera);
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _motionDelta = new THREE.Vector3();
    var _touchType = null;
    var _touchAngle = 0.0;
    var _touchCenter = { x: 0.5, y: 0.5 };
    var _touchDistance = 1.0;

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        viewerApi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
        _started = false;
    };

    this.deactivate = function(name)
    {
        _rollInteraction.end();
        viewerApi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
        this.utilities.restorePivot();
        _touchType = null;

        _isDragging = false;
        _started = false;
    };

    this.getCursor = function()
    {
        return "auto";
    };

    this.getMotionDelta = function(dxyz)
    {
        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);
    };

    this.stepMotionDelta = function()
    {
        _startXYZ.copy(_moveXYZ);
    };

    this.update = function()
    {
        if( !_started )
        {
            // Stash the current COI and while the interaction is active
            // use the center of the view as the pivot for rolling.
            //
            // Position the temporary COI half way between the near and far
            // clipping planes to avoid clipping problems:
            //
            var viewVec = _navapi.getEyeVector();
            var distance = (_camera.near + _camera.far) * 0.5;
            viewVec.normalize().multiplyScalar(distance);
            var target = viewVec.add(_camera.position);

            this.utilities.savePivot();
            this.utilities.setPivotPoint( target, true, true );
            this.utilities.pivotActive(true);

            // var ringSize = (_touchType === "roll") ? _touchDistance : kRingSizeDefault;
            var ringSize = kRingSizeDefault;
            _rollInteraction.start( target, ringSize );
            _started = true;
        }

        var moved = _needNextRefresh;

        this.getMotionDelta(_motionDelta);

        var deltaX = _motionDelta.x;
        var deltaY = _motionDelta.y;
        var deltaZ = _motionDelta.z;

        if( _needNextRefresh || _touchType === "roll" || _isDragging && (deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0) )
        {
            if( _touchType === "roll" )
                _needNextRefresh = _rollInteraction.handleRollTouch(_touchAngle);
            else
                _needNextRefresh = _rollInteraction.handleRoll(deltaX, deltaY, _moveXYZ);
        }
        this.stepMotionDelta();

        if( _camera.dirty )
            moved = true;

        return moved;
    };

    this.handleResize = function()
    {
        _rollInteraction.resize();
        _needNextRefresh = true;
    };

    function fingerSeparation(event)
    {
        var dx = event.pointers[1].clientX - event.pointers[0].clientX;
        var dy = event.pointers[1].clientY - event.pointers[0].clientY;
        var dist = Math.sqrt(dx * dx + dy * dy);

        // Normalize:
        var vp = _navapi.getScreenViewport();
        return dist / Math.min(vp.width, vp.height);
    }

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            // Single touch, fake the mouse for now...
            case "dragstart":
                _touchType = "drag";
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return this.handleMouseMove(event);

            case "dragend":
                _touchType = null;
                return this.handleButtonUp(event, 0);


            // Rotate gesture detected:
            case "rotatestart":
                viewerApi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
                _touchType = "roll";
                _touchAngle = THREE.Math.degToRad(event.rotation);
                _touchCenter = {
                    x: (event.normalizedX + 1.0) * 0.5,
                    y: 1.0 - (event.normalizedY + 1.0) * 0.5
                };
                _touchDistance = fingerSeparation(event);
                return true;

            case "rotatemove":
                _touchAngle = THREE.Math.degToRad(event.rotation);
                return (_touchType === "roll");

            case "rotateend":
                viewerApi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
                _touchAngle = THREE.Math.degToRad(event.rotation);
                _touchType = null;

                // Sigh... minor hack
                // Can't consume the end event because the hot gesture
                // tool needs to see it to end the interaction.
                return false;
        }
        return false;
    };

    this.handleWheelInput = function(delta)
    {
        // Disable wheel while roll active:
        return true;
    };

    this.handleCameraChange = function()
    {
        var viewVec = _navapi.getEyeVector();
        var distance = (_camera.near + _camera.far) * 0.5;
        viewVec.normalize().multiplyScalar(distance);
        var target = viewVec.add(_camera.position);

        // Setting the pivot causes an infinite loop of camera changed events. Is it necessary to set it?
        //this.utilities.savePivot();
        //this.utilities.setPivotPoint( target, true, true );
        //this.utilities.pivotActive(true);

        _rollInteraction.updateHUD( target, kRingSizeDefault );
    };

    this.handleButtonDown = function( event, button )
    {
        _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _moveXYZ.copy(_startXYZ);

        _isDragging = true;
        _touchType = null;

        this.controller.setIsLocked(true);

        viewerApi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.handleCameraChange);

        return true;
    };

    this.handleButtonUp = function( event, button )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _isDragging = false;
        _needNextRefresh = true;    // To accept final motion.

        this.controller.setIsLocked(false);

        viewerApi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.handleCameraChange);

        return true;
    };

    this.handleMouseMove = function( event )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        return true;
    };

    this.handleBlur = function(event)
    {
        _isDragging = false;
        _touchType = null;
        return false;
    };

};
;AutodeskNamespace('Autodesk.Viewing');

/** This class may be used as a base class for new interaction tools or simply as a template for creating a new tool.
 *  @class
 *  @constructor
 *  @see Autodesk.Viewing.ToolController
 */
Autodesk.Viewing.ToolInterface = function()
{
    this.names = [ "unnamed" ];

    /**
     * This method should return an array containing the names of all tools implemented by this class. Often this would be a single name but it is possible to support multiple interactions with a single tool. When this tool is registered with the ToolController each name gets registered as an available tool.
     *  @returns {Array} - Array of strings. Should not be empty.
     */
    this.getNames = function() {
        return this.names;
    };

    /**
     * This is an optional convenience method to obtain the first name of this tool.
     * @returns {string} - The tools default name.
     */
    this.getName = function() {
        return this.names[0];
    };

    /**
     * This method is called by the ToolController.registerTool()
     * Use this as initialization
     */
    this.register = function() {
    };

    /**
     * This method is called by the ToolController.deregisterTool()
     * Use this to clean up your tool
     */
    this.deregister = function() {
    };

    /**
     * The activate method is called by the ToolController when it adds this tool to the list of those to receive event handling calls. Once activated, a tool's "handle*" methods may be called if no other higher priority tool handles the given event. Each active tool's "update" method also gets called once during each redraw loop.
     * @param {string} name - The name under which the tool has been activated.
     * @param {Autodesk.Viewing.Viewer3D} viewerApi - viewer instance
     */
    this.activate = function(name, viewerApi) {
    };

    /**
     * The deactivate method is called by the ToolController when it removes this tool from the list of those to receive event handling calls. Once deactivated, a tool's "handle*" methods and "update" method will no longer be called.
     * @param {string} name - The name under which the tool has been deactivated.
     */
    this.deactivate = function(name) {
    };

    /**
     * The update method is called by the ToolController once per frame and provides each tool with the oportunity to make modifications to the scene or the view.
     * @returns {boolean} - A state value indicating whether the tool has modified the view or the scene and a full refresh is required.
     */
    this.update = function() {
        return false;
    };

    /**
     * This method is called when a single mouse button click occurs.
     * @param {MouseEvent} event - the event object that triggered this call.
     * @param {Number} button - the button number that was clicked (0, 1, 2 for Left, Middle, Right respectively). Note that the button parameter value may be different that the button value indicated in the event object due to button re-mapping preferences that may be applied. This value should be respected over the value in the event object.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleSingleClick = function( event, button ) {
        return false;
    };

    /**
     * This method is called when a double mouse button click occurs.
     * @param {MouseEvent} event - the event object that triggered this call.
     * @param {Number} button - the button number that was clicked (0, 1, 2 for Left, Middle, Right respectively). Note that the button parameter value may be different that the button value indicated in the event object due to button re-mapping preferences that may be applied. This value should be respected over the value in the event object.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleDoubleClick = function( event, button ) {
        return false;
    };

    /**
     * This method is called when a single tap on a touch device occurs.
     * @param {Event} event - The triggering event. For tap events the canvasX, canvasY properties contain the canvas relative device coordinates of the tap and the normalizedX, normalizedY properties contain the tap coordinates in the normalized [-1, 1] range. The event.pointers array will contain either one or two touch events depending on whether the tap used one or two fingers.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleSingleTap = function( event ) {
        return false;
    };

    /**
     * This method is called when a double tap on a touch device occurs.
     * @param {Event} event - The triggering event. For tap events the canvasX, canvasY properties contain the canvas relative device coordinates of the tap and the normalizedX, normalizedY properties contain the tap coordinates in the normalized [-1, 1] range. The event.pointers array will contain either one or two touch events depending on whether the tap used one or two fingers.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleDoubleTap = function( event ) {
        return false;
    };

    /**
     * This method is called when a keyboard button is depressed.
     * @param {KeyboardEvent} event - the event object that triggered this call.
     * @param {Number} keyCode - the numerical key code identifying the key that was depressed. Note that the keyCode parameter value may be different that the value indicated in the event object due to key re-mapping preferences that may be applied. This value should be respected over the value in the event object.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleKeyDown = function( event, keyCode ) {
        return false;
    };

    /**
     * This method is called when a keyboard button is released.
     * @param {KeyboardEvent} event - the event object that triggered this call.
     * @param {Number} keyCode - the numerical key code identifying the key that was released. Note that the keyCode parameter value may be different that the value indicated in the event object due to key re-mapping preferences that may be applied. This value should be respected over the value in the event object.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleKeyUp = function( event, keyCode ) {
        return false;
    };

    /**
     * This method is called when a mouse wheel event occurs.
     * @param {Number} delta - a numerical value indicating the amount of wheel motion applied. Note that this value may be modified from the orignal event values so as to provide consistent results across browser families.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleWheelInput = function(delta) {
        return false;
    };

    /**
     * This method is called when a mouse button is depressed.
     * @param {MouseEvent} event - the event object that triggered this call.
     * @param {Number} button - the button number that was depressed (0, 1, 2 for Left, Middle, Right respectively). Note that the button parameter value may be different that the button value indicated in the event object due to button re-mapping preferences that may be applied. This value should be respected over the value in the event object.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleButtonDown = function(event, button) {
        return false;
    };

    /**
     * This method is called when a mouse button is released.
     * @param {MouseEvent} event - the event object that triggered this call.
     * @param {Number} button - the button number that was released (0, 1, 2 for Left, Middle, Right respectively). Note that the button parameter value may be different that the button value indicated in the event object due to button re-mapping preferences that may be applied. This value should be respected over the value in the event object.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleButtonUp = function(event, button) {
        return false;
    };

    /**
     * This method is called when a mouse motion event occurs.
     * @param {MouseEvent} event - the event object that triggered this call.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleMouseMove = function(event) {
        return false;
    };

    /**
     * This method is called when a touch gesture event occurs.
     * @param {Event} event - the event object that triggered this call. The event.type attribute will indicate the gesture event type. This will be one of: dragstart, dragmove, dragend, panstart, panmove, panend, pinchstart, pinchmove, pinchend, rotatestart, rotatemove, rotateend, drag3start, drag3move, drag3end. The event.canvas[XY] attributes will contain the coresponding touch position. The event.scale and event.rotation attributes contain pinch scaling and two finger rotation quantities respectively. The deltaX and deltaY attributes will contain drag offsets.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleGesture = function(event) {
        return false;
    };

    /**
     * This method is called when the canvas area loses focus.
     * @param {FocusEvent} event - the event object that triggered this call.
     * @returns {boolean} - True if this tool wishes to consume the event and false to continue to pass the event to lower priority active tools.
     */
    this.handleBlur = function(event) {
        return false;
    };

    /**
     * This method is called on every active tool whenever the screen area changes. The new canvas area can be obtained from the Navigation interface via the getScreenViewport method.
     * @see Autodesk.Viewing.Navigation
     */
    this.handleResize = function() {
    };
};
;
(function() {

'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

function Selector(viewer, model) {

    //Selection support
    var _this = this;
    this.selectedObjectIds = {};
    this.selectionCount = 0;
    this.selectionMode = av.SelectionMode.LEAF_OBJECT;

    var selectedParentMap = {};

    function getInstanceTree() {
        return model.getData().instanceTree;
    }

    function fireSelectionChangedEvent() {
        //Nothing here, events are done by the MultiModelSelector now.
    }


    function unmarkObject(dbId) {

        var it = getInstanceTree();

        if (selectedParentMap[dbId] > 0) {
            selectedParentMap[dbId]--;
            if (selectedParentMap[dbId] == 0) {
                viewer.highlightObjectNode(model, dbId, false);
            }

        } else if (selectedParentMap[dbId] < 0) {
            throw ("Selection State machine broken. Negatively selected object!");
        }

        if (it) {
            it.enumNodeChildren(dbId, function(childId) {
                unmarkObject(childId);
            }, false);
        }
    }
    

    function markObject(dbId, isChild) {

        var it = getInstanceTree();

        if (selectedParentMap[dbId]) {
            selectedParentMap[dbId]++;
        } else {
            viewer.highlightObjectNode(model, dbId, true, isChild);
            selectedParentMap[dbId] = 1;
        }
        
        if (it) {
            it.enumNodeChildren(dbId, function(childId) {
                markObject(childId, true);
            }, false);
        }
    }

    function isSelected(dbId) {

        if ((dbId !== undefined) && _this.selectedObjectIds[dbId])
            return true;
    }


    function select(dbId) {

        var it = getInstanceTree();
        if (it) {
            dbId = it.findNodeForSelection(dbId, _this.selectionMode);

            if (!it.isNodeSelectable(dbId))
                return;
        }

        var found = isSelected(dbId);
        if (!found) {
            _this.selectedObjectIds[dbId] = dbId;
            _this.selectionCount++;
            markObject(dbId);
        }
    }

    function deselect(dbId) {

        var found = isSelected(dbId);
        if (found) {
            unmarkObject(dbId);
            _this.selectedObjectIds[dbId] = 0;
            _this.selectionCount--;
        }
    }

    function selectionIsEqual(dbNodeArray) {
        if( _this.selectionCount !== dbNodeArray.length )
            return false;

        for (var i = 0; i < dbNodeArray.length; i++) {
            if (!isSelected(dbNodeArray[i]))
                return false;
        }
        return true;
    }


    this.getInstanceTree = getInstanceTree;

    this.getSelectionLength = function() {
        return _this.selectionCount;
    };


    this.getSelection = function() {
        var ret = [];
        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            if (sset[p]) {
                var dbId = parseInt(p);
                ret.push(dbId);
            }
        }

        return ret;
    };

    this.clearSelection = function(nofire) {
        if (this.selectionCount > 0) {
            var sset = _this.selectedObjectIds;
            for (var p in sset) {
                var dbId = parseInt(p);
                if (dbId !== undefined)
                    unmarkObject(dbId);
            }
            _this.selectedObjectIds = {};
            _this.selectionCount = 0;

            if( !nofire )
                fireSelectionChangedEvent();
        }
    };

    this.deselectInvisible = function() {
        var changed = false;

        var sset = _this.selectedObjectIds;
        var it = getInstanceTree();
        for (var p in sset) {
            var dbId = parseInt(p);
            var hidden = it.isNodeHidden(dbId);
            if (dbId && hidden) {
                deselect(dbId);
                changed = true;
            }
        }

        if (changed) {
            fireSelectionChangedEvent();
        }

        return changed;
    };


    // TODO: Optimize this so both select and toggleSelection don't have to lookup the node index.
    this.toggleSelection = function(dbId) {

        if (!dbId) {
            console.error("Attempting to select node 0.");
            return;
        }

        if (!isSelected(dbId)) {
            select(dbId);
        } else {
            deselect(dbId);
        }
        fireSelectionChangedEvent();
    };


    this.setSelectionMode = function(mode) {
        this.clearSelection(true);
        this.selectionMode = mode;
    };

    this.setSelection = function(dbNodeArray) {

        if( selectionIsEqual( dbNodeArray ) )
            return;

        this.clearSelection(true);

        if (dbNodeArray == null || dbNodeArray.length === 0)
            return;

        for (var i = 0; i < dbNodeArray.length; i++) {
            select(dbNodeArray[i]);
        }

        fireSelectionChangedEvent();
    };


    this.getSelectionBounds = function() {
        var bounds = new THREE.Box3();
        var box = new THREE.Box3();

        var instanceTree = getInstanceTree();
        var fragList = model.getFragmentList();
        
        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            var dbId = parseInt(p);
            instanceTree.enumNodeFragments(dbId, function(fragId) {
                fragList.getWorldBounds(fragId, box);
                bounds.union(box);
            }, true);
        }
        
        return bounds;
    };

    this.getSelectionVisibility = function () {
        var hasVisible = false,
            hasHidden = false;

        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            var dbId = parseInt(p);
            if (dbId) {
                var it = getInstanceTree();
                if (!it || !it.isNodeHidden(dbId)) {
                    hasVisible = true;
                } else {
                    hasHidden = true;
                }
                if (hasVisible && hasHidden) {
                    break;
                }
            }
        }

        return {hasVisible: hasVisible, hasHidden: hasHidden};
    };

    this.dtor = function () {
        this.selectedObjectIds = null;
    };

}

avp.Selector = Selector;


function MultiModelSelector(viewer) {

    var _models = [];

    this.addModel = function(model) {
        if (_models.indexOf(model) == -1) {
            model.selector = new Selector(viewer, model);
            _models.push(model);
        }
    };

    this.removeModel = function(model) {
        var idx = _models.indexOf(model);
        model.selector = null;
        _models.splice(idx, 1);
    };

    function warn() {
        if (_models.length > 1) {
            stderr("This selection call does not yet support multiple models.");
        }
    }

    function fireAggregateSelectionChangedEvent() {

        var perModel = [];

        for (var i=0; i<_models.length; i++) {
            var dbIdArray = [];
            var fragIdsArray = [];

            var sset = _models[i].selector.selectedObjectIds;
            var it = _models[i].selector.getInstanceTree();
            for (var p in sset) {
                if (sset[p]) {
                    var dbId = parseInt(p);
                    if (dbId) {
                        dbIdArray.push(dbId);

                        if (it) {
                            it.enumNodeFragments(dbId, function (fragId) {
                                fragIdsArray.push(fragId);
                            }, false);
                        }
                    }
                }
            }

            if (dbIdArray.length) {
                perModel.push({
                    fragIdsArray: fragIdsArray,
                    dbIdArray: dbIdArray,
                    nodeArray: dbIdArray,
                    model: _models[i]
                });
            }
        }

        var event;

        //For backwards compatibility, fire the old selection change event
        //when there is just one model in the scene
        if (_models.length === 1) {
            event = {
                type: av.SELECTION_CHANGED_EVENT,
                fragIdsArray: perModel[0] ? perModel[0].fragIdsArray : [],
                dbIdArray: perModel[0] ? perModel[0].dbIdArray : [],
                nodeArray: perModel[0] ? perModel[0].dbIdArray : [],
                model: _models[0]
            };
            viewer.api.fireEvent(event);
        }

        //Always fire the aggregate selection changed event
        event = {
            type: av.AGGREGATE_SELECTION_CHANGED_EVENT,
            selections: perModel
        };
        viewer.api.fireEvent(event);

    }


    function deselectInvisible() {

        var changed = false;

        for (var i=0; i<_models.length; i++) {
            changed = _models[i].selector.deselectInvisible() || changed;
        }

        if (changed)
            fireAggregateSelectionChangedEvent();
    }


    this.getSelectionLength = function() {
        warn();
        return _models[0].selector.getSelectionLength();
    };

    this.getSelection = function() {
        warn();
        if (_models.length > 1)
            console.warn("Use getAggregateSelection instead of getSelection when there are multiple models in the scene.");
        return _models[0].selector.getSelection();
    };

    this.getAggregateSelection = function() {
        var res = [];
        for (var i=0; i<_models.length; i++) {
            var selset = _models[i].selector.getSelection();
            if (selset && selset.length)
                res.push( { model:_models[i], selection:selset } );
        }

        return res;
    };

    this.clearSelection = function(nofire) {
        for (var i=0; i<_models.length; i++)
            _models[i].selector.clearSelection(nofire);

        if (!nofire)
            fireAggregateSelectionChangedEvent();
    };

    this.toggleSelection = function(dbId, model) {
        if (!model) {
            warn();
            model = _models[0];
        }
        model.selector.toggleSelection(dbId);

        fireAggregateSelectionChangedEvent();
    };

    this.setSelectionMode = function(mode) {
        for (var i=0; i<_models.length; i++)
            _models[i].selector.setSelectionMode(mode);
    };

    this.setSelection = function(dbNodeArray, model) {
        if (!dbNodeArray || dbNodeArray.length === 0)
            this.clearSelection();
        else {
            if (!model) {
                warn();
                model = _models[0];
            } else {
                for (var i=0; i<_models.length; i++)
                    if (_models[i] !== model)
                         _models[i].selector.clearSelection();
            }
            model.selector.setSelection(dbNodeArray);
        }

        fireAggregateSelectionChangedEvent();
    };

    this.getSelectionBounds = function() {
        if (_models.length == 1)
            return _models[0].selector.getSelectionBounds();
        else {
            var bbox = new THREE.Box3();
            for (var i=0; i<_models.length; i++) {
                var tmp = _models[i].selector.getSelectionBounds();
                bbox.union(tmp);
            }
            return bbox;
        }
    };

    this.getSelectionVisibility = function () {
        warn();
        return _models[0].selector.getSelectionVisibility();
    };

    this.dtor = function () {
        for (var i=0; i<_models.length; i++)
            _models[i].selector.dtor();
    };


    viewer.api.addEventListener( av.ISOLATE_EVENT, function(event) {
        deselectInvisible();
    });

    viewer.api.addEventListener( av.HIDE_EVENT, function(event) {
        deselectInvisible();
    });


}

avp.MultiModelSelector = MultiModelSelector;


})();
;
(function() {

    'use strict';

    var av = Autodesk.Viewing,
        avp = av.Private;

    var VisibilityManager = function (viewerImpl, model) {
        this.viewerImpl = viewerImpl;

        //Currently the visibility manager works on a single model only
        //so we make this explicit here.
        this.model = model;

        // Keep track of isolated nodes
        this.isolatedNodes = [];

        // Keeps track of hidden nodes. Only applies when there's no isolated node being tracked.
        this.hiddenNodes = [];
    };

    VisibilityManager.prototype.getInstanceTree = function () {
        if (this.model)
            return this.model.getData().instanceTree;
        else
            return null;
    };

    VisibilityManager.prototype.getIsolatedNodes = function () {
        return this.isolatedNodes.slice(0);
    };

    VisibilityManager.prototype.getHiddenNodes = function () {
        return this.hiddenNodes.slice(0);
    };

    VisibilityManager.prototype.isolate = function (node) {
        var rootId = this.getInstanceTree().getRootId();
        var isRoot = (typeof node == "number" && node === rootId)
            || (typeof node == "object" && node.dbId === rootId);

        if (node && !isRoot) {
            this.isolateMultiple(Array.isArray(node) ? node : [node]);
        } else {
            this.isolateNone();
        }
    };

    VisibilityManager.prototype.isolateNone = function () {

        this.model.setAllVisibility(true);
        this.viewerImpl.sceneUpdated(true);

        var root = this.model ? this.model.getRootId() : null;
        if (root) {
            this.setVisibilityOnNode(root, true);
        }

        this.hiddenNodes = [];
        this.isolatedNodes = [];
        this.viewerImpl.invalidate(true);

        var event = {type: av.ISOLATE_EVENT, nodeIdArray: [], model: this.model};
        this.viewerImpl.api.fireEvent(event);
    };

//Makes the children of a given node visible and
//everything else not visible
    VisibilityManager.prototype.isolateMultiple = function (nodeList) {

        //If given nodelist is null or is an empty array or contains the whole tree
        if (!nodeList || nodeList.length == 0) {
            this.isolateNone();
        }
        else {

            var root = this.model.getRootId();
            if (root) {
                this.setVisibilityOnNode(root, false);
            }
            this.model.setAllVisibility(false);
            this.viewerImpl.sceneUpdated(true);

            // Needs to happen after setVisibilityOnNode(root).
            this.isolatedNodes = nodeList.slice(0);
            this.hiddenNodes = [];

            for (var i = 0; i < nodeList.length; i++) {
                this.setVisibilityOnNode(nodeList[i], true);
            }

            var event = {type: av.ISOLATE_EVENT, nodeIdArray: nodeList, model: this.model};
            this.viewerImpl.api.fireEvent(event);
        }

        //force a repaint and a clear
        this.viewerImpl.invalidate(true);
    };


//Makes the children of a given node visible and
//everything else not visible
    VisibilityManager.prototype.hide = function (node) {
        
        var event;
        
        if (Array.isArray(node)) {
            for (var i = 0; i < node.length; ++i) {
                this.setVisibilityOnNode(node[i], false);
            }

            if (node.length > 0) {
                event = {type: av.HIDE_EVENT, nodeIdArray: node};
            }
        } else {
            this.setVisibilityOnNode(node, false);
            event = {type: av.HIDE_EVENT, nodeIdArray: [node]};
        }

        if (event)
            this.viewerImpl.api.fireEvent(event);
    };

    VisibilityManager.prototype.show = function (node) {
        
        var event;
        
        if (Array.isArray(node)) {
            for (var i = 0; i < node.length; ++i) {
                this.setVisibilityOnNode(node[i], true);
            }
    
            if (node.length > 0) {
                event = {type: av.SHOW_EVENT, nodeIdArray: node};
            }        
        } else {
            this.setVisibilityOnNode(node, true);
            event = {type: av.SHOW_EVENT, nodeIdArray: [node]};
        }

        if (event)
            this.viewerImpl.api.fireEvent(event);
    };

    VisibilityManager.prototype.toggleVisibility = function (node) {
        var hidden = this.getInstanceTree().isNodeHidden(node);
        this.setVisibilityOnNode(node, hidden); //Note -- toggle visibility, so we want !!hidden => hidden

        var event = {type: hidden ? av.SHOW_EVENT : av.HIDE_EVENT, nodeIdArray: [node]};
        this.viewerImpl.api.fireEvent(event);
    };

    VisibilityManager.prototype.setVisibilityOnNode = function (node, visible) {

        var viewer = this.viewerImpl;
        var model = this.model;
        var instanceTree = this.getInstanceTree();
        var hidden = !visible;

        if (instanceTree) {
            //Recursively process the tree under the root (recursion is inclusive of the root)
            instanceTree.enumNodeChildren(node, function (dbId) {

                instanceTree.setNodeHidden(dbId, hidden);
                instanceTree.enumNodeFragments(dbId, function (fragId) {
                    model.setVisibility(fragId, visible);
                }, false);

            }, true);
        } else {
            //No instance tree, assume fragId = dbId
            model.setVisibility(node, visible);
        }

        
        viewer.sceneUpdated(true);
        this.updateNodeVisibilityTracking(node, visible);
    };

    VisibilityManager.prototype.updateNodeVisibilityTracking = function(node, visible) {

        // Update hidden tracking array.
        var toVisible = visible;
        if (this.isolatedNodes.length > 0) {
            var isoIndex = this.isolatedNodes.indexOf(node);
            if (toVisible && isoIndex === -1) {
                this.isolatedNodes.push(node);
            }
            else if (!toVisible && isoIndex !== -1) {
                this.isolatedNodes.splice(isoIndex, 1);
            }
        } else {
            var hidIndex = this.hiddenNodes.indexOf(node);
            if (!toVisible && hidIndex === -1) {
                this.hiddenNodes.push(node);
            }
            else if (toVisible && hidIndex !== -1) {
                this.hiddenNodes.splice(hidIndex, 1);
            }
        }

        // When operating with the node, we can get simplify stuff.
        var instanceTree = this.getInstanceTree();
        if (instanceTree && instanceTree.root && instanceTree.root.dbId === node) {
            if (visible) {
                this.isolatedNodes = [];
                this.hiddenNodes = [];
            } else {
                this.isolatedNodes = [];
                this.hiddenNodes = [node];
            }
        }
    };

    VisibilityManager.prototype.setNodeOff = function (node, isOff) {
        var viewer = this.viewerImpl;
        var model = this.model;
        var instanceTree = this.getInstanceTree();

        if (instanceTree) {
            //Recursively process the tree under the root (recursion is inclusive of the root)
            instanceTree.enumNodeChildren(node, function (dbId) {

                instanceTree.setNodeOff(dbId, isOff);

                instanceTree.enumNodeFragments(dbId, function (fragId) {
                    model.getFragmentList().setFragOff(fragId, isOff);
                }, false);

            }, true);
        } else {
            model.getFragmentList().setFragOff(node, isOff);
        }

        viewer.sceneUpdated(true);
    };


    av.Private.VisibilityManager = VisibilityManager;
    
    
    
    function MultiModelVisibilityManager(viewer) {
    
        this.viewer = viewer;
        this.models = [];
    
    }
    
    MultiModelVisibilityManager.prototype.addModel = function(model) {
        if (this.models.indexOf(model) == -1) {
            model.visibilityManager = new VisibilityManager(this.viewer, model);
            this.models.push(model);
        }
    };

    MultiModelVisibilityManager.prototype.removeModel = function(model) {
        var idx = this.models.indexOf(model);
        model.visibilityManager = null;
        this.models.splice(idx, 1);
    };

    MultiModelVisibilityManager.prototype.warn = function() {
        if (this.models.length > 1) {
            stderr("This selection call does not yet support multiple models.");
        }
    };

    
    MultiModelVisibilityManager.prototype.getIsolatedNodes = function (model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        return model.visibilityManager.getIsolatedNodes();
    };

    MultiModelVisibilityManager.prototype.getHiddenNodes = function (model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        return model.visibilityManager.getHiddenNodes();
    };

    MultiModelVisibilityManager.prototype.isolate = function (node, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.isolate(node);
    };

//Makes the children of a given node visible and
//everything else not visible
    MultiModelVisibilityManager.prototype.hide = function (node, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.hide(node);
    };

    MultiModelVisibilityManager.prototype.show = function (node, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.show(node);
    };

    MultiModelVisibilityManager.prototype.toggleVisibility = function (node, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.toggleVisibility(node);        
    };

    MultiModelVisibilityManager.prototype.setVisibilityOnNode = function (node, visible, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.setVisibilityOnNode(node, visible);
    };

    MultiModelVisibilityManager.prototype.setNodeOff = function (node, isOff, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.setNodeOff(node, isOff);
    };

    
    
    av.Private.MultiModelVisibilityManager = MultiModelVisibilityManager;

})();;

//Those are globals -- set by the build system.
if (!LMV_WORKER_URL)
    var LMV_WORKER_URL = "src/workers/MainWorker-web.js";

if (ENABLE_INLINE_WORKER == undefined)
    var ENABLE_INLINE_WORKER = false;


(function(){

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

// A cache of entire worker script as data URL.
var WORKER_DATA_URL = null;
var WORKER_FETCHING_SCRIPT = false;
var WORKER_FETCHING_CALLBACKS = [];


avp.initWorkerScript = function(successCB, errorCB) {

    if (ENABLE_INLINE_WORKER && !WORKER_DATA_URL) {

        WORKER_FETCHING_CALLBACKS.push({
            successCB: successCB
        });

        if (WORKER_FETCHING_SCRIPT) {
            return;
        }

        var xhr = new XMLHttpRequest();
        var scriptURL = LMV_WORKER_URL;

        // We need to request the same version of the library for this worker.  Take the original
        // script url, which will already have the version string (if provided).
        //
        var originalScriptURL = avp.getResourceUrl(LMV_WORKER_URL);

        if (originalScriptURL) {
            scriptURL = originalScriptURL;
        }

        xhr.open("GET", scriptURL, true);
        xhr.withCredentials = false;

        xhr.onload = function () {

            // Set up global cached worker script.
            WORKER_FETCHING_SCRIPT = false;
            var blob;
            window.URL = window.URL || window.webkitURL;

            try {
                blob = new Blob([xhr.responseText], {type: 'application/javascript'});
            } catch (e) {
                // Backward compatibility.
                blob = new BlobBuilder();
                blob.append(xhr.responseText);
                blob = blob.getBlob();
            }
            WORKER_DATA_URL = URL.createObjectURL(blob);

            var callbacks = WORKER_FETCHING_CALLBACKS.concat(); // Shallow copy
            WORKER_FETCHING_CALLBACKS = [];
            for (var i=0; i<callbacks.length; ++i) {
                callbacks[i].successCB && callbacks[i].successCB();
            }
        };

        WORKER_FETCHING_SCRIPT = true;
        xhr.send();

    } else {
        if (successCB)
            successCB();
    }

};

// Create a web worker.
avp.createWorker = function() {

    var w;

    // When we are not at release mode, create web worker directly from URL.
    if ( ENABLE_INLINE_WORKER ) {
        w = new Worker(WORKER_DATA_URL);
    } else {
        w = new Worker( avp.getResourceUrl(LMV_WORKER_URL) );
    }

    w.doOperation = w.postMessage;

    return w;
};
    

avp.createWorkerWithIntercept = function() {
    var worker = avp.createWorker();

    worker.checkEvent = function(e) {
        if (e.data && e.data.assetRequest) {
            if (avp.assets) {
                avp.assets.push(e.data.assetRequest)
            }
            return true;
        }
        return false;
    };

    var interceptListeners = [];
    function popCallback(listener) {
        if (!interceptListeners) return null;
        for (var i=0; i<interceptListeners.length; ++i) {
            if (interceptListeners[i].arg === listener) {
                 var ret = interceptListeners[i].callback;
                interceptListeners.splice(i, 1);
                if (interceptListeners.length === 0)
                    interceptListeners = null;
                return ret;
            }
        }
        return null;
    }

    worker.addEventListenerWithIntercept = function (listener) {
        
        var callbackFn = function(ew) {
            if (worker.checkEvent(ew))
                return;

            listener(ew);
        };

        if (!interceptListeners) interceptListeners = [];
        interceptListeners.push({ arg: listener, callback: callbackFn });
        worker.addEventListener('message', callbackFn, false);
        return callbackFn;
    };

    worker.removeEventListenerWithIntercept = function(listener) {
        var callbackFn = popCallback(listener);
        if (callbackFn) {
            worker.removeEventListener('message', callbackFn, false);
        }
    };

    worker.clearAllEventListenerWithIntercept = function() {
        if (!interceptListeners) return;
        var copy = interceptListeners.concat();
        for (var i=0; i<copy.length; ++i) {
            worker.removeEventListenerWithIntercept(copy[i].arg);
        }
    };

    return worker;
}
    



})();;
(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

    var WORKER_GET_PROPERTIES = "GET_PROPERTIES";
    var WORKER_SEARCH_PROPERTIES = "SEARCH_PROPERTIES";
    var WORKER_BUILD_EXTERNAL_ID_MAPPING = "BUILD_EXTERNAL_ID_MAPPING";
    var WORKER_GET_OBJECT_TREE = "GET_OBJECT_TREE";
    var WORKER_ATTRIBUTES_MAP = "ATTRIBUTES_MAP";

    //TODO: pass in the model instead of the model.svf
    var PropDbLoader = function(sharedDbPath, model, eventTarget) {

        this.sharedDbPath = sharedDbPath;

        this.propWorker = null;
        this.eventTarget = eventTarget;
        this.model = model;
        this.svf = model.getData();
        
        
        //Sigh -- see SvfLoader for similar stuff
        this.domainParam = auth ? ("domain=" + encodeURIComponent(window.location.origin)) : "";
    };

    PropDbLoader.prototype.dtor = function() {
        if (this.propWorker && !this.sharedDbPath) {
            this.propWorker.clearAllEventListenerWithIntercept();
            this.propWorker.terminate();
            this.propWorker = null;
        }
    };



    //Cache of property workers per property database path.
    //Many bubbles (Revit, AutoCAD) share the same property database
    //across all viewables, so we can reuse the same worker for all
    //sheets. This is particularly important for gigantic Revit property databases.
    var propWorkerCache = {};

    var PROPDB_CB_COUNTER = 1;
    var PROPDB_CALLBACKS = {};

    function propertyWorkerCallback(e) {

        var data = e.data;

        if (data && data.debug) {
            stderr(data.message);
            return;
        }

        if (data.cbId) {
            var cbs = PROPDB_CALLBACKS[data.cbId];

            if (data && data.error) {
                if (cbs[1])
                    cbs[1](data.error);
            } else {
                if (cbs[0])
                    cbs[0](data.result);
            }

            delete PROPDB_CALLBACKS[data.cbId];
        }

    }

    function registerWorkerCallback(onSuccess, onError) {
        var cbId = PROPDB_CB_COUNTER++;

        PROPDB_CALLBACKS[cbId] = [onSuccess, onError];

        return cbId;
    }

    PropDbLoader.prototype.processLoadResult = function(result) {
        var scope = this;

        if (result.instanceTreeStorage) {

            var nodeAccess = new avp.InstanceTreeAccess(result.instanceTreeStorage, result.rootId, result.instanceBoxes);

            scope.svf.instanceTree = new avp.InstanceTree(nodeAccess, result.objectCount, result.maxTreeDepth);

            scope.svf.fragToNodeDone = true;
        }
        else if (result.objectCount) {
            //Case where there is no object tree, but objects
            //do still have properties. This is the case for F2D drawings.
            scope.svf.hasObjectProperties = result.objectCount;
            //stderr("Object count " + ew.data.objectCount);
        }

        scope.eventTarget.fireEvent({
            type: av.OBJECT_TREE_CREATED_EVENT,
            svf:scope.svf,
            model:scope.model
        });

    };

    PropDbLoader.prototype.processLoadError = function(error) {

        var scope = this;

        scope.propertyDbError = error;
        scope.eventTarget.fireEvent({
            type: av.OBJECT_TREE_UNAVAILABLE_EVENT,
            svf:scope.svf,
            model:scope.model
        });
    };


    PropDbLoader.prototype.load = function() {
        var scope = this;

        var onObjectTreeRead = function(result) {

            scope.processLoadResult(result);

            //If any other instance of PropDbLoader tried to load
            //the same property database while we were also loading it,
            //notify it with the result also.
            var cacheable = !!scope.sharedDbPath;
            var cached = cacheable && propWorkerCache[scope.sharedDbPath];
            if (cached && cached.waitingLoaders) {
                for (var i=0; i<cached.waitingLoaders.length; i++) {
                    cached.waitingLoaders[i].processLoadResult(result);
                }
                cached.waitingLoaders = null;
                cached.workerResult = result;
            }
        };

        var onObjectTreeError = function(error) {
            scope.processLoadError(error);

            //If any other instance of PropDbLoader tried to load
            //the same property database while we were also loading it,
            //notify it with the result also.
            var cacheable = !!scope.sharedDbPath;
            var cached = cacheable && propWorkerCache[scope.sharedDbPath];
            if (cached && cached.waitingLoaders) {
                for (var i=0; i<cached.waitingLoaders.length; i++) {
                    cached.waitingLoaders[i].processLoadError(error);
                }
                cached.waitingLoaders = null;
                cached.workerError = error;
            }

        };

        //See if we already loaded this property database once
        var cacheable = !!this.sharedDbPath;
        var cached = cacheable && propWorkerCache[this.sharedDbPath];

        if (cached) {
            stderr("Using cached property worker for ", this.sharedDbPath);
            this.propWorker = cached;
        } else {

            this.propWorker = avp.createWorkerWithIntercept();
            this.propWorker.addEventListenerWithIntercept(propertyWorkerCallback);

            if (cacheable) {
                propWorkerCache[this.sharedDbPath] = this.propWorker;
            }
        }

        var cbId = registerWorkerCallback(onObjectTreeRead, onObjectTreeError);

        var reqPath = avp.pathToURL(this.svf.basePath);

        //If there is a shared db path and there is no
        //per-SVF specific property database, use the shared one
        if (this.sharedDbPath && !this.svf.propertydb.values.length) {
            reqPath = this.sharedDbPath;
            stderr("Using shared property db: " + reqPath);
        }

        var xfer = { "operation":WORKER_GET_OBJECT_TREE,
                     "url": reqPath,
                     "propertydb" : this.svf.propertydb,
                     headers: av.HTTP_REQUEST_HEADERS,
                     "fragToDbId": this.svf.fragments.fragId2dbId, //the 1:1 mapping of fragment to dbId we got from the SVF or the 1:many we built on the fly for f2d
                     "fragBoxes" : this.svf.fragments.boxes, //needed to precompute bounding box hierarchy for explode function (and possibly others)
                     "auth" : auth,
                     "viewing_url" : VIEWING_URL,
                     "oss_url" : OSS_URL,
                     cbId: cbId,
                     queryParams : this.domainParam };
        this.propWorker.doOperation(xfer); // Send data to our worker.

    };


    PropDbLoader.prototype.asyncPropertyOperation = function(opArgs, success, fail) {

        var scope = this;

        if (scope.svf.instanceTree || scope.svf.hasObjectProperties) {

            opArgs.cbId = registerWorkerCallback(success, fail);

            this.propWorker.doOperation(opArgs); // Send data to our worker.
        } else if (scope.propertyDbError) {
            if (fail)
                fail(scope.propertyDbError);
        } else {
            var onEvent = function(e) {
                scope.eventTarget.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, onEvent);
                scope.eventTarget.removeEventListener(av.OBJECT_TREE_UNAVAILABLE_EVENT, onEvent);
                if (e.svf.instanceTree || e.svf.hasObjectProperties || scope.propertyDbError)
                    scope.asyncPropertyOperation(opArgs, success, fail);
                else if (fail)
                    fail({code:av.UNKNOWN_FAILURE, msg:"Failed to load properties"}); //avoid infinite recursion.
            };
            scope.eventTarget.addEventListener(av.OBJECT_TREE_CREATED_EVENT, onEvent);
            scope.eventTarget.addEventListener(av.OBJECT_TREE_UNAVAILABLE_EVENT, onEvent);
        }
    };


    PropDbLoader.prototype.getProperties = function(dbId, onSuccess, onError) {

        this.asyncPropertyOperation(
            {
                "operation":WORKER_GET_PROPERTIES,
                "dbId": dbId
            },
            onSuccess, onError
        );
    };

    /**
     * Bulk property retrieval with property name filter.
     * dbIds -- array of object dbIds to return properties for.
     * propFilter -- array of property names to retrieve values for. If empty, all properties are returned.
     */
    PropDbLoader.prototype.getBulkProperties = function(dbIds, propFilter, onSuccess, onError) {

        this.asyncPropertyOperation(
            {
                "operation":WORKER_GET_PROPERTIES,
                "dbIds": dbIds,
                "propFilter": propFilter
            },
            onSuccess, onError
        );
    };


    PropDbLoader.prototype.searchProperties = function(searchText, attributeNames, onSuccess, onError) {

        this.asyncPropertyOperation(
            {
                "operation": WORKER_SEARCH_PROPERTIES,
                "searchText": searchText,
                "attributeNames" : attributeNames
            },
            onSuccess, onError
        );
    };


    PropDbLoader.prototype.getExternalIdMapping = function(onSuccess, onError) {

        this.asyncPropertyOperation(
            {
                "operation": WORKER_BUILD_EXTERNAL_ID_MAPPING
            },
            onSuccess, onError
        );
    };


    PropDbLoader.prototype.getObjectTree = function(onSuccess, onError) {
        var scope = this;

        if (scope.svf.instanceTree) {
            onSuccess(scope.svf.instanceTree);
        } else if (scope.propertyDbError || 'hasObjectProperties' in scope.svf) {
            if (onError)
                onError(scope.propertyDbError);
        } else {
            // Property Db has been requested; waiting for worker to complete //
            var listener = function() {
                scope.eventTarget.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, listener);
                scope.eventTarget.removeEventListener(av.OBJECT_TREE_UNAVAILABLE_EVENT, listener);
                scope.getObjectTree(onSuccess, onError);
            };
            scope.eventTarget.addEventListener(av.OBJECT_TREE_CREATED_EVENT, listener);
            scope.eventTarget.addEventListener(av.OBJECT_TREE_UNAVAILABLE_EVENT, listener);
        }
    };

    PropDbLoader.prototype.attributeToIdMap = function(onSuccess, onError) {

        this.asyncPropertyOperation(
            {
                "operation": WORKER_ATTRIBUTES_MAP
            },
            onSuccess, onError
        );
    };


    avp.PropDbLoader = PropDbLoader;

})();
;

(function(){

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var NUM_WORKER_THREADS = av.isMobileDevice() ? 2 : 6;
var WORKER_LOAD_GEOMETRY = "LOAD_GEOMETRY";
var WORKER_LOAD_SVF = "LOAD_SVF";
var WORKER_LOAD_SVF_CONTD = "LOAD_SVF_CONTD";


/** @constructor */
var SvfLoader = function (parent) {
    this.viewer3DImpl = parent;
    this.next_pack = 0;
    this.loading = false;
    this.loadedPacksCount = 0;
    this.loadedPacks = [];
    this.tmpMatrix = new THREE.Matrix4();

    this.logger = avp.logger;
    this.loadTime = 0;
    this.domainParam = auth ? ("domain=" + encodeURIComponent(window.location.origin)) : "";

    // Local options inheriting from global options, but will change according to the size of the model.
    this.onDemandLoading = false;
    this.cullGeometryOnLoading = false;
    this.pageOutGeometryEnabled = false;
};

SvfLoader.prototype.dtor = function () {
    this.svf = null;
    this.options = null;

    if (this.svfWorker) {
        this.svfWorker.clearAllEventListenerWithIntercept();
        this.svfWorker.terminate();
        this.svfWorker = null;
    }
    if (this.pack_workers) {
        for (var i=0; i<this.pack_workers.length; i++) {
            this.pack_workers[i].clearAllEventListenerWithIntercept();
            this.pack_workers[i].terminate();
        }
        this.pack_workers = null;
    }
};

//Maps a relative resource path (like a pack file or texture)
//to an absolute URL (possibly signed).
avp.pathToURL = function(path) {

    if (path.indexOf("://") !== -1 ||
        path.indexOf("urn:") === 0) {
        return path;
    }

    if (typeof window === "undefined")
        return path;

    var rootRelPath = window.location.pathname;
    //chop off the index.html part
    var lastSlash = rootRelPath.lastIndexOf("/");
    rootRelPath = rootRelPath.substr(0, lastSlash+1);
    var absPath = window.location.protocol + "//" + window.location.host + rootRelPath + path;
    //stderr(absPath);
    return absPath;
};

SvfLoader.prototype.loadFile = function(path, options, onSuccess, onError) {
    if (this.loading) {
        console.log("Loading of SVF already in progress. Ignoring new request.");
        return false;
    }

    this.dtor();

    //If there is already a model loaded, we need to use the same globaOffset as the first model,
    //with the assumption that multiple models are loaded into the same space (more or less).
    if (this.viewer3DImpl.model && !options.globalOffset) {
        options.globalOffset = this.viewer3DImpl.model.getData().globalOffset;
    }

    var index = path.indexOf('urn:');
    if (index != -1) {
        // Extract urn:adsk.viewing:foo.bar.whateverjunks out of the path URL and bind it to logger.
        // From now on, we can send logs to viewing service, and logs are grouped by urn to make Splunk work.
        path = decodeURIComponent(path);
        var urn = path.substr(index, path.substr(index).indexOf('/'));
        stderr("Extracted URN: " + urn);

        // Extract urn(just base64 code)
        var _index = urn.lastIndexOf(':');
        this.svfUrn = urn.substr(_index + 1);
    } else {
        this.svfUrn = path;
    }

    this.sharedDbPath = options.sharedPropertyDbPath;
    this.currentLoadPath = path;

    this.options = options;
    var scope = this;
    
    avp.initWorkerScript(function() {
        scope.loadSvfCB(path, options, onSuccess, onError);
    });
    
    return true;
};


/**
 * Define this to manipulate the manifest before it is used. 
 * Must be either undefined or a function that takes exactly one argument, the manifest.
 *
 * I.e.: Autodesk.Viewing.Private.SvfLoader.prototype.interceptManifest = function(manifest) { <your code> };
 * 
 */
SvfLoader.prototype.interceptManifest = undefined;

SvfLoader.prototype.loadSvfCB = function(path, options, onSuccess, onError) {
    this.t0 = new Date().getTime();
    this.failedToLoadSomeGeometryPacks = null;

    var scope = this;
    var msg = { 
        url: avp.pathToURL(path),
        headers: av.HTTP_REQUEST_HEADERS,
        objectIds : options.ids,
        globalOffset : options.globalOffset,
        placementTransform : options.placementTransform,
        auth : auth,
        viewing_url : VIEWING_URL,
        oss_url : OSS_URL,
        queryParams : this.domainParam,
        bvhOptions : options.bvhOptions || {isWeakDevice : av.isMobileDevice()}
    };

    var w = this.svfWorker = avp.createWorkerWithIntercept();

    var onSVFLoad = function (ew) {
        var cleaner = function() {
            w.clearAllEventListenerWithIntercept();
            w.terminate();
            scope.svfWorker = null;
            w = null;
        };

        if (ew.data && ew.data.manifest) {

            scope.interceptManifest(ew.data.manifest);
            msg.operation = WORKER_LOAD_SVF_CONTD;
            msg.manifest = ew.data.manifest;
            w.doOperation(msg);
        } else if (ew.data && ew.data.svf) {
            //Decompression is done.
            var svf = scope.svf = ew.data.svf;

            if (scope.failedToLoadSomeGeometryPacks) {
                // Report a warning. It is not a fatal error.
                if (onError)
                    onError( scope.failedToLoadSomeGeometryPacks.code, scope.failedToLoadSomeGeometryPacks.msg);
                scope.failedToLoadSomeGeometryPacks = null;
            }

            scope.onSvfLoadDone(svf);

            if (onSuccess)
                onSuccess(scope.model);

            scope.viewer3DImpl.api.fireEvent({type:av.MODEL_ROOT_LOADED_EVENT, svf:svf, model:scope.model});

            var numGeomPacks = svf.geompacks.length;

            scope.svf.loadDone = false;
            if (numGeomPacks == 0) {
                scope.onGeomLoadDone();
            }
            else {
                // Dynamically determine whether need to enable on demand loading, according to the size of model roughly.
                if (svf.fragments.length > avp.FRAGS_PERSISTENT_MAX_COUNT) {
                    scope.onDemandLoading = avp.onDemandLoading;
                    scope.cullGeometryOnLoading = avp.cullGeometryOnLoading;
                }
                else {
                    scope.onDemandLoading = false;
                    scope.cullGeometryOnLoading = false;
                }

                stderr("SVF on demand loading: " + scope.onDemandLoading);
                stderr("SVF culling geometry on loading: " + scope.cullGeometryOnLoading);

                if (scope.onDemandLoading) {
                    // On demand loading is enabled, then 
                    // Defer to launch jobs for loading some geometry packs, 
                    // until the viewer really need them.
                    scope.loadedPacksCount = 0;
                }
                else {
                    // On demand loading is disabled, then 
                    // Require loading immediately
                    if (numGeomPacks) {
                        var count = Math.min(numGeomPacks, NUM_WORKER_THREADS);
                        for (var i=0; i<count; i++) {
                            var pf = svf.geompacks[i];
                            pf.loading = true;
                            scope.loadGeometryPack(pf.id, pf.uri);
                            scope.next_pack = i + 1;
                        }
                    }
                }
            }

            if (ew.data.progress == 1) { 
                scope.loading = false;
                cleaner();
            }

            if (!svf.fragments.polygonCounts)
                svf.fragments.polygonCounts = new Int32Array(svf.fragments.length);
            else {
            }

        } else if (ew.data && ew.data.bvh) {
            //Spatial index was done by the worker:
            if (ew.data.progress == 1) {
                if (!scope.svf.bvh) {
                    scope.svf.bvh = ew.data.bvh;
                    scope.model.setBVH(new avp.NodeArray(scope.svf.bvh.nodes, scope.svf.bvh.useLeanNodes), scope.svf.bvh.primitives, scope.options.bvhOptions);
                    scope.viewer3DImpl.invalidate(false, true);
                }
                scope.loading = false;
                cleaner();
            }
        } else if (ew.data && ew.data.progress) {
            if (ew.data.progress == 1) {
                scope.loading = false;
                cleaner();
            }
        } else if (ew.data && ew.data.error) {
            scope.loading = false;
            cleaner();
            if (onError)
                onError(ew.data.error.code, ew.data.error.msg, ew.data.error.args.httpStatus, ew.data.error.args.httpStatusText);
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else {
            stderr("SVF download failed.");
            //Download failed.
            scope.loading = false;
            cleaner();
        }
    };

    w.addEventListenerWithIntercept(onSVFLoad);
    
    msg.operation = WORKER_LOAD_SVF;
    msg.interceptManifest = !!this.interceptManifest;
    w.doOperation(msg);

    return true;
};


SvfLoader.prototype.loadGeometryPackOnDemand = function (packId) {

    var scope = this;
    if (!scope.onDemandLoading) {
        // Return immediately if do not allow on demand loading.
        return;
    }

    // Do nothing if the geometry pack file is already in loading.
    var pf = scope.svf.geompacks[packId];
    if (pf.loading) {
        return ;
    }

    var i;
    var onMeshLoad = function (ew) {
        if (ew.data && ew.data.mesh) {
            scope.processReceivedMesh(ew.data);

            if (ew.data.progress >= 1.0) {
                scope.pack_workers[ew.data.workerId].queued -= 1;
                scope.svf.geompacks[ew.data.packId].loading = false;

                // Removing the loaded pack from missing last frame, if exist.
                var missingPacks = scope.model.geomPacksMissingLastFrame();
                var idx = missingPacks.indexOf(ew.data.packId);
                if (idx >= 0) {
                    missingPacks.splice(idx, 1);
                }

                // Are all workers done?
                var isdone = true;
                for (var j = 0; j < scope.pack_workers.length; j++) {
                    if (scope.pack_workers[j].queued != 0) {
                        isdone = false;
                        break;
                    }
                }

                if (scope.loadedPacks.indexOf(ew.data.packId) == -1) {
                    // Recored which pack has been loaded.
                    scope.loadedPacks.push(ew.data.packId);
                }
                
                if (isdone && scope.model.geomPacksMissingLastFrame().length == 0) {
                    if (scope.loadedPacks.length == scope.svf.geompacks.length) {
                        // This is for whole geometry get loaded.
                        // Notice, if geometry page out is enabled, loaded geometry may be 
                        // get deleted later. So, this event just notify that all geometry
                        // pack file get downloaded at least once.
                        scope.onGeomLoadDone();
                    }
                    else {
                        // Notify event for a bunch of geometry pack file loaded done.
                        // ??? May need add handlers to react on this event. Such as,
                        // ??? Currently view cube won't start because it is set up 
                        // ??? at geom load done.
                        scope.onGeomPackFilesLoadDone();
                    }
                }

            }
        } else if (ew.data && ew.data.progress) {
            scope.pack_workers[ew.data.workerId].queued -= 1;
            scope.loadedPacksCount++;

            // This load is done, then can start next one.
            var pf = null, packId;
            var missingPacks = scope.model.geomPacksMissingLastFrame();
            for(i = 0; i < missingPacks.length; ++i) {
                packId = missingPacks[i];
                pf = scope.svf.geompacks[packId];
                if(!pf.loading) {
                    break;
                }
            }

            // Find one that hasn't been loaded.
            if (pf && !pf.loading) {
                scope.loadGeometryPackOnDemand(packId);
            }

            scope.viewer3DImpl.signalProgress(100 * scope.loadedPacks.length / scope.svf.geompacks.length);

        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else if (ew.data && ew.data.error) {
            scope.failedToLoadSomeGeometryPacks = {code:ew.data.error.code, msg:ew.data.error.msg};
        } else {
            //Download failed.
            scope.pack_workers[ew.data.workerId].queued -= 2;
            scope.svf.geompacks[ew.data.packId].loading = false;
        }
    };

    // Initialize pack workers if it is not ready yet.
    if (!this.pack_workers) {
        this.pack_workers = [];

        for (i = 0; i < NUM_WORKER_THREADS; i++) {
            var wr = avp.createWorkerWithIntercept();
            wr.addEventListenerWithIntercept(onMeshLoad);

            wr.queued = 0;
            this.pack_workers.push(wr);
        }
    }

    //Find the least busy worker
    var which = 0;
    var queued = this.pack_workers[0].queued;
    for (i = 1; i < NUM_WORKER_THREADS; i++) {
        if (this.pack_workers[i].queued < queued) {
            which = i;
            queued = this.pack_workers[i].queued;
        }
    }

    // If worker is busy, queue this reqest for next try.
    if (queued > 2 ) {
        // All workers are busy, then queue it for next try.
        scope.model.addGeomPackMissingLastFrame(packId);
        return;
    }

    var w, workerId;
    var path = pf.uri;
    w = this.pack_workers[which];
    w.queued += 2;
    workerId = which;

    //stderr("Loading pack " + packId);
    pf.loading = true;
    scope.svf.partPacksLoadDone = false; // Still loading geometry pack files.

    //Pass unzip job to the worker
    var reqPath = avp.pathToURL(this.svf.basePath + path);
    var xfer = { "operation":WORKER_LOAD_GEOMETRY,
                 "url": reqPath,
                 "packId": parseInt(packId), /* mesh IDs treat the pack file id as integer to save on storage in the per-fragment arrays */
                 headers: av.HTTP_REQUEST_HEADERS,
                 "workerId": workerId,
                 "auth" : auth,
                 "viewing_url" : VIEWING_URL,
                 "oss_url" : OSS_URL,
                 queryParams : this.domainParam};

    w.doOperation(xfer); // Send data to our worker.
};


SvfLoader.prototype.loadGeometryPack = function (packId, path) {
    var w;
    var workerId;
    var i, j;
    var scope = this;
    
    //stderr("Loading pack " + packId);

    var onMeshLoad = function (ew) {
        if (ew.data && ew.data.mesh) {
            scope.processReceivedMesh(ew.data);

            //Is the worker done loading the geom pack?
            if (ew.data.progress >= 1.0) {
                scope.pack_workers[ew.data.workerId].queued -= 1;

                scope.loadedPacksCount++;
                scope.viewer3DImpl.signalProgress(100 * scope.loadedPacksCount / scope.svf.geompacks.length);

                //Are all workers done?
                var isdone = true;
                for (j = 0; j < scope.pack_workers.length; j++) {
                    if (scope.pack_workers[j].queued != 0) {
                        isdone = false;
                        break;
                    }
                }

                if (isdone) {
                    for (j = 0; j < NUM_WORKER_THREADS; j++) {
                        scope.pack_workers[j].clearAllEventListenerWithIntercept();
                        scope.pack_workers[j].terminate();
                    }
                    scope.pack_workers = null;
                }

                if (scope.svf.fragments.numLoaded == scope.svf.fragments.length) { //all workers are done?
                    //then launch the texture loads in case that was not done already
                    if (!scope.svf.proteinMaterials || !PROTEIN_ROOT || !PRISM_ROOT) {
                        scope.viewer3DImpl.matman().loadTextures(scope.svf);
                    }
                    scope.onGeomLoadDone();
                }
            }
        } else if (ew.data && ew.data.progress) {
            //download is done, queue the next download
            scope.pack_workers[ew.data.workerId].queued -= 1;

            if (scope.next_pack < scope.svf.geompacks.length) {
                
                var pf = null;
                var missingPacks = scope.model.geomPacksMissingLastFrame();
                for(i = 0; i < missingPacks.length; ++i) {
                    pf = scope.svf.geompacks[missingPacks[i]];
                    if(pf && !pf.loading) {
                        break;
                    }
                }

                if(!pf || pf.loading) {
                    while(scope.next_pack < scope.svf.geompacks.length) {
                        pf = scope.svf.geompacks[scope.next_pack++];
                        if(!pf.loading) {
                            break;
                        }
                    }
                }

                if(pf && !pf.loading) {
                    pf.loading = true;
                    scope.loadGeometryPack(pf.id, pf.uri);
                }
                else {
                    scope.viewer3DImpl.modelQueue().enforceBvh = false;
                    scope.svf.fragments.packIds = null; // not needed anymore
                }
            }
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else if (ew.data && ew.data.error) {
            scope.failedToLoadSomeGeometryPacks = {code:ew.data.error.code, msg:ew.data.error.msg};
        } else {
            //Download failed.
            scope.pack_workers[ew.data.workerId].queued -= 2;
        }
    };

    if (!this.pack_workers) {
        this.pack_workers = [];

        for (i = 0; i < NUM_WORKER_THREADS; i++) {
            var wr = avp.createWorkerWithIntercept();
            wr.addEventListenerWithIntercept(onMeshLoad);

            wr.queued = 0;
            this.pack_workers.push(wr);
        }
    }

    //Find the least busy worker
    var which = 0;
    var queued = this.pack_workers[0].queued;
    for (i = 1; i < NUM_WORKER_THREADS; i++) {
        if (this.pack_workers[i].queued < queued) {
            which = i;
            queued = this.pack_workers[i].queued;
        }
    }
    w = this.pack_workers[which];
    w.queued += 2;
    workerId = which;


    //Pass unzip job to the worker
    var reqPath = avp.pathToURL(this.svf.basePath + path);
    var xfer = { "operation":WORKER_LOAD_GEOMETRY,
                 "url": reqPath,
                 "packId": parseInt(packId), /* mesh IDs treat the pack file id as integer to save on storage in the per-fragment arrays */
                 headers: av.HTTP_REQUEST_HEADERS,
                 "workerId": workerId,
                 "auth" : auth,
                 "viewing_url" : VIEWING_URL,
                 "oss_url" : OSS_URL,
                 queryParams : this.domainParam};

    w.doOperation(xfer); // Send data to our worker.
};
    

SvfLoader.prototype.processReceivedMesh = function(mdata) {

    //Find all fragments that instance this mesh
    var meshid = mdata.packId + ":" + mdata.meshIndex;

    var svf = this.svf;
    var fragments = svf.fragments;

    var fragIndexes = fragments.mesh2frag[meshid];
    if (fragIndexes === undefined) {
        stderr("Mesh " + meshid + " was not referenced by any fragments.");
        return;
    }
    if (!Array.isArray(fragIndexes))
        fragIndexes = [fragIndexes];

    // Let's do a culling when process the received meshes, 
    // which cull those won't be rendered in current frame.
    if (this.cullGeometryOnLoading) {
        var culled = true;
        for (var i=0; i<fragIndexes.length; ++i) {
            // Do not cull the first FRAGS_PERSISTENT_COUNT fragments.
            if (fragIndexes[i] < avp.FRAGS_PERSISTENT_COUNT) {
                culled = false;
                break;
            }

            culled = culled && this.viewer3DImpl.modelQueue().checkCull(fragIndexes[i], true, true);
            if (!culled)
                break;
        }
        if (culled) {
            // Discard this mesh directly.
            mdata.mesh = null;
            return;
        }
    }

    //Convert the received mesh to THREE buffer geometry
    avp.BufferGeometryUtils.meshToGeometry(mdata);

    var numInstances = fragIndexes.length;

    var rm = this.model;
    
    //Reuse previous index of this geometry, if available
    var idx = rm.getFragmentList().getGeometryId(fragIndexes[0]);
    var geomId = rm.getGeometryList().addGeometry(mdata.geometry, numInstances, idx);
    
    // This is to record how many instances this geometry has, 
    // and the number of instances have been rendered in one frame.
    if (this.cullGeometryOnLoading && numInstances > 1 &&
        rm.getFragmentList().geomidsmap[geomId] == null) {
        rm.getFragmentList().geomidsmap[geomId] = {n:numInstances, t:0};
    }
    
    var ib = mdata.geometry.attributes['index'].array || mdata.geometry.ib;
    var polyCount = ib.length / 3;

    //For each fragment, add a mesh instance to the renderer
    for (var i=0; i<fragIndexes.length; i++) {
        var fragId = 0|fragIndexes[i];

        //We get the matrix from the fragments and we set it back there
        //with the activateFragment call, but this is to maintain the
        //ability to add a plain THREE.Mesh -- otherwise it could be simpler
        rm.getFragmentList().getOriginalWorldMatrix(fragId, this.tmpMatrix);

        if (this.options.placementTransform) {
            this.tmpMatrix = new THREE.Matrix4().multiplyMatrices(this.options.placementTransform, this.tmpMatrix);
        }

        var materialId = fragments.materials[fragId].toString();

        if (fragments.polygonCounts)
            fragments.polygonCounts[fragId] = polyCount;

        var m = this.viewer3DImpl.setupMesh(this.model, mdata.geometry, materialId, this.tmpMatrix);
        rm.activateFragment(fragId, m, !!this.options.placementTransform);
    }

    if (!this.onDemandLoading) {
        //don't need this mapping anymore.
        fragments.mesh2frag[meshid] = null;
    }

    //Repaint and progress reporting
    fragments.numLoaded += fragIndexes.length;

    //repaint every once in a while -- more initially, less as the load drags on.
    if (svf.geomPolyCount > svf.nextRepaintPolys) {
		//console.log("num loaded " + numLoaded);
		svf.numRepaints ++;
        svf.nextRepaintPolys += 10000 * Math.pow(1.5, svf.numRepaints);
        this.viewer3DImpl.invalidate(false, true);
    }
};


SvfLoader.prototype.onSvfLoadDone = function(svf) {

    svf.geomPolyCount = 0;
    svf.instancePolyCount = 0;
    svf.geomMemory = 0;
    svf.fragments.numLoaded = 0;
    svf.meshCount = 0;
    svf.gpuNumMeshes = 0;
    svf.gpuMeshMemory = 0;

	svf.nextRepaintPolys = 10000;
	svf.numRepaints = 0;

    svf.urn = this.svfUrn;

    svf.basePath = "";
    var lastSlash = this.currentLoadPath.lastIndexOf("/");
    if (lastSlash != -1)
        svf.basePath = this.currentLoadPath.substr(0, lastSlash+1);


    var t1 = Date.now();
    this.loadTime += t1 - this.t0;
    stderr("SVF load: " + (t1 - this.t0));

    //Create the API Model object and its render proxy
    var model = this.model = new avp.RenderModel(svf);
    model.initialize(this);
    model.loader = this;

    //For 3D models, we can start loading the property database as soon
    //as we know the fragment list which contains the fragId->dbId map.
    //We would not load property db when we are on mobile device AND on demand loading is on (which
    //implies the model is not 'normal' in terms of its size.). This is only a temp solution that
    //allow big models loads on mobile without crash. Without property db loading selection could break.
    var shouldLoadPropertyDb = !(this.onDemandLoading && (avp.isMobileDevice()));
    if (shouldLoadPropertyDb) {
        this.loadPropertyDb();
    }
    
    var numMaterials = this.viewer3DImpl.matman().convertMaterials(svf);

    this.t0 = t1;

    //The BBox object loses knowledge of its
    //type when going across the worker thread boundary...
    svf.bbox = new THREE.Box3().copy(svf.bbox);

    //Camera vectors also lose their prototypes when they
    //cross the thread boundary...
    if (svf.cameras) {
        for (var i = 0; i < svf.cameras.length; i++) {
            var camera = svf.cameras[i];
            camera.position = new THREE.Vector3().copy(camera.position);
            camera.target = new THREE.Vector3().copy(camera.target);
            camera.up = new THREE.Vector3().copy(camera.up);
        }
    }

    //If the textures are likely to come from the Protein CDN
    //load them in parallel with the geometry packs
    if (svf.proteinMaterials && PROTEIN_ROOT && PRISM_ROOT) {
        this.viewer3DImpl.matman().loadTextures(svf);
    }

    stderr("scene bounds: " + JSON.stringify(svf.bbox));

    if (this.logger) {
        var metadataStats = {
            category: "metadata_load_stats",
            urn: svf.urn,
            has_topology: !!svf.topology,
            has_animations: !!svf.animations,
            cameras: svf.cameras ? svf.cameras.length : 0,
            lights: svf.lights ? svf.lights.length : 0,
            materials: numMaterials
        };
        this.logger.log(metadataStats);
    }

    this.viewer3DImpl.signalProgress(5, "Hold on, getting the model...");
    this.viewer3DImpl.invalidate(false, false);
};

SvfLoader.prototype.addTransparencyFlagsToMaterials = function(mats) {
    for(var id in mats) {
        var mat = mats[id];
        var userAssets = mat["userassets"];
        var innerMats = mat["materials"];
        var innerMat = innerMats[userAssets[0]];
        mat.transparent = innerMat["transparent"];
    }
};

SvfLoader.prototype.makeBVH = function(svf) {
    var t0 = performance.now();
    var mats = svf.materials ? svf.materials["materials"] : null;
    if (mats)
        this.addTransparencyFlagsToMaterials(mats);
    svf.bvh = new avp.BVHBuilder(svf.fragments, mats);
    svf.bvh.build(this.options.bvhOptions || {isWeakDevice : av.isMobileDevice()});
    var t1 = performance.now();
    stderr("BVH build time: " + (t1 - t0));
};

SvfLoader.prototype.onGeomPackFilesLoadDone = function() {
    // This is to signal client that part of pack files are load done.
    stderr("Part of geom pack files are load done.");

    // ??? There may be other things need to be handled here per geom pack files loading done?
    // ??? 

    this.svf.partPacksLoadDone = true;
    this.viewer3DImpl.invalidate(false, true);
};

SvfLoader.prototype.onGeomLoadDone = function() {
    this.svf.loadDone = true;

    // We need to keep a copy of the original fragments
    // transforms in order to restore them after explosions, etc.
    // the rotation/scale 3x3 part.
    // TODO: consider only keeping the position vector and throwing out
    //
    //delete this.svf.fragments.transforms;

    // Don't need these anymore (except perhaps for out of core stuff?)
    if (!this.onDemandLoading) {
        // On demand loading still need this.
        this.svf.fragments.entityIndexes = null;
        this.svf.fragments.mesh2frag = null; 
    }


    var t1 = Date.now();
    var msg = "Fragments load time: " + (t1 - this.t0);
    this.loadTime += t1 - this.t0;

    //If there is a post-transform, the BVH has to be computed after
    //all the world transforms/boxes are updated
    if (!this.svf.bvh || this.options.placementTransform) {
        this.makeBVH(this.svf);
        this.model.setBVH(this.svf.bvh.nodes, this.svf.bvh.primitives, this.options.bvhOptions);
    }
    stderr(msg);

    if (this.logger) {
        var modelStats = {
            category: "model_load_stats",
            is_f2d: false,
            has_prism: this.viewer3DImpl.matman().hasPrism,
            load_time: this.loadTime,
            geometry_size: this.model.getGeometryList().geomMemory,
            meshes_count: this.model.getGeometryList().geoms.length,
            fragments_count: this.model.getFragmentList().getCount(),
            urn: this.svfUrn
        };
        this.logger.log(modelStats, true);
    }

    function sendMessage(data){
        var aMessage = {'command':'assets', data: data};
        if (av.isBrowser)
            window.webkit.messageHandlers.callbackHandler.postMessage(aMessage);
    }

    if (avp.assets) {
        // Callback to ios.
        if (av.isBrowser && window.webkit) {
            sendMessage(avp.assets);
            avp.assets = null;
        }
        //stderr(JSON.stringify(avp.assets));
    }

    this.currentLoadPath = null;

    this.viewer3DImpl.onLoadComplete(this.model);
};

SvfLoader.prototype.loadPropertyDb = function() {
    this.svf.propWorker = new avp.PropDbLoader(this.sharedDbPath, this.model, this.viewer3DImpl.api);
    this.svf.propWorker.load();
};

avp.SvfLoader = SvfLoader;

av.FileLoaderManager.registerFileLoader("svf", ["svf"], avp.SvfLoader);


})();
;
(function(){

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var WORKER_PARSE_F2D = "PARSE_F2D";
var WORKER_STREAM_F2D = "STREAM_F2D";
var WORKER_PARSE_F2D_FRAME = "PARSE_F2D_FRAME";

/** @constructor */
function F2DLoader(parent) {
    this.viewer3DImpl = parent;
    this.loading = false;
    this.tmpMatrix = new THREE.Matrix4();

    this.logger = avp.logger;
    this.loadTime = 0;
    this.domainParam = auth ? ("domain=" + encodeURIComponent(window.location.origin)) : "";
}

F2DLoader.prototype.dtor = function () {
    this.svf = null;
    this.options = null;

    if (this.parsingWorker) {
        this.parsingWorker.terminate();
        this.parsingWorker = null;
    }
    if (this.streamingWorker) {
        this.streamingWorker.terminate();
        this.streamingWorker = null;
    }
};


F2DLoader.prototype.loadFile = function(path, options, onSuccess, onError) {
    if (this.loading) {
        console.log("Loading of SVF already in progress. Ignoring new request.");
        return false;
    }

    this.dtor();

    var index = path.indexOf('urn:');
    if (index != -1) {
        // Extract urn:adsk.viewing:foo.bar.whateverjunks out of the path URL and bind it to logger.
        // From now on, we can send logs to viewing service, and logs are grouped by urn to make Splunk work.
        path = decodeURIComponent(path);
        var urn = path.substr(index, path.substr(index).indexOf('/'));
        stderr("Extracted URN: " + urn);

        // Extract urn(just base64 code)
        var _index = urn.lastIndexOf(':');
        this.svfUrn = urn.substr(_index + 1);
    } else {
        this.svfUrn = path;
    }

    this.sharedDbPath = options.sharedPropertyDbPath;
    this.currentLoadPath = path;

    this.options = options;

    if (this.options.placementTransform) {
        this.modelScale = this.options.placementTransform.getMaxScaleOnAxis();
    } else {
        this.modelScale = 1;
    }

    this.isf2d = true;
    var scope = this;
    
    avp.initWorkerScript(function() {
        scope.loadFydoCB(path, options, onSuccess, onError);
    });
    
    return true;
};


F2DLoader.prototype.loadFydoCB = function(path, options, onSuccess, onError) {
    this.t0 = Date.now();

    var svfPath = avp.pathToURL(path);

    // Streaming worker as data producer that generates fydo frame streams.
    var streamingWorker = this.streamingWorker = avp.createWorker();
    // Parsing worker as data consumer that consumes fydo frame streams and generate meshes.
    var parsingWorker = this.parsingWorker = avp.createWorker();
    var scope = this;

    var onStream = function (ew) {
        if (ew.data && ew.data.type == "F2DBLOB") {
            var msg = { operation:WORKER_PARSE_F2D,
                data: ew.data.buffer,
                metadata: ew.data.metadata,
                manifest: ew.data.manifest,
                basePath: ew.data.basePath,
                f2dLoadOptions: {
                    modelSpace : options.modelSpace,
                    bgColor: options.bgColor
                },
                url: svfPath
                };
            parsingWorker.doOperation(msg, [msg.data]);
            streamingWorker.terminate();

        } else if (ew.data && ew.data.type == "F2DSTREAM") {

            var msg = { operation:WORKER_PARSE_F2D_FRAME,
                        data: ew.data.frames,
                        url: svfPath,
                        f2dLoadOptions: {
                            modelSpace : options.modelSpace,
                            bgColor: options.bgColor
                        }
                      };

            //first frame
            if (ew.data.metadata) {
                msg.metadata = ew.data.metadata;
                msg.manifest = ew.data.manifest;
            }

            //last frame?
            if (ew.data.finalFrame)
                msg.finalFrame = true;

            if (ew.data.progress)
                scope.viewer3DImpl.signalProgress(100*ew.data.progress);

            parsingWorker.doOperation(msg, msg.data ? [msg.data] : undefined);

            if (ew.data.finalFrame)
                streamingWorker.terminate();
        } else if (ew.data && ew.data.type == "F2DAssetURL") {
            avp.assets = avp.assets.concat(ew.data.urls);
        } else if (ew.data && ew.data.assetRequest) {
            avp.assets.push(ew.data.assetRequest);
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else if (ew.data && ew.data.error) {
            scope.loading = false;
            streamingWorker.terminate();
            if (onError)
                onError.call(this, ew.data.error.code, ew.data.error.msg, ew.data.error.args.httpStatus, ew.data.error.args.httpStatusText);
        } else {
            stderr("F2D download failed.");
            scope.loading = false;
            streamingWorker.terminate();
        }
    };



    var onParse = function (ew) {
        if (ew.data && ew.data.f2d) {
            var f = scope.svf = ew.data.f2d;

            parsingWorker.terminate();
            
            stderr("Num polylines: " + f.numPolylines);
            stderr("Line segments: " + f.numLineSegs);
            stderr("Circular arcs: " + f.numCircles);
            stderr("Ellipitcal arcs:" + f.numEllipses);
            stderr("Plain triangles:" + f.numTriangles);
            stderr("Total # of op codes generated by fydo.parse: " + f.opCount);

            scope.onSvfLoadDone(scope.svf);

            if (onSuccess)
                onSuccess(scope.model);

            scope.viewer3DImpl.api.fireEvent({type:av.MODEL_ROOT_LOADED_EVENT, svf:scope.svf, model:scope.model});
            

            for (var i=0; i < f.meshes.length; i++) {
                scope.processReceivedMesh2D(f.meshes[i], i);
            }

            f.meshes = null;

            scope.onGeomLoadDone();

            scope.loading = false;

        }  else if (ew.data && ew.data.f2dframe) {
            // stderr("# of op codes generated by f2d.parseFrame: " + ew.data.f2dframe.opCount);
            var baseIndex = 0;

            if (!ew.data.meshes) {
                //First message from the worker
                scope.svf = ew.data.f2dframe;
                baseIndex = ew.data.baseIndex;
            } else {
                //Update the world box and current mesh index
                //on subsequent messages from the worker.
                var bbox = ew.data.bbox;
                scope.svf.bbox = new THREE.Box3(bbox.min, bbox.max);
                baseIndex = ew.data.baseIndex;
            }

            var f = scope.svf;

            if (!f.fragments || !f.fragments.initialized) {
                //First message from the worker,
                //initialize the load states, fragment lists, etc.
                scope.onSvfLoadDone(f);

                if (onSuccess) {
                    onSuccess(scope.model);
                }
                scope.viewer3DImpl.api.fireEvent({type:av.MODEL_ROOT_LOADED_EVENT, svf:f, model:scope.model});

            }

            if (ew.data.meshes && ew.data.meshes.length)
            {
                for (var i = 0; i < ew.data.meshes.length; i++) {
                    scope.processReceivedMesh2D(ew.data.meshes[i], baseIndex+i);
                }
            }

            if (ew.data.finalFrame) {
                //Update the F2D properties which are accumulated
                //while reading the F2D stream.
                var cumulativeProps = ew.data.cumulativeProps;
                for (var p in cumulativeProps) {
                    f[p] = cumulativeProps[p];
                }

                scope.onGeomLoadDone();

                scope.loading = false;

                parsingWorker.terminate();
            }

        } else if (ew.data && ew.data.progress) {
            // TODO: ???
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else if (ew.data && ew.data.error) {
            scope.loading = false;
            parsingWorker.terminate();

            stderr("Error while parsing F2d: " + JSON.stringify(ew.data.error.args));

            // TODO: in debug model, viewer3d.html does not have any on error callback.
            // So, any errors would be swallowed, instead of reported back.
            // Is this intended? We should at least print the stack on console to help make our life easier.
            if (onError)
                onError.call(this, ew.data.error.code, ew.data.error.msg, ew.data.error.args.httpStatus, ew.data.error.args.httpStatusText);
        } else {
            stderr("F2D download failed.");
            //Download failed.
            scope.loading = false;
            parsingWorker.terminate();
        }
    };

    streamingWorker.addEventListener('message', onStream, false);
    parsingWorker.addEventListener('message', onParse, false);

    var msg = { operation:WORKER_STREAM_F2D,
        url: svfPath,
        headers: av.HTTP_REQUEST_HEADERS,
        objectIds : options.ids,
        auth : auth,
        viewing_url : VIEWING_URL,
        oss_url : OSS_URL,
        queryParams : this.domainParam };  // For CORS caching issue.

    streamingWorker.doOperation(msg);

    return true;
};



F2DLoader.prototype.processReceivedMesh = function(mdata) {

    //Find all fragments that instance this mesh
    var meshid = mdata.packId + ":" + mdata.meshIndex;

    var svf = this.svf;
    var fragments = svf.fragments;

    var fragIndexes = fragments.mesh2frag[meshid];
    if (fragIndexes === undefined) {
        stderr("Mesh " + meshid + " was not referenced by any fragments.");
        return;
    }
    if (!Array.isArray(fragIndexes))
        fragIndexes = [fragIndexes];

    //Convert the received mesh to THREE buffer geometry
    avp.BufferGeometryUtils.meshToGeometry(mdata);

    var numInstances = fragIndexes.length;

    var rm = this.model;
    
    //Reuse previous index of this geometry, if available
    var geomId = rm.getGeometryList().addGeometry(mdata.geometry, numInstances);

    var ib = mdata.geometry.attributes['index'].array || mdata.geometry.ib;
    var polyCount = ib.length / 3;

    //For each fragment, add a mesh instance to the renderer
    for (var i=0; i<fragIndexes.length; i++) {
        var fragId = 0|fragIndexes[i];

        //We get the matrix from the fragments and we set it back there
        //with the activateFragment call, but this is to maintain the
        //ability to add a plain THREE.Mesh -- otherwise it could be simpler
        rm.getFragmentList().getOriginalWorldMatrix(fragId, this.tmpMatrix);

        if (this.options.placementTransform) {
            this.tmpMatrix = new THREE.Matrix4().multiplyMatrices(this.options.placementTransform, this.tmpMatrix);
        }

        var materialId = fragments.materials[fragId].toString();

        if (fragments.polygonCounts)
            fragments.polygonCounts[fragId] = polyCount;

        var m = this.viewer3DImpl.setupMesh(this.model, mdata.geometry, materialId, this.tmpMatrix);
        rm.activateFragment(fragId, m);
    }

    //don't need this mapping anymore.
    fragments.mesh2frag[meshid] = null;

    //Repaint and progress reporting
    fragments.numLoaded += fragIndexes.length;

    var numLoaded = fragments.numLoaded;

    //repaint every once in a while -- more initially, less as the load drags on.
    if (svf.geomPolyCount > svf.nextRepaintPolys) {
		//console.log("num loaded " + numLoaded);
		svf.numRepaints ++;
        svf.nextRepaintPolys += 10000 * Math.pow(1.5, svf.numRepaints);
        this.viewer3DImpl.invalidate(false, true);
    }

    if ((numLoaded % 20) == 0) {
        this.viewer3DImpl.invalidate(false, true);
    }
};

F2DLoader.prototype.processReceivedMesh2D = function(mesh, mindex) {

    var mdata = { mesh: mesh, is2d: true, packId : "0", meshIndex: mindex };

    var meshId = "0:" + mindex;

    var frags = this.svf.fragments;

    //Remember the list of all dbIds referenced by this mesh.
    //In the 2D case this is 1->many (1 frag = many dbIds) mapping instead of
    // 1 dbId -> many fragments like in the SVF 3D case.
    var dbIds = Object.keys(mdata.mesh.dbIds).map(function(item){return parseInt(item);});
    frags.fragId2dbId[mindex] = dbIds;

    //TODO: dbId2fragId is not really necessary if we have a good instance tree for the 2D drawing (e.g. Revit, AutoCAD)
    //so we can get rid of this mapping if we can convert Viewer3DImpl.highlightFragment to use the same logic for 2D as for 3D.
    for (var j=0; j<dbIds.length; j++) {
        var dbId = dbIds[j];
        var fragIds = frags.dbId2fragId[dbId];
        if (Array.isArray(fragIds))
             fragIds.push(mindex);
        else if (typeof fragIds !== "undefined") {
            frags.dbId2fragId[dbId] = [fragIds, mindex];
        }
        else {
            frags.dbId2fragId[dbId] = mindex;
        }
    }

    frags.mesh2frag[meshId] = mindex;
    mesh.material.modelScale = this.modelScale;
    frags.materials[mindex] = this.viewer3DImpl.matman().create2DMaterial(this.svf, mesh.material);

    frags.length++;

    this.processReceivedMesh(mdata);

};

F2DLoader.prototype.onSvfLoadDone = function(svf) {

    //In the 2d case we create and build up the fragments mapping
    //on the receiving end.
    svf.fragments = {};
    svf.fragments.mesh2frag = {};
    svf.fragments.materials = [];
    svf.fragments.fragId2dbId = [];
    svf.fragments.dbId2fragId = [];
    svf.fragments.length = 0;
    svf.fragments.initialized = true;


    svf.geomPolyCount = 0;
    svf.instancePolyCount = 0;
    svf.geomMemory = 0;
    svf.fragments.numLoaded = 0;
    svf.meshCount = 0;
    svf.gpuNumMeshes = 0;
    svf.gpuMeshMemory = 0;

	svf.nextRepaintPolys = 10000;
	svf.numRepaints = 0;

    svf.urn = this.svfUrn;

    svf.basePath = "";
    var lastSlash = this.currentLoadPath.lastIndexOf("/");
    if (lastSlash != -1)
        svf.basePath = this.currentLoadPath.substr(0, lastSlash+1);



    var t1 = Date.now();
    this.loadTime += t1 - this.t0;
    stderr("SVF load: " + (t1 - this.t0));

    this.t0 = t1;

    //The BBox object loses knowledge of its
    //type when going across the worker thread boundary...
    svf.bbox = new THREE.Box3().copy(svf.bbox);

    //Create the API Model object and its render proxy
    var model = this.model = new avp.RenderModel(svf);
    model.initialize(this);
    model.loader = this;
    this.svf.propWorker = new avp.PropDbLoader(this.sharedDbPath, this.model, this.viewer3DImpl.api);

    stderr("scene bounds: " + JSON.stringify(svf.bbox));

    if (this.logger) {
        var metadataStats = {
            category: "metadata_load_stats",
            urn: svf.urn,
            layers: svf.layerCount
        };
        this.logger.log(metadataStats);
    }

    this.viewer3DImpl.signalProgress(5, "Hold on, getting the model...");
    this.viewer3DImpl.invalidate(false, false);
};


F2DLoader.prototype.onGeomLoadDone = function() {
    this.svf.loadDone = true;

    // Don't need these anymore
    this.svf.fragments.entityIndexes = null;
    this.svf.fragments.mesh2frag = null;

    var t1 = Date.now();
    var msg = "Fragments load time: " + (t1 - this.t0);
    this.loadTime += t1 - this.t0;

    //Load the property database after all geometry is loaded (2D case). For 2D,
    //the fragId->dbId mapping is only fully known once geometry is loaded, as
    //it's built on the fly.
    //TODO: As an optimization we can split the property db logic into two calls -- one to load the files
    //in parallel with the geometry and a second to do the processing.
    this.loadPropertyDb();

    stderr(msg);

    if (this.logger) {
        var modelStats = {
            category: "model_load_stats",
            is_f2d: true,
            has_prism: this.viewer3DImpl.matman().hasPrism,
            load_time: this.loadTime,
            geometry_size: this.model.getGeometryList().geomMemory,
            meshes_count: this.model.getGeometryList().geoms.length,
            urn: this.svfUrn
        };
        this.logger.log(modelStats, true);
    }

    function sendMessage(data){
        var aMessage = {'command':'assets', data: data};
        window.webkit.messageHandlers.callbackHandler.doOperation(aMessage);
    }

    if (avp.assets) {
        // Callback to ios.
        if (window.webkit) {
            sendMessage(avp.assets);
            avp.assets = null;
        }
        //stderr(JSON.stringify(avp.assets));
    }

    this.currentLoadPath = null;
    this.isf2d = undefined;

    this.viewer3DImpl.onLoadComplete(this.model);
};


F2DLoader.prototype.loadPropertyDb = function() {
    this.svf.propWorker.load();
};


avp.F2DLoader = F2DLoader;

av.FileLoaderManager.registerFileLoader("f2d", ["f2d"], avp.F2DLoader);


})();
;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var TAU = Math.PI * 2;

var VBB_GT_TRIANGLE_INDEXED = 0,
    VBB_GT_LINE_SEGMENT     = 1,
    VBB_GT_ARC_CIRCULAR     = 2,
    VBB_GT_ARC_ELLIPTICAL   = 3,
    VBB_GT_TEX_QUAD         = 4,
    VBB_GT_ONE_TRIANGLE     = 5;

var VBB_INSTANCED_FLAG  = 0, // this is intentionally 0 for the instancing case!
    VBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!
    VBB_SEG_START_LEFT  = 1,
    VBB_SEG_END_RIGHT   = 2,
    VBB_SEG_END_LEFT    = 3;

var VBB_COLOR_OFFSET    = 6,
    VBB_DBID_OFFSET     = 7,
    VBB_FLAGS_OFFSET    = 8,
    VBB_LAYER_VP_OFFSET = 9;

var QUAD_TRIANGLE_INDICES = [ 0,1,3, 0,3,2 ];

function VertexBufferBuilder(useInstancing, allocSize)
{
    var MAX_VCOUNT = allocSize || 65536;

    this.useInstancing = useInstancing;

    //TODO: Temporarily expand the stride to the full one, in order to work around new
    //more strict WebGL validation which complains when a shader addresses attributes outside
    //the vertex buffer, even when it does not actually access them. We would need separate shader
    //configurations for each of the two possible vertex strides for the selection shader, which is
    //currently shared between all 2d geometries.
    //this.stride = 10;
    this.stride = 12;

    this.vb  = new ArrayBuffer(this.stride * 4 * (this.useInstancing ? MAX_VCOUNT / 4 : MAX_VCOUNT));
    this.vbf = new Float32Array(this.vb);
    this.vbi = new Int32Array(this.vb);
    this.vcount = 0;

    this.ib = this.useInstancing ? null : new Uint16Array(MAX_VCOUNT);
    this.icount = 0;

    this.minx = this.miny =  Infinity;
    this.maxx = this.maxy = -Infinity;

    //Keeps track of objectIds referenced by geometry in the VB
    this.dbIds = {};

    this.numEllipticals   = 0;
    this.numCirculars     = 0;
    this.numTriangleGeoms = 0;
}

VertexBufferBuilder.prototype.expandStride = function()
{
    // since we already set the stride to the current max value of 12 in the
    // constructor above, we don't need to do anything here right now...
    return;

/*
    //Currently hardcoded to expand by 4 floats.
    var expandBy = 2;

    var stride = this.stride;

    if (stride >= 12)
        return;

    var nstride = this.stride + expandBy;

    var nvb = new ArrayBuffer(nstride * (this.vb.byteLength / stride));

    var src = new Uint8Array(this.vb);
    var dst = new Uint8Array(nvb);

    for (var i = 0, iEnd = this.vcount; i<iEnd; i++) {
        var os = i * stride * 4;
        var od = i * nstride * 4;

        for (var j=0; j<stride * 4; j++)
            dst[od+j] = src[os+j];
    }

    this.vb = nvb;
    this.vbf = new Float32Array(nvb);
    this.vbi = new Int32Array(nvb);
    this.stride = nstride;
*/
};

VertexBufferBuilder.prototype.addToBounds = function(x, y)
{
    if (x < this.minx) this.minx = x;
    if (x > this.maxx) this.maxx = x;
    if (y < this.miny) this.miny = y;
    if (y > this.maxy) this.maxy = y;
};

VertexBufferBuilder.prototype.setCommonVertexAttribs = function(offset, vertexId, geomType, color, dbId, layerId, vpId, linePattern)
{
    // align changes here with the "decodeCommonAttribs()" function in LineShader.js and VertexBufferReader.js!!!
    vertexId    = (vertexId    &   0xff); //  8 bit
    geomType    = (geomType    &   0xff); //  8 bit
    linePattern = (linePattern &   0xff); //  8 bit
    layerId     = (layerId     & 0xffff); // 16 bit
    vpId        = (vpId        & 0xffff); // 16 bit

    this.vbi[offset + VBB_FLAGS_OFFSET]    = vertexId | (geomType << 8) | (linePattern << 16); // vertexId: int8; geomType: int8; linePattern: int8; unused: int8
    this.vbi[offset + VBB_COLOR_OFFSET]    = color;
    this.vbi[offset + VBB_DBID_OFFSET]     = dbId;
    this.vbi[offset + VBB_LAYER_VP_OFFSET] = layerId | (vpId << 16); // layerId: int16; vpId: int16

    this.dbIds[dbId] = 1; // mark this feature as used
}

//Creates a non-indexed triangle geometry vertex (triangle vertex coords stored in single vertex structure)
VertexBufferBuilder.prototype.addVertexTriangleGeom = function(x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId)
{
    var vi  = this.vcount;
    var vbf = this.vbf;

    var repeat = this.useInstancing ? 1 : 4;
    for (var i=0; i<repeat; i++) {
        var offset = (vi+i) * this.stride;

        // align changes here with the "decodeTriangleData()" function in LineShader.js!!!
        vbf[offset]   = x1;
        vbf[offset+1] = y1;
        vbf[offset+2] = x2;

        vbf[offset+3] = y2;
        vbf[offset+4] = x3;
        vbf[offset+5] = y3;

        this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_ONE_TRIANGLE, color, dbId, layerId, vpId, /*linePattern*/0);
        this.vcount++;
    }

    return vi;
};


VertexBufferBuilder.prototype.addVertexLine = function(x, y, angle, distanceAlong, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType)
{
    var vi  = this.vcount;
    var vbf = this.vbf;

    var repeat = this.useInstancing ? 1 : 4;
    for (var i=0; i<repeat; i++) {
        var offset = (vi + i) * this.stride;

        // align changes here with the "decodeSegmentData()" function in LineShader.js!!!
        vbf[offset]   = x;
        vbf[offset+1] = y;
        vbf[offset+2] = angle;

        vbf[offset+3] = distanceAlong;
        vbf[offset+4] = lineWidth * 0.5; // we are storing only the half width (i.e., the radius)
        vbf[offset+5] = totalDistance;

        this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_LINE_SEGMENT, color, dbId, layerId, vpId, lineType);
        this.vcount++;
    }

    return vi;
};

VertexBufferBuilder.prototype.addVertexTexQuad = function(centerX, centerY, width, height, rotation, color, dbId, layerId, vpId)
{
    var vi  = this.vcount;
    var vbf = this.vbf;

    var repeat = this.useInstancing ? 1 : 4;
    for (var i=0; i<repeat; i++) {
        var offset = (vi + i) * this.stride;

        // align changes here with the "decodeTexQuadData()" function in LineShader.js!!!
        vbf[offset]   = centerX;
        vbf[offset+1] = centerY;
        vbf[offset+2] = rotation;

        vbf[offset+3] = width;
        vbf[offset+4] = height;

        this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_TEX_QUAD, color, dbId, layerId, vpId, /*linePattern*/0);
        this.vcount++;
    }

    return vi;
};


VertexBufferBuilder.prototype.addVertexArc = function(x, y, startAngle, endAngle, major, minor, tilt, lineWidth, color, dbId, layerId, vpId)
{
    var vi  = this.vcount;
    var vbf = this.vbf;

    var geomType = (major == minor) ? VBB_GT_ARC_CIRCULAR : VBB_GT_ARC_ELLIPTICAL;

    var repeat = this.useInstancing ? 1 : 4;
    for (var i=0; i<repeat; i++) {
        var offset = (vi+i) * this.stride;

        // align changes here with the "decodeArcData()" function in LineShader.js!!!
        vbf[offset]   = x;
        vbf[offset+1] = y;
        vbf[offset+2] = startAngle;

        vbf[offset+3] = endAngle;
        vbf[offset+4] = lineWidth * 0.5; // we are storing only the half width (i.e., the radius)
        vbf[offset+5] = major; // = radius for circular arcs

        if (geomType === VBB_GT_ARC_ELLIPTICAL) {
            vbf[offset+10] = minor;
            vbf[offset+11] = tilt;
        }

        this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, geomType, color, dbId, layerId, vpId, /*linePattern*/0);
        this.vcount++;
    }

    return vi;
};




//====================================================================================================
//====================================================================================================
// Indexed triangle code path can only be used when hardware instancing is not in use.
// Otherwise, the addTriangleGeom operation should be used to add simple triangles to the buffer.
//====================================================================================================
//====================================================================================================

VertexBufferBuilder.prototype.addVertex = function(x, y, color, dbId, layerId, vpId)
{
    if (this.useInstancing)
        return;//not supported if instancing is used.

    var vi     = this.vcount;
    var offset = this.stride * vi;
    var vbf    = this.vbf;

    // align changes here with the "decodeTriangleData()" function in LineShader.js!!!
    vbf[offset]   = x;
    vbf[offset+1] = y;

    this.setCommonVertexAttribs(offset, /*vertexId*/0, VBB_GT_TRIANGLE_INDEXED, color, dbId, layerId, vpId, /*linePattern*/0);
    this.vcount++;

    return vi;
};


VertexBufferBuilder.prototype.addVertexPolytriangle = function(x, y, color, dbId, layerId, vpId)
{
    if (this.useInstancing)
        return;//not supported if instancing is used.

    this.addVertex(x, y, color, dbId, layerId, vpId);

    this.addToBounds(x, y);
};

VertexBufferBuilder.prototype.addIndices = function(indices, vindex) {

    if (this.useInstancing)
        return; //not supported if instancing is used.

    var ib = this.ib;
    var ii = this.icount;

    if (ii + indices.length >= ib.length) {
        var ibnew = new Uint16Array(ib.length * 2);
        for (var i=0; i<ii; ++i) {
            ibnew[i] = ib[i];
        }
        this.ib = ib = ibnew;
    }

    for(var i=0; i<indices.length; ++i) {
        ib[ii+i] = vindex + indices[i];
    }

    this.icount += indices.length;
};

//====================================================================================================
//====================================================================================================
// End indexed triangle code path.
//====================================================================================================
//====================================================================================================


VertexBufferBuilder.prototype.finalizeQuad = function(vindex)
{
    if (!this.useInstancing) {
        this.addIndices(QUAD_TRIANGLE_INDICES, vindex);
    }
};


VertexBufferBuilder.prototype.addSegment = function(x1, y1, x2, y2, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType)
{
    var dx = x2 - x1;
    var dy = y2 - y1;
    var angle  = (dx || dy) ? Math.atan2(dy, dx)       : 0.0;
    var segLen = (dx || dy) ? Math.sqrt(dx*dx + dy*dy) : 0.0;

    //Add four vertices for the bbox of this line segment
    //This call sets the stuff that's common for all four
    var v = this.addVertexLine(x1, y1, angle, segLen, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType);

    this.finalizeQuad(v);
    this.addToBounds(x1, y1);
    this.addToBounds(x2, y2);
};


//Creates a non-indexed triangle geometry (triangle vertex coords stored in single vertex structure)
VertexBufferBuilder.prototype.addTriangleGeom = function(x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId)
{
    this.numTriangleGeoms++;

    var v = this.addVertexTriangleGeom(x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId);

    this.finalizeQuad(v);
    this.addToBounds(x1, y1);
    this.addToBounds(x2, y2);
    this.addToBounds(x3, y3);
};

VertexBufferBuilder.prototype.addArc = function(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layerId, vpId)
{
    if(major == minor)  {
        this.numCirculars++;
    } else {
        this.numEllipticals++;
    }

    // This is a workaround, when the circular arc has rotation, the extractor cannot handle it.
    // After the fix is deployed in extractor, this can be removed.
    var result = fixUglyArc(start, end);
    start = result.start;
    end   = result.end;

    //If both start and end angles are exactly 0, it's a complete ellipse/circle
    //This is working around a bug in the F2D writer, where an fmod operation will potentially.
    //convert 2pi to 0.
    if (start == 0 && end == 0)
        end = TAU;

    //Add two zero length segments as round caps at the end points
    {
        //If it's a full ellipse, then we don't need caps
        var range = Math.abs(start - end);
        if (range > 0.0001 && Math.abs(range - TAU) > 0.0001)
        {
            var sx = cx + major * Math.cos(start);
            var sy = cy + minor * Math.sin(start);
            this.addSegment(sx, sy, sx, sy, 0, lineWidth, color, dbId, layerId, vpId);

            var ex = cx + major * Math.cos(end);
            var ey = cy + minor * Math.sin(end);
            this.addSegment(ex, ey, ex, ey, 0, lineWidth, color, dbId, layerId, vpId);

            //TODO: also must add all the vertices at all multiples of PI/2 in the start-end range to get exact bounds
        }
        else
        {
            this.addToBounds(cx - major, cy - minor);
            this.addToBounds(cx + major, cy + minor);
        }
    }

    var v = this.addVertexArc(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layerId, vpId);

    this.finalizeQuad(v);

    //Testing caps
    if(false) {
        //If it's a full ellipse, then we don't need caps
        var range = Math.abs(start - end);
        if (Math.abs(range - TAU) > 0.0001)
        {
            var sx = cx + major * Math.cos(start);
            var sy = cy + minor * Math.sin(start);
            this.addSegment(sx, sy, sx, sy, 0, lineWidth, 0xff00ffff, dbId, layerId, vpId);

            var ex = cx + major * Math.cos(end);
            var ey = cy + minor * Math.sin(end);
            this.addSegment(ex, ey, ex, ey, 0, lineWidth, 0xff00ffff, dbId, layerId, vpId);
        }
    }
}


VertexBufferBuilder.prototype.addTexturedQuad = function(centerX, centerY, width, height, rotation, color, dbId, layerId, vpId)
{
    //Height is specified using the line weight field.
    //This will result in height being clamped to at least one pixel
    //but that's ok (zero height for an image would be rare).
    var v = this.addVertexTexQuad(centerX, centerY, width, height, rotation, color, dbId, layerId, vpId);

    this.finalizeQuad(v);

    var cos = 0.5 * Math.cos(rotation);
    var sin = 0.5 * Math.sin(rotation);
    var w = Math.abs(width * cos) + Math.abs(height * sin);
    var h = Math.abs(width * sin) + Math.abs(height * cos);
    this.addToBounds(centerX - w, centerY - h);
    this.addToBounds(centerX + w, centerY + h);
};

VertexBufferBuilder.prototype.isFull = function(addCount)
{
    addCount = addCount || 3;
    var mult = this.useInstancing ? 4 : 1;

    return (this.vcount * mult + addCount > 32767);
};

VertexBufferBuilder.prototype.toMesh = function()
{
    var mesh = {};

    mesh.vb = new Float32Array(this.vb.slice(0, this.vcount * this.stride * 4));
    mesh.vbstride = this.stride;

    var d = this.useInstancing ? 1 : 0;

    mesh.vblayout = {
        "fields1" :    { offset: 0,                   itemSize: 3, bytesPerItem: 4, divisor: d, normalize: false },
        "fields2" :    { offset: 3,                   itemSize: 3, bytesPerItem: 4, divisor: d, normalize: false },
        "color4b":     { offset: VBB_COLOR_OFFSET,    itemSize: 4, bytesPerItem: 1, divisor: d, normalize: true  },
        "dbId4b":      { offset: VBB_DBID_OFFSET,     itemSize: 4, bytesPerItem: 1, divisor: d, normalize: false },
        "flags4b":     { offset: VBB_FLAGS_OFFSET,    itemSize: 4, bytesPerItem: 1, divisor: d, normalize: false },
        "layerVp4b":   { offset: VBB_LAYER_VP_OFFSET, itemSize: 4, bytesPerItem: 1, divisor: d, normalize: false }
    };

    //Are we using an expanded vertex layout -- then add the extra attribute to the layout
    if (this.stride > 10) {
        mesh.vblayout["extraParams"] = { offset: 10, itemSize: 2, bytesPerItem: 4, divisor: d, normalize: false };
    }

    if (this.useInstancing) {
        mesh.numInstances = this.vcount;

        //Set up trivial vertexId and index attributes

        var instFlags = new Int32Array([ VBB_SEG_START_RIGHT, VBB_SEG_START_LEFT, VBB_SEG_END_RIGHT, VBB_SEG_END_LEFT ]);
        mesh.vblayout.instFlags4b = { offset: 0, itemSize: 4, bytesPerItem: 1, divisor: 0, normalize: false };
        mesh.vblayout.instFlags4b.array = instFlags.buffer;

        var idx = mesh.indices = new Uint16Array(QUAD_TRIANGLE_INDICES);
    } else {
        mesh.indices = new Uint16Array(this.ib.buffer.slice(0, 2 * this.icount));
    }

    mesh.dbIds = this.dbIds;

    var w  = this.maxx - this.minx;
    var h  = this.maxy - this.miny;
    var sz = Math.max(w, h);

    mesh.boundingBox = {
        min: { x: this.minx, y: this.miny, z: -sz * 1e-3 },
        max: { x: this.maxx, y: this.maxy, z:  sz * 1e-3 }
    };

    //Also compute a rough bounding sphere
    var bs = mesh.boundingSphere = {
        center: {
            x: 0.5 * (this.minx + this.maxx),
            y: 0.5 * (this.miny + this.maxy),
            z: 0.0
        },
        radius: 0.5 * Math.sqrt(w*w + h*h)
    };

    return mesh;
};

// The following logic attempts to "fix" imprecisions in arc definitions introduced
// by Heidi's fixed point math, in case that the extractor doesn't handle it correctly.

var fixUglyArc = function (start, end)
{
    //Snap critical angles exactly
    function snapCritical() {
        function fuzzyEquals(a, b) { return (Math.abs(a - b) < 1e-3); }

        if (fuzzyEquals(start, 0))   start = 0.0;
        if (fuzzyEquals(end,   0))   end   = 0.0;
        if (fuzzyEquals(start, TAU)) start = TAU;
        if (fuzzyEquals(end,   TAU)) end   = TAU;
    }

    snapCritical();

    //OK, in some cases the angles are both over-rotated...
    if (start > end) {
        while (start > TAU) {
            start -= TAU;
            end   -= TAU;
        }
    } else {
        while (end > TAU) {
            start -= TAU;
            end   -= TAU;
        }
    }

    //Snap critical angles exactly -- again
    snapCritical();

    //If the arc crosses the x axis, we have to make it clockwise...
    //This is a side effect of bringing over-rotated arcs in range above.
    //For example start = 5.0, end = 7.0 will result in start < 0 and end > 0,
    //so we have to make start > end in order to indicate we are crossing angle = 0.
    if (start < 0 && end > 0) {
        start += TAU;
    }

    return {start: start, end: end};
};

avp.VertexBufferBuilder = VertexBufferBuilder;

})();
;/**
 * Created by stanevt on 5/8/2015.
 */
function init_three_triangulator() {

"use strict";

if (Autodesk.Viewing.Private.Triangulator)
    return;

Autodesk.Viewing.Private.Triangulator = (function() {

    var TOL = 1e-10;

    function isZero(f) {
        return Math.abs(f) < TOL;
    }
    
    function isEqual(a, b) {
        return isZero(a - b);
    }


    function makePointId(idFrom, idTo, meshId) {
        var tmp = idFrom < idTo ? (idFrom + ":" + idTo) : (idTo + ":" + idFrom);
        return meshId + ":" + tmp;
    }

    function Edge(pt1, pt2, id1From, id1To, id2From, id2To, meshId) {

        this.pt1 = pt1;
        this.pt2 = pt2;

        this.p1 = -1;
        this.p2 = -1;

        //Use the triangle edges that created the two planar edge points
        //as IDs for those points.
        this.eid1 = makePointId(id1From, id1To, meshId);
        this.eid2 = makePointId(id2From, id2To, meshId);
    }


    function IntervalNode() {
        
        this.bbox = new THREE.Box2();
        this.left = null;
        this.right = null;
        this.node_edges = [];
    }

    //Acceleration structure for point-in-polygon checking
    function IntervalTree(pts, edges, bbox) {

        this.pts = pts;
        this.edges = edges;
        this.bbox = bbox;
        this.pipResult = false;

    }
    


    IntervalTree.prototype.splitNode = function(node) {
    
        if (node.bbox.min.y >= node.bbox.max.y)
            return;
            
        if (node.node_edges.length < 3)
            return;
    
        var split = 0.5 * (node.bbox.min.y + node.bbox.max.y);
        
        //node.bbox.makeEmpty();

        node.left = new IntervalNode();
        node.right = new IntervalNode();
        
        var pts = this.pts;
        var ne = node.node_edges;
        var remaining_node_edges = [];
        var tmpPt = new THREE.Vector2();
        
        for (var i=0; i<ne.length; i++) {

            var e = this.edges[ne[i]];

            var p1y = pts[e.p1].y;
            var p2y = pts[e.p2].y;

            if (p1y > p2y) {
                var tmp = p1y;
                p1y = p2y;
                p2y = tmp;
            }
            
            var boxPtr = null;
            
            if (p2y < split) {
                node.left.node_edges.push(ne[i]);
                boxPtr = node.left.bbox;
            } else if (p1y > split) {
                node.right.node_edges.push(ne[i]);
                boxPtr = node.right.bbox;
            } else {
                remaining_node_edges.push(ne[i]);
                //boxPtr = node.bbox;
            }
            
            if (boxPtr) {
                tmpPt.set(pts[e.p1].x, pts[e.p1].y);
                boxPtr.expandByPoint(tmpPt);
                tmpPt.set(pts[e.p2].x, pts[e.p2].y);
                boxPtr.expandByPoint(tmpPt);
            }
        }
        
        node.node_edges = remaining_node_edges;
        
        if (node.left.node_edges.length)
            this.splitNode(node.left);
        if (node.right.node_edges.length)
            this.splitNode(node.right);
    };
    

    IntervalTree.prototype.build = function() {

        this.root = new IntervalNode();

        var edge_indices = this.root.node_edges;
        for (var i=0; i<this.edges.length; i++)
            edge_indices.push(i);

        this.root.bbox.copy(this.bbox);

        //split recursively
        this.splitNode(this.root);
    };




    IntervalTree.prototype.pointInPolygonRec = function(node, x, y) {
    
        if (node.bbox.min.y <= y && node.bbox.max.y >= y) {
        
            var pts = this.pts;
            var ne = node.node_edges;
        
            for (var i=0, iEnd=ne.length; i<iEnd; i++) {
            
                var e = this.edges[ne[i]];

                // get the last point in the polygon
                var p1 = pts[e.p1];
                var vtx0X = p1.x;
                var vtx0Y = p1.y;

                // get test bit for above/below X axis
                var yflag0 = (vtx0Y >= y);

                var p2 = pts[e.p2];
                var vtx1X = p2.x;
                var vtx1Y = p2.y;

                var yflag1 = (vtx1Y >= y);

                // Check if endpoints straddle (are on opposite sides) of X axis
                // (i.e. the Y's differ); if so, +X ray could intersect this edge.
                // The old test also checked whether the endpoints are both to the
                // right or to the left of the test point.  However, given the faster
                // intersection point computation used below, this test was found to
                // be a break-even proposition for most polygons and a loser for
                // triangles (where 50% or more of the edges which survive this test
                // will cross quadrants and so have to have the X intersection computed
                // anyway).  I credit Joseph Samosky with inspiring me to try dropping
                // the "both left or both right" part of my code.
                if (yflag0 != yflag1)
                {
                    // Check intersection of pgon segment with +X ray.
                    // Note if >= point's X; if so, the ray hits it.
                    // The division operation is avoided for the ">=" test by checking
                    // the sign of the first vertex wrto the test point; idea inspired
                    // by Joseph Samosky's and Mark Haigh-Hutchinson's different
                    // polygon inclusion tests.
                    if (((vtx1Y-y)*(vtx0X-vtx1X) >=
                            (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)
                    {
                        this.pipResult = !this.pipResult;
                    }
                }

            }
        
        }
        
        var nl = node.left;
        if (nl && nl.bbox.min.y <= y && nl.bbox.max.y >= y) {
            this.pointInPolygonRec(nl, x, y);
        }
        
        var nr = node.right;
        if (nr && nr.bbox.min.y <= y && nr.bbox.max.y >= y) {
            this.pointInPolygonRec(nr, x, y);
        }

    };
    
    IntervalTree.prototype.pointInPolygon = function(x, y) {
    
          this.pipResult = false;
          
          this.pointInPolygonRec(this.root, x, y);
          
          return this.pipResult;
    
    };



    
    //Functionality for converting a list of two point segments into a connected
    //set of (hopefully) closed contour lines. The contour set is then used
    //for triangulation
    function ContourSet(edges, bbox) {
    
        this.edges = edges;
        this.bbox = bbox;
    
        this.pts = [];
        this.idmap = {};
        this.xymap = {};
        this.contours = [];

        this.scale = (1e6) / this.bbox.size().length();
    }
    
    
    
    ContourSet.prototype.getPointIndex = function(px, py, eid) {
        var findByEdgeId = this.idmap[eid];
        if (findByEdgeId !== undefined) {
            return findByEdgeId;
        }
/*
        findByEdgeId = this.idmap[eid] = this.pts.length;
        pts.push({x: px, y: py, id: eid});
        return findByEdgeId;
*/

        var x = 0 | (px * this.scale);
        var y = 0 | (py * this.scale);

        var mx = this.xymap[x];
        var my;

        if (mx === undefined) {
            this.xymap[x] = mx = {};
            my = undefined;
        } else {
            my = mx[y];
        }

        if (my === undefined) {
            mx[y] = my = this.pts.length;
            this.idmap[eid] = my;
            this.pts.push({x: px, y: py /*, id : eid*/});
        }

        return my;
    };
    
    ContourSet.prototype.snapEdges = function() {
        
        for (var i=0; i<this.edges.length; i++) {

            var e = this.edges[i];

            e.p1 = this.getPointIndex(e.pt1.x, e.pt1.y, e.eid1);
            e.p2 = this.getPointIndex(e.pt2.x, e.pt2.y, e.eid2);
        }
    };

    ContourSet.prototype.sanitizeEdges = function() {
        var edgeSet = {};
        var sanitizedEdges = [];

        for (var i = 0, len = this.edges.length; i < len; i++) {
            var e = this.edges[i];
            if (e.p1 === e.p2) {
                continue;
            }

            var key = Math.min(e.p1, e.p2) + ':' + Math.max(e.p1, e.p2);
            if (edgeSet[key] !== true) {
                edgeSet[key] = true;
                sanitizedEdges.push(e);
            }
        }

        this.edges = sanitizedEdges;
    };

    ContourSet.prototype.stitchContours = function() {
        
        //Create jump table from edge to edge
        //and back
        var edge_table = {};
        
        for (var i=0; i<this.edges.length; i++) {
            var e = this.edges[i];
            
            if (e.p1 === e.p2)
                continue;
            
            if (edge_table[e.p1] !== undefined)
                edge_table[e.p1].push(e.p2);
            else                
                edge_table[e.p1] = [e.p2];
            
            if (edge_table[e.p2] !== undefined)
                edge_table[e.p2].push(e.p1);
            else
                edge_table[e.p2] = [e.p1];
        }
        
        var cur_cntr = [];
        
        for (var p in edge_table) {
            if (edge_table[p].length !== 2) {
                stderr("Incomplete edge table");
                break;
            }
        }
        
        //Start with the first edge, and stitch until we can no longer
        while (true) {
        
            var sfrom = undefined;
        
            //Look for doubly connected point first
            for (var p in edge_table) {
                if (edge_table[p].length > 1) {
                    sfrom = p;
                    break;
                }
            }

            //If no double-connected point found, we know
            //the it will be an open contour, but stitch as much 
            //as we can anyway.
            if (!sfrom) {            
                for (var p in edge_table) {
                    if (edge_table[p].length > 0) {
                        sfrom = p;
                        break;
                    }
                }
            }

            if (!sfrom)
                break;

            var prev = -1;
            var cur = parseInt(sfrom);
            var cur_segs = edge_table[sfrom];

            //start a new contour
            cur_cntr.push(cur);

            while (cur_segs && cur_segs.length) {
                
                var toPt = cur_segs.shift();
                
                //skip backpointer if we hit it
                if (toPt === prev)
                    toPt = cur_segs.shift();

                if (toPt === undefined) {
                    delete edge_table[cur];
                    break;
                }
                        
                cur_cntr.push(toPt);
                
                if (cur_segs.length == 0)
                    delete edge_table[cur];
                else if (cur_segs[0] === prev)
                    delete edge_table[cur];
                
                prev = cur;
                cur = toPt;
                cur_segs = edge_table[toPt];
            }
            
            if (cur_cntr.length) {
                this.contours.push(cur_cntr);
                cur_cntr = [];
            }
        }

        var openCntrs = [];
        for (var i=0; i<this.contours.length; i++) {
            var cntr = this.contours[i];
            if (cntr[0] !== cntr[cntr.length-1])
                openCntrs.push(cntr);
        }


        if (openCntrs.length) {
            //console.warn("Incomplete stitch");
            
            var didSomething = true;
            while (didSomething) {
                
                didSomething = false;

                //Try to combine contours
                var cntr_edge_table = {};
                var contours = this.contours;
                
                for (var i=0; i<contours.length; i++) {
                    var cntr = contours[i];
                    var start = cntr[0];
                    var end = cntr[cntr.length-1];
                    
                    if (start === end)
                        continue;
                    
                    if (!cntr_edge_table[start])
                        cntr_edge_table[start] = [-i-1];
                    else
                        cntr_edge_table[start].push(-i-1);
                        
                    
                    if (!cntr_edge_table[end])
                        cntr_edge_table[end] = [i];
                    else
                        cntr_edge_table[end].push(i);
                }

                for (var p in cntr_edge_table) {
                    var entry = cntr_edge_table[p];

                    if (entry.length == 2) {
                        var toerase = undefined;

                        if (entry[0] < 0 && entry[1] < 0) {
                            var c1 = -entry[0]-1; var c2 = -entry[1]-1;
                            //join start point to startpoint
                            contours[c2].shift();
                            Array.prototype.push.apply(contours[c1].reverse(),contours[c2]);
                            toerase = c2;
                        }

                        if (entry[0] < 0 && entry[1] > 0) {
                            var c1 = -entry[0]-1; var c2 = entry[1];
                            //join start point to endpoint
                            contours[c2].pop();
                            Array.prototype.push.apply(contours[c2], contours[c1]);
                            toerase = c1;
                        }

                        if (entry[0] > 0 && entry[1] < 0) {
                            var c1 = entry[0]; var c2 = -entry[1]-1;
                            //join end point to startpoint
                            contours[c1].pop();
                            Array.prototype.push.apply(contours[c1], contours[c2]);
                            toerase = c2;
                        }

                        if (entry[0] > 0 && entry[1] > 0) {
                            var c1 = entry[0]; var c2 = entry[1];
                            //join end point to endpoint
                            contours[c1].pop();
                            Array.prototype.push.apply(contours[c1], contours[c2].reverse());
                            toerase = c2;
                        }
                        
                        if (toerase !== undefined) {
                            contours.splice(toerase, 1);
                            didSomething = true;
                        }
                        break;
                    }
                }

            }
            
        }


    };




    

    function TriangulatedSurface(cset) {

        this.indices = [];

        this.cset = cset;
        var _pts = this.pts = cset.pts;
        
        this.intervalTree = new IntervalTree(cset.pts, cset.edges, cset.bbox);
        this.intervalTree.build();


        for (var i=0; i<_pts.length; i++) {
            _pts[i].id = i;
        }
        
        var sweepCtx = new lmv_poly2tri.SweepContext([]);
        
        sweepCtx.points_  = _pts.slice();



        if (cset.contours) {
        
            var contours = this.cset.contours;
            
            for (var j=0; j<contours.length; j++) {
            
                var cntr = contours[j];
                
                //Contour is not closed
                var isOpen = (cntr[0] !== cntr[cntr.length-1]);
                
                //if (isOpen)
                //    continue;
                
                var edge = [];
                
                for (var k=0; k<cntr.length-1; k++) {
                    edge.push(_pts[cntr[k]]);
                }
                
                sweepCtx.initEdges(edge, isOpen);
            }

        } else {
        
            var edges = this.cset.edges;
        
            for (var i=0; i<edges.length; i++) {
                
                var e = edges[i];
                
                if (e.p1 == e.p2)
                    continue;
                
                var triedge = [_pts[e.p1], _pts[e.p2]];
                sweepCtx.initEdges(triedge, true);
            }
            
        }
        
        this.triangulate(sweepCtx);
        this.processResult(sweepCtx);
    }
    
    
    TriangulatedSurface.prototype.triangulate = function(sweepCtx) {
    
        try {
            sweepCtx.triangulate();
        } catch (e) {
        }
    };
    
    
    TriangulatedSurface.prototype.processResult = function(sweepCtx) {
        for (var i=0; i<sweepCtx.map_.length; i++) {
            var t = sweepCtx.map_[i];
            var p0 = t.points_[0];
            var p1 = t.points_[1];
            var p2 = t.points_[2];

            if (p0.id !== undefined && p1.id !== undefined && p2.id !== undefined)
                this.filterFace(p0.id, p1.id, p2.id);

        }
    };
    
    
    
    TriangulatedSurface.prototype.pointInEdgeList = function(x, y) {
        var yflag0, yflag1;
        var vtx0X, vtx0Y, vtx1X, vtx1Y;

        var pts = this.cset.pts;
        var edges = this.cset.edges;

        var inside_flag = false;


        for (var j= 0, jEnd = edges.length; j<jEnd; ++j)
        {
            var e = edges[j];

            // get the last point in the polygon
            vtx0X = pts[e.p1].x;
            vtx0Y = pts[e.p1].y;

            // get test bit for above/below X axis
            yflag0 = (vtx0Y >= y);


            vtx1X = pts[e.p2].x;
            vtx1Y = pts[e.p2].y;

            yflag1 = (vtx1Y >= y);

            // Check if endpoints straddle (are on opposite sides) of X axis
            // (i.e. the Y's differ); if so, +X ray could intersect this edge.
            // The old test also checked whether the endpoints are both to the
            // right or to the left of the test point.  However, given the faster
            // intersection point computation used below, this test was found to
            // be a break-even proposition for most polygons and a loser for
            // triangles (where 50% or more of the edges which survive this test
            // will cross quadrants and so have to have the X intersection computed
            // anyway).  I credit Joseph Samosky with inspiring me to try dropping
            // the "both left or both right" part of my code.
            if (yflag0 != yflag1)
            {
                // Check intersection of pgon segment with +X ray.
                // Note if >= point's X; if so, the ray hits it.
                // The division operation is avoided for the ">=" test by checking
                // the sign of the first vertex wrto the test point; idea inspired
                // by Joseph Samosky's and Mark Haigh-Hutchinson's different
                // polygon inclusion tests.
                if (((vtx1Y-y)*(vtx0X-vtx1X) >=
                        (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)
                {
                    inside_flag = !inside_flag;
                }
            }
        }

        return inside_flag;
    };

    
    
    TriangulatedSurface.prototype.pointInContour = function(x, y, cntr) {
        var yflag0, yflag1;
        var vtx0X, vtx0Y, vtx1X, vtx1Y;

        var inside_flag = false;
        
        var pts = this.cset.pts;

        // get the last point in the polygon
        vtx0X = pts[cntr[cntr.length-1]].x;
        vtx0Y = pts[cntr[cntr.length-1]].y;

        // get test bit for above/below X axis
        yflag0 = (vtx0Y >= y);

        for (var j= 0, jEnd=cntr.length; j<jEnd; ++j)
        {
            vtx1X = pts[cntr[j]].x;
            vtx1Y = pts[cntr[j]].y;

            yflag1 = (vtx1Y >= y);

            // Check if endpoints straddle (are on opposite sides) of X axis
            // (i.e. the Y's differ); if so, +X ray could intersect this edge.
            // The old test also checked whether the endpoints are both to the
            // right or to the left of the test point.  However, given the faster
            // intersection point computation used below, this test was found to
            // be a break-even proposition for most polygons and a loser for
            // triangles (where 50% or more of the edges which survive this test
            // will cross quadrants and so have to have the X intersection computed
            // anyway).  I credit Joseph Samosky with inspiring me to try dropping
            // the "both left or both right" part of my code.
            if (yflag0 != yflag1)
            {
                // Check intersection of pgon segment with +X ray.
                // Note if >= point's X; if so, the ray hits it.
                // The division operation is avoided for the ">=" test by checking
                // the sign of the first vertex wrto the test point; idea inspired
                // by Joseph Samosky's and Mark Haigh-Hutchinson's different
                // polygon inclusion tests.
                if (((vtx1Y-y)*(vtx0X-vtx1X) >=
                        (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)
                {
                    inside_flag = !inside_flag;
                }
            }

            // move to the next pair of vertices, retaining info as possible
            yflag0 = yflag1;
            vtx0X = vtx1X;
            vtx0Y = vtx1Y;
        }

        return inside_flag;
    };


    TriangulatedSurface.prototype.pointInPolygon = function(x, y) {
        var inside = false;

        for (var i=0; i<this.cset.contours.length; i++) {

            if (this.pointInContour(x, y, this.cset.contours[i]))
                inside = !inside;
        }

        return inside;
    };

    
    TriangulatedSurface.prototype.filterFace = function(i0, i1, i2) {

        var p0 = this.pts[i0];
        var p1 = this.pts[i1];
        var p2 = this.pts[i2];

        var cx = (p0.x + p1.x + p2.x) / 3;
        var cy = (p0.y + p1.y + p2.y) / 3;

        if (this.intervalTree.pointInPolygon(cx, cy)) {
       // if (this.pointInEdgeList(cx, cy)) {
       // if (pointInPolygon(cx, cy)) {

            var e1x = p1.x - p0.x;
            var e1y = p1.y - p0.y;
            var e2x = p2.x - p0.x;
            var e2y = p2.y - p0.y;

            var cross = e1x * e2y - e2x * e1y;

            if (cross > 0) {
                this.indices.push(i0, i1, i2);
            } else {
                this.indices.push(i0, i2, i1);
            }

        }
    };
    
    


    return {

        TriangulatedSurface : TriangulatedSurface,
        ContourSet : ContourSet,
        Edge: Edge

    };


})();

}
;
function init_three_intersector() {

"use strict";

if (Autodesk.Viewing.Private.Intersector)
    return;

Autodesk.Viewing.Private.Intersector = (function() {

    var TOL = 1e-10;
    var Edge = Autodesk.Viewing.Private.Triangulator.Edge;

    function isZero(f) {
        return Math.abs(f) < TOL;
    }

    function isEqual(a, b) {
        return isZero(a - b);
    }


	var v1 = new THREE.Vector3();

    function xPlaneSegment(plane, pt0, pt1, res1, res2) {

        var direction = v1.subVectors(pt1, pt0);

        var denominator = plane.normal.dot( direction );

        if ( isZero(denominator) ) {

            res1.copy(pt0);
            res2.copy(pt1);

            // line is coplanar
            return 2;
        }
        
        denominator = 1.0 / denominator;

        var t = - ( pt0.dot( plane.normal ) * denominator + plane.constant * denominator);

        if ( t < -TOL || t > 1 + TOL ) {

            return 0;

        }

        var pt = direction.multiplyScalar( t ).add( pt0 );

        res1.copy(pt);

        return 1;
    }


    var res1 = new THREE.Vector3();
    var res2 = new THREE.Vector3();

    // res is array containing result segments.
    // returns number of intersection point on the plane (0, 1, or 2) with the values of the points stored in the res array
    function xTrianglePlane(plane, pt0, pt1, pt2, i0, i1, i2, res, meshId) {

        var d0 = plane.distanceToPoint(pt0);
        var d1 = plane.distanceToPoint(pt1);
        var d2 = plane.distanceToPoint(pt2);

        // Check if all points are to one side of the plane
        if (d0 < -TOL && d1 < -TOL && d2 < -TOL) {
            return null;
        }
        if (d0 > TOL && d1 > TOL && d2 > TOL) {
            return null;
        }

        var s0 = Math.sign(d0);
        var s1 = Math.sign(d1);
        var s2 = Math.sign(d2);

        // Skip coplanar triangles (leave it to the neighbouring triangles to contribute their edges)
        if (s0 === 0 && s1 === 0 && s2 === 0) {
            return null;
        }

        var tmp1, tmp2;
        var i1From, i1To, i2From, i2To;

        //There is intersection, compute it
        if (s0 !== s1) {
            var numInts = xPlaneSegment(plane, pt0, pt1, res1, res2);
            if (numInts == 2) {
                res.push(new Edge(pt0.clone(), pt1.clone(), i0, i0, i1, i1, meshId));
                return;
            } else if (numInts == 1) {
                i1From = i0; 
                i1To = i1;
                tmp1 = res1.clone();
            } else {
                console.warn("Unexpected zero intersections where at least one was expected");
            }
        }

        if (s1 !== s2) {
            var numInts = xPlaneSegment(plane, pt1, pt2, res1, res2);
            if (numInts == 2) {
                res.push(new Edge(pt1.clone(), pt2.clone(), i1, i1, i2, i2, meshId));
                return;
            } else if (numInts == 1) {
                if (tmp1) {
                    // Avoid the singular scenario where the signs are 0, -1 and +1
                    if (res1.distanceTo(tmp1) > TOL) {
                        i2From = i1;
                        i2To = i2;    
                        tmp2 = res1.clone();
                    }
                }
                else {
                    i1From = i1;
                    i1To = i2;
                    tmp1 = res1.clone();
                }
            } else {
                console.warn("Unexpected zero intersections where at least one was expected");
            }
        }

        if (s2 !== s0) {
            var numInts = xPlaneSegment(plane, pt2, pt0, res1, res2);
            if (numInts == 2) {
                res.push(new Edge(pt2.clone(), pt0.clone(), i2, i2, i0, i0, meshId));
                return;
            } else if (numInts == 1) {
                if (tmp1) {
                    // Avoid the singular scenario where the signs are 0, -1 and +1
                    if (res1.distanceTo(tmp1) > TOL) {
                        i2From = i2;
                        i2To = i0;
                        tmp2 = res1.clone();
                    }
                } else {
                    console.warn("Unexpected single intersection point");
                }
            } else {
                console.warn("Unexpected zero intersections where at least one was expected");
            }
        }


        if (tmp1 && tmp2) {
            res.push(new Edge(tmp1, tmp2, i1From, i1To, i2From, i2To, meshId));
        } else {
            console.warn("Unexpected one intersection where two were expected");
        }

    }
    
    var point = new THREE.Vector3();
    
    function xBoxPlane(plane, box) {
    
        point.set( box.min.x, box.min.y, box.min.z ); // 000
        var d = plane.distanceToPoint(point);
        var s = Math.sign(d);
        
        point.set( box.min.x, box.min.y, box.max.z ); // 001
        var d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;
        
        point.set( box.min.x, box.max.y, box.min.z ); // 010
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.min.x, box.max.y, box.max.z ); // 011
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.max.x, box.min.y, box.min.z ); // 100
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.max.x, box.min.y, box.max.z ); // 101
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.max.x, box.max.y, box.min.z ); // 110
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.max.x, box.max.y, box.max.z ); // 111        
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        return false;
    }

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();
    var mi = new THREE.Matrix4();
    var pi = new THREE.Plane();

	function xMeshPlane( plane, mesh, intersects ) {

        var geometry = mesh.geometry;
        var baseIndex = intersects.length;

        var attributes = geometry.attributes;
        
        var matrixWorld = mesh.matrixWorld;
        mi.getInverse(matrixWorld);
        pi.copy(plane).applyMatrix4(mi);

        var a, b, c;

        if (attributes.index !== undefined) {

            var indices = attributes.index.array || geometry.ib;
            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;
            var offsets = geometry.offsets;

            if (!offsets || offsets.length === 0) {

                offsets = [{start: 0, count: indices.length, index: 0}];

            }

            for (var oi = 0, ol = offsets.length; oi < ol; ++oi) {

                var start = offsets[oi].start;
                var count = offsets[oi].count;
                var index = offsets[oi].index;

                for (var i = start, il = start + count; i < il; i += 3) {

                    a = index + indices[i];
                    b = index + indices[i + 1];
                    c = index + indices[i + 2];

                    vA.x = positions[a*stride]; vA.y = positions[a*stride+1]; vA.z = positions[a*stride+2];
                    vB.x = positions[b*stride]; vB.y = positions[b*stride+1]; vB.z = positions[b*stride+2];
                    vC.x = positions[c*stride]; vC.y = positions[c*stride+1]; vC.z = positions[c*stride+2];
                    
                    /*
                    vA.fromArray(positions, a * stride);
                    vB.fromArray(positions, b * stride);
                    vC.fromArray(positions, c * stride);
                    */
                    
                    xTrianglePlane(pi, vA, vB, vC, a, b, c, intersects, mesh.fragId);
                }

            }

        } else {

            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;

            for (var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9) {

                a = i;
                b = i + 1;
                c = i + 2;

                vA.x = positions[a*stride]; vA.y = positions[a*stride+1]; vA.z = positions[a*stride+2];
                vB.x = positions[b*stride]; vB.y = positions[b*stride+1]; vB.z = positions[b*stride+2];
                vC.x = positions[c*stride]; vC.y = positions[c*stride+1]; vC.z = positions[c*stride+2];

                /*
                vA.fromArray(positions, a * stride);
                vB.fromArray(positions, b * stride);
                vC.fromArray(positions, c * stride);
                */

                xTrianglePlane(pi, vA, vB, vC, a, b, c, intersects, mesh.fragId);
            }

        }

        //Put the points into world space. It should actually be possible to do
        //the entire math in object space -- but we have to check if all fragments
        //that belong to the same dbId have the same world transform.
        for (var i=baseIndex; i<intersects.length; i++) {
            intersects[i].pt1.applyMatrix4(matrixWorld);
            intersects[i].pt2.applyMatrix4(matrixWorld);
        }

    }


	function makeRotationAxis( axis, cosa, m ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = cosa;
		var s = Math.sqrt(1.0 - c*c);
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		m.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

	}


	function makePlaneBasis(plane) {

        //var origin = plane.coplanarPoint();

        var sceneUp = new THREE.Vector3(0,0,1);
        var cross = plane.normal.clone().cross(sceneUp);
        cross = cross.normalize();
        var dot = sceneUp.dot(plane.normal);

        //We are ignoring the translation here, since
        //we will drop the Z coord for the 2D processing steps anyway.
        var planeBasis = new THREE.Matrix4();

        if (!(isZero(cross.x) && isZero(cross.y) && isZero(cross.z))) {
            makeRotationAxis(cross, dot, planeBasis);
            planeBasis.elements[14] = plane.constant;
        } else {
            planeBasis.elements[14] = dot * plane.constant;
        }

        return planeBasis;
    }


    function convertToPlaneCoords(planeBasis, edges3d, bbox) {

        for (var i=0; i<edges3d.length; i++) {
            var e = edges3d[i];

            e.pt1.applyMatrix4(planeBasis);
            e.pt2.applyMatrix4(planeBasis);

            bbox.expandByPoint(e.pt1);
            bbox.expandByPoint(e.pt2);
        }
    }


    return {

        makePlaneBasis: makePlaneBasis,
        convertToPlaneCoords: convertToPlaneCoords,

        intersectTrianglePlane : xTrianglePlane,
        intersectMeshPlane : xMeshPlane,
        intersectBoxPlane : xBoxPlane

    };

})();

}
;(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;


/**
 * BVH definitions:
 *
 * BVH Node: if this was C (the only real programming language), it would go something like this,
 * but with better alignment.
 *
 * This is definition for "fat" nodes (for rasterization),
 * i.e. when inner nodes also contain primitives.
 * struct Node {                                                            byte/short/int offset
 *      float worldBox[6]; //world box of the node node                         0/0/0
 *      int leftChildIndex; //pointer to left child node (right is left+1)     24/12/6
 *      ushort primCount; //how many fragments are at this node                28/14/7
 *      ushort flags; //bitfield of good stuff                                 30/15/7.5
 *
 *      int primStart; //start of node's own primitives (fragments) list       32/16/8
 * };
 * => sizeof(Node) = 36 bytes

 * Definition for lean nodes (for ray casting): when a node is either inner node (just children, no primitives)
 * or leaf (just primitives, no children).
 * struct Node {
 *      float worldBox[6]; //world box of the node node
 *      union {
 *          int leftChildIndex; //pointer to left child node (right is left+1)
 *          int primStart; //start of node's own primitives (fragments) list
 *      };
 *      ushort primCount; //how many fragments are at this node
 *      ushort flags; //bitfield of good stuff
 * };
 * => sizeof(Node) = 32 bytes
 *
 * The class below encapsulates an array of such nodes using ArrayBuffer as backing store.
 *
 * @param {ArrayBuffer|number} initialData  Initial content of the NodeArray, or initial allocation of empty nodes
 * @param {boolean} useLeanNode Use minimal node structure size. Currently this parameter must be set to false.
 */
function NodeArray(initialData, useLeanNode) {
    'use strict';

    if (useLeanNode) {
        this.bytes_per_node = 32;
    } else {
        this.bytes_per_node = 36;
    }

    var initialCount;
    var initialBuffer;

    if (initialData instanceof ArrayBuffer) {
        initialCount = initialData.byteLength / this.bytes_per_node;
        initialBuffer = initialData;
        this.nodeCount = initialCount;
    }
    else {
        initialCount = initialData | 0;
        initialBuffer =  new ArrayBuffer(this.bytes_per_node * initialCount);
        this.nodeCount = 0;
    }

    this.nodeCapacity = initialCount;
    this.nodesRaw = initialBuffer;

    this.is_lean_node = useLeanNode;
    this.node_stride = this.bytes_per_node  / 4;
    this.node_stride_short = this.bytes_per_node / 2;

    //Allocate memory buffer for all tree nodes
    this.nodesF = new Float32Array(this.nodesRaw);
    this.nodesI = new Int32Array(this.nodesRaw);
    this.nodesS = new Uint16Array(this.nodesRaw);
}

NodeArray.prototype.setLeftChild = function(nodeidx, childidx) {
    this.nodesI[nodeidx * this.node_stride + 6] = childidx;
};
NodeArray.prototype.getLeftChild = function(nodeidx) {
    return this.nodesI[nodeidx * this.node_stride + 6];
};

NodeArray.prototype.setPrimStart = function(nodeidx, start) {
    if (this.is_lean_node)
        this.nodesI[nodeidx * this.node_stride + 6] = start;
    else
        this.nodesI[nodeidx * this.node_stride + 8] = start;
};
NodeArray.prototype.getPrimStart = function(nodeidx) {
    if (this.is_lean_node)
        return this.nodesI[nodeidx * this.node_stride + 6];
    else
        return this.nodesI[nodeidx * this.node_stride + 8];
};

NodeArray.prototype.setPrimCount = function(nodeidx, count) {
    this.nodesS[nodeidx * this.node_stride_short + 14] = count;
};
NodeArray.prototype.getPrimCount = function(nodeidx) {
    return this.nodesS[nodeidx * this.node_stride_short + 14];
};

NodeArray.prototype.setFlags = function(nodeidx, axis, isFirst, isTransparent) {
    this.nodesS[nodeidx * this.node_stride_short + 15] = (isTransparent << 3) | (isFirst << 2) | (axis & 0x3);
};
NodeArray.prototype.getFlags = function(nodeidx) {
    return this.nodesS[nodeidx * this.node_stride_short + 15];
};

NodeArray.prototype.setBox0 = function(nodeidx, src) {
    var off = nodeidx * this.node_stride;
    var dst = this.nodesF;
    dst[off] = src[0];
    dst[off+1] = src[1];
    dst[off+2] = src[2];
    dst[off+3] = src[3];
    dst[off+4] = src[4];
    dst[off+5] = src[5];
};
NodeArray.prototype.getBoxThree = function(nodeidx, dst) {
    var off = nodeidx * this.node_stride;
    var src = this.nodesF;
    dst.min.x = src[off];
    dst.min.y = src[off+1];
    dst.min.z = src[off+2];
    dst.max.x = src[off+3];
    dst.max.y = src[off+4];
    dst.max.z = src[off+5];
};
NodeArray.prototype.setBoxThree = function(nodeidx, src) {
    var off = nodeidx * this.node_stride;
    var dst = this.nodesF;
    dst[off] = src.min.x;
    dst[off+1] = src.min.y;
    dst[off+2] = src.min.z;
    dst[off+3] = src.max.x;
    dst[off+4] = src.max.y;
    dst[off+5] = src.max.z;
};




NodeArray.prototype.makeEmpty = function(nodeidx) {

    var off = nodeidx * this.node_stride;
    var dst = this.nodesI;

    //No point to makeEmpty here, because the box gets set
    //directly when the node is initialized in bvh_subdivide.
    //box_make_empty(this.nodesF, off);

    //_this.setLeftChild(nodeidx,-1);
    dst[off + 6] = -1;

    //both prim count and flags to 0
    dst[off + 7] = 0;

    //_this.setPrimStart(nodeidx, -1);
    if (!this.is_lean_node)
        dst[off + 8] = -1;

};

NodeArray.prototype.realloc = function(extraSize) {
    if (this.nodeCount + extraSize > this.nodeCapacity) {
        var nsz = 0 | (this.nodeCapacity * 3 / 2);
        if (nsz < this.nodeCount + extraSize)
            nsz = this.nodeCount + extraSize;

        var nnodes = new ArrayBuffer(nsz * this.bytes_per_node);
        var nnodesI = new Int32Array(nnodes);
        nnodesI.set(this.nodesI);

        this.nodeCapacity = nsz;
        this.nodesRaw = nnodes;
        this.nodesF = new Float32Array(nnodes);
        this.nodesI = nnodesI;
        this.nodesS = new Uint16Array(nnodes);
    }
};

NodeArray.prototype.nextNodes = function(howMany) {

    this.realloc(howMany);

    var res = this.nodeCount;
    this.nodeCount += howMany;

    for (var i=0; i<howMany; i++) {
        this.makeEmpty(res+i);
    }

    return res;
};

NodeArray.prototype.getRawData = function() {
    return this.nodesRaw.slice(0, this.nodeCount * this.bytes_per_node);
};

var BOX_STRIDE = 6;
var POINT_STRIDE = 3;
var BOX_EPSILON = 1e-5;
var BOX_SCALE_EPSILON = 1e-5;
var MAX_DEPTH = 15; /* max tree depth */
var MAX_BINS = 16;

/**
* Bounding Volume Hierarchy build algorithm.
* Uses top down binning -- see "On fast Construction of SAH-based Bounding Volume Hierarchies" by I.Wald
* Ported from the C version here: https://git.autodesk.com/stanevt/t-ray/blob/master/render3d/t-ray/t-core/t-bvh.c
* Optimized for JavaScript.
*/
var BVHModule = function() {
    //There be dragons in this closure.

"use strict";


/**
 * Utilities for manipulating bounding boxes stored
 * in external array (as sextuplets of float32)
 */


function box_get_centroid(dst, dst_off, src, src_off) {
    dst[dst_off] = 0.5*(src[src_off] + src[src_off + 3]);
    dst[dst_off+1] = 0.5*(src[src_off + 1] + src[src_off + 4]);
    dst[dst_off+2] = 0.5*(src[src_off + 2] + src[src_off + 5]);
}

function box_add_point_0(dst, src, src_off) {

    if (dst[0] > src[src_off])   dst[0] = src[src_off];
    if (dst[3] < src[src_off])   dst[3] = src[src_off];

    if (dst[1] > src[src_off+1]) dst[1] = src[src_off+1];
    if (dst[4] < src[src_off+1]) dst[4] = src[src_off+1];

    if (dst[2] > src[src_off+2]) dst[2] = src[src_off+2];
    if (dst[5] < src[src_off+2]) dst[5] = src[src_off+2];

}

function box_add_box_0(dst, src, src_off) {

    if (dst[0] > src[src_off]) dst[0] = src[src_off];
    if (dst[1] > src[src_off+1]) dst[1] = src[src_off+1];
    if (dst[2] > src[src_off+2]) dst[2] = src[src_off+2];

    if (dst[3] < src[src_off+3]) dst[3] = src[src_off+3];
    if (dst[4] < src[src_off+4]) dst[4] = src[src_off+4];
    if (dst[5] < src[src_off+5]) dst[5] = src[src_off+5];
}

function box_add_box_00(dst, src) {
    if (dst[0] > src[0]) dst[0] = src[0];
    if (dst[1] > src[1]) dst[1] = src[1];
    if (dst[2] > src[2]) dst[2] = src[2];

    if (dst[3] < src[3]) dst[3] = src[3];
    if (dst[4] < src[4]) dst[4] = src[4];
    if (dst[5] < src[5]) dst[5] = src[5];
}

function box_get_size(dst, dst_off, src, src_off) {
    for (var i=0; i<3; i++) {
        dst[dst_off+i] = src[src_off+3+i] - src[src_off+i];
    }
}

//function box_copy(dst, dst_off, src, src_off) {
//    for (var i=0; i<6; i++) {
//        dst[dst_off+i] = src[src_off+i];
//    }
//}

// unwound version of box_copy
function box_copy_00(dst, src) {
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
    dst[4] = src[4];
    dst[5] = src[5];
}

var dbl_max = Infinity;

//function box_make_empty(dst, dst_off) {
//        dst[dst_off]   =  dbl_max;
//        dst[dst_off+1] =  dbl_max;
//        dst[dst_off+2] =  dbl_max;
//        dst[dst_off+3] = -dbl_max;
//        dst[dst_off+4] = -dbl_max;
//        dst[dst_off+5] = -dbl_max;
//}

function box_make_empty_0(dst) {
    dst[0] =  dbl_max;
    dst[1] =  dbl_max;
    dst[2] =  dbl_max;
    dst[3] = -dbl_max;
    dst[4] = -dbl_max;
    dst[5] = -dbl_max;
}

function box_area(src, src_off) {

    var dx = src[src_off+3] - src[src_off];
    var dy = src[src_off+4] - src[src_off+1];
    var dz = src[src_off+5] - src[src_off+2];

    if (dx < 0 || dy < 0 || dz < 0)
        return 0;

    return 2.0 * (dx * dy + dy * dz + dz * dx);
}

function box_area_0(src) {

    var dx = src[3] - src[0];
    var dy = src[4] - src[1];
    var dz = src[5] - src[2];

    if (dx < 0 || dy < 0 || dz < 0)
        return 0;

    return 2.0 * (dx * dy + dy * dz + dz * dx);
}





function bvh_split_info() {
    this.vb_left = new Float32Array(6);
    this.vb_right = new Float32Array(6);
    this.cb_left = new Float32Array(6);
    this.cb_right = new Float32Array(6);
    this.num_left = 0;
    this.best_split = -1;
    this.best_cost = -1;
    this.num_bins = -1;
}

bvh_split_info.prototype.reset = function () {
    this.num_left = 0;
    this.best_split = -1;
    this.best_cost = -1;
    this.num_bins = -1;
};


function bvh_bin() {
    this.box_bbox = new Float32Array(6); // bbox of all primitive bboxes
    this.box_centroid = new Float32Array(6); // bbox of all primitive centroids
    this.num_prims = 0; // number of primitives in the bin
}

bvh_bin.prototype.reset = function() {
    this.num_prims = 0; // number of primitives in the bin
    box_make_empty_0(this.box_bbox);
    box_make_empty_0(this.box_centroid);
};

function accum_bin_info() {
    this.BL = new Float32Array(6);
    this.CL = new Float32Array(6);
    this.NL = 0;
    this.AL = 0;
}

accum_bin_info.prototype.reset = function() {
    this.NL = 0;
    this.AL = 0;

    box_make_empty_0(this.BL);
    box_make_empty_0(this.CL);
};


//Scratch variables used by bvh_bin_axis
//TODO: can be replaced by a flat ArrayBuffer
var bins = [];
var i;
for (i=0; i<MAX_BINS; i++) {
    bins.push(new bvh_bin());
}

//TODO: can be replaced by a flat ArrayBuffer
var ai = [];
for (i=0; i<MAX_BINS-1; i++)
    ai.push(new accum_bin_info());

var BR = new Float32Array(6);
var CR = new Float32Array(6);


function assign_bins(bvh, start, end, axis, cb, cbdiag, num_bins) {

    var centroids = bvh.centroids;
    var primitives = bvh.primitives;
    var boxes = bvh.boxes;

    /* bin assignment */
    var k1 = num_bins * (1.0 - BOX_SCALE_EPSILON) / cbdiag[axis];
    var cbaxis = cb[axis];
    var sp = bvh.sort_prims;

    for (var j = start; j <= end; j++)
    {
        /* map array index to primitive index -- since primitive index array gets reordered by the BVH build*/
        /* while the primitive info array is not reordered */
        var iprim = primitives[j]|0;

        var fpbin = k1 * (centroids[iprim * 3/*POINT_STRIDE*/ + axis] - cbaxis);
        var binid = fpbin|0; //Truncate to int is algorithmic -> not an optimization thing!

        /* possible floating point problems */
        if (binid < 0)
        {
            binid = 0;
            //debug("Bin index out of range " + fpbin);
        }
        else if (binid >= num_bins)
        {
            binid = num_bins-1;
            //debug("Bin index out of range. " + fpbin);
        }

        /* Store the bin index for the partitioning step, so we don't recompute it there */
        sp[j] = binid;

        /* update other bin data with the new primitive */
        //var bin = bins[binid];
        bins[binid].num_prims ++;

        box_add_box_0(bins[binid].box_bbox, boxes, iprim * 6/*BOX_STRIDE*/);
        box_add_point_0(bins[binid].box_centroid, centroids, iprim * 3 /*POINT_STRIDE*/);
    }
    /* at this point all primitves are assigned to a bin */
}


function bvh_bin_axis(bvh, start, end, axis, cb, cbdiag, split_info) {

    /* if size is near 0 on this axis, cost of split is infinite */
    if (cbdiag[axis] < bvh.scene_epsilon)
    {
        split_info.best_cost = Infinity;
        return;
    }

    var num_bins = MAX_BINS;
    if (num_bins > end-start+1)
        num_bins = end-start+1;

    var i;
    for (i=0; i<num_bins; i++)
        bins[i].reset();

    for (i=0; i<num_bins-1; i++)
        ai[i].reset();

    split_info.num_bins = num_bins;

    assign_bins(bvh, start, end, axis, cb, cbdiag, num_bins);


    /* now do the accumulation sweep from left to right */
    box_copy_00(ai[0].BL, bins[0].box_bbox);
    box_copy_00(ai[0].CL, bins[0].box_centroid);
    ai[0].AL = box_area_0(ai[0].BL);
    ai[0].NL = bins[0].num_prims;
    var bin;
    for (i=1; i<num_bins-1; i++)
    {
        bin = bins[i];
        var aii = ai[i];
        box_copy_00(aii.BL, ai[i-1].BL);
        box_add_box_00(aii.BL, bin.box_bbox);
        aii.AL = box_area_0(aii.BL);

        box_copy_00(aii.CL, ai[i-1].CL);
        box_add_box_00(aii.CL, bin.box_centroid);

        aii.NL = ai[i-1].NL + bin.num_prims;
    }

    /* sweep from right to left, keeping track of lowest cost and split */
    i = num_bins - 1;
    box_copy_00(BR, bins[i].box_bbox);
    box_copy_00(CR, bins[i].box_centroid);
    var AR = box_area_0(BR);
    var NR = bins[i].num_prims;

    var best_split = i;
    var best_cost = AR * NR + ai[i-1].AL * ai[i-1].NL;
    box_copy_00(split_info.vb_right, BR);
    box_copy_00(split_info.cb_right, bins[i].box_centroid);
    box_copy_00(split_info.vb_left, ai[i-1].BL);
    box_copy_00(split_info.cb_left, ai[i-1].CL);
    split_info.num_left = ai[i-1].NL;

    for (i=i-1; i>=1; i--)
    {
        bin = bins[i];
        box_add_box_00(BR, bin.box_bbox);
        box_add_box_00(CR, bin.box_centroid);
        AR = box_area_0(BR);
        NR += bin.num_prims;

        var cur_cost = AR * NR + ai[i-1].AL * ai[i-1].NL;

        if (cur_cost <= best_cost)
        {
            best_cost = cur_cost;
            best_split = i;

            box_copy_00(split_info.vb_right, BR);
            box_copy_00(split_info.cb_right, CR);
            box_copy_00(split_info.vb_left, ai[i-1].BL);
            box_copy_00(split_info.cb_left, ai[i-1].CL);
            split_info.num_left = ai[i-1].NL;
        }
    }

    split_info.best_split = best_split;
    split_info.best_cost = best_cost;
}

function bvh_partition(bvh, start, end, axis, cb, cbdiag, split_info) {

    //At this point, the original algorithm does an in-place NON-STABLE partition
    //to move primitives to the left and right sides of the split plane
    //into contiguous location of the primitives list for use by
    //the child nodes. But, we want to preserve the ordering by size
    //without having to do another sort, so we have to use
    //a temporary storage location to copy into. We place right-side primitives
    //in temporary storage, then copy back into the original storage in the right order.
    //Left-side primitives are still put directly into the destination location.
    var primitives = bvh.primitives;
    //var centroids = bvh.centroids;
    var i,j;

    //sort_prims contains bin indices computed during the split step.
    //Here we read those and also use sort_prims as temporary holding
    //of primitive indices. Hopefully the read happens before the write. :)
    //In C it was cheap enough to compute this again...
    //var k1 = split_info.num_bins * (1.0 - BOX_SCALE_EPSILON) / cbdiag[axis];
    //var cbaxis = cb[axis];
    var sp = bvh.sort_prims;

    var right = 0;
    var left = start|0;
    var best_split = split_info.best_split|0;

    for (i=start; i<=end; i++) {
        var iprim = primitives[i]|0;
        //var fpbin = (k1 * (centroids[3/*POINT_STRIDE*/ * iprim + axis] - cbaxis));
        var binid = sp[i]; /* fpbin|0; */

        if (binid < best_split) {
            primitives[left++] = iprim;
        } else {
            sp[right++] = iprim;
        }
    }

    //if ((left-start) != split_info.num_left)
    //    debug("Mismatch between binning and partitioning.");

    //Copy back the right-side primitives into main primitives array, while
    //maintaining order
    for (j=0; j<right; j++) {
        primitives[left+j] = sp[j];
    }
    /* at this point the binning is complete and we have computed a split */
}


function bvh_fatten_inner_node(bvh, nodes, nodeidx, start, end, cb, cbdiag, poly_cut_off) {

    var primitives = bvh.primitives;
    var centroids = bvh.centroids;

    //Take the first few items to place into the inner node,
    //but do not go over the max item or polygon count.
    var prim_count = end - start + 1;

    if (prim_count > bvh.frags_per_inner_node)
        prim_count = bvh.frags_per_inner_node;

    if (prim_count > poly_cut_off)
        prim_count = poly_cut_off;


    nodes.setPrimStart(nodeidx, start);
    nodes.setPrimCount(nodeidx, prim_count);
    start += prim_count;

    //Because we take some primitives off the input, we have to recompute
    //the bounding box used for computing the node split.
    box_make_empty_0(cb);
    for (var i=start; i<=end; i++) {
        box_add_point_0(cb, centroids, 3/*POINT_STRIDE*/ * primitives[i]);
    }

    //Also update the split axis -- it could possibly change too.
    box_get_size(cbdiag, 0, cb, 0);
    //Decide which axis to split on.
    var axis = 0;
    if (cbdiag[1] > cbdiag[0])
        axis = 1;
    if (cbdiag[2] > cbdiag[axis])
        axis = 2;

    return axis;
}


var cbdiag = new Float32Array(3); //scratch variable used in bvh_subdivide

function bvh_subdivide(bvh,
                       nodeidx, /* current parent node to consider splitting */
                       start, end, /* primitive sub-range to be considered at this recursion step */
                       vb, /* bounding volume of the primitives' bounds in the sub-range */
                       cb, /* bounding box of primitive centroids in this range */
                       transparent, /* does the node contain opaque or transparent objects */
                       depth /* recursion depth */
                       )
{
    box_get_size(cbdiag, 0, cb, 0);
    var nodes = bvh.nodes;
    var frags_per_leaf = transparent ? bvh.frags_per_leaf_node_transparent : bvh.frags_per_leaf_node;
    var frags_per_inner = transparent ? bvh.frags_per_inner_node_transparent : bvh.frags_per_inner_node;
    var polys_per_node = bvh.max_polys_per_node;

    //Decide which axis to split on.
    var axis = 0;
    if (cbdiag[1] > cbdiag[0])
        axis = 1;
    if (cbdiag[2] > cbdiag[axis])
        axis = 2;

    //Whether the node gets split or not, it gets
    //the same overall bounding box.
    nodes.setBox0(nodeidx, vb);

    //Check the expected polygon count of the node
    var poly_count = 0;
    var poly_cut_off = 0;
    if (bvh.polygonCounts) {
        for (var i=start; i<=end; i++) {
            poly_count += bvh.polygonCounts[bvh.primitives[i]];
            poly_cut_off++;
            if (poly_count > polys_per_node)
                break;
        }
    }

    var prim_count = end - start + 1;

    var isSmall = ((prim_count <= frags_per_leaf) && (poly_count < polys_per_node)) ||
                  (prim_count === 1);

    //Decide whether to terminate recursion
    if (isSmall ||
      depth > MAX_DEPTH || //max recusrion depth
      cbdiag[axis] < bvh.scene_epsilon) //node would be way too tiny for math to make sense (a point)
    {
        nodes.setLeftChild(nodeidx, -1);
        nodes.setPrimStart(nodeidx, start);
        nodes.setPrimCount(nodeidx, end-start+1);
        nodes.setFlags(nodeidx, 0, 0, transparent ? 1 : 0);
        return;
    }

    //Pick the largest (first) primitives to live in this node
    //NOTE: this assumes primitives are sorted by size.
    //NOTE: This step is an optional departure from the original
    if (frags_per_inner) {
        axis = bvh_fatten_inner_node(bvh, nodes, nodeidx, start, end, cb, cbdiag, poly_cut_off);
        start = start + nodes.getPrimCount(nodeidx);
    }

    var split_info = new bvh_split_info();

    //Do the binning of the remaining primitives to go into child nodes
    bvh_bin_axis(bvh, start, end, axis, cb, cbdiag, split_info);

    if (split_info.num_bins < 0) {
        //Split was too costly, so add all objects to the current node and bail
        nodes.setPrimCount(nodeidx, nodes.getPrimCount(nodeidx) + end - start + 1);
        return;
    }

    bvh_partition(bvh, start, end, axis, cb, cbdiag, split_info);

    var child_idx = nodes.nextNodes(2);

    /* set info about split into the node */
    var cleft = (split_info.vb_left[3+axis] + split_info.vb_left[axis]) * 0.5;
    var cright = (split_info.vb_right[3+axis] + split_info.vb_right[axis]) * 0.5;

    nodes.setFlags(nodeidx, axis, cleft < cright ? 0 : 1, transparent ? 1 : 0);
    nodes.setLeftChild(nodeidx, child_idx);


    /* validate split */
    /*
    if (true) {
        for (var i=start; i< start+num_left; i++)
        {
            //int binid = (int)(k1 * (info->prim_info[info->bvh->iprims[i]].centroid.v[axis] - cb->min.v[axis]));
            var cen = primitives[i] * POINT_STRIDE;
            if (   centroids[cen] < split_info.cb_left[0]
                || centroids[cen] > split_info.cb_left[3]
                || centroids[cen+1] < split_info.cb_left[1]
                || centroids[cen+1] > split_info.cb_left[4]
                || centroids[cen+2] < split_info.cb_left[2]
                || centroids[cen+2] > split_info.cb_left[5])
            {
                debug ("wrong centroid box");
            }
        }

        for (i=start+num_left; i<=end; i++)
        {
            //int binid = (int)(k1 * (info->prim_info[info->bvh->iprims[i]].centroid.v[axis] - cb->min.v[axis]));
            var cen = primitives[i] * POINT_STRIDE;
            if (   centroids[cen] < split_info.cb_right[0]
                || centroids[cen] > split_info.cb_right[3]
                || centroids[cen+1] < split_info.cb_right[1]
                || centroids[cen+1] > split_info.cb_right[4]
                || centroids[cen+2] < split_info.cb_right[2]
                || centroids[cen+2] > split_info.cb_right[5])
            {
                debug ("wrong centroid box");
            }
        }
    }
    */

    /* recurse */
   //bvh_subdivide(bvh, child_idx, start, start + split_info.num_left - 1, split_info.vb_left, split_info.cb_left, transparent, depth+1);
   //bvh_subdivide(bvh, child_idx + 1, start + split_info.num_left, end, split_info.vb_right, split_info.cb_right, transparent, depth+1);

    //Iterative stack-based recursion for easier profiling
   bvh.recursion_stack.push([bvh, child_idx + 1, start + split_info.num_left, end, split_info.vb_right, split_info.cb_right, transparent, depth+1]);
   bvh.recursion_stack.push([bvh, child_idx, start, start + split_info.num_left - 1, split_info.vb_left, split_info.cb_left, transparent, depth+1]);

}


function compute_boxes(bvh) {

    var boxv_o = bvh.boxv_o;
    var boxc_o = bvh.boxc_o;
    var boxv_t = bvh.boxv_t;
    var boxc_t = bvh.boxc_t;

    box_make_empty_0(boxv_o);
    box_make_empty_0(boxc_o);
    box_make_empty_0(boxv_t);
    box_make_empty_0(boxc_t);

    var c = bvh.centroids;
    var b = bvh.boxes;

    for (var i=0, iEnd=bvh.prim_count; i<iEnd; i++) {


        box_get_centroid(c, 3/*POINT_STRIDE*/*i, b, 6/*BOX_STRIDE*/*i);

        if (i >= bvh.first_transparent) {

            box_add_point_0(boxc_t, c, 3/*POINT_STRIDE*/*i);
            box_add_box_0(boxv_t, b, 6/*BOX_STRIDE*/*i);

        } else {

            box_add_point_0(boxc_o, c, 3/*POINT_STRIDE*/*i);
            box_add_box_0(boxv_o, b, 6/*BOX_STRIDE*/*i);

        }
    }

    box_get_size(cbdiag, 0, bvh.boxv_o, 0);
    var maxsz = Math.max(cbdiag[0], cbdiag[1], cbdiag[2]);
    bvh.scene_epsilon = BOX_EPSILON * maxsz;
}




    //Module exports
    return {
        bvh_subdivide : bvh_subdivide,
        compute_boxes : compute_boxes,
        box_area : box_area
    };

}();



//Given a list of LMV fragments, builds a spatial index for view-dependent traversal and hit testing
function BVHBuilder(fragments, materialDefs) {

    //Invariants
    this.boxes = fragments.boxes; //Array of Float32, each bbox is a sextuplet
    this.polygonCounts = fragments.polygonCounts;
    this.materials = fragments.materials; //material indices (we need to know which fragments are transparent)
    this.materialDefs = materialDefs;

    this.prim_count = fragments.length;

    //To be initialized by build() function based on build options
    this.frags_per_leaf_node = -1;
    this.frags_per_inner_node = -1;
    this.nodes = null;

    this.work_buf = new ArrayBuffer(this.prim_count * 4);
    this.sort_prims = new Int32Array(this.work_buf);

    //Allocate memory buffer for re-ordered fragment primitive indices,
    //which will be sorted by node ownership and point to the index
    //of the fragment data.
    this.primitives = new Int32Array(this.prim_count);

    //The BVH split algorithm works based on centroids of the bboxes.
    this.centroids = new Float32Array(POINT_STRIDE * this.prim_count);

    //BBoxes and centroid bboxes for opaque and transparent primitive sets
    this.boxv_o = new Float32Array(6);
    this.boxc_o = new Float32Array(6);
    this.boxv_t = new Float32Array(6);
    this.boxc_t = new Float32Array(6);


    this.recursion_stack = [];
}

BVHBuilder.prototype.sortPrimitives = function() {

    var prim_sizes = new Float32Array(this.work_buf);
    var matDefs = this.materialDefs;
    var matInds = this.materials;
    var primitives = this.primitives;
    var numTransparent = 0;

    var i, iEnd;
    for (i=0, iEnd=this.prim_count; i<iEnd; i++) {

        //Start with trivial 1:1 order of the indices array
        primitives[i] = i;

        var transparent = matDefs && matDefs[matInds[i]] ? matDefs[matInds[i]].transparent : false;

        if (transparent)
            numTransparent++;

        if (WANT_SORT) {
            prim_sizes[i] = BVHModule.box_area(this.boxes, BOX_STRIDE*i);

            //In order to make transparent objects appear last,
            //we give them a negative size, so that they are naturally
            //sorted last in the sort by size.
            if (transparent)
                prim_sizes[i] = -prim_sizes[i];
        } else {
            //We still need the transparency flag for the loop below
            //where we find the last opaque item, but we can
            //short-cut the size computation.
            prim_sizes[i] = transparent ? -1 : 1;
        }
    }

    //Sort the input objects by size
    //TODO: Actually, we assume all LMV SVF files come
    //sorted by draw priority already, so we can skip this step.
    //However, the transparent objects do not always come last (bug in LMVTK?),
    //so we still have to pull them out to the end of the list
    var WANT_SORT = false;

    if (WANT_SORT) {
        Array.prototype.sort.call(this.primitives, function(a, b) {
            return prim_sizes[b] - prim_sizes[a];
        });
    } else {
        if (numTransparent && numTransparent < this.prim_count) {

            var tmpTransparent = new Int32Array(numTransparent);
            var oidx = 0, tidx = 0;

            for (i=0, iEnd = this.prim_count; i<iEnd; i++) {
                if (prim_sizes[i] >= 0)
                    primitives[oidx++] = primitives[i];
                else
                    tmpTransparent[tidx++] = primitives[i];
            }

            primitives.set(tmpTransparent, this.prim_count - numTransparent);
        }
    }

    this.first_transparent = this.prim_count - numTransparent;
};


BVHBuilder.prototype.build = function(options) {
    //Kick off the BVH build.

    var useSlimNodes = options && !!options.useSlimNodes;

    var self = this;
    function assign_option(name, defaultVal) {
        if (options.hasOwnProperty(name))
            self[name] = options[name];
        else
            self[name] = defaultVal;
    }

    //options for build optimized for rasterization renderer scenes
    if (useSlimNodes) {
        assign_option("frags_per_leaf_node", 1);
        assign_option("frags_per_inner_node", 0);
        assign_option("frags_per_leaf_node_transparent", 1);
        assign_option("frags_per_inner_node_transparent", 0);
        assign_option("max_polys_per_node", Infinity);
    } else {
        var multiplier = options.isWeakDevice ? 0.5 : 1.0;

        //TODO: tune these constants
        assign_option("frags_per_leaf_node", 0 | (32 * multiplier));
        //Placing fragments at inner nodes places more emphasis on bigger objects during tree traversal
        //but it can only be done for opaque objects. Transparent objects have to be strictly back to front
        //traversal regardless of size, unless a unified traversal
        assign_option("frags_per_inner_node", 0|(this.frags_per_leaf_node) );
        assign_option("frags_per_leaf_node_transparent", this.frags_per_leaf_node);
        assign_option("frags_per_inner_node_transparent", 0);
        assign_option("max_polys_per_node", 0 | (10000 * multiplier));
    }

    //Reuse existing node array if there
    if (this.nodes && (this.nodes.is_lean_node == useSlimNodes))
        this.nodes.nodeCount = 0;
    else {
        var est_nodes = this.prim_count / this.frags_per_leaf_node;
        var num_nodes = 1;
        while (num_nodes < est_nodes)
            num_nodes *= 2;

        this.nodes = new NodeArray(num_nodes, options ? options.useSlimNodes : false);
    }

    this.sortPrimitives();

    BVHModule.compute_boxes(this);

    //Init the root nodes at 0 for opaque
    //and 1 for transparent objects
    var root = this.nodes.nextNodes(2);

    //Now kick off the recursive tree build

    //Opaque
    BVHModule.bvh_subdivide(this, root, 0, this.first_transparent - 1, this.boxv_o, this.boxc_o, false, 0);

    var a;
    while(this.recursion_stack.length) {
        a = this.recursion_stack.pop();
        BVHModule.bvh_subdivide(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }

    //Transparent
    BVHModule.bvh_subdivide(this, root+1, this.first_transparent, this.prim_count-1, this.boxv_t, this.boxc_t, true, 0);

    while(this.recursion_stack.length) {
        a = this.recursion_stack.pop();
        BVHModule.bvh_subdivide(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
};

avp.NodeArray = NodeArray;
avp.BVHBuilder = BVHBuilder;

})();;

(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = Autodesk.Viewing.Private;

var TAU = Math.PI * 2;

//Constants duplicated from src/lmvtk/VertexBufferBuilder.js
var VBB_GT_TRIANGLE_INDEXED = 0,
    VBB_GT_LINE_SEGMENT     = 1,
    VBB_GT_ARC_CIRCULAR     = 2,
    VBB_GT_ARC_ELLIPTICAL   = 3,
    VBB_GT_TEX_QUAD         = 4,
    VBB_GT_ONE_TRIANGLE     = 5;

var VBB_INSTANCED_FLAG  = 0, // this is intentionally 0 for the instancing case!
    VBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!
    VBB_SEG_START_LEFT  = 1,
    VBB_SEG_END_RIGHT   = 2,
    VBB_SEG_END_LEFT    = 3;

var VBB_COLOR_OFFSET    = 6,
    VBB_DBID_OFFSET     = 7,
    VBB_FLAGS_OFFSET    = 8,
    VBB_LAYER_VP_OFFSET = 9;

/**
 * Initializes a "view" into a compacted interleaved vertex buffer array using our custom 2D vertex layout.
 * See src/lmvtk/VertexBufferBuilder.js for more details.
 */
avp.VertexBufferReader = function(geometry)
{
    this.vb  = geometry.vb.buffer;
    this.vbf = new Float32Array(this.vb);
    this.vbi = new Int32Array(this.vb);

    this.stride = geometry.vbstride;
    this.vcount = this.vbf.length / this.stride;

    this.useInstancing = false; // TODO: derive value from somewhere...
};

avp.VertexBufferReader.prototype.getDbIdAt = function(vindex) {
    return this.vbi[vindex*this.stride + VBB_DBID_OFFSET];
};

avp.VertexBufferReader.prototype.getVertexFlagsAt = function(vindex) {
    return this.vbi[vindex*this.stride + VBB_FLAGS_OFFSET];
};

avp.VertexBufferReader.prototype.getLayerIndexAt = function(vindex) {
    return this.vbi[vindex*this.stride + VBB_LAYER_VP_OFFSET] & 0xffff;
};

avp.VertexBufferReader.prototype.getViewportIndexAt = function(vindex) {
    return (this.vbi[vindex*this.stride + VBB_LAYER_VP_OFFSET] >> 16) & 0xffff;
};

avp.VertexBufferReader.prototype.decodeLineAt = function(vindex, layer, vpId, callback)
{
    if (!callback.onLineSegment) { return; }

    var baseOffset = this.stride * vindex;
    var x0         = this.vbf[baseOffset];
    var y0         = this.vbf[baseOffset+1];
    var angle      = this.vbf[baseOffset+2];
    var distAlong  = this.vbf[baseOffset+3];

    var x1 = x0 + distAlong * Math.cos(angle);
    var y1 = y0 + distAlong * Math.sin(angle);

    callback.onLineSegment(x0, y0, x1, y1, vpId);
};

avp.VertexBufferReader.prototype.decodeCircularArcAt = function(vindex, layer, vpId, callback)
{
    if (!callback.onCircularArc) { return; }

    var baseOffset = this.stride * vindex;
    var cx         = this.vbf[baseOffset];
    var cy         = this.vbf[baseOffset+1];
    var start      = this.vbf[baseOffset+2];
    var end        = this.vbf[baseOffset+3];
    var radius     = this.vbf[baseOffset+5];

    callback.onCircularArc(cx, cy, start, end, radius, vpId);
};

avp.VertexBufferReader.prototype.decodeEllipticalArcAt = function(vindex, layer, vpId, callback)
{
    if (!callback.onEllipticalArc) { return; }

    var baseOffset = this.stride * vindex;
    var cx         = this.vbf[baseOffset];
    var cy         = this.vbf[baseOffset+1];
    var start      = this.vbf[baseOffset+2];
    var end        = this.vbf[baseOffset+3];
    var major      = this.vbf[baseOffset+5];
    var minor      = this.vbf[baseOffset+10];
    var tilt       = this.vbf[baseOffset+11];

    callback.onEllipticalArc(cx, cy, start, end, major, minor, tilt, vpId);
};

avp.VertexBufferReader.prototype.decodeTriangleVertex = function(vindex, layer, vpId, callback)
{
    if (!callback.onTriangleVertex) { return; }

    var baseOffset = this.stride * vindex;
    var cx         = this.vbf[baseOffset];
    var cy         = this.vbf[baseOffset+1];

    callback.onTriangleVertex(cx, cy, vpId);
};


avp.VertexBufferReader.prototype.enumGeomsForObject = function(dbId, callback)
{
    var i = 0;
    while (i < this.vcount) {
        var flag = this.getVertexFlagsAt(i);

        //var vertexId    = (flag >>  0) & 0xff;        //  8 bit
        var geomType    = (flag >>  8) & 0xff;        //  8 bit
        //var linePattern = (flag >> 16) & 0xff;        //  8 bit
        var layerId     = this.getLayerIndexAt(i);    // 16 bit
        var vpId        = this.getViewportIndexAt(i); // 16 bit

        if (this.getDbIdAt(i) === dbId)
        {
            switch (geomType) {
                case VBB_GT_TRIANGLE_INDEXED:    this.decodeTriangleVertex( i, layerId, vpId, callback); break;
                case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         i, layerId, vpId, callback); break;
                case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  i, layerId, vpId, callback); break;
                case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(i, layerId, vpId, callback); break;
                case VBB_GT_TEX_QUAD:            break; // TODO: do we really want to snap to rasters?
                case VBB_GT_ONE_TRIANGLE:        break; // TODO: do we really want to snap to interior edges?
                default:                         break;
            }
        }

        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,
        //each vertex is listed four times with a different vertexId flag
        i += (this.useInstancing || (geomType == VBB_GT_TRIANGLE_INDEXED)) ? 1 : 4;
    }

};

})();
;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var OUTSIDE     = avp.OUTSIDE       = 0;
var INTERSECTS  = avp.INTERSECTS    = 1;
var CONTAINS    = avp.CONTAINS      = 2;

//Encapsulates frustum-box intersection logic
    function FrustumIntersector() {
        this.frustum = new THREE.Frustum();
        this.viewProj = new THREE.Matrix4();
        this.viewDir = [0, 0, 1];
        this.ar = 1.0;
        this.viewport = new THREE.Vector3(1, 1, 1);
        this.areaConv = 1;
        this.areaCullThreshold = 1; // The pixel size of the object projected on screen, will be culled if less than this value.
    }

    FrustumIntersector.prototype.reset = function (camera) {
        this.viewProj.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this.frustum.setFromMatrix(this.viewProj);
        var vm = camera.matrixWorldInverse.elements;
        this.ar = camera.aspect;
        this.viewDir[0] = -vm[2];
        this.viewDir[1] = -vm[6];
        this.viewDir[2] = -vm[10];
        this.areaConv = (camera.clientWidth * camera.clientHeight) / 4;
    };

    FrustumIntersector.prototype.projectedArea = (function () {

        var points;
        var tmpBox;

        function init_three() {
            if (!points) {
                points = [
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3(),
                    new THREE.Vector3()
                ];
                tmpBox = new THREE.Box2();
            }
        }

        function applyProjection(p, m) {

            var x = p.x, y = p.y, z = p.z;
            var e = m.elements;

            var w = ( e[3] * x + e[7] * y + e[11] * z + e[15] );

            //This is the difference between this function and
            //the normal THREE.Vector3.applyProjection. We avoid
            //inverting the positions of point behind the camera,
            //otherwise our screen area computation can result in
            //boxes getting clipped out when they are in fact partially visible.
            if (w < 0)
                w = -w;

            var d = 1.0 / w;

            p.x = ( e[0] * x + e[4] * y + e[8] * z + e[12] ) * d;
            p.y = ( e[1] * x + e[5] * y + e[9] * z + e[13] ) * d;

            //We also don't need the Z
            //p.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;
        }

        return function (box) {

            init_three();

            var matrix = this.viewProj;

            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            points[0].set(box.min.x, box.min.y, box.min.z); // 000
            points[1].set(box.min.x, box.min.y, box.max.z); // 001
            points[2].set(box.min.x, box.max.y, box.min.z); // 010
            points[3].set(box.min.x, box.max.y, box.max.z); // 011
            points[4].set(box.max.x, box.min.y, box.min.z); // 100
            points[5].set(box.max.x, box.min.y, box.max.z); // 101
            points[6].set(box.max.x, box.max.y, box.min.z); // 110
            points[7].set(box.max.x, box.max.y, box.max.z); // 111

            for (var i = 0; i < 8; i++)
                applyProjection(points[i], matrix);

            tmpBox.makeEmpty();
            tmpBox.setFromPoints(points);

            // Clamp both min and max value between [-1.0, 1.0]
            if (tmpBox.min.x < -1.0)
                tmpBox.min.x = -1.0;
            if (tmpBox.min.x > 1.0)
                tmpBox.min.x = 1.0;
            if (tmpBox.min.y < -1.0)
                tmpBox.min.y = -1.0;
            if (tmpBox.min.y > 1.0)
                tmpBox.min.y = 1.0;

            if (tmpBox.max.x > 1.0)
                tmpBox.max.x = 1.0;
            if (tmpBox.max.x < -1.0)
                tmpBox.max.x = -1.0;
            if (tmpBox.max.y > 1.0)
                tmpBox.max.y = 1.0;
            if (tmpBox.max.y < -1.0)
                tmpBox.max.y = -1.0;

            return (tmpBox.max.x - tmpBox.min.x) * (tmpBox.max.y - tmpBox.min.y);
        };

    })();

    FrustumIntersector.prototype.estimateDepth = function (bbox) {

        var e = this.viewProj.elements;

        // Take center of box and find its distance from the eye.
        var x = (bbox.min.x+bbox.max.x)/2.0;
        var y = (bbox.min.y+bbox.max.y)/2.0;
        var z = (bbox.min.z+bbox.max.z)/2.0;

        var w = e[3] * x + e[7] * y + e[11] * z + e[15];

        var d = 1.0 / ( e[3] * x + e[7] * y + e[11] * z + e[15] );

        return ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;

    };


    FrustumIntersector.prototype.intersectsBox = (function () {

        //Copied from three.js and modified to return separate
        //value for full containment versus intersection.
        //Return values: 0 -> outside, 1 -> intersects, 2 -> contains
        var p1, p2;

        function init_three() {
            if (!p1) {
                p1 = new THREE.Vector3();
                p2 = new THREE.Vector3();
            }
        }

        return function (box) {

            init_three();

            var planes = this.frustum.planes;
            var contained = 0;

            for (var i = 0; i < 6; i++) {

                var plane = planes[i];

                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                var d1 = plane.distanceToPoint(p1);
                var d2 = plane.distanceToPoint(p2);

                // if both outside plane, no intersection

                if (d1 < 0 && d2 < 0) {

                    return OUTSIDE;

                }

                if (d1 > 0 && d2 > 0) {

                    contained++;

                }
            }

            return (contained == 6) ? CONTAINS : INTERSECTS;
        };


    })();


    avp.FrustumIntersector = FrustumIntersector;

})();;

var VBIntersector = (function() {

    "use strict";

	var inverseMatrix;
	var ray;

	var vA;
	var vB;
	var vC;
	
	function init_three() {

        if (!inverseMatrix) {	
            inverseMatrix = new THREE.Matrix4();
            ray = new THREE.Ray();

            vA = new THREE.Vector3();
            vB = new THREE.Vector3();
            vC = new THREE.Vector3();
        }
    }

	function meshRayCast( mesh, raycaster, intersects ) {

        init_three();

        var geometry = mesh.geometry;

		if (!geometry)
		    return;

        var material = mesh.material;
        
        var side = material ? material.side : THREE.FrontSide;

        var attributes = geometry.attributes;

		inverseMatrix.getInverse( mesh.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        var a, b, c, i, j, il;
        var precision = raycaster.precision;
        var positions, stride, intersectionPoint, distance;

        if (attributes.index !== undefined) {

            var indices = attributes.index.array || geometry.ib;
            positions = geometry.vb ? geometry.vb : attributes.position.array;
            stride = geometry.vb ? geometry.vbstride : 3;
            var offsets = geometry.offsets;

            if (!offsets || offsets.length === 0) {

                offsets = [{start: 0, count: indices.length, index: 0}];

            }

            for (var oi = 0, ol = offsets.length; oi < ol; ++oi) {

                var start = offsets[oi].start;
                var count = offsets[oi].count;
                var index = offsets[oi].index;

                for (i = start, il = start + count; i < il; i += 3) {

                    a = index + indices[i];
                    b = index + indices[i + 1];
                    c = index + indices[i + 2];

                    vA.fromArray(positions, a * stride);
                    vB.fromArray(positions, b * stride);
                    vC.fromArray(positions, c * stride);

                    if (side === THREE.BackSide) {

                        intersectionPoint = ray.intersectTriangle(vC, vB, vA, true);

                    } else {

                        intersectionPoint = ray.intersectTriangle(vA, vB, vC, side !== THREE.DoubleSide);

                    }

                    if (intersectionPoint === null) continue;

                    intersectionPoint.applyMatrix4(mesh.matrixWorld);

                    distance = raycaster.ray.origin.distanceTo(intersectionPoint);

                    if (distance < precision || distance < raycaster.near || distance > raycaster.far) continue;

                    intersects.push( {

                        distance: distance,
                        point: intersectionPoint,
                        face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),
                        faceIndex: null,
                        fragId: mesh.fragId,
                        dbId: mesh.dbId

                    } );

                }

            }

        } else {

            positions = geometry.vb ? geometry.vb : attributes.position.array;
            stride = geometry.vb ? geometry.vbstride : 3;

            for (i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9) {

                a = i;
                b = i + 1;
                c = i + 2;

                vA.fromArray(positions, a * stride);
                vB.fromArray(positions, b * stride);
                vC.fromArray(positions, c * stride);

                if (material.side === THREE.BackSide) {

                    intersectionPoint = ray.intersectTriangle(vC, vB, vA, true);

                } else {

                    intersectionPoint = ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);

                }

                if (intersectionPoint === null) continue;

                intersectionPoint.applyMatrix4(mesh.matrixWorld);

                distance = raycaster.ray.origin.distanceTo(intersectionPoint);

                if (distance < precision || distance < raycaster.near || distance > raycaster.far) continue;

                intersects.push( {

                    distance: distance,
                    point: intersectionPoint,
                    face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),
                    faceIndex: null,
                    fragId: mesh.fragId,
                    dbId: mesh.dbId

                } );

            }

        }

    }


	function lineRayCast( mesh, raycaster, intersects ) {

        init_three();

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = mesh.geometry;

		if (!geometry)
		    return;

		inverseMatrix.getInverse( mesh.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		var vStart = new THREE.Vector3();
		var vEnd = new THREE.Vector3();
		var interSegment = new THREE.Vector3();
		var interRay = new THREE.Vector3();
		var step = mesh.mode === THREE.LineStrip ? 1 : 2;
        var positions, stride, distance, distSq;
        var i;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;

			if ( attributes.index !== undefined ) {

				var indices = geometry.ib ? geometry.ib : attributes.index.array;
				positions = geometry.vb ? geometry.vb : attributes.position.array;
 				stride = geometry.vb ? geometry.vbstride : 3;
 				var offsets = geometry.offsets;

				if ( !offsets || offsets.length === 0 ) {

					offsets = [ { start: 0, count: indices.length, index: 0 } ];

				}

				for ( var oi = 0; oi < offsets.length; oi++){

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( i = start; i < start + count - 1; i += step ) {

						var a = index + indices[ i ];
						var b = index + indices[ i + 1 ];

						vStart.fromArray( positions, a * stride );
						vEnd.fromArray( positions, b * stride );

						distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						distance = ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( mesh.matrixWorld ),
							face: null,
							faceIndex: null,
                            fragId: mesh.fragId,
                            dbId: mesh.dbId

						} );

					}

				}

			} else {

				positions = geometry.vb ? geometry.vb : attributes.position.array;
 				stride = geometry.vb ? geometry.vbstride : 3;

				for ( i = 0; i < positions.length / stride - 1; i += step ) {

					vStart.fromArray( positions, stride * i );
					vEnd.fromArray( positions, stride * i + stride );

					distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					distance = ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( mesh.matrixWorld ),
						face: null,
						faceIndex: null,
                        fragId: mesh.fragId,
                        dbId : mesh.dbId
					});

				}

			}

		}
	}


    function rayCast(mesh, raycaster, intersects) {

        if (mesh.isLine)
            lineRayCast(mesh, raycaster, intersects);
        else
            meshRayCast(mesh, raycaster, intersects);

    }


	function intersectObjectRec( object, raycaster, intersects, recursive ) {

        if (object instanceof THREE.Mesh)
            rayCast(object, raycaster, intersects); //use our extended impl in case of Mesh.
        else
            object.raycast( raycaster, intersects ); //fall back to normal THREE.js impl

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObjectRec( children[ i ], raycaster, intersects, true );

			}

		}

	}

	var descSort = function ( a, b ) {
		return a.distance - b.distance;
	};

    function intersectObject(object, raycaster, intersects, recursive) {
        intersectObjectRec(object, raycaster, intersects, recursive);
        intersects.sort(descSort);
    }


    return {
        meshRayCast : meshRayCast,
        lineRayCast : lineRayCast,
        rayCast : rayCast,
        intersectObject : intersectObject
    };

})();


;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

//Finds a precanned BufferAttribute corresponding to the given
//attribute data, so that we don't have to allocate the same exact
//one over and over and over.
    var bufattrs = {};

    function findBufferAttribute(attributeName, attributeData, numInstances) {

        //Note .array could be undefined in case we are using
        //an interleaved buffer.
        var attr;
        if (attributeData.array) {
            attr = new THREE.BufferAttribute(attributeData.array, attributeData.itemSize);
        }
        else {
            var id = attributeName + "|" +
                attributeData.bytesPerItem + "|" +
                attributeData.normalize + "|" +
                attributeData.isPattern + "|" +
                attributeData.divisor + "|" +
                attributeData.offset;

            attr = bufattrs[id];
            if (attr)
                return attr;

            attr = new THREE.BufferAttribute(undefined, attributeData.itemSize);
            bufattrs[id] = attr;
        }

        attr.bytesPerItem = attributeData.bytesPerItem;
        attr.normalize = attributeData.normalize;
        attr.isPattern = attributeData.isPattern;

        if (numInstances) {
            attr.divisor = attributeData.divisor;
        }

        if (attributeData.array) {
            //Is the data for the attribute specified separately
            //from the interleaved VB?
        }
        else if (attributeData.hasOwnProperty("offset")) {
            //If the attribute is in the interleaved VB, it has
            //an offset into it.
            attr.itemOffset = attributeData.offset;
        }
        else {
            stderr("VB attribute is neither interleaved nor separate. Something is wrong with the buffer specificaiton.");
        }

        return attr;
    }

    var attrKeys = {};

    function findAttributesKeys(geometry) {
        var key = "";

        for (var p in geometry.attributes)
            key += p + "|";

        var res = attrKeys[key];
        if (res)
            return res;

        res = Object.keys(geometry.attributes);
        attrKeys[key] = res;

        return res;
    }


    var indexAttr;
    var LmvBufferGeometry;
    var idcounter = 1;

    function init_three_bufgeom() {

        indexAttr = new THREE.BufferAttribute(undefined, 1);

        LmvBufferGeometry = function () {

            //Avoid calling the superclass constructor for performance reasons.
            //Skips the creation of a uuid and defining an accessor for the .id property.
            //THREE.BufferGeometry.call(this);

            //Null those out since we don't need them.
            this.uuid = null;
            this.name = null;
            this.id = idcounter++;

            this.attributes = {};
            this.attributesKeys = [];

            this.drawcalls = [];
            this.offsets = this.drawcalls; // backwards compatibility

            this.boundingBox = null;
            this.boundingSphere = null;

            this.numInstances = undefined;
            this.streamingDraw = false;
            this.streamingIndex = false;
            this.svfid = undefined;

            this.vb = null;
            this.vbbuffer = undefined;
            this.ib = null;
            this.ibbuffer = undefined;
            this.vaos = undefined;

            this.vbNeedsUpdate = false;
            this.vbstride = 0;
            this.byteSize = 0;

            this.attributesKeys = undefined;
            this.__webglInit = false;
        };

        LmvBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
        LmvBufferGeometry.prototype.constructor = LmvBufferGeometry;

    }

    function createLmvBufferGeometry() {
        if (!LmvBufferGeometry)
            init_three_bufgeom();

        return new LmvBufferGeometry();
    }


//Converts a mesh description passed back from worker threads into a renderable three.js
//compatible LmvBufferGeometry.
//Sets various extra flags we need.
    function meshToGeometry(mdata) {

        var mesh = mdata.mesh;
        var geometry = createLmvBufferGeometry();


        geometry.byteSize = 0;

        geometry.vb = mesh.vb;
        geometry.vbbuffer = undefined;
        geometry.vbNeedsUpdate = true;
        geometry.byteSize += mesh.vb.byteLength;

        geometry.vbstride = mesh.vbstride;
        if (mesh.isLines) /* mesh is SVF lines */
            geometry.isLines = mesh.isLines;
        if (mdata.is2d) /* mesh is from F2D */
            geometry.is2d = true;

        geometry.numInstances = mesh.numInstances;

        for (var attributeName in mesh.vblayout) {
            var attributeData = mesh.vblayout[attributeName];

            //geometry.addAttribute(attributeName, findBufferAttribute(attributeData, geometry.numInstances));
            geometry.attributes[attributeName] = findBufferAttribute(attributeName, attributeData, geometry.numInstances);
        }

        //Index buffer setup
        if (!avp.memoryOptimizedLoading) {
            geometry.addAttribute("index", new THREE.BufferAttribute(mesh.indices, 1));
        } else {

            geometry.attributes.index = indexAttr;
            geometry.ib = mesh.indices;
            geometry.ibbuffer = undefined;
        }

        geometry.attributesKeys = findAttributesKeys(geometry);

        geometry.byteSize += mesh.indices.byteLength;

        //TODO: Not sure chunking into list of smaller offset/counts
        //is required for LMV data since it's already broken up.
        //if (mesh.indices.length > 65535)
        //    stderr("Mesh with >65535 indices. May have to break up the draw calls.");
        if (mesh.vb.length / mesh.vbstride > 65535)
            stderr("Mesh with >65535 vertices. It will fail to draw.");

        //TODO: This is a transient object that gets freed once the geometry
        //is added to the GeometryList. We can save on the object creation
        //eventually when we do micro optimizations.
        geometry.boundingBox = new THREE.Box3().copy(mesh.boundingBox);
        geometry.boundingSphere = new THREE.Sphere().copy(mesh.boundingSphere);

        //MEM
        geometry.drawcalls = null;
        geometry.offsets = null;

        mdata.geometry = geometry;

        mdata.mesh = null;
    }



    avp.BufferGeometryUtils =  {
        meshToGeometry: meshToGeometry
    };

})();;
(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

    /** @constructor
     * Maintains a list of buffer geometries and running totals of their memory usage, etc.
     * Each geometry gets an integer ID to be used as reference in packed fragment lists.
     */
    function GeometryList(model) {

        this.geoms = [null]; //keep index 0 reserved for invalid id
        this.numGeomsInMemory = 0;
        this.geomMemory = 0;
        this.gpuMeshMemory = 0;
        this.gpuNumMeshes = 0;
        this.geomPolyCount = 0;
        this.instancePolyCount = 0;
        this.is2d = model.is2d();

        this.svf = model.getData();
        var numObjects = this.svf.geomMetadata ? this.svf.geomMetadata.primCounts.length : 0;

        this.geomBoxes = new Float32Array(Math.max(1, numObjects) * 6);

        if (this.svf.packFileTotalSize) {

            //In pack files, primitive indices use 4 byte integers,
            //while we use 2 byte integers for rendering, so make this
            //correction when estimating GPU usage for geometry
            var estimatedGPUMem = this.svf.packFileTotalSize - this.svf.primitiveCount * 3 * 2;


            //If the model is certain to be below a certain size,
            //we will skip the heuristics that upload some meshes to
            //GPU and keep other in system mem, and just push it all to the GPU.
            if (estimatedGPUMem <= avp.GPU_MEMORY_LIMIT &&
                numObjects < avp.GPU_OBJECT_LIMIT)
                this.svf.disableStreaming = true;
        }

    }

    GeometryList.prototype.getGeometry = function (svfid) {
        return this.geoms[svfid];
    };

    GeometryList.prototype.addGeometry = function (geometry, numInstances, svfid) {

        //Heuristically determine if we want to load this mesh onto the GPU
        //or use streaming draw from system memory
        var GPU_MEMORY_LOW = avp.GPU_MEMORY_LIMIT;
        var GPU_MEMORY_HIGH = 2 * GPU_MEMORY_LOW;
        var GPU_MESH_MAX = avp.GPU_OBJECT_LIMIT;

        if (this.isf2d)
            GPU_MEMORY_HIGH *= 2; //there isn't much in terms of textures in 2d drawings, so we can afford to more room for geometry

//this.disableStreaming = true;
        if (this.disableStreaming ||
            (this.gpuMeshMemory < GPU_MEMORY_LOW && this.geoms.length < GPU_MESH_MAX)) {
            //We are below the lower limits, so the mesh automatically is
            //assigned to retained mode
            geometry.streamingDraw = false;
            geometry.streamingIndex = false;
        }
        else if (this.gpuMeshMemory >= GPU_MEMORY_HIGH) {
            //We are above the upper limit, so mesh is automatically
            //assigned to streaming draw
            geometry.streamingDraw = true;
            geometry.streamingIndex = true;
        }
        else {
            //Between the lower and upper limits,
            //Score mesh importance based on its size
            //and number of instances it has. If the score
            //is high, we will prefer to put the mesh on the GPU
            //so that we don't schlep it across the bus all the time.
            var weightScore;

            if (!this.is2d) {
                weightScore = geometry.byteSize * (numInstances || 1);
            } else {
                //In the case of 2D, there are no instances, so we just keep
                //piling into the GPU until we reach the "high" mark.
                weightScore = 100001;
            }

            if (weightScore < 100000) {
                geometry.streamingDraw = true;
                geometry.streamingIndex = true;
            }
        }

        if (!geometry.streamingDraw) {
            this.gpuMeshMemory += geometry.byteSize;
            this.gpuNumMeshes += 1;
        }

        this.numGeomsInMemory++;

        if (svfid === undefined || svfid <= 0)
            svfid = this.geoms.length;

        this.geoms[svfid] = geometry;

        if (this.geomBoxes.length / 6 < this.geoms.length) {
            var nb = new Float32Array(6 * (this.geoms.length * 3 / 2));
            nb.set(this.geomBoxes);
            this.geomBoxes = nb;
        }

        var bb = geometry.boundingBox;
        this.geomBoxes[svfid * 6] = bb.min.x;
        this.geomBoxes[svfid * 6 + 1] = bb.min.y;
        this.geomBoxes[svfid * 6 + 2] = bb.min.z;
        this.geomBoxes[svfid * 6 + 3] = bb.max.x;
        this.geomBoxes[svfid * 6 + 4] = bb.max.y;
        this.geomBoxes[svfid * 6 + 5] = bb.max.z;

        //Free the bbx objects if we don't want them.
        if (avp.memoryOptimizedLoading && !this.is2d) {
            geometry.boundingBox = null;
            geometry.boundingSphere = null;
        }

        this.geomMemory += geometry.byteSize;
        var ib = geometry.attributes['index'].array || geometry.ib;
        var polyCount = ib.length / 3;

        //TODO: Asssignment into the svf is temporary until the dependencies
        //are unentangled
        this.svf.geomPolyCount = this.geomPolyCount += polyCount;
        this.instancePolyCount += polyCount * (numInstances || 1);

        geometry.svfid = svfid;

        return svfid;
    };

    GeometryList.prototype.removeGeometry = function (idx) {
        var geometry = this.getGeometry(idx);
        if (!geometry) {
            return 0;
        }
        var size = geometry.byteSize;
        this.geoms[idx] = null;
        this.numGeomsInMemory--;

        return size;
    };

    GeometryList.prototype.getModelBox = function (geomid, dst) {

        if (!this.geoms[geomid]) {
            dst.makeEmpty();
            return;
        }

        var off = geomid * 6;
        var bb = this.geomBoxes;
        dst.min.x = bb[off];
        dst.min.y = bb[off + 1];
        dst.min.z = bb[off + 2];
        dst.max.x = bb[off + 3];
        dst.max.y = bb[off + 4];
        dst.max.z = bb[off + 5];
    };

    GeometryList.prototype.dispose = function (renderer) {
        for (var i = 0, iEnd = this.geoms.length; i < iEnd; i++)
            if (this.geoms[i])
                renderer.deallocateGeometry(this.geoms[i]);
    };

    GeometryList.prototype.printStats = function () {

        stderr("Total geometry size: " + (this.geomMemory / (1024 * 1024)) + " MB");
        stderr("Number of meshes: " + this.geoms.length);
        stderr("Num Meshes on GPU: " + this.gpuNumMeshes);
        stderr("Net GPU geom memory used: " + this.gpuMeshMemory);

    };


    avp.GeometryList = GeometryList;

})();
;
//Implements runtime flat array storage for the node tree encoded by the property database
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;
	
	//
	// struct Node {
	//     int dbId;
	//	   int parentDbId;
	//	   int firstChild; //if negative it's a fragment list
	//     int numChildren;
	//     int flags;	
	// };
	// sizeof(Node) == 20
	var SIZEOF_NODE = 5, //integers
		OFFSET_DBID = 0,
		OFFSET_PARENT = 1,
		OFFSET_FIRST_CHILD = 2,
		OFFSET_NUM_CHILD = 3,
		OFFSET_FLAGS = 4;

	// note: objectCount and fragmentCount are not used
	function NodeArray(objectCount, fragmentCount) {

		this.nodes = [];
		this.nextNode = 0;
		
		this.children = [];
		this.nextChild = 0;

		this.dbIdToIndex = {};

		this.names = [];
		this.s2i = {}; //duplicate string pool
		this.strings = [];
		this.nameSuffixes = []; //integers

		//Occupy index zero so that we can use index 0 as undefined
		this.getIndex(0);
	}

	NodeArray.prototype.getIndex = function(dbId) {

		var index = this.dbIdToIndex[dbId];

		if (index)
			return index;

		index = this.nextNode++;

		//Allocate space for new node
		this.nodes.push(dbId); //store the dbId as first integer in the Node structure
		//Add four blank integers to be filled by setNode
		for (var i=1; i<SIZEOF_NODE; i++)
			this.nodes.push(0);

		this.dbIdToIndex[dbId] = index;

		return index;
	};

	NodeArray.prototype.setNode = function(dbId, parentDbId, name, flags, childrenIds, isLeaf) {

		var index = this.getIndex(dbId);

		var baseOffset = index * SIZEOF_NODE;

		this.nodes[baseOffset+OFFSET_PARENT] = parentDbId;
		this.nodes[baseOffset+OFFSET_FIRST_CHILD] = this.nextChild;
		this.nodes[baseOffset+OFFSET_NUM_CHILD] = isLeaf ? -childrenIds.length : childrenIds.length;
		this.nodes[baseOffset+OFFSET_FLAGS] = flags;

		for (var i=0; i<childrenIds.length; i++)
			this.children[this.nextChild++] = isLeaf ? childrenIds[i] : this.getIndex(childrenIds[i]);

		if (this.nextChild > this.children.length)
			console.error("Child index out of bounds -- should not happen");
	
		this.processName(index, name);
	};

	NodeArray.prototype.processName = function(index, name) {

		//Attempt to decompose the name into a base string + integer,
		//like for example "Base Wall [12345678]" or "Crank Shaft:1"
		//We will try to reduce memory usage by storing "Base Wall" just once.
		var base;
		var suffix;

		//Try Revit style [1234] first
		var iStart = -1;
		var iEnd = -1;

		if (name) { //name should not be empty, but hey, it happens.
			iEnd = name.lastIndexOf("]");
			iStart = name.lastIndexOf("[");

			//Try Inventor style :1234
			if (iStart === -1 || iEnd === -1) {
				iStart = name.lastIndexOf(":");
				iEnd = name.length;
			}		
		}

		//TODO: Any other separators? What does AutoCAD use?

		if (iStart >= 0 && iEnd > iStart) {
			base = name.slice(0, iStart+1);
			var ssuffix = name.slice(iStart+1, iEnd);
			suffix = parseInt(ssuffix, 10);
			
			//make sure we get the same thing back when
			//converting back to string, otherwise don't 
			//decompose it.
			if (!suffix || suffix+"" !== ssuffix) {
				base = name;
				suffix = 0;
			}
		} else {
			base = name;
			suffix = 0;
		}


		var idx = this.s2i[base];
		if (idx === undefined) {
			this.strings.push(base);
			idx = this.strings.length-1;
			this.s2i[base] = idx;
		}

		this.names[index] = idx;
		this.nameSuffixes[index] = suffix;
	};


	function arrayToBuffer(a) {
		var b = new Int32Array(a.length);
		b.set(a);
		return b;
	}

    // note none of these arguments are used
	NodeArray.prototype.flatten = function(dbId, parentDbId, name, flags, childrenIds, isLeaf) {
		this.nodes = arrayToBuffer(this.nodes);
		this.children = arrayToBuffer(this.children);
		this.names = arrayToBuffer(this.names);
		this.nameSuffixes = arrayToBuffer(this.nameSuffixes);
		this.s2i = null; //we don't need this temporary map once we've built the strings list
	};



	function InstanceTreeAccess(nodeArray, rootId, nodeBoxes) {
		this.nodes = nodeArray.nodes;
		this.children = nodeArray.children;
		this.dbIdToIndex = nodeArray.dbIdToIndex;
		this.names = nodeArray.names;
		this.nameSuffixes = nodeArray.nameSuffixes;
		this.strings = nodeArray.strings;
		this.rootId = rootId;
		this.numNodes = this.nodes.length / SIZEOF_NODE;
		this.visibleIds = null;


		this.nodeBoxes = nodeBoxes || new Float32Array(6 * this.numNodes);
	}

    // note dbId is not used
	InstanceTreeAccess.prototype.getNumNodes = function(dbId) {
		return this.numNodes;
	};

	InstanceTreeAccess.prototype.getIndex = function(dbId) {
		return this.dbIdToIndex[dbId];
	};

	InstanceTreeAccess.prototype.name = function(dbId) {
		var idx = this.dbIdToIndex[dbId];
		var base = this.strings[this.names[idx]];
		var suffix = this.nameSuffixes[idx];
		if (suffix) {
			//NOTE: update this logic if more separators are supported in processName above
			var lastChar = base.charAt(base.length-1);
			if (lastChar === "[")
				return base + suffix + "]";
			else
				return base + suffix;
		} else {
			return base;
		}
	};

	InstanceTreeAccess.prototype.getParentId = function(dbId) {
		return this.nodes[this.dbIdToIndex[dbId] * SIZEOF_NODE + OFFSET_PARENT];
	};

	InstanceTreeAccess.prototype.getNodeFlags = function(dbId) {
		return this.nodes[this.dbIdToIndex[dbId] * SIZEOF_NODE + OFFSET_FLAGS];
	};

	InstanceTreeAccess.prototype.setNodeFlags = function(dbId, flags) {
		this.nodes[this.dbIdToIndex[dbId] * SIZEOF_NODE + OFFSET_FLAGS] = flags;
	};

	InstanceTreeAccess.prototype.getNumChildren = function(dbId) {
		var numChildren = this.nodes[this.dbIdToIndex[dbId] * SIZEOF_NODE + OFFSET_NUM_CHILD];
		if (numChildren > 0)
			return numChildren;
		return 0;		
	};

	InstanceTreeAccess.prototype.getNumFragments = function(dbId) {
		var numChildren = this.nodes[this.dbIdToIndex[dbId] * SIZEOF_NODE + OFFSET_NUM_CHILD];
		if (numChildren < 0)
			return -numChildren;
		return 0;		
	};

	InstanceTreeAccess.prototype.getNodeBox = function(dbId, dst) {
		var off = this.getIndex(dbId) * 6;
		for (var i=0; i<6; i++)
			dst[i] = this.nodeBoxes[off+i];
	};

	//Returns an array containing the dbIds of all objects
	//that are physically represented in the scene. Not all
	//objects in the property database occur physically in each graphics viewable.
	InstanceTreeAccess.prototype.getVisibleIds = function() {
		if (!this.visibleIds) {
			this.visibleIds = Object.keys(this.dbIdToIndex).map(function(k) { return parseInt(k); });
		}

		return this.visibleIds;
	};


	InstanceTreeAccess.prototype.enumNodeChildren = function(dbId, callback) {
		var idx = this.dbIdToIndex[dbId];
		var firstChild = this.nodes[idx * SIZEOF_NODE + OFFSET_FIRST_CHILD];
		var numChildren = this.nodes[idx * SIZEOF_NODE + OFFSET_NUM_CHILD];

		if (numChildren > 0) {
			for (var i=0; i<numChildren; i++) {
				var childDbId = this.nodes[this.children[firstChild+i] * SIZEOF_NODE];
				callback(childDbId, dbId, idx);
			}
		}
	};

	InstanceTreeAccess.prototype.enumNodeFragments = function(dbId, callback) {
		var idx = this.dbIdToIndex[dbId];
		var firstChild = this.nodes[idx * SIZEOF_NODE + OFFSET_FIRST_CHILD];
		var numChildren = this.nodes[idx * SIZEOF_NODE + OFFSET_NUM_CHILD];

		//If numChildren is negative, it means leaf node and children are fragments
		if (numChildren < 0) {
			numChildren = -numChildren;
			for (var i=0; i<numChildren; i++) {
				callback(this.children[firstChild+i], dbId, idx);
			}
		}
	};

	avp.InstanceTreeStorage = NodeArray;
	avp.InstanceTreeAccess = InstanceTreeAccess;


})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var NODE_TYPE_ASSEMBLY   = 0x0,    // Real world object as assembly of sub-objects
    NODE_TYPE_INSERT     = 0x1,    // Insert of multiple-instanced object
    NODE_TYPE_LAYER      = 0x2,    // A layer (specific abstraction collection)
    NODE_TYPE_COLLECTION = 0x3,    // An abstract collection of objects (e.g. “Doors”)
    NODE_TYPE_COMPOSITE  = 0x4,    // A real world object whose internal structure is not relevant to end user
    NODE_TYPE_MODEL      = 0x5,    // Root of tree representing an entire Model. An aggregate model can contain multiple nested models.
    NODE_TYPE_GEOMETRY   = 0x6,    // Leaf geometry node
    NODE_TYPE_BITS       = 0x7,    //mask for all bits used by node type

    NODE_FLAG_NOSELECT   = 0x20000000,
    NODE_FLAG_OFF        = 0x40000000,
    NODE_FLAG_HIDE       = 0x80000000;

av.SelectionMode = {

    LEAF_OBJECT : 0,
    FIRST_OBJECT : 1,
    LAST_OBJECT : 2

};


function InstanceTree(nodeAccess, objectCount, maxDepth) {

    this.nodeAccess = nodeAccess;
    this.maxDepth = maxDepth;
    this.objectCount = objectCount;
    this.numHidden = 0;
    this.numOff = 0;
}


InstanceTree.prototype.setFlagNode = function(dbId, flag, value) {

    var old = this.nodeAccess.getNodeFlags(dbId);

    // "!!" converts to bool
    if (!!(old & flag) == value)
        return false;

    if (value)
        this.nodeAccess.setNodeFlags(dbId, old | flag);
    else
        this.nodeAccess.setNodeFlags(dbId, old & ~flag);

    return true;
};

InstanceTree.prototype.setFlagGlobal = function(flag, value) {
    var na = this.nodeAccess;

    var i=0, iEnd = na.numNodes;
    if (value) {
        for (; i<iEnd; i++) {
            na.setNodeFlags(i, na.getNodeFlags(i) | flag);
        }
    } else {
        var notflag = ~flag;
        for (; i<iEnd; i++) {
            na.setNodeFlags(i, na.getNodeFlags(i) & notflag);
        }
    }
};

/**
 * When a node is OFF, it is completely skipped for display purposes
 */
InstanceTree.prototype.setNodeOff = function(dbId, value) {
    var res = this.setFlagNode(dbId, NODE_FLAG_OFF, value);
    if (res) {
        if (value)
            this.numOff++;
        else
            this.numOff--;
    }
    return res;
};

InstanceTree.prototype.isNodeOff = function(dbId) {
    return !!(this.nodeAccess.getNodeFlags(dbId) & NODE_FLAG_OFF);
};


/**
 * When a node is HIDDEN it will display in ghosted style
 * if display of hidden objects is on
 */
InstanceTree.prototype.setNodeHidden = function(dbId, value) {
    var res = this.setFlagNode(dbId, NODE_FLAG_HIDE, value);
    if (res) {
        if (value)
            this.numHidden++;
        else
            this.numHidden--;
    }
    return res;
};

InstanceTree.prototype.isNodeHidden = function(dbId) {
    return !!(this.nodeAccess.getNodeFlags(dbId) & NODE_FLAG_HIDE);
};

InstanceTree.prototype.getNodeType = function(dbId) {
    return this.nodeAccess.getNodeFlags(dbId) & NODE_TYPE_BITS;
};

InstanceTree.prototype.isNodeSelectable = function(dbId) {
    return !(this.nodeAccess.getNodeFlags(dbId) & NODE_FLAG_NOSELECT);
};

InstanceTree.prototype.getNodeParentId = function(dbId) {
    return this.nodeAccess.getParentId(dbId);
};

InstanceTree.prototype.getRootId = function() {
    return this.nodeAccess.rootId;
};

InstanceTree.prototype.getNodeName = function(dbId) {
    return this.nodeAccess.name(dbId);
};

InstanceTree.prototype.getChildCount = function(dbId) {
    return this.nodeAccess.getNumChildren(dbId);
};

InstanceTree.prototype.getNodeBox = function(dbId, dst) {
    this.nodeAccess.getNodeBox(dbId, dst);
};



InstanceTree.prototype.enumNodeFragments = function(node, callback, recursive) {

    //TODO: Temporary until we are consistently using dbId
    var dbId;
    if (typeof node == "number")
        dbId = node;
    else if (node)
        dbId = node.dbId;

    var self = this;

    function traverse(dbId) {

        self.nodeAccess.enumNodeFragments(dbId, callback);

        if (recursive) {
            self.enumNodeChildren(dbId, function (child_dbId) {
                traverse(child_dbId);
            });
        }
    }

    traverse(dbId);

};


InstanceTree.prototype.enumNodeChildren = function(node, callback, recursive) {

    //TODO: Temporary until we are consistently using dbId
    var dbId;
    if (typeof node == "number")
        dbId = node;
    else if (node)
        dbId = node.dbId;

    var self = this;

    if (recursive) {
        callback(dbId);
    }

    function traverse(dbId) {

        self.nodeAccess.enumNodeChildren(dbId, function(childId) {
            callback(childId);

            if (recursive)
                traverse(childId);
        });

    }

    traverse(dbId);
};


//Given a leaf node, find the correct parent
//node to select according to the given selection mode
InstanceTree.prototype.findNodeForSelection = function(dbId, selectionMode) {

    //Default legacy mode -- select exactly the node we got asked for.
    if (selectionMode === av.SelectionMode.LEAF_OBJECT)
        return dbId;

    var res = dbId;
    var node, nt;

    if (selectionMode === av.SelectionMode.FIRST_OBJECT) {
        //1. Find the leaf node of the selection tree containing it and then follow the chain of parents all the way up to the root to get the complete path from root to leaf node.
        //2. Start at the root and walk down the path until the first node that is not a Model, Layer or Collection. Select it.
        var idpath = [];

        node = dbId;
        while (node) {
            idpath.push(node);
            node = this.getNodeParentId(node);
        }

        for (var i=idpath.length-1; i>=0; i--) {
            nt = this.getNodeType(idpath[i]);
            if ( (nt !== NODE_TYPE_MODEL) &&
                 (nt !== NODE_TYPE_LAYER) &&
                 (nt !== NODE_TYPE_COLLECTION) ) {
                res = idpath[i];
                break;
            }
        }
    }

    else if (selectionMode === av.SelectionMode.LAST_OBJECT) {
        // Start at the leaf and walk up the path until the first node that is Composite. Select it. If there’s no Composite node in the path select the leaf.

        node = dbId;
        while (node) {
            nt = this.getNodeType(node);
            if (nt === NODE_TYPE_COMPOSITE) {
                res = node;
                break;
            }
            node = this.getNodeParentId(node);
        }

    }

    return res;

};


avp.InstanceTree = InstanceTree;

})();
;

(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

var //visibility/highlight bitmask flags
    //NOTE: This is confusing and it should be fixed, but when the MESH_VISIBLE bit is off, the mesh
    //will draw in ghosted mode. To completely skip drawing a mesh, set the HIDE flag.
    MESH_VISIBLE =      avp.MESH_VISIBLE        = 1,
    MESH_HIGHLIGHTED =  avp.MESH_HIGHLIGHTED    = 2,
    MESH_HIDE =         avp.MESH_HIDE           = 4,
    MESH_ISLINE =       avp.MESH_ISLINE         = 8,
    MESH_MOVED =        avp.MESH_MOVED          = 16,
    MESH_TRAVERSED =    avp.MESH_TRAVERSED      = 0x20,
    MESH_RENDERFLAG =   avp.MESH_RENDERFLAG     = 0x80;

    /** @constructor
     * Represents the full list of all geometry instances associated with a
     * particular model. The order in the list is 1:1 with fragment list in
     * the source LMV/SVF package file.
     */
    function FragmentList(fragments, geoms, loader) {

        this.fragments = fragments;
        this.svfLoader = loader;
        var initialSize = this.fragments.length;

        this.geoms = geoms;

        //3D SVF files are of known initial size and known world bounds.
        //2D F2D files start out with nothing and get filled up as we load.
        this.isFixedSize = this.fragments.length > 0;
        if (this.isFixedSize) {
            this.boxes = this.fragments.boxes;
            this.transforms = this.fragments.transforms;
            this.useThreeMesh = !avp.memoryOptimizedLoading;
        } else {
            this.boxes = null;
            this.transforms = null;
            this.useThreeMesh = true;
        }

        if (initialSize <= 0)
            initialSize = 1;

        //This will be the list of all mesh instances in the model.
        //Corresponds to all fragments in the case of SVF.
        this.vizmeshes = new Array(initialSize);
        this.vizflags = new Uint8Array(initialSize); // visibility/highlight mode flags

        this.geomids = new Int32Array(initialSize);
        this.materialids = new Int32Array(initialSize);
        this.materialmap = {};

        this.reachLimit = false;
        this.traversedGeom = [];
        this.culledGeom = [];
        this.geomidsmap = {};

        this.animxforms = null;

        for (var i = 0; i < initialSize; i++) {
            this.vizflags[i] = 1; //MESH_VISIBLE initially
            this.geomids[i] = -1; //0 is a valid geom index, so use -1 as starting value
        }

        this.allVisible = true;
        this.allVisibleDirty = false;
        this.nextAvailableFragID = initialSize;
    }

    FragmentList.prototype.getNextAvailableFragmentId = function () {
        return this.nextAvailableFragID++;
    };

    FragmentList.prototype.fragmentsHaveBeenAdded = function() {
        return this.vizflags.length > this.fragments.length;
    };

    FragmentList.prototype.getSvfMaterialId = function (fragId) {
        var mat = this.getMaterial(fragId);
        return mat ? mat.svfMatId : undefined;
    };

    FragmentList.prototype.requireGeometry = function (fragId) {
        var geom = null;
        var geomId = this.geomids[fragId];
        if (geomId >= 0) {
            // A valid geometry id, then get corresponding geometry
            geom = this.geoms.getGeometry(geomId);
        }

        if (geom == null && !this.reachLimit) {
            // Request to load this geometry.
            var packId = this.fragments.packIds[fragId];
            this.svfLoader.loadGeometryPackOnDemand(packId);
        }

        return geom;
    };

    FragmentList.prototype.setMesh = function (fragId, meshInfo, updateFragmentData) {

        //Remove any temporary geometry we used for the fragment
        //while it was loading
        var oldGeom = this.vizmeshes[fragId];
        if (oldGeom && oldGeom.parent) {
            oldGeom.parent.remove(oldGeom);
        }

        //The various data arrays need to be re-sized if the fragment is new
        //so we have to do it manually in case this happens
        if (this.vizflags.length <= fragId) {
            if (this.isFixedSize) {
                console.warn("Attempting to resize a fragments list that was initialized with fixed data. This will have a performance impact.");
                this.isFixedSize = false;
            }

            var nlen = Math.ceil(1.5 * this.vizflags.length);
            if (this.useThreeMesh && nlen < this.vizmeshes.length)
                nlen = this.vizmeshes.length;


            var nflags = new Uint8Array(nlen);
            nflags.set(this.vizflags);
            this.vizflags = nflags;

            if (this.transforms) {
                var ntransforms = new Float32Array(nlen * 12);
                ntransforms.set(this.transforms);
                this.transforms = ntransforms;
            }
            if (this.boxes) {
                var nboxes = new Float32Array(nlen * 6);
                nboxes.set(this.boxes);
                this.boxes = nboxes;
            }

            if (this.geomids) {
                var nids = new Int32Array(nlen);
                nids.set(this.geomids);
                this.geomids = nids;

            }

            if (this.materialids) {
                var nmids = new Int32Array(nlen);
                nmids.set(this.materialids);
                this.materialids = nmids;
            }
        }

        //Remember the mesh in the frag->viz mesh array
        if (this.useThreeMesh) {
            var mesh = new THREE.Mesh(meshInfo.geometry, meshInfo.material);

            if (meshInfo.matrix) {
                if (mesh.matrix) {
                    mesh.matrix.copy(meshInfo.matrix);
                }
                mesh.matrixWorld.copy(meshInfo.matrix);
            }

            mesh.is2d = meshInfo.is2d;
            mesh.isLine = meshInfo.isLine;

            mesh.matrixAutoUpdate = false;

            //Add the mesh to the render group for this fragment
            //Note each render group renders potentially many fragments.
            mesh.frustumCulled = false; //we do our own culling in RenderQueue, the renderer doesn't need to

            mesh.fragId = fragId;
            mesh.dbId = this.fragments.fragId2dbId[fragId] | 0;

            this.vizmeshes[fragId] = mesh;

        } else {
            this.geomids[fragId] = meshInfo.geometry.svfid;
            this.materialids[fragId] = meshInfo.material.id;
            if (!this.materialmap[meshInfo.material.id])
                this.materialmap[meshInfo.material.id] = meshInfo.material;
        }


        this.vizflags[fragId] = 1 | (meshInfo.isLine ? MESH_ISLINE : 0); // 1 = visible, but not highlighted

        if (updateFragmentData) {
            // Update transform and bb
            var transform = meshInfo.matrix;

            // Copy the transform to the fraglist array
            var i = fragId * 12;
            var cur = transform.elements;
            var orig = this.transforms;
            orig[i] = cur[0];
            orig[i + 1] = cur[1];
            orig[i + 2] = cur[2];
            orig[i + 3] = cur[4];
            orig[i + 4] = cur[5];
            orig[i + 5] = cur[6];
            orig[i + 6] = cur[8];
            orig[i + 7] = cur[9];
            orig[i + 8] = cur[10];
            orig[i + 9] = cur[12];
            orig[i + 10] = cur[13];
            orig[i + 11] = cur[14];


            // Transform the local BB to world
            var b = new THREE.Box3();
            if (meshInfo.geometry && meshInfo.geometry.boundingBox) {
                b.copy(meshInfo.geometry.boundingBox);
            } else {
                this.geoms.getModelBox(this.geomids[fragId], b);
            }
            b.applyMatrix4(transform);

            // Copy the bounding box to the fraglist array
            var boffset = fragId * 6;
            var bb = this.boxes;
            bb[boffset] = b.min.x;
            bb[boffset + 1] = b.min.y;
            bb[boffset + 2] = b.min.z;
            bb[boffset + 3] = b.max.x;
            bb[boffset + 4] = b.max.y;
            bb[boffset + 5] = b.max.z;
        }
    };


    FragmentList.prototype.isFlagSet = function (fragId, flag) {
        return !!(this.vizflags[fragId] & flag);
    };

    FragmentList.prototype.setFlagFragment = function (fragId, flag, value) {

        var old = this.vizflags[fragId];

        // "!!" casts to boolean
        if (!!(old & flag) == value)
            return false;

        if (value)
            this.vizflags[fragId] = old | flag;
        else
            this.vizflags[fragId] = old & ~flag;

        return true;
    };

    FragmentList.prototype.setFlagGlobal = function (flag, value) {
        var vizflags = this.vizflags;
        var i = 0, iEnd = vizflags.length;
        if (value) {
            for (; i < iEnd; i++) {
                vizflags[i] = vizflags[i] | flag;
            }
        } else {
            var notflag = ~flag;
            for (; i < iEnd; i++) {
                vizflags[i] = vizflags[i] & notflag;
            }
        }
    };

    FragmentList.prototype.hideLines = function (hide) {

//        this.setFlagGlobal(MESH_HIDE, hide);
        var flag = MESH_HIDE;

        var vizflags = this.vizflags;
        var i = 0, iEnd = vizflags.length;
        if (hide) {
            for (; i < iEnd; i++) {
                if (vizflags[i] & MESH_ISLINE)
                    vizflags[i] = vizflags[i] | flag;
            }
        } else {
            var notflag = ~flag;
            for (; i < iEnd; i++) {
                if (vizflags[i] & MESH_ISLINE)
                    vizflags[i] = vizflags[i] & notflag;
            }
        }

        this.allVisibleDirty = true;
    };

    FragmentList.prototype.isFragVisible = function (frag) {
        return (this.vizflags[frag] & 3/*MESH_VISIBLE|MESH_HIGHLIGHTED*/) == 1;
    };

    FragmentList.prototype.isFragOff = function (frag) {
        return !!(this.vizflags[frag] & MESH_HIDE);
    };

    FragmentList.prototype.isLine = function (frag) {
        return !!(this.vizflags[frag] & MESH_ISLINE/*MESH_VISIBLE|MESH_HIGHLIGHTED*/);
    };


    FragmentList.prototype.areAllVisible = function () {
        if (this.allVisibleDirty) {

            var vizflags = this.vizflags;
            var allVisible = true;
            for (var i = 0, iEnd = vizflags.length; i < iEnd; i++) {
                if ((vizflags[i] & 1/*MESH_VISIBLE*/) === 0) {
                    allVisible = false;
                    break;
                }
            }

            this.allVisible = allVisible;
            this.allVisibleDirty = false;
        }

        return this.allVisible;
    };

    FragmentList.prototype.getVizmesh = (function () {

        //A scratch object that we fill in and return in the case
        //we don't use THREE.Mesh for persistent storage. If the caller
        //needs to hold on to the mesh outside the callback scope, it has to clone it.
        var m;

        function init_three() {
            if (!m) {
                m = new THREE.Mesh(undefined, undefined, true);
                m.isTemp = true;
                m.dbId = 0;
                m.fragId = -1;
            }
        }

        return function (fragId) {

            if (this.useThreeMesh) {
                return this.vizmeshes[fragId];
            } else {
                init_three();

                m.geometry = this.getGeometry(fragId);
                m.material = this.getMaterial(fragId);
                m.dbId = this.getDbIds(fragId);
                m.fragId = fragId;
                m.visible = true;
                m.isLine = this.isLine(fragId);
                m.hide = this.isFragOff(fragId);

                this.getWorldMatrix(fragId, m.matrixWorld);

                return m;
            }
        };

    })();

    FragmentList.prototype.getMaterialId = function (fragId) {
        return this.useThreeMesh ? this.vizmeshes[fragId].material.id : this.materialids[fragId];
    };

    FragmentList.prototype.getMaterial = function (fragId) {
        return this.useThreeMesh ? this.vizmeshes[fragId].material : this.materialmap[this.materialids[fragId]];
    };

    FragmentList.prototype.getGeometry = function (fragId) {
        return this.useThreeMesh ? this.vizmeshes[fragId].geometry : this.geoms.getGeometry(this.geomids[fragId]);
    };

    FragmentList.prototype.getGeometryId = function (fragId) {
        return this.useThreeMesh ? fragId : this.geomids[fragId];
    };

    FragmentList.prototype.setMaterial = function (fragId, material) {

        if (this.useThreeMesh) {

            this.vizmeshes[fragId].material = material;

        } else {

            this.materialids[fragId] = material.id;
            this.materialmap[material.id] = material;

        }
    };

    FragmentList.prototype.getCount = function () {
        return this.vizflags.length;
    };

    FragmentList.prototype.getDbIds = function (fragId) {
        return this.fragments.fragId2dbId[fragId];
    };

    FragmentList.prototype.dispose = function (glrenderer) {

        var DISPOSE_EVENT = {type: 'dispose'};

        if (this.useThreeMesh) {
            var REMOVED_EVENT = {type: 'removed'};
            for (var i = 0; i < this.vizmeshes.length; i++) {
                var m = this.vizmeshes[i];
                if (m) {
                    m.dispatchEvent(REMOVED_EVENT);
                    m.geometry.dispatchEvent(DISPOSE_EVENT);
                }
            }
        } else {
            this.geoms.dispose(glrenderer);
        }
    };

// This function should probably not be called outside VisibityManager
// in order to maintain node visibility state.
    FragmentList.prototype.setVisibility = function (fragId, value) {
        this.setFlagFragment(fragId, MESH_VISIBLE, value);
        this.allVisibleDirty = true;
    };


    FragmentList.prototype.setFragOff = function (fragId, value) {
        this.setFlagFragment(fragId, MESH_HIDE, value);
        this.allVisibleDirty = true;
    };


    FragmentList.prototype.setAllVisibility = function (value) {
        this.setFlagGlobal(MESH_VISIBLE, value);

        this.allVisible = value;
        this.allVisibleDirty = false;
    };


    FragmentList.prototype.updateAnimTransform = function (fragId, scale, rotationQ, translation) {

        var ax = this.animxforms;
        var off;

        //Allocate animation transforms on first use.
        if (!ax) {
            var count = this.getCount();
            ax = this.animxforms = new Float32Array(10 * count); //3 scale + 4 rotation + 3 translation
            for (var i = 0; i < count; i++) {
                off = i * 10;
                ax[off] = 1;
                ax[off + 1] = 1;
                ax[off + 2] = 1;
                ax[off + 3] = 0;
                ax[off + 4] = 0;
                ax[off + 5] = 0;
                ax[off + 6] = 1;
                ax[off + 7] = 0;
                ax[off + 8] = 0;
                ax[off + 9] = 0;
            }
        }

        off = fragId * 10;
        var moved = false;

        if (scale) {
            ax[off] = scale.x;
            ax[off + 1] = scale.y;
            ax[off + 2] = scale.z;
            moved = true;
        }

        if (rotationQ) {
            ax[off + 3] = rotationQ.x;
            ax[off + 4] = rotationQ.y;
            ax[off + 5] = rotationQ.z;
            ax[off + 6] = rotationQ.w;
            moved = true;
        }

        if (translation) {
            ax[off + 7] = translation.x;
            ax[off + 8] = translation.y;
            ax[off + 9] = translation.z;
            moved = true;
        }

        this.setFlagFragment(fragId, MESH_MOVED, moved);

        //Assume that if we are called with null everything the caller wants to reset the transform.
        if (!moved) {
            ax[off] = 1;
            ax[off + 1] = 1;
            ax[off + 2] = 1;
            ax[off + 3] = 0;
            ax[off + 4] = 0;
            ax[off + 5] = 0;
            ax[off + 6] = 1;
            ax[off + 7] = 0;
            ax[off + 8] = 0;
            ax[off + 9] = 0;
        }
    };

    FragmentList.prototype.getAnimTransform = function (fragId, scale, rotationQ, translation) {

        if (!this.animxforms)
            return false;

        if (!this.isFlagSet(fragId, MESH_MOVED))
            return false;

        var off = fragId * 10;
        var ax = this.animxforms;

        if (scale) {
            scale.x = ax[off];
            scale.y = ax[off + 1];
            scale.z = ax[off + 2];
        }

        if (rotationQ) {
            rotationQ.x = ax[off + 3];
            rotationQ.y = ax[off + 4];
            rotationQ.z = ax[off + 5];
            rotationQ.w = ax[off + 6];
        }

        if (translation) {
            translation.x = ax[off + 7];
            translation.y = ax[off + 8];
            translation.z = ax[off + 9];
        }

        return true;
    };

    FragmentList.prototype.getOriginalWorldMatrix = function (index, dstMtx) {
        var i = index * 12;

        var cur = dstMtx.elements;
        var orig = this.transforms;

        if (orig) {
            cur[0] = orig[i];
            cur[1] = orig[i + 1];
            cur[2] = orig[i + 2];
            cur[3] = 0;
            cur[4] = orig[i + 3];
            cur[5] = orig[i + 4];
            cur[6] = orig[i + 5];
            cur[7] = 0;
            cur[8] = orig[i + 6];
            cur[9] = orig[i + 7];
            cur[10] = orig[i + 8];
            cur[11] = 0;
            cur[12] = orig[i + 9];
            cur[13] = orig[i + 10];
            cur[14] = orig[i + 11];
            cur[15] = 1;
        } else if (this.useThreeMesh) {
            var m = this.getVizmesh(index);
            if (m)
                dstMtx.copy(m.matrixWorld);
            else
                dstMtx.identity();
        } else {
            dstMtx.identity();
        }
    };


    FragmentList.prototype.getWorldMatrix = (function () {

        var tmp, pos, rot, scale;

        function init_three() {
            tmp = new THREE.Matrix4();
            pos = new THREE.Vector3();
            rot = new THREE.Quaternion();
            scale = new THREE.Vector3();
        }


        return function (index, dstMtx) {

            if (!tmp)
                init_three();

            this.getOriginalWorldMatrix(index, dstMtx);

            //If mesh hasn't moved from its original location, just use that.
            if (!this.isFlagSet(index, MESH_MOVED)) {
                return;
            }

            //Otherwise construct the overall world matrix
            this.getAnimTransform(index, scale, rot, pos);

            tmp.compose(pos, rot, scale);

            dstMtx.multiplyMatrices(tmp, dstMtx);
        };

    })();


    FragmentList.prototype.getWorldBounds = (function () {

        var tmp;

        function init_three() {
            tmp = new THREE.Matrix4();
        }

        return function (index, dstBox) {

            if (!tmp)
                init_three();

            //Check if the world transform of the mesh is unchanged from
            //the original LMV file -- in such case we can use the original
            //bounding box from the LMV package, which is presumably more precise (tighter)
            //than just transforming the model box.
            //This is important if we want to keep our bounding volume hierarchy efficient.
            if (this.boxes && !this.isFlagSet(index, MESH_MOVED)) {
                var b = this.boxes;
                var boffset = index * 6;
                dstBox.min.x = b[boffset];
                dstBox.min.y = b[boffset + 1];
                dstBox.min.z = b[boffset + 2];
                dstBox.max.x = b[boffset + 3];
                dstBox.max.y = b[boffset + 4];
                dstBox.max.z = b[boffset + 5];
                return;
            }

            this.getWorldMatrix(index, tmp);

            if (this.useThreeMesh) {
                var m = this.getVizmesh(index);
                if (m && m.geometry) {
                    dstBox.copy(m.geometry.boundingBox);
                }
            }
            else {
                this.geoms.getModelBox(this.geomids[index], dstBox);
            }

            if (!dstBox.empty())
                dstBox.applyMatrix4(tmp);
        };

    })();


    avp.FragmentList = FragmentList;



    /**
     * Convenience class encapsulating a single fragment in a given FragmentList.
     * Use sparingly, as it is expensive to have those for every fragment in memory.
     */
    function FragmentPointer(frags, fragId) {

        this.frags = frags;
        this.fragId = fragId;

        this.scale = null;
        this.quaternion = null;
        this.position = null;
    }

    FragmentPointer.prototype.getWorldMatrix = function (dst) {

        return this.frags.getWorldMatrix(this.fragId, dst);

    };

    FragmentPointer.prototype.getWorldBounds = function (dst) {

        return this.frags.getWorldBounds(this.fragId, dst);

    };


    FragmentPointer.prototype.getAnimTransform = function () {

        if (!this.scale) {
            this.scale = new THREE.Vector3(1, 1, 1);
            this.quaternion = new THREE.Quaternion(0, 0, 0, 1);
            this.position = new THREE.Vector3(0, 0, 0);
        }

        return this.frags.getAnimTransform(this.fragId, this.scale, this.quaternion, this.position);

    };

    FragmentPointer.prototype.updateAnimTransform = function () {

        if (!this.scale) {
            this.scale = new THREE.Vector3(1, 1, 1);
            this.quaternion = new THREE.Quaternion(0, 0, 0, 1);
            this.position = new THREE.Vector3(0, 0, 0);
        }

        return this.frags.updateAnimTransform(this.fragId, this.scale, this.quaternion, this.position);
    };

    FragmentPointer.prototype.getMaterial = function () {

        return this.frags.getMaterial(this.fragId);

    };

    FragmentPointer.prototype.setMaterial = function (material) {

        return this.frags.setMaterial(this.fragId, material);

    };


    avp.FragmentPointer = FragmentPointer;



})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var _tmpBox;

function init_three() {
    
    if (!_tmpBox)
        _tmpBox = new THREE.Box3();

}

/** @constructor
 * Represents a subset of objects from a larger list, for e.g. a draw call batch
 * to send to the renderer. It's like a small view into an ordered FragmentList.
 *
 * frags -- FragmentList of all available meshes (1:1 correspondance with LMV fragments)
 * fragOrder -- Array of indices, pointing into the array of fragments
 * start -- start index in the array of indices
 * count -- how many mesh indices (after start index) are contained in the subset.
 *
 */
function RenderBatch(frags, fragOrder, start, count) {

    this.frags = frags;
    this.indices = fragOrder;

    this.start = start;
    this.count = count;
    this.lastItem = start; //for dynamic adding

    //Compatibility with THREE.Scene.
    this.overrideMaterial = null;

    //Whether sort by material ID has been done
    this.sortDone = false;

    this.avgFrameTime = undefined;
    this.numAdded = 0;

    this.boundingBox = new THREE.Box3();
    this.boundingBoxHidden = new THREE.Box3(); //bbox counting hidden/ghosted
    

    //Tells the renderer whether to sort by Z before drawing.
    //We only set this for RenderBatches containing transparent objects.
    this.sortObjects = false;
    this.sortDone = false;
    this.depths = null;
    this.indicesView = null;

    //Tells the renderer whether to do per-mesh frustum culling.
    //In some cases when we know the whole batch is completely
    //contained in the viewing frustum, we turn this off.
    this.frustumCulled = true;

    //Used by ground shadow code path
    this.forceVisible = false;

    this.renderImmediate = !frags.useThreeMesh;

    //Set per frame during scene traversal
    this.renderImportance = 0.0;

    init_three();
}

RenderBatch.prototype.getIndices = function() {
    return Array.isArray(this.indices) ? this.indices[0] : this.indices;
};

RenderBatch.prototype.sortByMaterial = function() {

    //Render batch must be complete before we can sort it
    if (this.numAdded < this.count)
        return;

    var frags = this.frags;
    var indices = this.getIndices();

    if (!indices)
        stderr("Only indexed RenderSubsets can be sorted.");

    var tmp = indices.subarray(this.start, this.start + this.count);
    Array.prototype.sort.call(tmp, function (a,b) {
        var ma = frags.getMaterialId(a);
        var mb = frags.getMaterialId(b);

        if (ma === undefined)
            return mb ? 1 : 0;
        if (mb === undefined)
            return -1;

        return ma - mb;
    });

    //indices.set(tmp, this.start);

    this.numAdded = 0;
    this.sortDone = true;
};


RenderBatch.prototype.sortByDepth = (function() {

    var frags;
    var indices;
    var frustum;
    var bbox;
    var depths;
    
    function calDepth(fragId, i) {
        if (!frags.getGeometry(fragId))
            depths[i] = -Infinity;
        else {
            frags.getWorldBounds(fragId, bbox);
            depths[i] = frustum.estimateDepth(bbox);
        }
    }
    
    //function sortCB(a, b) {
    //    return depths[b] - depths[a];
    //}

    return function(frustumIn) {
    
        frags = this.frags;
        indices = this.getIndices();
        frustum = frustumIn;
        bbox = _tmpBox;
    
        if (!indices)
            stderr("Only indexed RenderSubsets can be sorted.");
    
        if (!this.indicesView || this.indicesView.length < this.count)
            this.indicesView = indices.subarray(this.start, this.start + this.count);

        if (!this.depths || this.depths.length < this.count)
            this.depths = new Float32Array(this.count);

        depths = this.depths;

        this.forEachNoMesh(calDepth);

        // Does not work, this call sorts on depths[indicesViews[i]], not depths[i],
		// where 'i' is an index into both the depths and indicesViews lists.
		//Array.prototype.sort.call(this.indicesView, sortCB);
		
		// Insertion sort appears to be about 7x or more faster
		// for lists of 64 or less objects vs. defining a sort() function.
		// Asking if there's a faster way. Traian mentioned quicksort > 8
		// objects; I might give this a try.
		var tempDepth, tempIndex;
		for ( var j = 1; j < depths.length; j++ ) {
			var k = j;
			while ( k > 0 && depths[k-1] < depths[k] ) {
				// swap
				tempDepth = depths[k-1];
				depths[k-1] = depths[k];
				depths[k] = tempDepth;
				tempIndex = this.indicesView[k-1];
				this.indicesView[k-1] = this.indicesView[k];
				this.indicesView[k] = tempIndex;
				k--;
			}
		}

        //indices.set(this.indicesView, this.start);
    
    };
})();

//Use only for incremental adding to linearly ordered (non-BVH) scenes!
RenderBatch.prototype.onFragmentAdded = (function () {

    return function(fragId) {

        this.frags.getWorldBounds(fragId, _tmpBox);
        this.boundingBox.union(_tmpBox);

        this.sortDone = false;

        //NOTE: This only works with trivial fragment ordering (linear render queues).
        //Otherwise the item index does not necessarily match the fragId due to the 
        //reordering jump table (this.indices).
        if (this.lastItem <= fragId) {
            this.lastItem = fragId + 1;
            this.numAdded++;
        }
    };
})();


//Use the complex implementation of forEach only when paging is enabled.
//TODO: This might be better done using inheritance from RenderBatch
if (avp.pageOutGeometryEnabled) {

RenderBatch.prototype.forEach = function(callback, drawMode, includeEmpty) {

    var indices = this.getIndices();
    var frags = this.frags;
    var pageOutGeometryEnabled = (frags.getCount() > avp.FRAGS_PERSISTENT_MAX_COUNT);

    for (var i=this.start, iEnd=this.lastItem; i<iEnd; i++) {
        var idx = indices ? indices[i] : i;
        var m;

        // Only do this when page out enabled.
        if (pageOutGeometryEnabled) {
            if ((frags.isFlagSet(idx, avp.MESH_TRAVERSED)) && (drawMode == avp.MESH_RENDERFLAG)) {
                // If already trversed for rendering, ignore this fragment.
                continue;
            }

            m = frags.getVizmesh(idx);
            if (!includeEmpty && (drawMode && frags.isFlagSet(idx, drawMode))) {
                
                if (!m.geometry) {
                    // Require geometry only when truly need it.
                    m.geometry = frags.requireGeometry(idx);                    
                }
                else {
                    // Set traversed flag for this fragment.
                    if (drawMode == avp.MESH_RENDERFLAG)
                        frags.setFlagFragment(idx, avp.MESH_TRAVERSED, true);

                    if (idx>avp.FRAGS_PERSISTENT_COUNT) {
                        // Only do this if using optimized memory for geometry rendering, 
                        // and ignore the first FRAGS_PERSISTENT_COUNT fragments that are more improtant
                        // to persistent in memory all the time.
                        // let's check whether this geometry has been fully used.
                        // If so then add it to the traversed geometry list for recycle.
                        var geomId = frags.geomids[idx];
                        var geomTraversed = true;
                        var map = frags.geomidsmap[geomId];
                        if (map != null) {
                            map.t++;
                            geomTraversed = map.n == map.t;
                        }

                        if (geomTraversed)
                            frags.traversedGeom.push(geomId);
                    }

                }
            }
        }
        else {            
            m = frags.getVizmesh(idx);
        }

        // if drawMode is given, iterate vizflags that match
        if ((includeEmpty || (m && m.geometry)) &&
            (!drawMode || frags.isFlagSet(idx, drawMode))) {

            callback(m, idx);
        }
    }
};


} else {

RenderBatch.prototype.forEach = function(callback, drawMode, includeEmpty) {

    var indices = this.getIndices();
    var frags = this.frags;

    for (var i=this.start, iEnd=this.lastItem; i<iEnd; i++) {
        var idx = indices ? indices[i] : i;

        var m = frags.getVizmesh(idx);

        // if drawMode is given, iterate vizflags that match
        if ((includeEmpty || (m && m.geometry)) &&
            (!drawMode || frags.isFlagSet(idx, drawMode))) {

            callback(m, idx);
        }
    }
};

}
    

RenderBatch.prototype.forEachNoMesh = function(callback, drawMode, includeEmpty) {

    var indices = this.getIndices();
    var frags = this.frags;

    for (var i=this.start, iEnd=this.lastItem; i<iEnd; i++) {
        var fragId = indices ? indices[i] : i;

        var geometry;
        if (frags.useThreeMesh) {
            var m = frags.getVizmesh(fragId);
            if (m)
                geometry = m.geometry;
        }
        else {
            geometry = frags.getGeometry(fragId);
        }

        // if drawMode is given, iterate vizflags that match
        if ((includeEmpty || geometry) &&
            (!drawMode || frags.isFlagSet(fragId, drawMode))) {

            callback(fragId, i-this.start);
        }
    }
};


RenderBatch.prototype.raycast = (function() {

    return function (raycaster, intersects, dbIdFilter) {

        //Assumes bounding box is up to date.
        if (raycaster.ray.isIntersectionBox(this.boundingBox) === false)
            return;

        var self = this;
        var tmpBox = _tmpBox;

        this.forEach(function (m, fragId) {

            //Check the dbIds filter if given
            if (dbIdFilter && dbIdFilter.length) {
                //Theoretically this can return a list of IDs (for 2D meshes)
                //but this code will not be used for 2D geometry intersection.
                var dbId = 0 | self.frags.getDbIds(fragId);

                //dbIDs will almost always have just one integer in it, so
                //indexOf should be fast enough.
                if (dbIdFilter.indexOf(dbId) === -1)
                    return;
            }

            self.frags.getWorldBounds(fragId, tmpBox);

            if (raycaster.ray.isIntersectionBox(tmpBox)) {
                VBIntersector.rayCast(m, raycaster, intersects);
            }
        }, avp.MESH_VISIBLE);
    };
})();

RenderBatch.prototype.calculateBounds = (function() {

    var vizflags;
    var bounds;
    var boundsH;
    var frags;
    var tmpBox;

    function cb(fragId) {

        frags.getWorldBounds(fragId, tmpBox);

        var f = vizflags[fragId];
        if (f&1/*MESH_VISIBLE*/)
            bounds.union(tmpBox);
        else
            boundsH.union(tmpBox); //mesh is "ghosted"
    }

    return function() {
        this.boundingBox.makeEmpty();
        this.boundingBoxHidden.makeEmpty();

        vizflags = this.frags.vizflags;
        bounds = this.boundingBox;
        boundsH = this.boundingBoxHidden;
        frags = this.frags;
        tmpBox = _tmpBox;

        this.forEachNoMesh(cb);
    };
})();



function evalVisbility(drawMode, vizflags, idx) {

    var v;
    var vfin = vizflags[idx] & 0x7f;
    switch (drawMode) {

        case avp.RENDER_HIDDEN:
                 v = !(vfin & avp.MESH_VISIBLE); //visible (bit 0 on)
                 break;
        case avp.RENDER_HIGHLIGHTED:
                 v = (vfin & avp.MESH_HIGHLIGHTED); //highlighted (bit 1 on)
                 break;
        default:
                 v = ((vfin & (avp.MESH_VISIBLE|avp.MESH_HIGHLIGHTED|avp.MESH_HIDE)) == 1); //visible but not highlighted, and not a hidden line (bit 0 on, bit 1 off, bit 2 off)
                 break;
    }
    
    //Store evaluated visibility into bit 7 of the vizflags
    //to use for immediate rendering
    vizflags[idx] = vfin | (v ? avp.MESH_RENDERFLAG : 0);

    return v;
}


function evalCulling(checkCull, frustum, frags, idx) {

    var culled = false;

    frags.getWorldBounds(idx, _tmpBox);
    if (checkCull && !frustum.intersectsBox(_tmpBox)) {
        culled = true;
    }
    //This code path disabled because it was found to slow things down overall.
    /*
    else {
        // Check whether the projected area is smaller than a threshold,
        // if yes, do not render it.
        var area = frustum.projectedArea(_tmpBox);
        area *= frustum.areaConv;
        if (area < frustum.areaCullThreshold) {
            culled = true;
        }
    }
    */

    return culled;
}


//Use the complex implementation only when paging is enabled.
//TODO: This might be better done using inheritance from RenderBatch
if (avp.pageOutGeometryEnabled || avp.onDemandLoading) {

RenderBatch.prototype.applyVisibility = function() {

    var frags, vizflags, frustum, drawMode, fragIdCb, checkCull, allHidden;

    function applyVisCB(m, idx) {
        if (!m && frags.useThreeMesh) {
            if (fragIdCb)
                fragIdCb(idx);
            return;
        }

        var culled = evalCulling(checkCull, frustum, frags, idx);

        if (culled) {
            if (m) {
                m.visible = false;
            } else {
                stderr("Unexpected null mesh");
            }
            vizflags[idx] = vizflags[idx] & ~avp.MESH_RENDERFLAG;

            // Record culled geometries for paging out.
            if (idx > avp.FRAGS_PERSISTENT_COUNT) {
                // This fragment is culled, then move its geometry to culled geomtry list.
                var geomId = frags.geomids[idx];
                if (frags.geoms.getGeometry(geomId)) {
                    var map = frags.geomidsmap[geomId];
                    // Let's only record the geometries that don't used by more than one fragments.
                    // As multiple referenced geometry are more important.
                    if (!map)
                        frags.culledGeom.push(geomId);  
                }                
            }

            return;    
        }

        var v = evalVisbility(drawMode, vizflags, idx);
        
        if (m)
            m.visible = !!v;
        
        allHidden = allHidden && !v;
    }


    return function(drawModeIn, frustumIn, fragIdCbIn) {

        //Used when parts of the same scene
        //have to draw in separate passes (e.g. during isolate).
        //Consider maintaining two render queues instead if the
        //use cases get too complex, because this approach
        //is not very scalable as currently done (it traverses
        //the entire scene twice, plus the flag flipping for each item).

        allHidden = true;
        frustum = frustumIn;
        drawMode = drawModeIn;
        fragIdCb = fragIdCbIn;

        //Check if the entire render batch is contained inside
        //the frustum. This will save per-object checks.
        var containment = frustum.intersectsBox((drawMode === avp.RENDER_HIDDEN) ? this.boundingBoxHidden : this.boundingBox);
        if (containment === avp.OUTSIDE)
            return allHidden; //nothing to draw

        vizflags = this.frags.vizflags;
        frags = this.frags;
        checkCull = (containment !== avp.CONTAINS);
        
        this.forEach(applyVisCB, null, fragIdCb);

        return allHidden;
    };
}();


} else {

RenderBatch.prototype.applyVisibility = function() {

    var frags, vizflags, frustum, drawMode, fragIdCb, checkCull, allHidden;

    function applyVisCB(m, idx) {
        if((!m && frags.useThreeMesh) || (!m.geometry)) {
            if (fragIdCb)
                fragIdCb(idx);
            return;
        }

        var culled = evalCulling(checkCull, frustum, frags, idx);

        if (culled) {
            if (m) {
                m.visible = false;
            } else {
                stderr("Unexpected null mesh");
            }
            vizflags[idx] = vizflags[idx] & ~avp.MESH_RENDERFLAG;

            return;
        }

        var v = evalVisbility(drawMode, vizflags, idx);

        if (m)
            m.visible = !!v;

        allHidden = allHidden && !v;
    }

    function applyVisCBNoMesh(idx) {
        if(!frags.getGeometryId(idx)) {
            if (fragIdCb)
                fragIdCb(idx);
            return;
        }

        var culled = evalCulling(checkCull, frustum, frags, idx);

        if (culled) {
            vizflags[idx] = vizflags[idx] & ~avp.MESH_RENDERFLAG;
            return;
        }

        var v = evalVisbility(drawMode, vizflags, idx);

        allHidden = allHidden && !v;
    }

    return function(drawModeIn, frustumIn, fragIdCbIn) {

        //Used when parts of the same scene
        //have to draw in separate passes (e.g. during isolate).
        //Consider maintaining two render queues instead if the
        //use cases get too complex, because this approach
        //is not very scalable as currently done (it traverses
        //the entire scene twice, plus the flag flipping for each item).

        allHidden = true;
        frustum = frustumIn;
        drawMode = drawModeIn;
        fragIdCb = fragIdCbIn;

        //Check if the entire render batch is contained inside
        //the frustum. This will save per-object checks.
        var containment = frustum.intersectsBox((drawMode === avp.RENDER_HIDDEN) ? this.boundingBoxHidden : this.boundingBox);
        if (containment === avp.OUTSIDE)
            return allHidden; //nothing to draw

        vizflags = this.frags.vizflags;
        frags = this.frags;
        checkCull = (containment !== avp.CONTAINS);

        if (!fragIdCbIn && !frags.useThreeMesh) {
            this.forEachNoMesh(applyVisCBNoMesh, null);
        } else {
            this.forEach(applyVisCB, null, fragIdCb);
        }
        
        return allHidden;
    };
}();


}






avp.RenderBatch = RenderBatch;


})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

//TODO: better heuristic for group size might be needed
//But it should be based on polygon count as well as
//fragment count. But polygon count is not known
//until we get the meshes later on.
var MAX_FRAGS_PER_GROUP = 333;

/**
 * All rendering and other scene related data associated with a 3D model or 2D Drawing.
 * The "linear" variant uses simple non-hierarchical linear scene traversal when rendering a frame.
 * Good for small scenes, incrementally loaded scenes, and 2D drawings where draw order matters.
 */
function ModelIteratorLinear(renderModel) {

    var _frags = renderModel.getFragmentList();
    var fragCount = _frags.getCount();
    
    var _currentScene = 0;


    //Custom re-order of the fragments for optimized rendering.
    //those are indices into the immutable vizmeshes fragment list.
    //NOTE: We use the array container as reference to pass to RenderBatches, because the
    //typed array can get resized when loading data with unknown size
    var _fragOrder = [ new Int32Array(fragCount) ];

    //Trivial initial order
    var i;
    for (i=0; i<fragCount; i++) {
        _fragOrder[0][i] = i;
    }

    //Create a RenderBatch for each batch of fragments.
    //We will then draw each batch in turn to get a progressive
    //effect. The number of fragments per batch should be close
    //to what we can draw in a single frame while maintaining interactivity.
    //This linear list of batches is used for 2D scenes and for 3D scenes
    //while they are loading. After load is done, the linear traversal is replaced
    //by a view-based bounding volume hierarchy traversal.
    var fragsPerScene = MAX_FRAGS_PER_GROUP;
    if (renderModel.is2d())
        fragsPerScene /= 6; //2d meshes are all fully packed, so we can't draw so many per batch.
    if (av.isMobileDevice())
        fragsPerScene /= 3; //This is tuned for ~15fps on Nexus 7.
    fragsPerScene = fragsPerScene | 0;
    var _fragsPerScene = fragsPerScene > 0 ? fragsPerScene : MAX_FRAGS_PER_GROUP;

    var numScenes = 0 | ((fragCount + _fragsPerScene - 1) / _fragsPerScene);

    var _geomScenes = new Array(numScenes);

    for (i=0; i<numScenes; i++) {
        //Scene for this fragment group
        var startIndex = i * _fragsPerScene;
        var scene = _geomScenes[i] = new avp.RenderBatch(_frags, _fragOrder, startIndex, _fragsPerScene);
        var lastIndex = startIndex + _fragsPerScene;
        if (lastIndex > fragCount)
            lastIndex = fragCount;
        scene.lastItem = lastIndex;
    }


    this.addFragment = function(fragId) {

        //The frag order indices array will not auto-resize (it's ArrayBuffer)
        //so we have to do it manually
        if (_fragOrder[0].length <= fragId)
        {
            var nlen = 2 * _fragOrder[0].length;
            if (nlen <= fragId)
                nlen = fragId + 1;

            var ninds = new Int32Array(nlen);
            ninds.set(_fragOrder[0]);
            _fragOrder[0] = ninds;

            //We only set this when the fragment index goes
            //beyond the initial fragment size -- assuming
            //that the initial bounds passed into the RenderQueue constructor
            //is valid for the initial fragment list.
            this.visibleBoundsDirty = true;
        }
        //Note: this assumes trivial ordering
        //We cannot set/add meshes if reordering of the indices has already happened.
        //This is OK, because trivial ordering with unknown initial fragment count
        //happens only for 2D models where we preserve trivial draw order anyway.
        _fragOrder[0][fragId] = fragId;


        //Find a parent for the mesh -- in the case of SVF
        //fragments we just map fragment index to increasing
        //scene index, since fragments are already ordered
        //in the way we want to draw them
        var sceneIndex = 0 | (fragId / _fragsPerScene);
        if (_geomScenes) {
            var scene = _geomScenes[sceneIndex];
            if (!scene) {
                _geomScenes[sceneIndex] = scene = new avp.RenderBatch(_frags, _fragOrder, sceneIndex * _fragsPerScene, _fragsPerScene);
            }
            // did scene get set reasonably?
            if (scene)
                scene.onFragmentAdded(fragId);
        }

    };

    this.reset = function() {
        _currentScene = 0;
    };

    
    this.nextBatch = function() {
    
        if (_currentScene == _geomScenes.length)
            return null;

        var res = _geomScenes[_currentScene++];
        res.renderImportance = 0;
        return res;
    };


    this.getVisibleBounds = function(visibleBounds, visibleBoundsWithHidden) {

        //Case where we are not using BVH

        for (var i=0; i<_geomScenes.length; i++) {

            _geomScenes[i].calculateBounds();

            visibleBounds.union(_geomScenes[i].boundingBox);

            visibleBoundsWithHidden.union(_geomScenes[i].boundingBox);
            visibleBoundsWithHidden.union(_geomScenes[i].boundingBoxHidden);

        }

    };
    
    this.rayCast = function(raycaster, intersects, dbIdFilter) {
        for (var i = 0; i < _geomScenes.length; i++) {
            _geomScenes[i].raycast(raycaster, intersects, dbIdFilter);
        }
    };
/*
    this.getRenderProgress = function() {
        return _currentScene / _geomScenes.length;
    };
*/
    this.getSceneCount = function() {
        return _geomScenes.length;
    };
    
    this.getGeomScenes = function() {
        return _geomScenes;
    };
    
    this.done = function() {
        return _currentScene === _geomScenes.length;
    };


}

avp.ModelIteratorLinear = ModelIteratorLinear;


})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

function ModelIteratorBVH() {

    var _frags;

	var _bvhNodes = null;
	var _bvhFragOrder = null;
	var _bvhScenes = null;
    var _bvhNodeQueue = null, _bvhNodeAreas = null, _bvhHead, _bvhTail;
    var _bvhLIFO = 1;
    var _bvhPrioritizeScreenSize = true;
    var _bvhOpaqueDone = false;
    var _tmpBox = new THREE.Box3();
    var _tmpBox2 = new THREE.Box3();

    var _frustum;
    var _done = false;

    
    this.initialize = function(renderModelLinear, nodes, primitives, options) {
    
        _frags = renderModelLinear.getFragmentList();

        if (options && options.hasOwnProperty("prioritize_screen_size")) {
            _bvhPrioritizeScreenSize = options.prioritize_screen_size;
        }

        _bvhFragOrder = primitives;
        _bvhScenes = new Array(nodes.nodeCount);
        _bvhNodes = nodes;
        _bvhNodeQueue = new Int32Array(nodes.nodeCount + 1);
        _bvhNodeAreas = new Float32Array(nodes.nodeCount);

        for (var i=0; i<nodes.nodeCount; i++) {
            var primCount = nodes.getPrimCount(i);
            if (primCount) {
                _bvhScenes[i] = new avp.RenderBatch(_frags, _bvhFragOrder, nodes.getPrimStart(i), primCount);
                //Those are set manually, because we will not be adding fragments to the
                //render batch one by one -- the fragments are already loaded.
                _bvhScenes[i].lastItem = _bvhScenes[i].start + primCount;
                _bvhScenes[i].numAdded = primCount;
                if (nodes.getFlags(i) & 8) {
                    _bvhScenes[i].sortObjects = true; //scene contains transparent objects
                }
                nodes.getBoxThree(i, _bvhScenes[i].boundingBox);
            }
        }
    
    };
    
    // note: fragId and mesh are not used in this function
    this.addFragment = function(fragId, mesh) {
    };


    this.reset = function(frustum) {
        _frustum = frustum;
        _bvhHead = 0; _bvhTail = 0;
        _bvhNodeQueue[_bvhTail++] = 0;
        _bvhOpaqueDone = false;
        _done = false;
    };
    

    //Used to insert nodes into the (sorted) render queue based on
    //a heuristic other than strict front to back or back to front order.
    function insertNode(idx) {

        //This is basically a single sub-loop of an insertion sort.

        var val = _bvhNodeAreas[idx];
        var j = _bvhTail;

        if (_bvhLIFO) {
            while (j > _bvhHead && _bvhNodeAreas[_bvhNodeQueue[j - 1]] > val) {
                _bvhNodeQueue[j] = _bvhNodeQueue[j - 1];
                j--;
            }
        } else {
            while (j > _bvhHead && _bvhNodeAreas[_bvhNodeQueue[j - 1]] < val) {
                _bvhNodeQueue[j] = _bvhNodeQueue[j - 1];
                j--;
            }
        }

        _bvhNodeQueue[j] = idx;
        _bvhTail++;
    }

    this.nextBatch = function() {

        if (!_bvhOpaqueDone && _bvhHead === _bvhTail) {
            //If we are done with the opaque nodes, queue the transparent ones
            //before processing the contents of the last opaque node
            _bvhNodeQueue[_bvhTail++] = 1; //root of transparent subtree is at index 1
            _bvhOpaqueDone = true;
        }

        while(_bvhHead !== _bvhTail) {

            var nodeIdx = (_bvhLIFO || _bvhOpaqueDone) ? _bvhNodeQueue[--_bvhTail] : _bvhNodeQueue[_bvhHead++];

            _bvhNodes.getBoxThree(nodeIdx, _tmpBox);
            var intersects = _frustum.intersectsBox(_tmpBox);

            //Node is entirely outside, go on to the next node
            if (intersects !== avp.OUTSIDE) {
                var child = _bvhNodes.getLeftChild(nodeIdx);
                var isInner = (child !== -1);
                var firstIdx, secondIdx;

                //Is it inner node? Add children for processing.
                if (isInner) {
                    var flags = _bvhNodes.getFlags(nodeIdx);
                    var reverseAxis = _frustum.viewDir[flags & 3] < 0 ? 1 : 0;
                    var firstChild = (flags >> 2) & 1;
                    var transparent = (flags >> 3) & 1;
                    var depthFirst = (_bvhLIFO || _bvhOpaqueDone) ? 1 : 0;
                    var areaFirst = 0, areaSecond = 0;

                    if (_bvhPrioritizeScreenSize && !_bvhOpaqueDone) {

                        //If traversing based on visible screen area, we have to
                        //compute the area for each child and insert them into
                        //the queue accordingly.

                        firstIdx = child + firstChild;
                        secondIdx = child + 1 - firstChild;

                        _bvhNodes.getBoxThree(firstIdx, _tmpBox);
                        _bvhNodeAreas[firstIdx] = areaFirst = _frustum.projectedArea(_tmpBox);
                        _bvhNodes.getBoxThree(secondIdx, _tmpBox);
                        _bvhNodeAreas[secondIdx] = areaSecond = _frustum.projectedArea(_tmpBox);

                        //insert each node in the right place based on screen area,
                        //so that the queue (or stack, if LIFO traversal) is kept sorted
                        //at every step of the way
                        if (areaFirst > 0)
                            insertNode(firstIdx);

                        if (areaSecond > 0)
                            insertNode(secondIdx);
                    } else {

                        //Traversal by view direction.

                        //Reverse order if looking in the negative of the child split axis
                        //Reverse order if we are traversing last first
                        //If node contains transparent objects, then reverse the result so we traverse back to front.
                        //In other words, reverse the order if an odd number of flags are true.
                        if (reverseAxis ^ depthFirst ^ transparent)
                            firstChild = 1 - firstChild;

                        firstIdx = child + firstChild;
                        secondIdx = child + 1 - firstChild;

                        _bvhNodeQueue[_bvhTail++] = firstIdx;
                        _bvhNodeAreas[firstIdx] = -1; //TODO: This has to be something based on camera distance
                                                      //so that we can draw transparent back to front when multiple models are mixed

                        _bvhNodeQueue[_bvhTail++] = secondIdx;
                        _bvhNodeAreas[secondIdx] = -1;
                    }

                }

                //Are there graphics in the node? Then return its scene.
                var prims = _bvhNodes.getPrimCount(nodeIdx);
                if (prims !== 0) {
                    var scene = _bvhScenes[nodeIdx];

                    scene.renderImportance = _frustum.projectedArea(scene.boundingBox);

                    //NOTE: Frustum culling for the RenderBatch is done in
                    //RenderBatch.applyVisibility, so we don't need it here.
                    //Just return the batch and it will get cull checked later.
                    //TODO: May be we want to move the check to here, but then the linear iterator will also need to start checking.
                    /*
                     var whichBox = (_drawMode === RENDER_HIDDEN) ? scene.boundingBoxHidden : scene.boundingBox;

                     //If the geometry is attached to an inner node and we know
                     //it's not fully contained, we can narrow down the intersection
                     //by checking the box of just the inner node's geometry.
                     //The check for the node box itself also includes the children so it could be bigger.
                     if (intersects !== CONTAINS && isInner)
                     intersects = _frustum.intersectsBox(whichBox);

                     //Turn off frustum culling for the batch if it's fully contained
                     scene.frustumCulled = (intersects !== avp.CONTAINS);

                     if (intersects !== avp.OUTSIDE)
                     return scene;
                     */

                    return scene;
                }
            }

            if (!_bvhOpaqueDone && _bvhHead === _bvhTail) {
                //If we are done with the opaque nodes, queue the transparent ones
                //before processing the contents of the last opaque node
                _bvhNodeQueue[_bvhTail++] = 1; //root of transparent subtree is at index 1
                _bvhOpaqueDone = true;
            }

        }

        _done = true;
        return null;
    };
    
    
    function updateBVHRec(nodeIdx) {

        var child = _bvhNodes.getLeftChild(nodeIdx);

        if (child !== -1) {
            updateBVHRec(child);
            updateBVHRec(child+1);
        }

        _tmpBox.makeEmpty();

        if (child !== -1) {
            _bvhNodes.getBoxThree(child, _tmpBox2);
            _tmpBox.union(_tmpBox2);

            _bvhNodes.getBoxThree(child+1, _tmpBox2);
            _tmpBox.union(_tmpBox2);
        }

        var prims = _bvhNodes.getPrimCount(nodeIdx);
        if (prims) {
            _tmpBox.union(_bvhScenes[nodeIdx].boundingBox);
            _tmpBox.union(_bvhScenes[nodeIdx].boundingBoxHidden);
        }

        _bvhNodes.setBoxThree(nodeIdx, _tmpBox);
    }
    
    this.getVisibleBounds = function(visibleBounds, visibleBoundsWithHidden) {

        for (var i=0; i<_bvhScenes.length; i++) {

            var s = _bvhScenes[i];

            if (!s)
                continue;

            s.calculateBounds();

            visibleBounds.union(s.boundingBox);

            visibleBoundsWithHidden.union(s.boundingBox);
            visibleBoundsWithHidden.union(s.boundingBoxHidden);
        }

        //Also update all bounding volume tree nodes' bounds.
        //If objects move too much this will make the BVH less effective.
        //However, this only happens during explode or animation, so it shouldn't
        //be an issue. We can always rebuild the BVH in case objects really move a lot.
        updateBVHRec(0); //opaque root
        updateBVHRec(1); //transparent root
        
    };
    
    this.rayCast = function(raycaster, intersects, dbIdFilter) {

        var nodeStack = [1, 0];
        var pt = new THREE.Vector3();

        while (nodeStack.length) {
            var nodeIdx = nodeStack.pop();

            _bvhNodes.getBoxThree(nodeIdx, _tmpBox);
            var xPt = raycaster.ray.intersectBox(_tmpBox, pt);

            if (xPt === null)
                continue;

            var child = _bvhNodes.getLeftChild(nodeIdx);
            if (child !== -1) {
                nodeStack.push(child);
                nodeStack.push(child + 1);
            }

            var prims = _bvhNodes.getPrimCount(nodeIdx);
            if (prims !== 0) {
                var scene = _bvhScenes[nodeIdx];
                scene.raycast(raycaster, intersects, dbIdFilter);
            }
        }
 
    };
/*
    this.getRenderProgress = function() {
        return _renderCounter / _bvhScenes.length;
    };
*/
    this.getSceneCount = function() {
        return _bvhScenes.length;
    };
    
    this.getGeomScenes = function() {
        return _bvhScenes;
    };
    
    this.done = function() {
        return _done;
    };

}

avp.ModelIteratorBVH = ModelIteratorBVH;

})();;
(function() {

"use strict";

var av = Autodesk.Viewing;
var avp = av.Private;

var nextModelId = 1;

function RenderModel(svf) {

    av.Model.call(this, svf);

    var _this = this;

    //assuming initial bounding box is correct
    var _visibleBounds = new THREE.Box3();
    var _visibleBoundsWithHidden = new THREE.Box3();
    var _tmpBox = new THREE.Box3();
    
    var _numHighlighted = 0;
    
    var _renderCounter = 0;

        
    this.visibleBoundsDirty = false;
    this.enforceBvh = false;

    this.id = nextModelId++;

    var _geoms;
    var _frags;
    
    var _linearIterator;
    var _bvhIterator;
    var _iterator;
    var _frustum;
    var _drawMode;
    var _bvhOn = false;
    
    
    var _pageOutGeomCount = 0;
    var _pageOutStatus = avp.PAGEOUT_NONE;
    var _packIds = [];


    this.getGeometryList = function() { return _geoms; };
    this.getFragmentList = function() { return _frags; };

    this.initialize = function(loader) {
    
        _geoms = new avp.GeometryList(this);

        var fragments = this.getData().fragments;

        //TODO: having the loader and passing it down sucks, find a way not to
        _frags = new avp.FragmentList(fragments, _geoms, loader);
        
        var initialBbox = this.getBoundingBox();
        if (initialBbox) {
            _visibleBounds.copy(initialBbox);
            _visibleBoundsWithHidden.copy(initialBbox);
        }

        _iterator = _linearIterator = new avp.ModelIteratorLinear(this);
    };

    this.dtor = function(glrenderer) {
        this.getFragmentList().dispose(glrenderer);
    };
    
    this.activateFragment = function(fragId, meshInfo, overrideTransform) {

        _frags.setMesh(fragId, meshInfo, overrideTransform);

        //The linear iterator can be updated to add meshes incrementally.
        //The BVH iterator is not mutable, yet.
        _iterator.addFragment(fragId);

        //update the world bbox
        {
            _frags.getWorldBounds(fragId, _tmpBox);
            _visibleBounds.union(_tmpBox);
            _visibleBoundsWithHidden.union(_tmpBox);
        }

    };

    this.setFragment = function(fragId, mesh) {
    
        if (fragId === undefined)
            fragId = this.getFragmentList().getNextAvailableFragmentId();

        _frags.setMesh(fragId, mesh, true);

        //The linear iterator can be updated to add meshes incrementally.
        //The BVH iterator is not mutable, yet.
        if (_linearIterator)
            _linearIterator.addFragment(fragId);
        if (_bvhIterator && !_frags.fragmentsHaveBeenAdded())
            _bvhIterator.addFragment(fragId);

        //update the world bbox
        {
            _frags.getWorldBounds(fragId, _tmpBox);
            _visibleBounds.union(_tmpBox);
            _visibleBoundsWithHidden.union(_tmpBox);
        }

        return fragId;
    };

    
    this.setBVH = function(nodes, primitives, options) {

        _iterator = _bvhIterator = new avp.ModelIteratorBVH();
        
        _iterator.initialize(this, nodes, primitives, options);

    };
    
    
    this.resetIterator = function(camera, frustum, drawMode, moved) {
        
        _pageOutGeomCount = 0;

        if (moved) {
            _packIds = [];
            _pageOutStatus = avp.PAGEOUT_NONE;

            var frags = this.getFragmentList();

            // Reset traverse status
            frags.traversedGeom = [];
            frags.culledGeom = [];
            var len = frags.vizflags.length;
            for (var i=0; i<len; ++i) {
                frags.setFlagFragment(i, avp.MESH_TRAVERSED, false);
            }
            for (var p in frags.geomidsmap) {
                if (frags.geomidsmap.hasOwnProperty(p)) {
                    frags.geomidsmap[p].t = 0;
                }
            }
        }

        //Decide whether to use the BVH for traversal
        //If we are far out from the scene, use pure big-to-small
        //importance order instead of front to back.
        _bvhOn = false;
        if (_bvhIterator && !_frags.fragmentsHaveBeenAdded()) {
            //TODO: BVH always on when available, because the linear iteration
            //does not respect transparent objects drawing last -- it just
            //draws in the order the fragments come in the SVF package
        /*
            if(this.enforceBvh || !_linearIterator) {
                _bvhOn = true;
            } else {
                var diag = _visibleBoundsWithHidden.size().length();
                var center = _visibleBoundsWithHidden.center();
                var dist = camera.position.distanceTo(center);
                if (dist < diag * 0.5)
                    _bvhOn = true;
            }
            */
            _bvhOn = true;
        }
       
        if (_bvhOn) {
            _iterator = _bvhIterator;
        } else {
            _iterator = _linearIterator;
        }
        
        _renderCounter = 0;
        _drawMode = drawMode;
        _frustum = frustum;
        _iterator.reset(frustum);
        return _iterator;
    };
    
    
    
    //Used for accumulating geom pack IDs used in the current frame.
    function fragIdCallback(fragId) {
        var packId = _this.getFragmentList().fragments.packIds[fragId];
        if(_packIds.indexOf(packId) == -1) {
            _packIds.push(packId);
        }
    }

    
    this.nextBatch = function() {
        
         while(1) {
            var scene = _iterator.nextBatch();
            _renderCounter++;
            
            if (!scene)
                return null;
        
            //TODO: Move this to the iterator?
            if (!this.is2d()) {
                //Generally opaque batches are sorted once by material, while
                //transparent batches are sorted back to front each frame
                if (scene.sortObjects && !this.getFragmentList().useThreeMesh)
                    scene.sortByDepth(_frustum);
                else if (!scene.sortDone)
                    scene.sortByMaterial();
            }

            //TODO: move this into the iterator?
            var allHidden = scene.applyVisibility(
                _drawMode, 
                _frustum, 
                this.getFragmentList().fragments.packIds ? fragIdCallback : null);
            
            if (!allHidden)
                return scene;
            
        }
    
    };
    
    
    this.getVisibleBounds = function(includeGhosted) {

        if (this.visibleBoundsDirty) {

            _visibleBounds.makeEmpty();
            _visibleBoundsWithHidden.makeEmpty();

            _iterator.getVisibleBounds(_visibleBounds, _visibleBoundsWithHidden, includeGhosted);


            this.visibleBoundsDirty = false;

        }

        return includeGhosted ? _visibleBoundsWithHidden : _visibleBounds;
    };

    
    
    // Add "meshes" parameter, after we get meshes of the object using id buffer,
    // then we just need to ray intersect this object instead of all objects of the model.
    this.rayIntersect = function(raycaster, ignoreTransparent, dbIds) {

        if (this.visibleBoundsDirty)
            this.getVisibleBounds();

        var intersects = [];
        var i;

        if (dbIds && dbIds.length > 0) {

            //Collect the mesh fragments for the given database ID node filter.
            var it = this.getData().instanceTree;
            var fragIds = [];
            if (it) {
                for (i=0; i<dbIds.length; i++) {
                    it.enumNodeFragments(dbIds[i], function(fragId) {
                        fragIds.push(fragId);
                    }, true);
                }
            } else {
                //No instance tree -- treat dbIds as fragIds
                fragIds = dbIds;
            }

            //If there are multiple fragments it pays to still use
            //the bounding volume hierarchy to do the intersection,
            //because it can cull away entire fragments by bounding box,
            //instead of checking every single fragment triangle by triangle
            if (fragIds.length > 2) { //2 is just an arbitrary value, assuming checking 2 fragments is still cheap than full tree traversal
                _iterator.rayCast(raycaster, intersects, dbIds);
            } else {
                for (i=0; i<fragIds.length; i++) {
                    var mesh = _frags.getVizmesh(fragIds[i]);
                    if (!mesh)
                        continue;
                    var res = VBIntersector.rayCast(mesh, raycaster, intersects);
                    if (res) {
                        intersects.push(res);
                    }
                }
            }

        } else {
            _iterator.rayCast(raycaster, intersects);
        }


        if (!intersects.length)
            return null;

        intersects.sort(function(a, b) { return a.distance - b.distance; });

        //pick the nearest object that is visible as the selected.
        var result;
        for (i=0; i<intersects.length; i++) {
            var fragId = intersects[i].fragId;

            //skip past f2d consolidated meshes.
            //TODO: we should completely avoid intersecting those in the ray caster.
            if (this.is2d())
                continue;

            var isVisible = this.isFragVisible(fragId); //visible set,

            if (isVisible) {

                var material = _frags.getMaterial(fragId);

                if (ignoreTransparent && material.transparent)
                    continue;

                result = intersects[i];

                var intersectPoint = intersects[i].point;

                // check against cutplanes
                var isCut = false;
                if (material.cutplanes) {
                    for (var j=0; j<material.cutplanes.length; j++) {
                        isCut = isCut || (material.cutplanes[j].dot(new THREE.Vector4(
                            intersectPoint.x, intersectPoint.y, intersectPoint.z, 1.0
                            )) > 1e-6);
                    }
                }
                if (isCut) {
                    result = null;
                }
                else {
                    break;
                }
            }
        }

        if (result)
            result.model = this;

        return result;
    };



    this.setHighlighted = function(fragId, value) {
        var changed = _frags.setFlagFragment(fragId, avp.MESH_HIGHLIGHTED, value);

        if (changed) {
            if (value)
                _numHighlighted++;
            else
                _numHighlighted--;
        }

        return changed;
    };

    // This function should probably not be called outside VisibityManager
    // in order to maintain node visibility state.
    this.setVisibility = function(fragId, value) {
        _frags.setVisibility(fragId, value);
        this.visibleBoundsDirty = true;
    };

    this.setAllVisibility = function(value) {
        _frags.setAllVisibility(value);
        this.visibleBoundsDirty = true;
    };

    this.hideLines = function(hide) {
        _frags.hideLines(hide);
    };

    this.hasHighlighted = function() {
        return !!_numHighlighted;
    };

    this.isFragVisible = function(frag) {
        return _frags.isFragVisible(frag);
    };

    this.areAllVisible = function() {
        return _frags.areAllVisible();
    };
/*
    this.getRenderProgress = function() {
        return _iterator.getRenderProgress();
    };
*/
    
    this.getGeomScenes = function() { return _iterator.getGeomScenes(); };

    this.getRenderProgress = function() {
        return _renderCounter / _iterator.getSceneCount();
    };



    this.pageOutStatus = function() {
        return _pageOutStatus;
    };

    // Page geometry out if memory is under pressure
    this.pageOutIfNeeded = function(forcePageOut) {

        var _geoms = this.getGeometryList();
        var _frags = this.getFragmentList();

        var num = _geoms.numGeomsInMemory;
        if (num > avp.GEOMS_COUNT_LIMIT) {
            // Over the limit, then start page out
            var sum = 0, p = 0, i = 0, len, geomId, size;
            var remaining = avp.GEOMS_PAGEOUT_COUNT;

            // Remove untraversed geometries first.
            len = _frags.culledGeom.length;
            len = len > remaining ? remaining : len;
            for (i=0; i<len; i++) {
                geomId = _frags.culledGeom[i];
                size = _geoms.removeGeometry(geomId);
                if (size > 0) {
                    sum += size;
                    p++;
                }
            }
            _frags.culledGeom.splice(0, len);
            remaining = remaining - len;

            // If not enough, continue to remove geometries that are already traversed.
            if (remaining > 0) {
                len = _frags.traversedGeom.length;
                i = len > remaining ? len - remaining : 0;
                // Remove all geometries that have been traversed in a reversed order.
                for (; i<len; ++i) {
                    geomId = _frags.traversedGeom[i];
                    size = _geoms.removeGeometry(geomId);
                    if (size > 0) {
                        sum += size;
                        p++;
                    }
                }
                len = len > remaining ? remaining : len;
                _frags.traversedGeom.splice(-len, len);
            }

            num = _geoms.numGeomsInMemory;
            if (forcePageOut && num > avp.GEOMS_COUNT_LIMIT) {
                // If existing geometries are still over the limitation, and force page out enabled,
                // Let's do it anyway.
                len = _geoms.geoms.length;
                for (i=0; i<len; ++i) {
                    size = _geoms.removeGeometry(i);
                    if (size > 0) {
                        sum += size;
                        p++;
                    }
                    if (_geoms.numGeomsInMemory < avp.GEOMS_COUNT_LIMIT)
                        break;
                }
                stderr("A force page out occur. ");
            }

            _pageOutGeomCount += p;
            stderr("Unload: " + p + " , Size: " + sum/(1024 * 1024) + "MB. " + "Remaining: " + _geoms.numGeomsInMemory);

            if (_geoms.numGeomsInMemory > avp.GEOMS_COUNT_LIMIT) {
                // If still above the limit, then page out failed.
                // This case illustrate that too many geometry get loaded,
                // but haven't render yet.
                // So, let's redo the rendering, and stop loading further more until
                // there are more memory freed up.
                _frags.reachLimit = true;
                _packIds = [];

                return avp.PAGEOUT_FAIL;
            }
        }

        _frags.reachLimit = false;
        return avp.PAGEOUT_SUCCESS;
    };


    this.frameUpdatePaging = function(isBeginFrame) {
    
        var _frags = this.getFragmentList();
        // Page out at each end of render
        var _pageOutGeometryEnabled = avp.pageOutGeometryEnabled && (_frags.getCount() > avp.FRAGS_PERSISTENT_MAX_COUNT);
        if (_pageOutGeometryEnabled && !isBeginFrame) {
            if (_pageOutStatus == avp.PAGEOUT_FAIL) {
                // The last time of paging out failed, which means that
                // small part of the model get traversed, then let's wait until
                // enough geometries are ready to recycle.
                if (_frags.traversedGeom.length > avp.GEOMS_PAGEOUT_COUNT * 0.5) {
                    _pageOutStatus = this.pageOutIfNeeded();
                }
            }
            else {
                _pageOutStatus = this.pageOutIfNeeded();
            }
        }

        if (_iterator.done()) {

            if (_pageOutGeometryEnabled) {
                // We will give a last try of paging out,
                // if still fail and traversed geometry is not empty, then will need another render.
                // otherwise, need a hard page out no matter geometry get traversed or not.
                _pageOutStatus = this.pageOutIfNeeded();
                if (_pageOutStatus == avp.PAGEOUT_FAIL && _pageOutGeomCount === 0) {
                    this.pageOutIfNeeded(true);
                }
            }
        }

    };


    this.geomPacksMissingLastFrame = function() {
        return _packIds;
    };

    // Explicitly add the pack as missing from last frame.
    this.addGeomPackMissingLastFrame = function(packId) {
        if(_packIds.indexOf(packId) == -1) {
            _packIds.push(packId);
        }
    };


}

RenderModel.prototype = Object.create(av.Model.prototype);
RenderModel.prototype.constructor = RenderModel;

avp.RenderModel = RenderModel;

})();
;
//TODO: This file is in the process of being refactored into three parts: RenderModel, ModelIteratorBVH and ModelIteratorLinear
//Please keep this in mind when making changes here


(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

    /** @constructor
     * RenderScene
     * Represents the full graphical scene.
     * Used for iterating through the scene for progressive rendering,
     * hit testing, etc.
     * */
    function RenderScene() {

        var _needsRender = false;

        var _done = false;
        var _renderCounter = 0;
        var _firstFrameLastBatch = null;
        var _wantStableVisbility = true;

        var _models = [];
        var _candidateScenes = [];
        var _tmpBox = new THREE.Box3();

        var _frustum = new avp.FrustumIntersector();

        var _raycaster = new THREE.Raycaster();

        var _drawMode = avp.RENDER_NORMAL;
        var _wasBeginFrame = false;
        var _frameStamp = 0;
        var _perf = performance;


//TODO: This should be removed, because the functionality that uses it
//in the SvfLoader does not seem needed
        // If the given fragment is culled by either view frustum or
        // project area, then return true otherwise false.
        this.checkCull = function () {

            var box = new THREE.Box3();

            return function (idx, checkCull, checkArea) {
                _models[0].getFragmentList().getWorldBounds(idx, box);
                if (checkCull && !_frustum.intersectsBox(box)) {
                    return true;
                }
                else if (checkArea) {
                    var area = _frustum.projectedArea(box);
                    area *= _frustum.areaConv;
                    if (area < _frustum.areaCullThreshold) {
                        return true;
                    }
                }
                return false;
            }

        }();


        this.addModel = function(renderModel) {
            _models.push(renderModel);
            _candidateScenes.length = _models.length;
        };

        this.removeModel = function(renderModel) {
            var idx = _models.indexOf(renderModel);
            if (idx >= 0) {
                _models.splice(idx, 1);
            }
            _candidateScenes.length = _models.length;
            return idx >= 0;
        };

        this.isEmpty = function() {
            return _models.length === 0;
        };

        this.needsRender = function () {
            return _needsRender;
        };
        this.resetNeedsRender = function () {
            _needsRender = false;
        };


        //Incrementally render some meshes until we run out of time
        this.renderSome = function (renderObjectCB, timeRemaining) {

            var t0 = _perf.now(), t1;

            //If the render queue is just starting to render
            //we will remember how many items we draw on the first pass
            //and keep drawing the same number of items on subsequent first passes,
            //until we get to a second renderSome pass. This is to make sure that
            //while moving the camera in a single motion, the number of items we draw
            //does not vary, which causes some ugly flashing -- because the render time
            //per item varies a little from frame to frame.
            var isBeginFrame = ( _renderCounter === 0 );
            if (_wantStableVisbility && isBeginFrame && !_wasBeginFrame) {
                //case of a new initial frame when the previous frame was not initial
                _firstFrameLastBatch = null;
                _wasBeginFrame = true;
            }

            while (1) {

                //Find the best candidate render batch to render now -- in case
                //there are multiple models.
                //TODO: In case a huge number of models is loaded, we may have to
                //rethink the linear loop below and use some priority heap or somesuch.
                var candidateIdx = 0;
                var scene = _candidateScenes[0];
                for (var q=1; q<_candidateScenes.length; q++) {
                    var candidate = _candidateScenes[q];
                    if (candidate === null)
                        continue;
                    if (!scene) {
                        candidateIdx = q;
                        scene = candidate;
                    }
                    if (candidate.renderImportance > scene.renderImportance) {
                        candidateIdx = q;
                        scene = candidate;
                    }
                }

                var outOfTime = false;
                if (scene) {
                    //Fetch a new render batch from the model that we took the
                    //current batch from.
                    _candidateScenes[candidateIdx] = _models[candidateIdx].nextBatch();

                    renderObjectCB(scene);

                    _renderCounter++;

                    t1 = _perf.now();
                    var delta = t1 - t0;
                    t0 = t1;

                    //For each sub-scene, keep a running average
                    //of how long it took to render over the
                    //last few frames.
                    if (scene.avgFrameTime === undefined)
                        scene.avgFrameTime = delta;
                    else
                        scene.avgFrameTime = 0.8 * scene.avgFrameTime + 0.2 * delta;

                    //stderr(i + " " + scene.avgFrameTime);

                    timeRemaining -= scene.avgFrameTime;

                    var done = false;

                    if (_wantStableVisbility && isBeginFrame && _firstFrameLastBatch !== null) {
                        //In case we are drawing an initial frame, and the previous frame
                        //was also an initial frame, we will loop for as many items as we
                        //drew on the last pass.
                        if (scene == _firstFrameLastBatch)
                            done = true;
                    }
                    else //Otherwise (not first frame) draw based on timing.
                    {
                        if (timeRemaining <= 0)
                            done = true;
                    }

                    if (done) {
                        outOfTime = true;
                        break;
                    }

                }

                if (!scene) {
                    _done = true;
                    break;
                }

                if (outOfTime)
                    break;
            }

            //Remember how many items we drew on the first progressive frame, so that
            //we draw the same number if the next frame is also a first progressive frame
            //(e.g. camera moved and reset the render queue)
            if (_wantStableVisbility && isBeginFrame && _firstFrameLastBatch == null) {
                _firstFrameLastBatch = scene;
            }

            //stderr(t0 - start);

            for (var q=0; q<_models.length; q++) {
                if (_models[q].frameUpdatePaging(isBeginFrame) === avp.PAGEOUT_FAIL)
                    _needsRender = true;
            }

            if (_done || !isBeginFrame) {
                _firstFrameLastBatch = null;
                _wasBeginFrame = false;
            }

            return timeRemaining;
        };


        //Resets the scene traversal
        this.reset = function (camera, drawMode, moved) {
            _frameStamp++;
            _done = false;
            _drawMode = drawMode;


            _renderCounter = 0;
            this.resetNeedsRender();

            //Calculate the viewing frustum
            //TODO: same math is done in the renderer also. We could unify
            _frustum.reset(camera);

            if (!_models.length)
                return;

            //Begin the frustum based scene iteration process per model
            for (var i=0; i<_models.length; i++) {
                _models[i].resetIterator(camera, _frustum, drawMode, moved);
                _candidateScenes[i] = _models[i].nextBatch();
            }
        };


        this.isDone = function () {
            return _done || this.isEmpty();
        };

        this.setAllVisibility = function (value) {
            for (var i=0; i<_models.length; i++)
                _models[i].setAllVisibility(value);
        };

        this.hideLines = function (hide) {
            for (var i=0; i<_models.length; i++)
                _models[i].hideLines(hide);
        };

        this.hasHighlighted = function () {
            for (var i=0; i<_models.length; i++)
                if (_models[i].hasHighlighted())
                    return true;

            return false;
        };

        this.areAllVisible = function () {
            for (var i=0; i<_models.length; i++)
                if (!_models[i].areAllVisible())
                    return false;

            return true;
        };

        this.invalidateVisibleBounds = function() {
            for (var i=0; i<_models.length; i++)
                _models[i].visibleBoundsDirty = true;
        };


        this.getVisibleBounds = function (includeGhosted) {
            if (_models.length === 1)
                return _models[0].getVisibleBounds(includeGhosted);

            _tmpBox.makeEmpty();
            for (var i=0; i<_models.length; i++)
                _tmpBox.union(_models[i].getVisibleBounds(includeGhosted));

            return _tmpBox;
        };

        // Add "meshes" parameter, after we get meshes of the object using id buffer,
        // then we just need to ray intersect this object instead of all objects of the model.
        this.rayIntersect = function (position, direction, ignoreTransparent, dbIds) {

            _raycaster.set(position, direction);

            if (_models.length > 1) {
                var modelHits = [];
                for (var i=0; i<_models.length; i++) {
                    if (_models[i].is2d())
                        continue;
                    var res = _models[i].rayIntersect(_raycaster, ignoreTransparent, dbIds);
                    if (res)
                        modelHits.push(res);
                }

                if (!modelHits.length)
                    return null;

                modelHits.sort(function(a,b) {return a.distance - b.distance});

                return modelHits[0];
            } else {
                if (!_models.length || _models[0].is2d())
                    return null;
                return _models[0].rayIntersect(_raycaster, ignoreTransparent, dbIds);
            }
        };


        this.getRenderProgress = function () {
            return _models[0].getRenderProgress();
        };

        this.getFragmentList = function () {
            return _models[0].getFragmentList();
        };

        this.getGeometryList = function () {
            return _models[0].getGeometryList();
        };

        this.getSceneCount = function () {
            return _models[0].getSceneCount();
        };

        this.getModels = function() {
            return _models;
        };

        //Used by ground shadow update
        //TODO: we need to allow multiple iterators over the render queue
        this.getGeomScenes = function () {
            return _models[0].getGeomScenes();
        };

        this.geomPacksMissingLastFrame = function () {
            return _models[0].geomPacksMissingLastFrame();
        };




        this.explode = function(scale) {

            if (!_models.length)
                return;

            for (var q=0; q<_models.length; q++) {
                var model = _models[q];
                var svf = model.getData();

                var mc = model.getVisibleBounds(true).center();

            //var t0 = Date.now();

                var fragList = model.getFragmentList();
                var pt = new THREE.Vector3();

                //Input scale is in the range 0-1, where 0
                //means no displacement, and 1 maximum reasonable displacement.
                scale *= 2;

                //If we have a full part hierarchy we can use a
                //better grouping strategy when exploding
                if (svf.instanceTree && svf.instanceTree.nodeAccess.nodeBoxes && scale !== 0) {

                    var scaledExplodeDepth = scale * (svf.instanceTree.maxDepth - 1) + 1;
                    var explodeDepth = 0 | scaledExplodeDepth;
                    var currentSegmentFraction = scaledExplodeDepth - explodeDepth;

                    var it = svf.instanceTree;
                    var tmpBox = new Float32Array(6);

                    (function explodeRec(nodeId, depth, cx, cy, cz, ox, oy, oz) {

                        var oscale = scale*2; //TODO: also possibly related to depth
                        if (depth == explodeDepth)
                            oscale *= currentSegmentFraction; //smooth transition of this tree depth from non-exploded to exploded state

                        it.getNodeBox(nodeId, tmpBox);
                        var mycx = 0.5 * (tmpBox[0] + tmpBox[3]);
                        var mycy = 0.5 * (tmpBox[1] + tmpBox[4]);
                        var mycz = 0.5 * (tmpBox[2] + tmpBox[5]);

                        if (depth > 0 && depth <= explodeDepth) {
                            var dx = (mycx - cx) * oscale;
                            var dy = (mycy - cy) * oscale;
                            var dz = (mycz - cz) * oscale;

                            //var omax = Math.max(dx, Math.max(dy, dz));
                            ox += dx;
                            oy += dy;
                            oz += dz;
                        }

                        svf.instanceTree.enumNodeChildren(nodeId, function(dbId) {
                            explodeRec(dbId, depth+1, mycx, mycy, mycz, ox, oy, oz);
                        }, false);

                        svf.instanceTree.enumNodeFragments(nodeId, function(fragId) {

                            pt.x = ox; pt.y = oy; pt.z = oz;
                            fragList.updateAnimTransform(fragId, null, null, pt);

                        }, false);

                    })(svf.instanceTree.getRootId(), 0, mc.x, mc.y, mc.x, 0, 0, 0);
                }
                else {
                    var boxes = fragList.fragments.boxes;

                    for (var i= 0, iEnd=fragList.getCount(); i<iEnd; i++) {

                        if (scale == 0) {

                            fragList.updateAnimTransform(i);

                        } else {

                            var box_offset = i * 6;

                            var cx = 0.5 * (boxes[box_offset] + boxes[box_offset + 3]);
                            var cy = 0.5 * (boxes[box_offset + 1] + boxes[box_offset + 4]);
                            var cz = 0.5 * (boxes[box_offset + 2] + boxes[box_offset + 5]);

                            cx = scale * (cx - mc.x);
                            cy = scale * (cy - mc.y);
                            cz = scale * (cz - mc.z);

                            pt.x = cx;
                            pt.y = cy;
                            pt.z = cz;
                            fragList.updateAnimTransform(i, null, null, pt);
                        }
                    }
                }

            //var t1 = Date.now();
            //stderr(t1 - t0);


            }

            this.invalidateVisibleBounds();

        };


    }


    avp.RenderScene = RenderScene;

})();;
(function() {

'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

function RenderContext() {

    var _renderer;
    var _depthMaterial;
    var _idMaterial;

    //The camera and lights used for an entire progressive pass (potentially several GL frames)
    var _camera;
    var _lights;

    var _clearPass,
        _saoBlurPass,
        _saoPass,
        _saoMipPass,
        _saoMipFirstPass,
        _fxaaPass,
        _celPass,
        _blendPass,
        _copyPass;

    var _saoBufferValid = false;

    var _lastX, _lastY, _lastID, _lastIDValid = false;

    var _depthTarget;
    var _depthMipMap = null;
    var _colorTarget = null;
    var _overlayTarget = null;
    var _postTarget1 = null;
    var _postTarget2 = null;
    var _idTarget = null;

    var _exposureBias = 0.0;
    var _envRotation = 0.0;
    var _tonemapMethod = 0;
    var _unitScale = 1.0;

    var _w, _h;
    var _warnedLeak = false;

    var _readbackBuffer = new Uint8Array(4);

    var _white = new THREE.Color().setRGB(1, 1, 1);
    var _black = new THREE.Color().setRGB(0, 0, 0);
    var _clearColor = null;
    var _blockMRT = false;
    var _isWeakDevice = false;

    var _mrtFloat32Works = false;
    var _mrtRGBA8Works = false;

    var _lastObjId = 0,
        _lastObjTime = 0,
        _easeCurve = [0.42,0,1,1],
        _easeSpeed = 0.004;

    //Rendering options
    var _settings = {
        antialias: true,
        sao: false,
        useHdrTarget: false,
        haveTwoSided: false,
        useSSAA: false, /* Whether to use supersampled targets when antialiasing is used (default is FXAA) */
        idbuffer: true,
        customPresentPass: false,
        toonShaded: false,
        envMapBg: false
    };

    var _oldSettings = {};

    var avs = Autodesk.Viewing.Shaders;


    //TODO: hide this once there is a way
    //to obtain the current pipeline configuration
    this.settings = _settings;


    this.init = function (glrenderer, width, height) {

        avs.init_ShaderChunks(THREE);
        avs.init_FireflyPhongShader(THREE);
        avs.init_FireflyPrismShader(THREE);
        avs.init_BackgroundShader(THREE);
        avs.init_BlendShader(THREE);
        avs.init_CelShader(THREE);
        avs.init_CopyShader(THREE);
        avs.init_FXAAShader(THREE);
        avs.init_LineShader(THREE);
        avs.init_NormalsShader(THREE);
        avs.init_SAOBlurShader(THREE);
        avs.init_SAOMinifyShader(THREE);
        avs.init_SAOShader(THREE);
        avs.init_FireflyBasicShader(THREE);

        createRenderPasses();

        if (!glrenderer) {
            console.error("You need a gl context to make a renderer. Things will go downhill from here.");
            return;
        }

        //Firefox on Mac OSX reports it can do MRT, but it actually does not work in our case,
        //so we have to detect this case manually.
        _blockMRT = window.navigator.userAgent.indexOf("Firefox") != -1 && window.navigator.userAgent.indexOf("Mac OS") != -1;
        _isWeakDevice = av.isMobileDevice();

        _settings.idbuffer = !_isWeakDevice;

        _w = width;
        _h = height;

        _renderer = glrenderer;

        this.initPostPipeline(_settings.sao, _settings.antialias, false);

    };


    function createRenderPasses() {

        function setNoDepthNoBlend(pass) {
            pass.material.blending = THREE.NoBlending;
            pass.material.depthWrite = false;
            pass.material.depthTest = false;
        }

        var depthShader = avs.NormalsShader;

        _depthMaterial = new THREE.ShaderMaterial({
            fragmentShader: depthShader.fragmentShader,
            vertexShader: depthShader.vertexShader,
            uniforms: THREE.UniformsUtils.clone(depthShader.uniforms) });
        _depthMaterial.blending = THREE.NoBlending;
        _depthMaterial.packedNormals = true;

        // Prepare an alternative normal/depth material without cutplanes to render section caps
        _depthMaterial._noCutplanesMaterial = _depthMaterial.clone();
        _depthMaterial._noCutplanesMaterial.cutplanes = null;
        _depthMaterial._noCutplanesMaterial.blending = THREE.NoBlending;
        _depthMaterial._noCutplanesMaterial.packedNormals = true;

        _saoPass = new avs.LmvShaderPass(avs.SAOShader);
        setNoDepthNoBlend(_saoPass);

        _saoBlurPass = new avs.LmvShaderPass(avs.SAOBlurShader);
        setNoDepthNoBlend(_saoBlurPass);

        _saoMipFirstPass = new avs.LmvShaderPass(avs.SAOMinifyFirstShader);
        setNoDepthNoBlend(_saoMipFirstPass);

        _saoMipPass = new avs.LmvShaderPass(avs.SAOMinifyShader);
        setNoDepthNoBlend(_saoMipPass);

        _fxaaPass = new avs.LmvShaderPass(avs.FXAAShader);
        setNoDepthNoBlend(_fxaaPass);

        _celPass = new avs.LmvShaderPass(avs.CelShader);
        setNoDepthNoBlend(_celPass);

        _blendPass = new avs.LmvShaderPass(avs.BlendShader);
        setNoDepthNoBlend(_blendPass);

        _clearPass = new avs.LmvShaderPass(avs.BackgroundShader);
        setNoDepthNoBlend(_clearPass);

        _copyPass = new avs.LmvShaderPass(avs.CopyShader);
        setNoDepthNoBlend(_copyPass);
    }


    function cubicBezier(p, t) {
		//var cx = 3.0 * p[0];
		//var bx = 3.0 * (p[2] - p[0]) - cx;
		//var ax = 1.0 - cx -bx;
		var cy = 3.0 * p[1];
		var by = 3.0 * (p[3] - p[1]) - cy;
		var ay = 1.0 - cy - by;

        //return ((ax * t + bx) * t + cx) * t;
        return ((ay * t + by) * t + cy) * t;
    }

    // note: highResTimer is not used
    this.overlayUpdate = function(highResTimer) {

        if (_lastObjId === 0 || _lastObjId === -1)
            return false;

        var old = _blendPass.uniforms.highlightIntensity.value;

        var t = ((performance.now() - _lastObjTime) * _easeSpeed);
        t = Math.min(t, 1.0);

        var current = cubicBezier(_easeCurve, t);

        if (old != current) {
            _blendPass.uniforms.highlightIntensity.value = current;
            return true;
        }

        return false;
    };

    this.beginScene = function (prototypeScene, camera, customLights, needClear) {
        _camera = camera;
        _lights = customLights;
        _saoBufferValid = false;
        _lastIDValid = false;

        if (!_colorTarget) {
            if (!_w && !_warnedLeak) {
                console.error("Rendering to a canvas that was resized to zero. If you see this message you may be accidentally leaking a viewer instance.");
                _warnedLeak = true;
            }
            return;
        }

        //We need to render once with the "prototype" scene which
        //only contains the cameras and lights, so that their positions
        //and transforms get updated to the latest camera. Hence the
        //call to render instead of just clear.


        //Clear the color target
        if (needClear) {

            if (_clearColor && !_settings.envMapBg) {
                _renderer.setClearColor(_clearColor, 1.0);
                _renderer.clearTarget(_colorTarget, true, true, false); //clear color and depth buffer
            } else {

                _clearPass.uniforms['uCamDir'].value = _camera.worldUpTransform ? _camera.getWorldDirection().clone().applyMatrix4(_camera.worldUpTransform) : _camera.getWorldDirection();
                _clearPass.uniforms['uCamUp'].value = _camera.worldUpTransform ? _camera.up.clone().applyMatrix4(_camera.worldUpTransform) : _camera.up;
                _clearPass.uniforms['uResolution'].value.set(_w, _h);
                _clearPass.uniforms['uHalfFovTan'].value = Math.tan(THREE.Math.degToRad(_camera.fov * 0.5));

                _renderer.clearTarget(_colorTarget, false, true, false); //clear depth buffer
                _clearPass.render(_renderer, _colorTarget, null); //clear the color buffer
            }
        }

        //Clear the id buffer
        if (_idTarget) {
            _renderer.setClearColor(_white, 1.0);
            _renderer.clearTarget(_idTarget, true, false, false);
        }

        //Clear the G-buffer target if needed and update the SSAO uniforms.
        if (_settings.sao || _settings.toonShaded) {

            if (needClear) {
                _renderer.setClearColor(_black, 0.0);
                //Skip clearing the depth buffer as it's shared with the color target
                _renderer.clearTarget(_depthTarget, true, false, false);
            }

            var near = camera.near;
            var far = camera.far;

            _saoPass.uniforms['cameraNear'].value = near;
            _saoPass.uniforms['cameraFar'].value = far;
            _celPass.uniforms['cameraNear'].value = near;
            _celPass.uniforms['cameraFar'].value = far;

            _saoMipFirstPass.uniforms['cameraNear'].value = near;
            _saoMipFirstPass.uniforms['cameraInvNearFar'].value = 1.0 / (near - far);

            var P = camera.projectionMatrix.elements;

            //Scaling factor needed to increase contrast of our SSAO.
            if (camera.isPerspective) {
                /*  vec4(-2.0f / (width*P[0][0]),
                 -2.0f / (height*P[1][1]),
                 ( 1.0f - P[0][2]) / P[0][0],
                 ( 1.0f + P[1][2]) / P[1][1])*/
                _saoPass.uniforms[ 'projInfo' ].value.set(
                    -2.0 / (_colorTarget.width * P[0]),
                    -2.0 / (_colorTarget.height * P[5]),
                    (1.0 - P[8]) / P[0],
                    (1.0 + P[9]) / P[5]);   //TODO: Not certain if we need + or - here for OpenGL off-center matrix (original is DX-style)
                                            //would have to verify if some day we have off-center projections.

                _celPass.uniforms[ 'projInfo'].value.copy(_saoPass.uniforms[ 'projInfo' ].value);

                _saoPass.uniforms[ 'isOrtho' ].value = 0.0;

                _celPass.uniforms[ 'isOrtho' ].value = 0.0;

            } else {
                _saoPass.uniforms[ 'projInfo' ].value.set(
                    -2.0 / (_colorTarget.width * P[0]),
                    -2.0 / (_colorTarget.height * P[5]),
                    (1.0 - P[12]) / P[0],
                    (1.0 - P[13]) / P[5]);

                _celPass.uniforms[ 'projInfo'].value.copy(_saoPass.uniforms[ 'projInfo' ].value);

                _saoPass.uniforms[ 'isOrtho' ].value = 1.0;

                _celPass.uniforms[ 'isOrtho' ].value = 1.0;

            }

            var hack_scale = 0.25;
            _saoPass.uniforms[ 'projScale' ].value = hack_scale * 0.5 * (_colorTarget.height * P[5]);

        }

        //Render the prototype/pre-model scene, which may also contain some user added custom geometry.
        this.renderScenePart(prototypeScene, true, true, false, true);
    };


    //Called incrementally by the scene traversal, potentially
    //across several frames.
    this.renderScenePart = function (scene, colorTarget, saoTarget, idTarget, updateLights) {

        //console.time("renderScenePart");
        _saoBufferValid = false;
        _lastIDValid = false;
        var lights = updateLights ? _lights : undefined;

        //Three possibilities here -- MRT fully supported (Mac OS or native GL backends on Windows).
        //MRT supported only for targets that have exactly equal number of bitplanes and bpp (ANGLE on Windows)
        //MRT not supported at all. (Not sure --> some mobile platforms?).

		var oldMat;
        if (_mrtFloat32Works && _mrtRGBA8Works) {
            //You lucky dog! Fast code path for you.

            //In case of MRT, we ignore the which target flags, because
            //we assume the shaders are set up to write to the multiple targets anyway.
            //NOP: except idTarget, since hidden pass doesn't want that
            if (_settings.idbuffer && idTarget && (_settings.sao || _settings.toonShaded)) {
                _renderer.render(scene, _camera, [_colorTarget, _depthTarget, _idTarget], false, lights);
            }
            else if ((_settings.sao || _settings.toonShaded)) {
                _renderer.render(scene, _camera, [_colorTarget, _depthTarget], false, lights);
            }
            else if (_settings.idbuffer && idTarget) {
                _renderer.render(scene, _camera, [_colorTarget, _idTarget]);
            }
            else /*if (_settings.antialias)*/ {
                _renderer.render(scene, _camera, _colorTarget, false, lights);
            }
            //else {
            //    _renderer.render(scene, _camera, null);
            //}

        } else if (_mrtRGBA8Works) {
            //It's something...

            if (_settings.idbuffer && idTarget) {
                _renderer.render(scene, _camera, [_colorTarget, _idTarget], false, lights);
            }
            else /*if (_settings.antialias)*/ {
                _renderer.render(scene, _camera, _colorTarget, false, lights);
            }

            //Float target has to be rendered separately in case we can't
            //bind MRT with different bpp targets.
            if ((_settings.sao || _settings.toonShaded) && saoTarget) {
                //Render the depth pass
                oldMat = scene.overrideMaterial;

                scene.overrideMaterial = _depthMaterial;

                _renderer.render(scene, _camera, _depthTarget, false, undefined);

                scene.overrideMaterial = oldMat;
            }

        } else {
            //Poor sod. No MRT at all. Three passes.

            //Render the color target first -- actually this is slower
            //because the color shader is likely a lot slower than the
            //depth+normal shader, but if we render depth first, then
            //we lose stuff behind transparent objects (potentially).
            //So we cannot do this until the progressive render is split
            //into non-transparent and transparent worlds.
            if (colorTarget) {
                _renderer.render(scene, _camera, _colorTarget, false, lights);
            }

            //TODO: In 3D we really don't want to get into
            //this situation -- we don't have a reasonable ID material that
            //will work for e.g. cutout maps. We'd have to run basically a full
            //shader, or at least one that support opacity and alpha map checks.
            if (_settings.idbuffer && idTarget && _idMaterial) {

                oldMat = scene.overrideMaterial;

                scene.overrideMaterial = _idMaterial;

                _renderer.render(scene, _camera, _idTarget, false, undefined);

                scene.overrideMaterial = oldMat;
            }

            if ((_settings.sao || _settings.toonShaded) && saoTarget) {
                //Render the depth pass
                oldMat = scene.overrideMaterial;

                scene.overrideMaterial = _depthMaterial;

                _renderer.render(scene, _camera, _depthTarget, false, undefined);

                scene.overrideMaterial = oldMat;
            }

        }

        //console.timeEnd("renderScenePart");
    };

    this.clearAllOverlays = function () {
        _renderer.clearTarget(_overlayTarget, true, false, false);
    };

    this.renderOverlays = function (overlays, lights) {
        var haveOverlays = 0;

        for (var key in overlays) {
            var p = overlays[key];
            var s = p.scene;
            var c = p.camera ? p.camera : _camera;
            if (s.children.length) {

                if (!haveOverlays) {
                    haveOverlays = 1;

                    //clear the overlay target once we see
                    //the first non-empty overlay scene
                    _renderer.setClearColor(_black, 0.0);
                    _renderer.clearTarget(_overlayTarget, true, false, false);
                }


                if (p.materialPre) {
                    s.overrideMaterial = p.materialPre;
                }
                _renderer.render(s, c, _overlayTarget, false, lights);

                if (p.materialPost) {
                    s.overrideMaterial = p.materialPost;
                    _renderer.context.depthFunc(_renderer.context.GREATER);
                    _renderer.render(s, c, _overlayTarget, false, lights);
                    _renderer.context.depthFunc(_renderer.context.LEQUAL);
                }

                s.overrideMaterial = null;
            }
        }

        _blendPass.uniforms['useOverlay'].value = haveOverlays;
    };


    this.computeSSAO = function(skipAOPass) {
        if (!skipAOPass && _settings.sao && !_settings.toonShaded) {

            //console.time("SAO");
            if (!_saoBufferValid) {
                //Create mip levels for the depth/normals target
                if (_depthMipMap) {
                    var prevMip = _depthMipMap[0];
                    _saoMipFirstPass.uniforms['resolution'].value.set(1.0 / prevMip.width, 1.0 / prevMip.height);
                    _saoMipFirstPass.render(_renderer, prevMip, _depthTarget);
                    for (var i = 1; i < _depthMipMap.length; i++) {
                        var curMip = _depthMipMap[i];
                        _saoMipPass.uniforms['resolution'].value.set(1.0 / curMip.width, 1.0 / curMip.height);
                        _saoMipPass.render(_renderer, curMip, prevMip);
                        prevMip = curMip;
                    }
                }

                _saoPass.render(_renderer, _postTarget2, _colorTarget);

                //console.timeEnd("SAO");
                //console.time("SAOblur");
                //Do the bilateral blur
                _saoBlurPass.uniforms['axis'].value.set(1, 0);
                _saoBlurPass.render(_renderer, _postTarget1, _postTarget2);
                _saoBlurPass.uniforms['axis'].value.set(0, 1);
                _saoBlurPass.render(_renderer, _postTarget2, _postTarget1);

                _saoBufferValid = true;
            }

            _blendPass.uniforms['useAO'].value = 1;
            //console.timeEnd("SAOblur");
        } else {
            _blendPass.uniforms['useAO'].value = 0;
        }

    };

    this.presentBuffer = function (userFinalPass) {

        if (!_renderer)
            return;

        //See if the blend pass is trivial 1:1, in which
        //case we can just use the main color target for
        //the final pass and skip the blend pass.
        //NOTE: This needs to be adjusted if the blend pass ever
        //does the tone mapping again.
        //TODO: Another possible improvement is to support blending of the SAO
        //inside the FXAA pass, in case the blend pass is just modulating by the AO value.
        var canSkipBlendPass = !_settings.sao &&
                               !_blendPass.uniforms['useOverlay'].value &&
                               !_blendPass.uniforms['objID'].value;

        if (canSkipBlendPass) {

            if (_settings.antialias) {

                if (userFinalPass) {
                    _fxaaPass.render(_renderer, _postTarget1, _colorTarget);
                    userFinalPass.render(_renderer, null, _postTarget1);
                } else if (_settings.toonShaded) {
                    _celPass.render(_renderer, _postTarget1, _colorTarget);
                    _fxaaPass.render(_renderer, null, _postTarget1);
                } else {
                    _fxaaPass.render(_renderer, null, _colorTarget);
                }
            }
            else if (userFinalPass) {
                userFinalPass.render(_renderer, null, _colorTarget);
            } else if (_settings.toonShaded) {
                _celPass.render(_renderer, _postTarget1, _colorTarget);
                _copyPass.render(_renderer, null, _postTarget1);
            } else {
                _copyPass.render(_renderer, null, _colorTarget);
            }

        } else {

            //console.time("post");
            //If we have fxaa, do the blending into an offscreen target
            //then FXAA into the final target
            if (_settings.antialias) {
                _blendPass.render(_renderer, _postTarget1, _colorTarget);

                if (userFinalPass) {
                    _fxaaPass.render(_renderer, _postTarget2, _postTarget1);
                    userFinalPass.render(_renderer, null, _postTarget2);
                } else if (_settings.toonShaded) {
                    _celPass.render(_renderer, _postTarget2, _postTarget1);
                    _fxaaPass.render(_renderer, null, _postTarget2);
                } else {
                    _fxaaPass.render(_renderer, null, _postTarget1);
                }
            }
            else {
                if (userFinalPass) {

                    _blendPass.render(_renderer, _postTarget1, _colorTarget);
                    userFinalPass.render(_renderer, null, _postTarget1);

                } else {
                    if (_settings.toonShaded) {
                        _blendPass.render(_renderer, _postTarget1, _colorTarget);
                        _celPass.render(_renderer, _postTarget2, _postTarget1);
                        _copyPass.render(_renderer, null, _postTarget2);
                    } else {
                        _blendPass.render(_renderer, null, _colorTarget);
                    }
                }
            }
        }

    };


    this.composeFinalFrame = function (skipAOPass, progressiveDone, skipPresent) {
        //Finish progressive queue
        if (progressiveDone) {

        }

        //Apply the post pipeline and then show to screen.
        //Note that we must preserve the original color buffer
        //so that we can update it progressively
        if (_settings.sao && !_settings.toonShaded)
            this.computeSSAO(skipAOPass);

        if (!skipPresent)
            this.presentBuffer();

        //console.timeEnd("post");

    };

    this.cleanup = function () {
        if (_colorTarget) {
            _colorTarget.dispose();
            _colorTarget = null;
        }

        if (_depthTarget) {
            _depthTarget.dispose();
            _depthTarget = null;
        }

        if (_overlayTarget) {
            _overlayTarget.dispose();
            _overlayTarget = null;
        }

        if (_postTarget1) {
            _postTarget1.dispose();
            _postTarget1 = null;
        }

        if (_postTarget2) {
            _postTarget2.dispose();
            _postTarget2 = null;
        }

        if (_depthMipMap) {
            for (var i=0; i<_depthMipMap.length; i++) {
                _depthMipMap[i].dispose();
            }

            _depthMipMap = [];
        }
    };

    this.setSize = function (w, h, force) {

        _w = w;
        _h = h;

        var sw = 0 | (w * _renderer.getPixelRatio());
        var sh = 0 | (h * _renderer.getPixelRatio());

        _settings.logicalWidth = w;
        _settings.logicalHeight = h;
        _settings.deviceWidth = sw;
        _settings.deviceHeight = sh;

        //Just a way to release the targets in cases when
        //we use a custom render context and don't need this one
        //temporarily
        if (w === 0 && h === 0) {
            this.cleanup();
            return;
        }

        _renderer.setSize(w, h);

        stderr("width: " + sw + " height: " + sh);

        var resX = 1.0 / sw;
        var resY = 1.0 / sh;

        //supersample antialiasing
        //Create a somewhat larger render target, that is power of 2 size and has mipmap
        if (_settings.useSSAA || (_settings.toonShaded && _renderer.getPixelRatio() <= 1)) {
            /*
                sw *= 3 / _renderer.getPixelRatio();
                sh *= 3 / _renderer.getPixelRatio();

                var w = 1;
                while (w < sw) w *= 2;
                var h = 1;
                while (h < sh) h *= 2;

                sw = w;
                sh = h;
                */
                sw *=2;
                sh *=2;

            force = true;
        }

        //Just the regular color target -- shares depth buffer
        //with the depth target.
        if (force || !_colorTarget || _colorTarget.width != sw || _colorTarget.height != sh) {

            stderr("Reallocating render targets.");
            this.cleanup();

            _colorTarget = new THREE.WebGLRenderTarget(sw, sh,
                {   minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBFormat,
                    type: _settings.useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,
                    //anisotropy: Math.min(this.getMaxAnisotropy(), 4),
                    stencilBuffer: false,
                    generateMipmaps: false
                });

            _overlayTarget = new THREE.WebGLRenderTarget(sw, sh,
                {  minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    stencilBuffer: false,
                    generateMipmaps: false
                });


            _overlayTarget.shareDepthFrom = _colorTarget;


            _depthTarget = null;
            _postTarget1 = null;
            _postTarget2 = null;
            _depthMipMap = [];
        }

        if (_settings.antialias || _settings.sao || _settings.customPresentPass || _settings.toonShaded)
        {
            if (force || !_postTarget1 || _postTarget1.width != sw || _postTarget1.height != sh) {
                //We need one extra post target if FXAA is on, so
                //to use as intermediate from Blend->FXAA pass.
                _postTarget1 = new THREE.WebGLRenderTarget(sw, sh,
                    {
                        minFilter: THREE.LinearFilter,
                        magFilter: THREE.LinearFilter,
                        format: THREE.RGBAFormat,
                        //anisotropy: 0,
                        //anisotropy: Math.min(this.getMaxAnisotropy(), 4),
                        stencilBuffer: false,
                        depthBuffer: false,
                        generateMipmaps: false
                    });
            }
        }


        if (_settings.sao || _settings.toonShaded) {
            if (force || !_depthTarget || _depthTarget.width != sw || _depthTarget.height != sh) {

                var format = THREE.FloatType;
                if (av.isMobileDevice()) {
                    format = THREE.HalfFloatType;
                }

                _depthTarget = new THREE.WebGLRenderTarget(sw, sh,
                    { minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBFormat,
                        type: format,
                        stencilBuffer: false});
                _depthTarget.shareDepthFrom = _colorTarget;

                //SSAO depth/normals mip maps. Those are "manually" created
                //because we use custom sampling. Also, they are separately bound into
                //the shader because there doesn't seem to be an easy way to load them
                //as mip levels of the same texture, in the case they were render buffers initially.
                _depthMipMap = [];
                for (var j = 0; j < 5; j++) {
                    var mip = new THREE.WebGLRenderTarget(0 | (sw / (2 << j)), 0 | (sh / (2 << j)),
                        {   minFilter: THREE.NearestFilter,
                            magFilter: THREE.NearestFilter,
                            format: THREE.RGBAFormat,
                            //type:THREE.FloatType,
                            depthBuffer: false,
                            stencilBuffer: false});
                    mip.generateMipmaps = false;
                    _depthMipMap.push(mip);
                    _saoPass.uniforms['tDepth_mip' + (j + 1)].value = mip;
                }

                //Re-check this when render targets change
                _mrtFloat32Works = !_blockMRT && _renderer.verifyMRTWorks([_colorTarget, _depthTarget]);

                //We only need a second post target if SAO is on.
                _postTarget2 = _postTarget1.clone();
            }

            if (!_postTarget2 && _settings.antialias && _settings.customPresentPass)
                _postTarget2 = _postTarget1.clone();

            _saoPass.uniforms[ 'size' ].value.set(sw, sh);
            _saoPass.uniforms[ 'resolution' ].value.set(resX, resY);
            _saoPass.uniforms[ 'tDepth' ].value = _depthTarget;

            _saoBlurPass.uniforms[ 'size' ].value.set(sw, sh);
            _saoBlurPass.uniforms[ 'resolution' ].value.set(resX, resY);

            _celPass.uniforms['tDepth'].value = _depthTarget;
        }

        if (_settings.idbuffer) {
            if (force || !_idTarget || _idTarget.width != sw || _idTarget.height != sh) {
                _idTarget = new THREE.WebGLRenderTarget(sw, sh,
                    {   minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBFormat, /* TODO: need full RGBA for ids over 2^24, but that doesn't match the color target */
                        type: THREE.UnsignedByteType,
                        stencilBuffer: false,
                        generateMipmaps: false
                    });

                _idTarget.shareDepthFrom = _colorTarget;

                //Re-check this when render targets change
                _mrtRGBA8Works = !_blockMRT && _renderer.verifyMRTWorks([_colorTarget, _idTarget]);
                if (!_mrtRGBA8Works) {
                    console.warn("ID buffer requested, but MRT is not supported. Some features will not work.");
                }
            }

            _celPass.uniforms['tID'].value = _idTarget;

        } else if (_idTarget) {

            _idTarget.dispose();
            _idTarget = null;
        }


        _fxaaPass.uniforms[ 'uResolution' ].value.set(resX, resY);
        _celPass.uniforms[ 'resolution' ].value.set(resX, resY);

        _blendPass.uniforms[ 'tOverlay' ].value = _overlayTarget;
        _blendPass.uniforms[ 'tAO' ].value = _postTarget2;
        _blendPass.uniforms[ 'useAO' ].value = _settings.sao ? 1 : 0;
        _blendPass.uniforms[ 'resolution' ].value.set(resX, resY);
        _blendPass.uniforms[ 'tID' ].value = _idTarget;
    };

    this.getMaxAnisotropy = function () {
        return _renderer.getMaxAnisotropy();
    };

    this.hasMRT = function () {
        return !_blockMRT && (_renderer && _renderer.supportsMRT());
    };

    this.applyMRTFlags = function(mat) {
        var oldN = mat.mrtNormals;
        var oldI = mat.mrtIdBuffer;

        mat.mrtNormals = this.hasMRT() && _mrtFloat32Works && (_settings.sao || _settings.toonShaded);
        mat.mrtIdBuffer = this.hasMRT() && _mrtRGBA8Works && _settings.idbuffer;

        if (mat.mrtNormals !== oldN || mat.mrtIdBuffer !== oldI)
            mat.needsUpdate = true;
    };

    this.initPostPipeline = function (useSAO, useFXAA) {

        //TODO: Do we want to move the IE check to higher level code?
        _settings.sao = useSAO && !_isIE11;
        _settings.antialias = useFXAA && !_isIE11;

        if (_settings.sao)
            _settings.toonShaded = false;

        if (_settings.haveTwoSided) {
            _depthMaterial.side = THREE.DoubleSide;
            _depthMaterial._noCutplanesMaterial.side = _depthMaterial.side;
        }

        //TODO: do we really need to update all these or just the depthMaterial?
        _depthMaterial.needsUpdate = true;
        _depthMaterial._noCutplanesMaterial.needsUpdate = true;
        _saoPass.material.needsUpdate = true;
        _saoBlurPass.material.needsUpdate = true;
        _saoMipFirstPass.material.needsUpdate = true;
        _saoMipPass.material.needsUpdate = true;
        _fxaaPass.material.needsUpdate = true;
        _celPass.material.needsUpdate = true;
        _blendPass.material.needsUpdate = true;
        _clearPass.material.needsUpdate = true;
        _copyPass.material.needsUpdate = true;

        //Also reallocate the render targets
        this.setSize(_w, _h);
    };

    this.setClearColors = function (colorTop, colorBot) {
        if (!colorBot) {
            _clearColor = colorTop.clone();
        }
        //If the gradient is trivial, we can use a simple clear instead.
        else if (colorTop.equals(colorBot) || _isWeakDevice) {
            _clearColor = new THREE.Color(
                0.5 * (colorTop.x + colorBot.x),
                0.5 * (colorTop.y + colorBot.y),
                0.5 * (colorTop.z + colorBot.z));
        } else {
            _clearColor = undefined;
        }

        if (!_clearColor) {
            _clearPass.uniforms.color1.value.copy(colorTop);
            _clearPass.uniforms.color2.value.copy(colorBot);
        }
    };


    this.setAOOptions = function (radius, intensity) {

        if (radius !== undefined) {
            _saoPass.uniforms[ 'radius' ].value = radius;
            //_saoPass.uniforms[ 'bias' ].value = radius * 1e-5;
            //stderr("ao radius " + _saoPass.uniforms[ 'radius' ].value);
        }
        if (intensity !== undefined) {
            _saoPass.uniforms[ 'intensity' ].value = intensity;
            //stderr("ao intensity" + _saoPass.uniforms[ 'intensity' ].value);
        }
        _saoBufferValid = false;
    };

    this.getAORadius = function () {
        return _saoPass.uniforms['radius'].value;
    };

    this.getAOIntensity = function() {
        return _saoPass.uniforms['intensity'].value;
    };

    this.setCubeMap = function(map) {
        _clearPass.material.envMap = map;
    };

    this.setEnvRotation = function(rotation) {
        _envRotation = rotation;
        _clearPass.material.envRotationSin = Math.sin(rotation);
        _clearPass.material.envRotationCos = Math.cos(rotation);
    };

    this.getEnvRotation = function() {
        return _envRotation;
    };

    this.setTonemapExposureBias = function (bias) {
        _exposureBias = bias;

        //_blendPass.uniforms['exposureBias'].value = Math.pow(2.0, bias);
    };

    this.getExposureBias = function () {
        return _exposureBias;
    };

    this.setTonemapMethod = function (value) {

        _tonemapMethod  = value;

        if (value === 0) {
        /*
            if (_settings.useHdrTarget) {
                //reallocate the render target if we are going from hdr to ldr
                _settings.useHdrTarget = false;
                this.setSize(_w, _h, true);
            }
            */
            _renderer.gammaInput = false;
        }
        else {
        /*
            if (!_settings.useHdrTarget) {
                //reallocate the render target if we are going from hdr to ldr
                _settings.useHdrTarget = true;
                this.setSize(_w, _h, true);
            }
        */
            //Tell the renderer to linearize all material colors
            _renderer.gammaInput = true;
        }


        // _blendPass.uniforms['toneMapMethod'].value = value;

    };

    this.getToneMapMethod = function () {
        return _tonemapMethod;
    };

    this.toggleTwoSided = function (isTwoSided) {

        //In case the viewer encounters two-sided materials
        //it will let us know, so that we can update
        //the override material used for the SAO G-buffer to also
        //render two sided.
        if (_settings.haveTwoSided != isTwoSided) {
            if (_depthMaterial) {
                _depthMaterial.side = isTwoSided ? THREE.DoubleSide : THREE.FrontSide;
                _depthMaterial.needsUpdate = true;
                _depthMaterial._noCutplanesMaterial.side = _depthMaterial.side;
                _depthMaterial._noCutplanesMaterial.needsUpdate = true;
            }
        }
        _settings.haveTwoSided = isTwoSided;
    };

    this.toggleCelShading = function (value) {

        _settings.sao = !value;
        _settings.toonShaded = value;
        _settings.idbuffer = value;

        this.initPostPipeline(_settings.sao, _settings.antialias);
    };

    this.toggleEnvMapBackground = function (value) {

        _settings.envMapBg = value;
        _clearPass.uniforms.envMapBackground.value = value;
    };

    this.enter2DMode = function(idMaterial) {
        _idMaterial = idMaterial;
        _oldSettings.sao = _settings.sao;
        _oldSettings.antialias = _settings.antialias;
        _oldSettings.idbuffer = _settings.idbuffer;
        _settings.idbuffer = true;
        _blendPass.material.defines.IS_2D = "";
        this.initPostPipeline(false, false);
    };

    this.exit2DMode = function() {
        _idMaterial = null;
        _settings.idbuffer = _oldSettings.idbuffer;
        delete _blendPass.material.defines.IS_2D;
        this.initPostPipeline(_oldSettings.sao, _oldSettings.antialias);
    };

    //Returns the value of the ID buffer at the given
    //viewport location. Note that the viewport location is in
    //OpenGL-style coordinates [-1, 1] range.
    this.idAtPixel = function (vpx, vpy) {
        if (!_idTarget)
            return 0;

        var px = 0 | ((vpx + 1.0) * 0.5 * _idTarget.width);
        var py = 0 | ((vpy + 1.0) * 0.5 * _idTarget.height);

        //stderr("x:" + px + " y:" + py);
        if (_lastIDValid && px === _lastX && py === _lastY)
            return _lastID;

        _renderer.readRenderTargetPixels(_idTarget, px, py, 1, 1, _readbackBuffer);

        var id =  (_readbackBuffer[2] << 16) | (_readbackBuffer[1] << 8) | _readbackBuffer[0];

        //sign extend the upper byte to get back negative numbers (since we clamp 32 bit to 24 bit when rendering ids)
        id = (id << 8) >> 8;

        _lastX = px;
        _lastY = py;
        _lastID = id;
        _lastIDValid = true;

        return id;
    };

    this.idAtPixels = function (vpx, vpy, res) {
        if (!_idTarget)
            return 0;

        var px = (vpx + 1.0) * 0.5 * _idTarget.width - (res - 1) * 0.5;
        var py = (vpy + 1.0) * 0.5 * _idTarget.height - (res - 1) * 0.5;

        var readbackBuffer = new Uint8Array(4 * res * res);

        _renderer.readRenderTargetPixels(_idTarget, px, py, res, res, readbackBuffer);

        var id;
        for (var i = 0; i < res * res; i++) {
            id = (readbackBuffer[4 * i + 2] << 16) | (readbackBuffer[4 * i + 1] << 8) | readbackBuffer[4 * i];

            //sign extend the upper byte to get back negative numbers (since we clamp 32 bit to 24 bit when rendering ids)
            id = (id << 8) >> 8;
            if (id >= 0) break;
        }

        return id;
    };

    this.readbackTargetId = function() {
        if (!_idTarget)
            return null;

        var readbackBuffer = new Uint8Array(4 * _idTarget.width * _idTarget.height);
        _renderer.readRenderTargetPixels(_idTarget, 0, 0, _idTarget.width, _idTarget.height, readbackBuffer);

        return {
            buffer: readbackBuffer,
            width: _idTarget.width,
            height: _idTarget.height
        };
    };

    this.rolloverObjectViewport = function (vpx, vpy, dbIds) {
        var objId = dbIds ? dbIds[0] : this.idAtPixel(vpx, vpy);
        return this.rolloverObjectId(objId, dbIds);
    };

    this.rolloverObjectId = function(objId, dbIds) {

        if (objId == _lastObjId)
            return false;
        //stderr(objId);

        _blendPass.uniforms['highlightIntensity'].value = 0;
        _blendPass.uniforms['objID'].value = objId;

        _lastObjTime = performance.now();
        _lastObjId = objId;

        // When dbIds is provided, highlight nodes in a range
        if (dbIds) {

            if (dbIds.length > 1)
                dbIds.shift();
            _blendPass.uniforms['highlightRange'].value = 1;
            _blendPass.uniforms['objIDStart'].value = dbIds[0];
            _blendPass.uniforms['objIDEnd'].value = dbIds[dbIds.length - 1];
        }
        else {

            _blendPass.uniforms['highlightRange'].value = 0;

            //Check if nothing was at that pixel -- 0 means object
            //that has no ID, ffffff (-1) means background, and both result
            //in no highlight.
            if (objId <= 0) {
                objId = 0;
            }

            _blendPass.uniforms['objIDv3'].value.set((objId & 0xFF) / 255,
                                                    ((objId >> 8) & 0xFF) / 255,
                                                    ((objId >> 16) & 0xFF) / 255);
        }

        return true;
    };

    this.setUnitScale = function(metersPerUnit) {
        _unitScale = metersPerUnit;
    };

    this.getUnitScale = function() {
        return _unitScale;
    };

    this.getBlendPass = function() {
        return _blendPass;
    };

    // TODO_NOP: hack expose colorTarget so shadow/reflection can draw into
    this.getColorTarget = function() {
        return _colorTarget;
    };

    // TODO_NOP: hack expose depthMaterial to register with matman for cutplanes
    this.getDepthMaterial = function() {
        return _depthMaterial;
    };
}

avp.RenderContext = RenderContext;

})();;/**
 * NVIDIA FXAA 3.11 by TIMOTHY LOTTES
 * "PC VERSION" Quality, ported to WebGL
 * https://gist.githubusercontent.com/bkaradzic/6011431/raw/92a3737404c0e764fa554077b16e07a46442da51/Fxaa3_11.h
 */

(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_FXAAShader = function(THREE) {

"use strict";

if (typeof avs.FXAAShader !== "undefined")
    return;

avs.FXAAShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"uResolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }
	},

	vertexShader: [

        "uniform vec2 uResolution;",
        "varying vec2 vPos;",
        "varying vec4 vPosPos;",

        "void main() {",
            "vPos = uv;",
            "vPosPos.xy = uv + vec2(-0.5, -0.5) * uResolution;",
            "vPosPos.zw = uv + vec2( 0.5,  0.5) * uResolution;",

            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}",

	].join("\n"),

	fragmentShader: [

        "#define FXAA_EDGE_SHARPNESS (8.0)",
        "#define FXAA_EDGE_THRESHOLD (0.125)",
        "#define FXAA_EDGE_THRESHOLD_MIN (0.05)",
        "#define FXAA_RCP_FRAME_OPT (0.50)",
        "#define FXAA_RCP_FRAME_OPT2 (2.0)",

        "uniform sampler2D tDiffuse;",
        "uniform highp vec2 uResolution;",
        "varying vec2 vPos;",
        "varying vec4 vPosPos;",

        "float FxaaLuma(vec3 rgb) {",
            "return dot(rgb, vec3(0.299, 0.587, 0.114));",
        "}",

        "void main() {",
            "float lumaNw = FxaaLuma(texture2D(tDiffuse, vPosPos.xy).rgb);",
            "float lumaSw = FxaaLuma(texture2D(tDiffuse, vPosPos.xw).rgb);",
            "float lumaNe = FxaaLuma(texture2D(tDiffuse, vPosPos.zy).rgb) + 1.0/384.0;",
            "float lumaSe = FxaaLuma(texture2D(tDiffuse, vPosPos.zw).rgb);",

            "vec3 rgbM = texture2D(tDiffuse, vPos.xy).rgb;",
            "float lumaM = FxaaLuma(rgbM.rgb);",

            "float lumaMax = max(max(lumaNe, lumaSe), max(lumaNw, lumaSw));",
            "float lumaMin = min(min(lumaNe, lumaSe), min(lumaNw, lumaSw));",

            "float lumaMaxSubMinM = max(lumaMax, lumaM) - min(lumaMin, lumaM);",
            "float lumaMaxScaledClamped = max(FXAA_EDGE_THRESHOLD_MIN, lumaMax * FXAA_EDGE_THRESHOLD);",
            "if (lumaMaxSubMinM < lumaMaxScaledClamped) {",
                "gl_FragColor = vec4(rgbM, 1.0);",
                "return;",
            "}",

            "float dirSwMinusNe = lumaSw - lumaNe;",
            "float dirSeMinusNw = lumaSe - lumaNw;",
            "vec2 dir1 = normalize(vec2(dirSwMinusNe + dirSeMinusNw, dirSwMinusNe - dirSeMinusNw));",
            "vec3 rgbN1 = texture2D(tDiffuse, vPos.xy - dir1 * FXAA_RCP_FRAME_OPT*uResolution).rgb;",
            "vec3 rgbP1 = texture2D(tDiffuse, vPos.xy + dir1 * FXAA_RCP_FRAME_OPT*uResolution).rgb;",

            "float dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * FXAA_EDGE_SHARPNESS;",
            "vec2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);",
            "vec3 rgbN2 = texture2D(tDiffuse, vPos.xy - dir2 * FXAA_RCP_FRAME_OPT2*uResolution).rgb;",
            "vec3 rgbP2 = texture2D(tDiffuse, vPos.xy + dir2 * FXAA_RCP_FRAME_OPT2*uResolution).rgb;",

            "vec3 rgbA = rgbN1 + rgbP1;",
            "vec3 rgbB = ((rgbN2 + rgbP2) * 0.25) + (rgbA * 0.25);",

            "float lumaB = FxaaLuma(rgbB);",
            "if ((lumaB < lumaMin) || (lumaB > lumaMax))",
                "gl_FragColor = vec4(rgbA * 0.5, 1.0);",
            "else",
                "gl_FragColor = vec4(rgbB, 1.0);",
        "}",

	].join("\n")

};

}

})();;
(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_ShaderChunks = function(THREE) {

"use strict";

avs.PackDepthShaderChunk = [
    //Packs a float in the range 0-1 to an RGBA8
    "vec4 packDepth( const in float depth ) {",
        "vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;",
        "enc = fract(enc);",
        "enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);",
        "return enc;",
    "}",

    //Used to unpack depth value when input depth texture is RGBA8
    "float unpackDepth( const in vec4 rgba_depth ) {",
        "return dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );",
    "}",
].join("\n");


avs.TonemapShaderChunk = [
    //post-gamma luminance
    "float luminance_post(vec3 rgb) {",
    "return dot(rgb, vec3(0.299, 0.587, 0.114));",
    "}",

    //pre-gamma luminance
    "float luminance_pre(vec3 rgb) {",
        "return dot(rgb, vec3(0.212671, 0.715160, 0.072169));",
    "}",


    "vec3 xyz2rgb(vec3 xyz) {",
        //XYZ -> RGB conversion matrix using HDTV constants
        "vec3 R = vec3( 3.240479, -1.537150, -0.498535);",
        "vec3 G = vec3(-0.969256,  1.875992,  0.041556);",
        "vec3 B = vec3( 0.055648, -0.204043,  1.057311);",

        "vec3 rgb;",
        "rgb.b = dot(xyz, B);",
        "rgb.g = dot(xyz, G);",
        "rgb.r = dot(xyz, R);",

        "return rgb;",
    "}",

    "vec3 rgb2xyz(vec3 rgb) {",
        //RGB -> XYZ conversion matrix using HDTV constants
        "vec3 X = vec3(0.412453, 0.35758, 0.180423);",
        "vec3 Y = vec3(0.212671, 0.71516, 0.0721688);",
        "vec3 Z = vec3(0.0193338, 0.119194, 0.950227);",

        "vec3 xyz;",
        "xyz.x = dot(rgb, X);",
        "xyz.y = dot(rgb, Y);",
        "xyz.z = dot(rgb, Z);",

        "return xyz;",
    "}",

    "vec3 xyz2xyY(vec3 xyz) {",
        "float sum = xyz.x + xyz.y + xyz.z;",

        //Note in case of division by 0, the hardware
        //should output zero for sum, so we are still ok with the result
        "sum = 1.0 / sum;",

        "vec3 xyY;",
        "xyY.z = xyz.y;",
        "xyY.x = xyz.x * sum;",
        "xyY.y = xyz.y * sum;",

        "return xyY;",
    "}",

    "vec3 xyY2xyz(vec3 xyY) {",

        "float x = xyY.x;",
        "float y = xyY.y;",
        "float Y = xyY.z;",

        "vec3 xyz;",
        "xyz.y = Y;",
        "xyz.x = x * (Y / y);",
        "xyz.z = (1.0 - x - y) * (Y / y);",

        "return xyz;",
    "}",



    //OGS/RaaS Cannon tonemappong with ColorPerserving enabled.
    "float toneMapCanon_T(float x)",
    "{",
        // this function fits the measured Canon sigmoid *without gamma correction* through 0.0
        "float xpow = pow(x, 1.60525727);",
        "float tmp = ((1.05542877*4.68037409)*xpow) / (4.68037409*xpow + 1.0);",
        "return clamp(tmp, 0.0, 1.0);",
    "}",


    "const float Shift = 1.0 / 0.18;",

    //Best fit of John Hable's generalized filmic function parameters to the Canon curve
    //This is a significantly better and cheaper to compute fit than the power and polynomial
    //least squares fits from OGS/RaaS (which have larger max and average error, and also go negative near
    //the origin).
    "float toneMapCanonFilmic_NoGamma(float x) {",

        //This extra exposure by 1.0/0.18 mimics what is also done in OGS's implementation
        //and the curve fit was done with this scale in mind.
        "x *= Shift;",

        "const float A = 0.2;", //shoulder strength
        "const float B = 0.34;", //linear strength
        "const float C = 0.002;", //linear angle
        "const float D = 1.68;", //toe strength
        "const float E = 0.0005;", //toe numerator
        "const float F = 0.252;", //toe denominator (E/F = toe angle)
        "const float scale = 1.0/0.833837;",

        "return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;",
    "}",


    //Same as above but with 2.2 gamma built into the fit and working on the
    //whole RGB triplet at once (i.e. non color preserving version).
    "vec3 toneMapCanonFilmic_WithGamma(vec3 x) {",

        //This extra exposure by 1.0/0.18 mimics what is also done in OGS's implementation
        //and the curve fit was done with this scale in mind.
        "x *= Shift;",

        //Best overall error params
/*
        "const float A = 0.2;",
        "const float B = 0.23;",
        "const float C = 0.147;",
        "const float D = 0.26;",
        //"const float E = 0.0;",
        "const float F = 0.22;",
        "const float scale = 1.0/0.900202;",
*/

        //Best max deviation params
        "const float A = 0.27;",
        "const float B = 0.29;",
        "const float C = 0.052;",
        "const float D = 0.2;",
        //"const float E = 0.0;",
        "const float F = 0.18;",
        "const float scale = 1.0/0.897105;",

        "return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;",
    "}",


    "vec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {",
        "vec3 outColor = x.rgb;",
        "outColor = min(outColor, vec3(3.0));",
        "float inLum = luminance_pre(outColor);",
        "if (inLum > 0.0) {",
            "float outLum = toneMapCanon_T(inLum);",
            "outColor = outColor * (outLum / inLum);",
            "outColor = clamp(outColor, vec3(0.0), vec3(1.0));",
        "}",
        "float gamma = 1.0/2.2;",
        "outColor = pow(outColor, vec3(gamma));",
        "return outColor;",
    "}"

].join("\n");


avs.OrderedDitheringShaderChunk = [
    "vec3 orderedDithering(vec3 col) {",
        //Matrix for 4x4 ordered dithering. (http://en.wikipedia.org/wiki/Ordered_dithering)
        "const vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);",
        "const vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);",
        "const vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);",
        "const vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);",

        //No integer & in WebGL, otherwise we would do &3...
        "int i = int(mod(float(gl_FragCoord.x), 4.0));",
        "int j = int(mod(float(gl_FragCoord.y), 4.0));",

        //Ideally we would index i*4+j into an array of 16 floats, but WebGL doesn't allow
        //access with non-constant index. Using a texture for a 4x4 seems like overkill.
        "vec4 biasRow;",
        "if      (i==0) biasRow = m0;",
        "else if (i==1) biasRow = m1;",
        "else if (i==2) biasRow = m2;",
        "else           biasRow = m3;",
        "float bias;",
        "if      (j==0) bias = biasRow.x;",
        "else if (j==1) bias = biasRow.y;",
        "else if (j==2) bias = biasRow.z;",
        "else           bias = biasRow.w;",

        "return col + bias / 17.0 / 256.0;",
    "}",
].join("\n");


avs.CutPlanesUniforms = {
    "cutplanes": { type: "v4v", value: [] },
    "hatchParams": { type: "v2", value: new THREE.Vector2(1.0, 10.0) },
    "hatchTintColor": { type: "c", value: new THREE.Color( 0xFFFFFF ) },
    "hatchTintIntensity": { type: "f", value: 1.0 },
};

// requires vWorldPosition
avs.CutPlanesShaderChunk = [
    "#if NUM_CUTPLANES > 0",
        "uniform vec4 cutplanes[NUM_CUTPLANES];",

        "void checkCutPlanes(vec3 worldPosition) {",
            "for (int i=0; i<NUM_CUTPLANES; i++) {",
                // test if point is outside of cutting plane; if so, discard fragment
                "if (dot(vec4(worldPosition, 1.0), cutplanes[i]) > 0.0) {",
                    "discard;",
				"}",
            "}",
        "}",
    "#endif",
].join("\n");


avs.PackNormalsShaderChunk = [

//See http://aras-p.info/texts/CompactNormalStorage.html
//Currently using the slow and simple approach of mapping 3d normal to two spherical coords.
//TODO try other, cheaper ways to encode the normal.

"#define kPI 3.14159265358979",
"vec2 encodeNormal (vec3 n)",
"{",
    "return (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;",
"}",

"vec3 decodeNormal (vec2 enc)",
"{",
    "vec2 ang = enc * 2.0 - 1.0;",
    "vec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));",
    //"sincos(ang.x * kPI, scth.x, scth.y);",
    "vec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);",
    "return vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);",
"}",

].join("\n");

avs.HatchPatternShaderChunk = [

"#ifdef HATCH_PATTERN",
"uniform vec2 hatchParams;",
"uniform vec3 hatchTintColor;",
"uniform float hatchTintIntensity;",

//Gaussian falloff function
"float curveGaussian(float r, float invWidth) {",
    "float amt = clamp(r * invWidth, 0.0, 1.0);",
    "float exponent = amt * 3.5;",
    "return exp(-exponent*exponent);",
"}",

"vec4 calculateHatchPattern(vec2 hatchParams, vec2 coord, vec4 fragColor, vec3 hatchTintColor, float hatchTintIntensity ) {",
    "float hatchSlope = hatchParams.x;",
    "float hatchPeriod = hatchParams.y;",
    "if (abs(hatchSlope) <= 1.0) {",
        "float hatchPhase = coord.y - hatchSlope * coord.x;",
        "float dist = abs(mod((hatchPhase), (hatchPeriod)));",
        "if (dist < 1.0) {",
            "fragColor = vec4(0.0,0.0,0.0,1.0);",
        "} else {",
            "fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);",
        "}",
    "} else {",
        "float hatchPhase = - coord.y / hatchSlope + coord.x;",
        "float dist = abs(mod((hatchPhase), (hatchPeriod)));",
        "if (dist < 1.0) {",
            "fragColor = vec4(0.0,0.0,0.0,1.0);",
        "} else {",
            "fragColor.xyz = mix(fragColor.xyz, hatchTintColor, hatchTintIntensity);",
        "}",
    "}",
    "return fragColor;",
"}",

"#endif",

].join("\n");

avs.EnvSamplingShaderChunk = [
// Precomputed sin/cos of the environment rotation
"uniform float envRotationSin;",
"uniform float envRotationCos;",
"vec3 adjustLookupVector(in vec3 lookup) {",
    "return vec3(",
        "envRotationCos * lookup.x - envRotationSin * lookup.z,",
        "lookup.y,",
        "envRotationSin * lookup.x + envRotationCos * lookup.z);",
"}"
].join("\n");


avs.IdUniforms = {
    "dbId" : { type: "v4", value : new THREE.Vector4(0,0,0,0) }
};

avs.IdOutputShaderChunk = [

    "#ifdef MRT_ID_BUFFER",
        //When using MRT, we have to set the alpha channel to 1
        //in order to override alpha blending (which cannot be individually controlled per target
        //and we need it for the color target)
        "#ifdef MRT_NORMALS",
            "const int index = 2;",
        "#else",
            "const int index = 1;",
        "#endif",
            "gl_FragData[index] = vec4(dbId.rgb, 1.0);",
    "#elif defined(ID_COLOR)",
        //here we assume that in case we are only rendering
        //to an ID target, blending is off, so we can use
        //the alpha channel as well (which is usually 0 for IDs and will cause the pixels to be discarded).
        "gl_FragColor = dbId;",
    "#endif"

].join("\n");


avs.FinalOutputShaderChunk = [

    "#ifdef HATCH_PATTERN",
        "gl_FragColor = calculateHatchPattern(hatchParams, gl_FragCoord.xy, gl_FragColor, hatchTintColor, hatchTintIntensity);",
    "#endif",

    "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)",
        "gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;",
    "#endif",

    "#ifdef MRT_NORMALS",
        //We cannot avoid blending in the depth target when blending
        //to the color target is on, so
        //we pack the normal and depth in the first three elements
        //and use 0 or 1 as the alpha.
        //NOTE: Dropping the Z coordinate of the normal entirely means
        //that we lose information about its sign (we use sqrt to restore it later).
        //This is OK in this case because in view space surfaces that we see will have
        //positive Z component in all cases. If that changes we have to also
        //encode the sign bit in the x or y.
        "gl_FragData[1] = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);",
    "#endif",

    avs.IdOutputShaderChunk

].join("\n");

}

})();;(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_CopyShader = function(THREE) {

"use strict";

if (typeof avs.CopyShader !== "undefined")
    return;

//Trivial copy pass
avs.CopyShader = {

    uniforms: {
        "tDiffuse": { type: "t", value: null }
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "vUv = uv;",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform sampler2D tDiffuse;",

        "varying vec2 vUv;",

        "void main() {",

            "gl_FragColor = texture2D(tDiffuse, vUv);",

        "}"

    ].join("\n")

};

}

})();;(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_CelShader = function(THREE) {

"use strict";

if (typeof avs.CelShader !== "undefined")
    return;

avs.CelShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"tDepth":   { type: "t", value: null },
		"tID": { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  },
        "cameraNear":   { type: "f", value: 1 },
        "cameraFar":    { type: "f", value: 100 },
        "projInfo":     { type: "v4", value: new THREE.Vector4(0,0,0,0) },
        "isOrtho" :     { type: "f", value: 1.0 }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [
	
	    "#extension GL_OES_standard_derivatives : enable",

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDepth;",
		"uniform sampler2D tID;",
		"uniform vec2 resolution;",
		"uniform float cameraNear;",
		"uniform float cameraFar;",


        "uniform float isOrtho;",
        "uniform vec4 projInfo;",

		"varying vec2 vUv;",

        "vec4 recoverNZ(vec4 nrmz) {",
            "float z = sqrt(1.0 - dot(nrmz.xy, nrmz.xy));",
            "nrmz.w = -(nrmz.z +cameraNear) / (cameraFar - cameraNear);",
            "nrmz.z = z;",
            "return nrmz;",
        "}",
        
        avs.TonemapShaderChunk,
        
        "vec4 quantize(vec4 c) {",
            "c *= c;",
            //"float L = luminance_pre(c.xyz);",
            "float L = max(c.x, max(c.y, c.z));",
            "c.xyz *= floor(L * 8.0 + 0.5) / (8.0 * L);",
            "c.w = 1.0;",
            "return sqrt(c);",
        "}",

        "vec4 quantizeRGB(vec4 c) {",
            "c *= c;",
            "c.xyz *= floor(c.xyz * 8.0 + 0.5) / 8.0;",
            "c.w = 1.0;",
            "return sqrt(c);",
        "}",

        "vec3 reconstructCSPosition(vec2 S, float z) {",
            "return vec3((S.xy * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);",
        "}",

        /** Reconstructs screen-space unit normal from screen-space position */
        "vec3 reconstructCSFaceNormal(vec3 C) {",
            "return normalize(cross(dFdy(C), dFdx(C)));",
        "}",
        
        "vec3 getPosition(ivec2 ssP, float depth) {",
            "vec3 P;",

            // Offset to pixel center
            "P = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);",
            "return P;",
        "}",
        
        "int isObjectEdge() {",

            "vec4 MM = texture2D(tID, vUv + vec2( 0.0,  0.0));",

            "vec4 LL = texture2D(tID, vUv + vec2(-1.0, -1.0) * resolution);",
            "if (MM != LL) return 1;",

            "vec4 LM = texture2D(tID, vUv + vec2( 0.0, -1.0) * resolution);",
            "if (MM != LM) return 1;",

            "vec4 LR = texture2D(tID, vUv + vec2( 1.0, -1.0) * resolution);",
            "if (MM != LR) return 1;",

            "vec4 ML = texture2D(tID, vUv + vec2(-1.0,  0.0) * resolution);",
            "if (MM != ML) return 1;",

            "vec4 MR = texture2D(tID, vUv + vec2( 1.0,  0.0) * resolution);",
            "if (MM != MR) return 1;",
            
            "vec4 UL = texture2D(tID, vUv + vec2(-1.0,  1.0) * resolution);",
            "if (MM != UL) return 1;",

            "vec4 UM = texture2D(tID, vUv + vec2( 0.0,  1.0) * resolution);",
            "if (MM != UM) return 1;",

            "vec4 UR = texture2D(tID, vUv + vec2( 1.0,  1.0) * resolution);",
            "if (MM != UR) return 1;",
            
            "return 0;",
            
        "}",
        
        "float normalDiff(vec3 n1, vec3 n2) {",
            "float d = dot(n1.xyz, n2.xyz);",
            "return acos(clamp(d, -1.0, 1.0));",
        "}",
        
        "const float r = 1.0;",

        "void main() {",

            "vec4 color = texture2D(tDiffuse, vUv);",

            "ivec2 ssC = ivec2(gl_FragCoord.xy);",

            "if (isObjectEdge() == 1) {",
                "gl_FragColor = vec4(0,0,0,1);",
                "return;",
            "}",

            /*
            "else {",
                "gl_FragColor = vec4(1,1,1,1);",
                "return;",
            "}",

*/
            "vec4 MM = texture2D(tDepth, vUv + vec2( 0.0,  0.0));",

            //Check if it's a background pixel -- there are no edges then.
            //Note that silhouette edges are caught by the earlier check for isObjectEdge.
            "if (MM.z == 0.0) {",
                "gl_FragColor = quantize(color);",
                "return;",
            "}",

            "vec4 LL = texture2D(tDepth, vUv + vec2(-r, -r) * resolution);",
            "vec4 LM = texture2D(tDepth, vUv + vec2( 0.0, -r) * resolution);",
            "vec4 LR = texture2D(tDepth, vUv + vec2( r, -r) * resolution);",

            "vec4 ML = texture2D(tDepth, vUv + vec2(-r,  0.0) * resolution);",
            "vec4 MR = texture2D(tDepth, vUv + vec2( r,  0.0) * resolution);",
            
            "vec4 UL = texture2D(tDepth, vUv + vec2(-r, r) * resolution);",
            "vec4 UM = texture2D(tDepth, vUv + vec2( 0.0,  r) * resolution);",
            "vec4 UR = texture2D(tDepth, vUv + vec2( r,  r) * resolution);",

            "vec3 C = getPosition(ssC + ivec2(-1, -1), LL.z);",
            "vec3 LLz = reconstructCSFaceNormal(C);",
            "C = getPosition(ssC + ivec2( 0, -1), LM.z);",
            "vec3 LMz = reconstructCSFaceNormal(C);",
            "C = getPosition(ssC + ivec2( 1, -1), LR.z);",
            "vec3 LRz = reconstructCSFaceNormal(C);",

            "C = getPosition(ssC + ivec2(-1, 0), ML.z);",
            "vec3 MLz = reconstructCSFaceNormal(C);",
            "C = getPosition(ssC + ivec2( 0, 0), MM.z);",
            "vec3 MMz = reconstructCSFaceNormal(C);",
            "C = getPosition(ssC + ivec2( 1, 0), MR.z);",
            "vec3 MRz = reconstructCSFaceNormal(C);",

            "C = getPosition(ssC + ivec2(-1, 1), UL.z);",
            "vec3 ULz = reconstructCSFaceNormal(C);",
            "C = getPosition(ssC + ivec2(0, 1), UM.z);",
            "vec3 UMz = reconstructCSFaceNormal(C);",
            "C = getPosition(ssC + ivec2(1, 1), UR.z);",
            "vec3 URz = reconstructCSFaceNormal(C);",


            "LL = recoverNZ(LL);",
            "LM = recoverNZ(LM);",
            "LR = recoverNZ(LR);",

            "ML = recoverNZ(ML);",
            "MM = recoverNZ(MM);",
            "MR = recoverNZ(MR);",
            
            "UL = recoverNZ(UL);",
            "UM = recoverNZ(UM);",
            "UR = recoverNZ(UR);",

            //Angles between the center and surrounding normals 
            "float pLL = normalDiff(LL.xyz, MM.xyz);",
            "float pLM = normalDiff(LM.xyz, MM.xyz);",
            "float pLR = normalDiff(LR.xyz, MM.xyz);",

            "float pML = normalDiff(ML.xyz, MM.xyz);",
            "float pMM = normalDiff(MM.xyz, MM.xyz);",
            "float pMR = normalDiff(MR.xyz, MM.xyz);",

            "float pUL = normalDiff(UL.xyz, MM.xyz);",
            "float pUM = normalDiff(UM.xyz, MM.xyz);",
            "float pUR = normalDiff(UR.xyz, MM.xyz);",
        
            //Angles between the center and surrounding normals, where normals
            //are computed from depth buffer and projection matrix.

            "float pLLz = normalDiff(LLz.xyz, MMz.xyz);",
            "float pLMz = normalDiff(LMz.xyz, MMz.xyz);",
            "float pLRz = normalDiff(LRz.xyz, MMz.xyz);",

            "float pMLz = normalDiff(MLz.xyz, MMz.xyz);",
            "float pMMz = normalDiff(MMz.xyz, MMz.xyz);",
            "float pMRz = normalDiff(MRz.xyz, MMz.xyz);",

            "float pULz = normalDiff(ULz.xyz, MMz.xyz);",
            "float pUMz = normalDiff(UMz.xyz, MMz.xyz);",
            "float pURz = normalDiff(URz.xyz, MMz.xyz);",

            //Sobel
            //"vec4 G = (UL + 2.0 * UM + UR) - (LL + 2.0 * LM + LR) + (UR + 2.0 * MR - LR) - (UL + 2.0 * ML - LL);",
            //"float Gn = (pUL + 2.0 * pUM + pUR) - (pLL + 2.0 * pLM + pLR) + (pUR + 2.0 * pMR - pLR) - (pUL + 2.0 * pML - pLL);",
            //"float Gnz = (pULz + 2.0 * pUMz + pURz) - (pLLz + 2.0 * pLMz + pLRz) + (pURz + 2.0 * pMRz - pLRz) - (pULz + 2.0 * pMLz - pLLz);",
            "float dGx = (dFdx(UL.w) + 2.0 * dFdx(UM.w) + dFdx(UR.w)) - (dFdx(LL.w) + 2.0 * dFdx(LM.w) + dFdx(LR.w)) + (dFdx(UR.w) + 2.0 * dFdx(MR.w) - dFdx(LR.w)) - (dFdx(UL.w) + 2.0 * dFdx(ML.w) - dFdx(LL.w));",
            "float dGy = (dFdy(UL.w) + 2.0 * dFdy(UM.w) + dFdy(UR.w)) - (dFdy(LL.w) + 2.0 * dFdy(LM.w) + dFdy(LR.w)) + (dFdy(UR.w) + 2.0 * dFdy(MR.w) - dFdy(LR.w)) - (dFdy(UL.w) + 2.0 * dFdy(ML.w) - dFdy(LL.w));",
                
            //Filter given in Decaudin's 1996 paper
            "float Gn = (abs(pUL - pMM) + 2.0 * abs(pUM - pMM) + abs(pUR - pMM) + 2.0 * abs(pML - pMM) + 2.0 * abs(pMR - pMM) + abs(pLL - pMM) + 2.0 * abs(pLM - pMM) + abs(pLR - pMM));",
            "float Gnz = (abs(pULz - pMMz) + 2.0 * abs(pUMz - pMMz) + abs(pURz - pMMz) + 2.0 * abs(pMLz - pMMz) + 2.0 * abs(pMRz - pMMz) + abs(pLLz - pMMz) + 2.0 * abs(pLMz - pMMz) + abs(pLRz - pMMz));",
            "float G = (abs(UL.w - MM.w) + 2.0 * abs(UM.w - MM.w) + abs(UR.w - MM.w) + 2.0 * abs(ML.w - MM.w) + 2.0 * abs(MR.w - MM.w) + abs(LL.w - MM.w) + 2.0 * abs(LM.w - MM.w) + abs(LR.w - MM.w));",
        
            "float dd = abs(dFdx(G)) + abs(dFdy(G));",
            //"float dd = abs(dGx) + abs(dGy);",

            "if (dd > 0.004 || abs(Gnz) > 2.2 || abs(Gn) > 2.0)",
                 "gl_FragColor = vec4(0.0,0.0,0.0,1.0);",
            "else",
                "gl_FragColor = /*vec4(1.0,1.0,1.0,1.0);*/quantize(color);",

		"}"

	].join("\n")

};

}

})();;(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_BlendShader = function(THREE) {

"use strict";

if (typeof avs.BlendShader !== "undefined")
    return;

//Shader that composes a final frame from the color target, SSAO target and overlays target.
avs.BlendShader = {

    uniforms: {
        "tDiffuse": { type: "t", value: null }, //Color buffer containing the rendered 3d model

        "tAO": {type: "t", value:null }, //Ambient occlusion + depth buffer
        "useAO": {type: "i", value: 0 }, //Whether to blend in the AO buffer

        "tOverlay" : { type: "t", value: null}, //The selection/overlays buffer
        "useOverlay" : { type: "i", value:0 }, //Whether to blend in the overlays

        "tID" : { type: "t", value: null }, //The ID buffer
        "objID" : {type : "i", value: 0 }, //The currently highlighted object ID (0 means no highlight)
        "objIDv3" : {type : "v3", value: new THREE.Vector3(0,0,0) }, //The currently highlighted object ID as RGB triplet
        "highlightIntensity" : { type : "f", value: 1.0 },

        "resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }, // 1/size

        //Enable these if the forward pass renders in HDR-linear target and the Blend shader is doing the tone mapping
        //"exposureBias" : { type:"f", value: 1.0 },
        //"toneMapMethod" : { type:"i", value: 0 }

        "highlightRange" : { type: "i", value: 0 },
        "objIDStart" : { type: "i", value: 0 },
        "objIDEnd" : { type: "i", value: 0 }
    },


    defines: {
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

            "vUv = uv;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform sampler2D tDiffuse;",
        "uniform sampler2D tAO;",
        "uniform int useAO;",
        "uniform sampler2D tOverlay;",
        "uniform int useOverlay;",
        "uniform vec2 resolution;",
        //"uniform float exposureBias;",
        //"uniform int toneMapMethod;",
        "uniform int objID;",
        "uniform vec3 objIDv3;",
        "uniform sampler2D tID;",
        "uniform float highlightIntensity;",

        "uniform int highlightRange;",
        "uniform int objIDStart;",
        "uniform int objIDEnd;",

        "varying vec2 vUv;",

        avs.TonemapShaderChunk,

        // search 3x3 neighbors
        // the current pixel is outline if
        // (is selection && has empty neighbor) || (pixel is empty && has selection neighbor)
        "vec4 overlayEdgeDetect(vec2 vUv) {",
            "#define IS_SELECTION(C) ( (C).b > (C).r && (C).b > (C).g )",   // our color key
            "#define CHECK_EDGE_ALPHA(I, J)     { vec4 c = texture2D( tOverlay, vUv+resolution*vec2((I),(J)) ); maxAlpha = max(maxAlpha, c.a); if (c.a > 0.0 && IS_SELECTION(c)) { hasEdge++; selectionPixel = c; } }",
            "#define CHECK_EDGE_SELECTION(I, J) { vec4 c = texture2D( tOverlay, vUv+resolution*vec2((I),(J)) ); maxAlpha = max(maxAlpha, c.a); if (c.a <= 0.0) hasEdge++; }",

            "int hasEdge = 0;",
            "vec4 center = texture2D(tOverlay, vUv);",
            "vec4 selectionPixel = vec4(0.0);",
            "float maxAlpha = 0.0;",
            "bool paintOutline = false;",

            "if (center.a <= 0.0) {",           // if empty pixel, hasEdge counts selection pixels
                "CHECK_EDGE_ALPHA(-1.0,-1.0);",
                "CHECK_EDGE_ALPHA( 0.0,-1.0);",
                "CHECK_EDGE_ALPHA( 1.0,-1.0);",
                "CHECK_EDGE_ALPHA(-1.0, 0.0);",
                "CHECK_EDGE_ALPHA( 1.0, 0.0);",
                "CHECK_EDGE_ALPHA(-1.0, 1.0);",
                "CHECK_EDGE_ALPHA( 0.0, 1.0);",
                "CHECK_EDGE_ALPHA( 1.0, 1.0);",
                "if (hasEdge != 0) {",              // if has selection neighbors
                    "center = selectionPixel;",
                    "paintOutline = true;",
                "}",
            "}",
            "else if (center.a > 0.0 && IS_SELECTION(center)) {",  // if selection pixel, hasEdge counts alpha pixels
                "CHECK_EDGE_SELECTION(-1.0,-1.0);",
                "CHECK_EDGE_SELECTION( 0.0,-1.0);",
                "CHECK_EDGE_SELECTION( 1.0,-1.0);",
                "CHECK_EDGE_SELECTION(-1.0, 0.0);",
                "CHECK_EDGE_SELECTION( 1.0, 0.0);",
                "CHECK_EDGE_SELECTION(-1.0, 1.0);",
                "CHECK_EDGE_SELECTION( 0.0, 1.0);",
                "CHECK_EDGE_SELECTION( 1.0, 1.0);",
                "if (hasEdge != 0)",                // if has empty neighbors
                    "paintOutline = true;",
                "else",
                    "center.a = -center.a;",        // special flag marking inside pixel
            "}",

            // calculate outline color
            "if (paintOutline) {",
                "float maxComponent = max(center.r, max(center.g, center.b));",
                "center.rgb /= maxComponent;",
                "center.rgb = sqrt(center.rgb);",
                "center.a = 0.5 + 0.5 * maxAlpha * 0.125 * float(hasEdge);",
            "}",

            "return center;",
        "}",

        "vec4 sampleColor() {",
            "return texture2D( tDiffuse, vUv );",
        "}",

        "float sampleAO() {",
            "return (useAO != 0) ? texture2D(tAO, vUv).r : 1.0;",
        "}",

        "void main() {",

            "vec4 texel = sampleColor();",

//Tone mapping is currently done by the main forward pass, in order to fit the
//output into an RGBA8 render target. It's mathematically wrong to apply the
//ambient obscurance in gamma space, but the performance savings of not using RGBA32 target
//are significant.
            "texel.rgb *= sampleAO();",//sqrt for gamma correct the AO -- TODO: play with this to see if we get better results
/*
            "texel.rgb *= ao;",

            //Apply tone mapping
            "if (toneMapMethod == 1) {",
                "vec3 rgb = texel.rgb * exposureBias;",
                "texel.rgb = toneMapCanonFilmic_WithGamma(rgb);",
            "} else if (toneMapMethod == 2) {",
                "vec3 rgb = texel.rgb * exposureBias;",
                "float lum = luminance_pre(rgb);",
                "float lum2 = toneMapCanonFilmic_NoGamma(lum);",
                "rgb *= lum2 / lum;",
                "texel.rgb = rgb;",
                "texel.rgb = pow(texel.rgb, vec3(1.0/2.2));", //apply gamma, since this tone mapper is done in linear space
            "}",
*/
            //composite in the overlays texture
            "if (useOverlay != 0) {",
                "vec4 overlay = overlayEdgeDetect(vUv);",
                // Negative alpha signals the inside overlay condition, as above.
                "if (overlay.a < 0.0) {",
                    "overlay.a = -overlay.a;",

                    "if (overlay.a >= 0.99) {",
                        //Blend the overlay color with the luminance of the underlying
                        //pixel so that we do not lose detail from any underlying texture map
                        "overlay.a = 0.75;",
                        "texel.rgb = vec3(luminance_post(texel.rgb));",
                    "}",
                "}",

                "texel.rgb = mix(texel.rgb, sqrt(overlay.rgb)/*sqrt=gamma*/, overlay.a);",
            "}",

            "if (highlightRange == 0) {",
                "if (objID != 0) {",

                    "vec4 idAtPixel = texture2D(tID, vUv);",

                    "vec3 idDelta = abs(idAtPixel.rgb - objIDv3.rgb);",
                    "if (max(max(idDelta.r, idDelta.g), idDelta.b) < 1e-3) {",
                        "#ifdef IS_2D",
                        "texel.rgb = mix(texel.rgb, vec3(1.0,1.0,0.0), highlightIntensity * 0.25);",
                        "#else",
                        "texel.rgb += highlightIntensity * 0.2;",
                        "#endif",
                    "}",

                "}",
            "} else {",
                "vec4 idAtPixel = texture2D(tID, vUv);",
                "int dbId = int(idAtPixel.r * 255.0 + idAtPixel.g * 255.0 * 256.0 + idAtPixel.b * 255.0 * 256.0 * 256.0);",
                "if (dbId >= objIDStart && dbId <= objIDEnd) {",
                    "#ifdef IS_2D",
                    "texel.rgb = mix(texel.rgb, vec3(1.0,1.0,0.0), highlightIntensity * 0.25);",
                    "#else",
                    "texel.rgb += highlightIntensity * 0.2;",
                    "#endif",
                "}",
            "}",

            "gl_FragColor = texel;",
        "}"

    ].join("\n")

};

}

})();;/**
 * @author alteredq / http://alteredqualia.com/
 * @author stanevt
 */

(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

var LmvShaderPass = function ( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader,
		defines: THREE.UniformsUtils.clone(shader.defines)
	} );

	this.renderToScreen = false;

	this.enabled = true;
	this.clear = false;

    this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

    //this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), this.material );

    //Instead of using a screen quad we use a large triangle -- this is slightly
    //faster (~6% measured in our specific case), due to better cache coherency. See this article:
    //http://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/
    var triangle = new THREE.BufferGeometry();
    var p = new Float32Array(9);
    p[0] = -1; p[1] = -1; p[2] = 0;
    p[3] = 3; p[4] = -1; p[5] = 0;
    p[6] = -1; p[7] = 3; p[8] = 0;

    var uv = new Float32Array(6);
    uv[0] = 0; uv[1] = 0;
    uv[2] = 2; uv[3] = 0;
    uv[4] = 0; uv[5] = 2;
    
    var n = new Float32Array(9);
    n[0] = 0; n[1] = 0; n[2] = 1;
    n[3] = 0; n[4] = 0; n[5] = 1;
    n[6] = 0; n[7] = 0; n[8] = 1;
    

    triangle.addAttribute("position", new THREE.BufferAttribute(p, 3));
    triangle.addAttribute("normal", new THREE.BufferAttribute(n, 3));
    triangle.addAttribute("uv", new THREE.BufferAttribute(uv, 2));

    this.quad = new THREE.Mesh( triangle, this.material );


    this.scene = new THREE.Scene();
    this.scene.add( this.quad );
};

LmvShaderPass.prototype = {

    // note: delta is not used
	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer;

		}

		if ( this.renderToScreen || !writeBuffer ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

};

avs.LmvShaderPass = LmvShaderPass;

})();;(function() {

"use strict";

var av = Autodesk.Viewing,
    avs = av.Shaders;

/* Scalable Ambient Obscurance implementation based on: {http://graphics.cs.williams.edu/papers/SAOHPG12/} */

avs.init_SAOShader = function(THREE) {

if (typeof avs.SAOShader !== "undefined")
    return;

avs.SAOShader = {

    uniforms: {

        "tDepth":       { type: "t", value: null },
        "size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
        "resolution":   { type: "v2", value: new THREE.Vector2( 1/512, 1/512) },
        "cameraNear":   { type: "f", value: 1 },
        "cameraFar":    { type: "f", value: 100 },
        "radius":       { type: "f", value: 10.0 },
        "bias":         { type: "f", value: 0.01 },
        "projScale":    { type: "f", value: 500 },
        //"clipInfo":     { type: "v3", value: new THREE.Vector3(100, 99, -100) }, /* zf*zn, zn-zf, zf */
        "projInfo":     { type: "v4", value: new THREE.Vector4(0,0,0,0) },
        "intensity":    { type: "f", value: 0.5 },
        "isOrtho" :     { type: "f", value: 1.0 },

        "tDepth_mip1":       { type: "t", value: null },
        "tDepth_mip2":       { type: "t", value: null },
        "tDepth_mip3":       { type: "t", value: null },
        "tDepth_mip4":       { type: "t", value: null },
        "tDepth_mip5":       { type: "t", value: null }
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

        "vUv = uv;",

        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [
        "#define USE_MIPMAP 1",

        "uniform float cameraNear;",
        "uniform float cameraFar;",


        "uniform vec2 size;",        // texture width, height
        "uniform vec2 resolution;", //inverse of texture width, height

        "uniform float lumInfluence;",  // how much luminance affects occlusion

        "varying vec2 vUv;",

        // Total number of direct samples to take at each pixel
        "#define NUM_SAMPLES (17)",

        // If using depth mip levels, the log of the maximum pixel offset before we need to switch to a lower
        // miplevel to maintain reasonable spatial locality in the cache
        // If this number is too small (< 3), too many taps will land in the same pixel, and we'll get bad variance that manifests as flashing.
        // If it is too high (> 5), we'll get bad performance because we're not using the MIP levels effectively
        "#define LOG_MAX_OFFSET (3)",

        // This must be less than or equal to the MAX_MIP_LEVEL defined in SSAO.cpp
        "#define MAX_MIP_LEVEL (5)",

        // This is the number of turns around the circle that the spiral pattern makes.  This should be prime to prevent
        // taps from lining up.  This particular choice (7) was tuned for NUM_SAMPLES == 9
        "#define NUM_SPIRAL_TURNS (7)",

        //////////////////////////////////////////////////

        /** The height in pixels of a 1m object if viewed from 1m away.
         You can compute it from your projection matrix.  The actual value is just
         a scale factor on radius; you can simply hardcode this to a constant (~500)
         and make your radius value unitless (...but resolution dependent.)  */
        "uniform float           projScale;",

        /** Negative, "linear" values in world-space units */
        "uniform sampler2D tDepth;",

        //The mip levels of the depth -- with WebGL
        //we can't sample specific mips, so we have to
        //declare them explicitly
        "#ifdef USE_MIPMAP",
        "uniform sampler2D tDepth_mip1;",
        "uniform sampler2D tDepth_mip2;",
        "uniform sampler2D tDepth_mip3;",
        "uniform sampler2D tDepth_mip4;",
        "uniform sampler2D tDepth_mip5;",
        "#endif",

        /** World-space AO radius in scene units (r).  e.g., 1.0m */
        "uniform float radius;",

        /** Bias to avoid AO in smooth corners, e.g., 0.01m */
        "uniform float bias;",

        "uniform float intensity;",

        "uniform float isOrtho;",

        /** intensity / radius^6 */
        //"uniform float intensityDivR6;",
        //"float intensityDivR6 = intensity / pow(radius, 6.0);",

        /** Returns a unit vector and a screen-space radius for the tap on a unit disk (the caller should scale by the actual disk radius) */
        "vec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){",
            // Radius relative to ssR
            "float alpha = float(float(sampleNumber) + 0.5) * (1.0 / float(NUM_SAMPLES));",
            "float angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;",

            "ssR = alpha;",
            "return vec2(cos(angle), sin(angle));",
        "}",


        /** Used for packing Z into the GB channels */
        "float CSZToKey(float z) {",
            "return clamp(z * (1.0 / -cameraFar), 0.0, 1.0);",
        "}",


        /** Used for packing Z into the GB channels */
        "void packKey(float key, out vec2 p) {",
            // Round to the nearest 1/256.0
            "float temp = floor(key * 256.0);",

            // Integer part
            "p.x = temp * (1.0 / 256.0);",

            // Fractional part
            "p.y = key * 256.0 - temp;",
        "}",

        avs.PackDepthShaderChunk,

        //Used to unpack depth value when input depth texture is RGBA8
        "float unpackDepthNearFar( const in vec4 rgba_depth ) {",
            "float depth = unpackDepth( rgba_depth );",
            "if (depth == 0.0)",
                "return -cameraFar * 1.0e10;",
            "return depth * (cameraNear - cameraFar) - cameraNear;",
        "}",

        /*
         Clipping plane constants for use by reconstructZ

         clipInfo = (z_f == -inf()) ? Vector3(z_n, -1.0f, 1.0f) : Vector3(z_n * z_f,  z_n - z_f,  z_f);
         */
        //"uniform vec3      clipInfo;",
        //"vec3 clipInfo = vec3(cameraNear * cameraFar, cameraNear - cameraFar, cameraFar);",

        //"float reconstructCSZ(float d) {",
        //    "return clipInfo[0] / (clipInfo[1] * d + clipInfo[2]);",
        //"}",

        /**  vec4(-2.0f / (width*P[0][0]),
         -2.0f / (height*P[1][1]),
         ( 1.0f - P[0][2]) / P[0][0],
         ( 1.0f + P[1][2]) / P[1][1])


         where P is the projection matrix that maps camera space points
         to [-1, 1] x [-1, 1].  That is, GCamera::getProjectUnit(). */
        "uniform vec4 projInfo;",

    /** Reconstruct camera-space P.xyz from screen-space S = (x, y) in
         pixels and camera-space z < 0.  Assumes that the upper-left pixel center
         is at (0.5, 0.5) [but that need not be the location at which the sample tap
         was placed!]

         Costs 3 MADD.  Error is on the order of 10^3 at the far plane, partly due to z precision.
         */
        "vec3 reconstructCSPosition(vec2 S, float z) {",
            "return vec3((S.xy * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);",
        "}",

        /** Reconstructs screen-space unit normal from screen-space position */
        "vec3 reconstructCSFaceNormal(vec3 C) {",
            "return normalize(cross(dFdy(C), dFdx(C)));",
        "}",

        "vec3 reconstructNonUnitCSFaceNormal(vec3 C) {",
            "return cross(dFdy(C), dFdx(C));",
        "}",
        
        /** Read the camera-space position of the point at screen-space pixel ssP */
        "vec3 getPosition(ivec2 ssP, float depth) {",
            "vec3 P;",

            // Offset to pixel center
            "P = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);",
            "return P;",
        "}",

    /** Read the camera-space position of the point at screen-space pixel ssP + unitOffset * ssR.  Assumes length(unitOffset) == 1 */
        "vec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {",

            "ivec2 ssP = ivec2(ssR * unitOffset) + ssC;",

            "vec3 P;",

            // We need to divide by 2^mipLevel to read the appropriately scaled coordinate from a MIP-map.
            // Manually clamp to the texture size because texelFetch bypasses the texture unit
            //"ivec2 mipP = clamp(ssP >> mipLevel, ivec2(0), textureSize(CS_Z_buffer, mipLevel) - ivec2(1));",
            //"ivec2 mipP = ssP;",
            //"P.z = texelFetch(tDepth, mipP, 0).w;",

            "vec2 screenUV = (vec2(ssP) + vec2(0.5)) * resolution;",

            "#ifdef USE_MIPMAP",
                //"int mipLevel = clamp(int(floor(log2(ssR))) - LOG_MAX_OFFSET, 0, MAX_MIP_LEVEL);",
                "int mipLevel = int(max(0.0, min(floor(log2(ssR)) - float(LOG_MAX_OFFSET), float(MAX_MIP_LEVEL))));",

                "if (mipLevel == 0) {",
                    "P.z = texture2D(tDepth, screenUV).z;",
                    "if (P.z == 0.0) P.z = -cameraFar * 1.0e10;",
                "}",
                "else if (mipLevel == 1)",
                    "P.z = unpackDepthNearFar(texture2D(tDepth_mip1, screenUV));",
                "else if (mipLevel == 2)",
                    "P.z = unpackDepthNearFar(texture2D(tDepth_mip2, screenUV));",
                "else if (mipLevel == 3)",
                    "P.z = unpackDepthNearFar(texture2D(tDepth_mip3, screenUV));",
                "else if (mipLevel == 4)",
                    "P.z = unpackDepthNearFar(texture2D(tDepth_mip4, screenUV));",
                "else if (mipLevel == 5)",
                    "P.z = unpackDepthNearFar(texture2D(tDepth_mip5, screenUV));",
            "#else",
                "P.z = texture2D(tDepth, screenUV).z;",
                "if (P.z == 0.0) P.z = -cameraFar * 1.0e10;",
            "#endif",

            // Offset to pixel center
            "P = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);",

            "return P;",
        "}",

        /** Compute the occlusion due to sample with index \a i about the pixel at \a ssC that corresponds
         to camera-space point \a C with unit normal \a n_C, using maximum screen-space sampling radius \a ssDiskRadius

         Note that units of H() in the HPG12 paper are meters, not
         unitless.  The whole falloff/sampling function is therefore
         unitless.  In this implementation, we factor out (9 / radius).

         Four versions of the falloff function are implemented below
         */
        "float sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {",
            // Offset on the unit disk, spun for this pixel
            "float ssR;",
            "vec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);",
            "ssR *= ssDiskRadius;",

            // The occluding point in camera space
            "vec3 Q = getOffsetPosition(ssC, unitOffset, ssR);",

            "vec3 v = Q - C;",

            "float vv = dot(v, v);",
            "float vn = dot(v, n_C);",

            "const float epsilon = 0.01;",

            // A: From the HPG12 paper
            // Note large epsilon to avoid overdarkening within cracks
            //"return float(vv < radius * radius) * max((vn - bias) / (epsilon + vv), 0.0) * (radius * radius) * 0.6;",

            // B: Smoother transition to zero (lowers contrast, smoothing out corners). [Recommended]
            "float f = max(radius * radius - vv, 0.0); return f * f * f * max((vn - bias) / (epsilon + vv), 0.0);",

            // C: Medium contrast (which looks better at high radii), no division.  Note that the
            // contribution still falls off with radius^2, but we've adjusted the rate in a way that is
            // more computationally efficient and happens to be aesthetically pleasing.
            //"return 4.0 * max(1.0 - vv / (radius * radius), 0.0) * max(vn - bias, 0.0);",

            // D: Low contrast, no division operation
            //"return 2.0 * float(vv < radius * radius) * max(vn - bias, 0.0);",
        "}",


        // user variables

        "const bool useNoise = true;",      // use noise instead of pattern for sample dithering


        // generating noise / pattern texture for dithering

        "vec2 rand( const vec2 coord ) {",

            "vec2 noise;",

            "if ( useNoise ) {",

            "float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
            "float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",

            "noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",

            "} else {",

            "float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );",
            "float gg = fract( coord.t * ( size.y / 2.0 ) );",

            "noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",

            "}",

            //put in the range -1/1 for use as rotation angle
            "return ( noise * 2.0  - 1.0 );",

        "}",


        "float getRandomAngle(vec2 pos) {",
            "vec2 rnd = rand(pos);",
            "return atan(rnd.y, rnd.x);",
        "}",


        "void main() {",

        // Pixel being shaded
        "ivec2 ssC = ivec2(gl_FragCoord.xy);",

        //get the normal and depth from our normal+depth texture
        "vec4 nrmz = texture2D(tDepth, vUv);",

        // Unneccessary with depth test.
        "if (nrmz.z == 0.0) {",
            // We're on the skybox
            "gl_FragColor.r = 1.0;",
            "gl_FragColor.a = 0.0;",
            "packKey(1.0, gl_FragColor.gb);",
            "return;",
        "}",

        // World space point being shaded
        "vec3 C = getPosition(ssC, nrmz.z);",

        "packKey(CSZToKey(C.z), gl_FragColor.gb);",

        // Hash function used in the HPG12 AlchemyAO paper
        //"float randomPatternRotationAngle = (3 * ssC.x ^ ssC.y + ssC.x * ssC.y) * 10;",

        //No integer stuff on WebGL, so we have to use an alternative jitter pattern
        "float randomPatternRotationAngle = getRandomAngle(vUv);",

        // Reconstruct normals from positions. These will lead to 1-pixel black lines
        // at depth discontinuities, however the blur will wipe those out so they are not visible
        // in the final image.
        //"vec3 n_C = reconstructCSFaceNormal(C);",
        "vec3 n_C = vec3(nrmz.x, nrmz.y, sqrt(1.0 - dot(nrmz.xy, nrmz.xy)));",

        // Choose the screen-space sample radius
        // proportional to the projected area of the sphere
        "float ssDiskRadius = -projScale * radius / mix(C.z, -1.0, isOrtho);",

        "float sum = 0.0;",

		//NOTE: The loop below is unrolled in extremely ugly way, in order to avoid a Chrome/Windows codegen
		//issue that results in linker errors when the loop is not unrolled. My best guess
		//is that it has to do with the integer precision setting of the loop variable and then
		//later using that with another expected precision.
		/*
        "for (int i = 0; i < NUM_SAMPLES; ++i) {",
            "sum += sampleAO(ssC, C, n_C, ssDiskRadius, i, randomPatternRotationAngle);",
        "}",
        */
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 0, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 1, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 2, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 3, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 4, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 5, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 6, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 7, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 8, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 9, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 10, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 11, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 12, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 13, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 14, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 15, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 16, randomPatternRotationAngle);",

        "float intensityDivR6 = intensity / pow(radius, 6.0);",
        "float A = max(0.0, 1.0 - sum * intensityDivR6 * (5.0 / float(NUM_SAMPLES)));",

        // Bilateral box-filter over a quad for free, respecting depth edges
        // (the difference that this makes is subtle)
        //"if (abs(dFdx(C.z)) < 0.02) {",
        //    "A -= dFdx(A) * ((ssC.x & 1) - 0.5);",
        //"}",
        //"if (abs(dFdy(C.z)) < 0.02) {",
        //    "A -= dFdy(A) * ((ssC.y & 1) - 0.5);",
        //"}",
        //ARGH no integer ops in WebGL, fake the & 1 here
        "if (abs(dFdx(C.z)) < 0.02) {",
            "A -= dFdx(A) * (mod(float(ssC.x), 2.0) - 0.5);",
        "}",
        "if (abs(dFdy(C.z)) < 0.02) {",
            "A -= dFdy(A) * (mod(float(ssC.y), 2.0) - 0.5);",
        "}",

        "gl_FragColor.r = A;",
        "gl_FragColor.a = 1.0;",

        "}"

    ].join("\n")


};

}

})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avs = av.Shaders;

//Bilateral separable blur pass for SAO shader.

avs.init_SAOBlurShader = function(THREE) {

if (typeof avs.SAOBlurShader !== "undefined")
    return;

avs.SAOBlurShader = {

    uniforms: {

        "tDiffuse":     { type: "t", value: null },
        "size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
        "resolution":   { type: "v2", value: new THREE.Vector2( 1.0/512, 1.0/512) },
        "axis":         { type: "v2", value: new THREE.Vector2(1,0) }
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

            "vUv = uv;",

            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

    /** Increase to make depth edges crisper. Decrease to reduce flicker. */
    "#define EDGE_SHARPNESS     (1.0)",

    /** Step in 2-pixel intervals since we already blurred against neighbors in the
     first AO pass.  This constant can be increased while R decreases to improve
     performance at the expense of some dithering artifacts.

     Morgan found that a scale of 3 left a 1-pixel checkerboard grid that was
     unobjectionable after shading was applied but eliminated most temporal incoherence
     from using small numbers of sample taps.
     */
    "#define SCALE               (2)",

    /** Filter radius in pixels. This will be multiplied by SCALE. */
    "#define R                   (4)",


    //////////////////////////////////////////////////////////////////////////////////////////////

    /** Type of data to read from source.  This macro allows
     the same blur shader to be used on different kinds of input data. */
    "#define VALUE_TYPE        float",

    /** Swizzle to use to extract the channels of source. This macro allows
     the same blur shader to be used on different kinds of input data. */
    "#define VALUE_COMPONENTS   r",

    "#define VALUE_IS_KEY       0",

    /** Channel encoding the bilateral key value (which must not be the same as VALUE_COMPONENTS) */
    "#define KEY_COMPONENTS     gb",


    "#if __VERSION__ >= 330",
    // Gaussian coefficients
        "const float gaussian[R + 1] =",
    //    float[](0.356642, 0.239400, 0.072410, 0.009869);
    //    float[](0.398943, 0.241971, 0.053991, 0.004432, 0.000134);  // stddev = 1.0
        "float[](0.153170, 0.144893, 0.122649, 0.092902, 0.062970);  // stddev = 2.0",
    //      float[](0.111220, 0.107798, 0.098151, 0.083953, 0.067458, 0.050920, 0.036108); // stddev = 3.0
    "#endif",

    "uniform sampler2D   tDiffuse;",
    "uniform vec2 size;",
    "uniform vec2 resolution;",

    /** (1, 0) or (0, 1)*/
    "uniform vec2       axis;",

    "#define  result         gl_FragColor.VALUE_COMPONENTS",
    "#define  keyPassThrough gl_FragColor.KEY_COMPONENTS",

    /** Returns a number on (0, 1) */
    "float unpackKey(vec2 p) {",
        "return p.x * (256.0 / 257.0) + p.y * (1.0 / 257.0);",
    "}",

    "varying vec2 vUv;",

    "void main() {",
        
        "#   if __VERSION__ < 330",
            "float gaussian[R + 1];",
        "#       if R == 3",
            "gaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902;  // stddev = 2.0",
        "#       elif R == 4",
        "gaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902; gaussian[4] = 0.062970;  // stddev = 2.0",
        "#       elif R == 6",
        "gaussian[0] = 0.111220; gaussian[1] = 0.107798; gaussian[2] = 0.098151; gaussian[3] = 0.083953; gaussian[4] = 0.067458; gaussian[5] = 0.050920; gaussian[6] = 0.036108;",
        "#       endif",
        "#   endif",

        "ivec2 axisi = ivec2(axis);",

        "ivec2 ssC = ivec2(gl_FragCoord.xy);",
        //"vec4 temp = texelFetch(source, ssC, 0);",
        "vec4 temp = texture2D(tDiffuse, vUv);",

        "gl_FragColor.gb = temp.KEY_COMPONENTS;",
        "gl_FragColor.a = temp.a;",

        "VALUE_TYPE sum = temp.VALUE_COMPONENTS;",

        "if (temp.a == 0.0) {",
            // Sky pixel (we encoded that flag in the A component in the SAO shader)
            "result = sum;",
            "return;",
        "}",

        "float key = unpackKey(keyPassThrough);",

        // Base weight for depth falloff.  Increase this for more blurriness,
        // decrease it for better edge discrimination
        "float BASE = gaussian[0];",
        "float totalWeight = BASE;",
        "sum *= totalWeight;",

		//NOTE: The loop below is unrolled in extremely ugly way, in order to avoid a Chrome/Windows codegen
		//issue that results in linker errors when the loop is not unrolled. My best guess
		//is that it has to do with the integer precision setting of the loop variable and then
		//later using that with another expected precision.
		          /*
        "for (int r = -R; r <= R; ++r) {",
            // We already handled the zero case above.  This loop should be unrolled and the static branch optimized out,
            // so the IF statement has no runtime cost
            "if (r != 0) {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[r<0?-r:r];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
        "}",
        */
            "int r = -4; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[4];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = -3; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[3];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = -2; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[2];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r=-1; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[1];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = 1; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[1];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = 2; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[2];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = 3; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[3];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = 4; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[4];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",

        "const float epsilon = 0.0001;",
        "result = sum / (totalWeight + epsilon);",

    "}"

    ].join("\n")

};

}

})();;(function() {

"use strict";

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_SAOMinifyShader = function(THREE) {

if (typeof avs.SAOMinifyFirstShader !== "undefined")
    return;

//Shader used to convert the normals+depth texture into a smaller texture containing only depth
//Since it packs depth into RGBA8 target it also maps it to the range 0-1 then packs that float
//into an RGBA using magic.
avs.SAOMinifyFirstShader = {

    uniforms: {
        "tDiffuse": { type: "t", value: null }, //Initial normals+depth texture

        "cameraNear":   { type: "f", value: 1 },
        "cameraInvNearFar":    { type: "f", value: 100 },

        "resolution":   { type: "v2", value: new THREE.Vector2( 1.0/512, 1.0/512) } //1/size of lower mip level
    },

    vertexShader: [

        //"varying vec2 vUv;",

        "void main() {",

        //"vUv = uv;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform sampler2D tDiffuse;",
        "uniform vec2 resolution;",
        "uniform float cameraNear;",
        "uniform float cameraInvNearFar;",

        //"varying vec2 vUv;",

        avs.PackDepthShaderChunk,

        "void main() {",

        // Rotated grid subsampling to avoid XY directional bias or Z precision bias while downsampling.
        // On WebGL, the bit-and must be implemented with floating-point modulo........
        //"ivec2 ssP = ivec2(gl_FragCoord.xy);",
        //gl_FragColor = texelFetch2D(texture, clamp(ssP * 2 + ivec2(ssP.y & 1, ssP.x & 1), ivec2(0), textureSize(texture, previousMIPNumber) - ivec2(1)), previousMIPNumber);

        "vec2 ssP = vec2(gl_FragCoord.xy);",
        "ssP = ssP * 2.0 + mod(ssP, 2.0);",
        "ssP = (ssP + 0.5) * resolution * 0.5;",

//            "depth = texture2D(tDiffuse, vUv).z;",
        "float depth = texture2D(tDiffuse, ssP).z;",

        "if (depth != 0.0)",
            "depth = (depth + cameraNear) * cameraInvNearFar;",
        "gl_FragColor = packDepth(depth);",

        "}"

    ].join("\n")

};

//Shader used to generate mip levels for the depth texture (used by the SAO shader)
avs.SAOMinifyShader = {

    uniforms: {
        "tDiffuse": { type: "t", value: null }, //Lower mip level
        "resolution":   { type: "v2", value: new THREE.Vector2( 1.0/512, 1.0/512) } //1/size of lower mip level
    },

    vertexShader: [

        //"varying vec2 vUv;",

        "void main() {",

        //"vUv = uv;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform sampler2D tDiffuse;",
        "uniform vec2 resolution;",

        //"varying vec2 vUv;",

        "void main() {",

        // Rotated grid subsampling to avoid XY directional bias or Z precision bias while downsampling.
        // On WebGL, the bit-and must be implemented with floating-point modulo........
        //"ivec2 ssP = ivec2(gl_FragCoord.xy);",
        //gl_FragColor = texelFetch2D(texture, clamp(ssP * 2 + ivec2(ssP.y & 1, ssP.x & 1), ivec2(0), textureSize(texture, previousMIPNumber) - ivec2(1)), previousMIPNumber);


        "vec2 ssP = vec2(gl_FragCoord.xy);",
        "ssP = ssP * 2.0 + mod(ssP, 2.0);",
        "ssP = (ssP + 0.5) * resolution * 0.5;",
        "gl_FragColor = texture2D(tDiffuse, ssP);",

//            "gl_FragColor = texture2D(tDiffuse, vUv);",

        "}"

    ].join("\n")

};

}

})();;
(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_FireflyPhongShader = function(THREE) {
	'use strict';

if (typeof avs.FireflyPhongShader !== "undefined")
    return;

avs.FireflyPhongShader = {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "bump" ],
            THREE.UniformsLib[ "normalmap" ],
            THREE.UniformsLib[ "lights" ],
            avs.CutPlanesUniforms,
            avs.IdUniforms,

            {
                "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
                "specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
                "shininess": { type: "f", value: 30 },
                "reflMipIndex" : { type: "f", value: 0 },
                "wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) },

                "texMatrix" : { type: "m3", value: new THREE.Matrix3() },
                "texMatrixBump" : { type: "m3", value: new THREE.Matrix3() },
                "texMatrixAlpha" : { type: "m3", value: new THREE.Matrix3() },

                "irradianceMap": { type : "t", value: null },
                "exposureBias" : { type:"f", value: 1.0 },
                "envMapExposure" : { type:"f", value: 1.0 },
                "envRotationSin": {type: "f", value: 0.0},
                "envRotationCos": {type: "f", value: 1.0},
            }

        ] ),

        vertexShader: [

            "varying vec3 vViewPosition;",
            "#ifndef FLAT_SHADED",
                "varying vec3 vNormal;",
            "#endif",

            "#if defined( USE_MAP ) || defined( USE_SPECULARMAP )",
                "varying vec2 vUv;",
                "uniform mat3 texMatrix;",
            "#endif",

            "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
                "varying vec2 vUvBump;",
                "uniform mat3 texMatrixBump;",
            "#endif",

            "#if defined( USE_ALPHAMAP )",
                "varying vec2 vUvAlpha;",
                "uniform mat3 texMatrixAlpha;",
            "#endif",

            "#if defined( USE_ENVMAP )",
                "#if ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",
                    "uniform float refractionRatio;",
                "#endif",
            "#endif",

            "#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0",
                "varying vec3 vWorldPosition;",
            "#endif",

            "#ifdef USE_COLOR",
                "varying vec3 vColor;",
            "#endif",

//TODO: vFragDepth and depth varyings are basically the same ( vFragDepth = 1.0 - depth ) so they can be combined into one
            "#ifdef USE_LOGDEPTHBUF",
                "#ifdef USE_LOGDEPTHBUF_EXT",
                    "varying float vFragDepth;",
                "#endif",
                "uniform float logDepthBufFC;",
            "#endif",

            "#ifdef MRT_NORMALS",
                "varying float depth;",
            "#endif",

            avs.PackNormalsShaderChunk,

            "void main() {",

                "#if defined( USE_MAP ) || defined( USE_SPECULARMAP )",
                    "vUv = (texMatrix * vec3(uv, 1.0)).xy;",
                "#endif",

                "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
                    "vUvBump = (texMatrixBump * vec3(uv, 1.0)).xy;",
                "#endif",

                "#if defined( USE_ALPHAMAP )",
                    "vUvAlpha = (texMatrixAlpha * vec3(uv, 1.0)).xy;",
                "#endif",


                "#ifdef USE_COLOR",
                    "#ifdef GAMMA_INPUT",
                        "vColor = color * color;",
                    "#else",
                        "vColor = color;",
                    "#endif",
                "#endif",

                "#ifdef UNPACK_NORMALS",
                    "vec3 objectNormal = decodeNormal(normal);",
                "#else",
                    "vec3 objectNormal = normal;",
                "#endif",

                "#ifdef FLIP_SIDED",
                    "objectNormal = -objectNormal;",
                "#endif",

                "vec3 transformedNormal = normalMatrix * objectNormal;",

                "#ifndef FLAT_SHADED",
                    "vNormal = normalize( transformedNormal );",
                "#endif",

                "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

                "gl_Position = projectionMatrix * mvPosition;",

                "vViewPosition = -mvPosition.xyz;",

                "#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0",
                    "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
                    "vWorldPosition = worldPosition.xyz;",
                "#endif",

//TODO: vFragDepth and depth varyings are basically the same ( vFragDepth = 1.0 - depth ) so they can be combined into one
                "#ifdef USE_LOGDEPTHBUF",
                    "if (projectionMatrix[3][3] == 0.0) {",
                        "gl_Position.z = log2(max(1.0e-6, gl_Position.w + 1.0)) * logDepthBufFC;",
                        "#ifdef USE_LOGDEPTHBUF_EXT",
                            "vFragDepth = 1.0 + gl_Position.w;",
                        "#else",
                            "gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;",
                        "#endif",
                    "} else {", //Ortho projection -- do we really want log here, or can we just go with linear depth?
                        //"gl_Position.z = log2(max(1e-6, vViewPosition.z + 1.0)) * logDepthBufFC;",
                        "#ifdef USE_LOGDEPTHBUF_EXT",
                            "vFragDepth = 1.0 + vViewPosition.z;",
                        "#else",
                            //"gl_Position.z = (gl_Position.z - 1.0) * vViewPosition.z;",
                        "#endif",
                    "}",
                "#endif",

                "#ifdef MRT_NORMALS",
                    "depth = mvPosition.z;",
                "#endif",

            "}"


        ].join("\n"),

        fragmentShader: [

            "uniform vec3 diffuse;",
            "uniform float opacity;",

            "uniform vec3 emissive;",
            "uniform vec3 specular;",
            "uniform float shininess;",

            avs.EnvSamplingShaderChunk,

            "#ifdef USE_COLOR",
                "varying vec3 vColor;",
            "#endif",

            "#ifdef GAMMA_INPUT",
                "vec3 InputToLinear(vec3 c) {",
                    "return c * c;",
                "}",
                "float InputToLinear(float c) {",
                    "return c * c;",
                "}",
            "#else",
                "vec3 InputToLinear(vec3 c) {",
                    "return c;",
                "}",
                "float InputToLinear(float c) {",
                    "return c;",
                "}",
            "#endif",

            "#if defined( USE_MAP ) || defined( USE_SPECULARMAP )",
                "varying vec2 vUv;",
            "#endif",

            "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
                "varying vec2 vUvBump;",
            "#endif",

            "#if defined( USE_ALPHAMAP )",
                "varying vec2 vUvAlpha;",
            "#endif",

            "#ifdef USE_MAP",
                "uniform sampler2D map;",
            "#endif",

            "#if TONEMAP_OUTPUT > 0",
                "uniform float exposureBias;",
                avs.TonemapShaderChunk,
            "#endif",

            "#if defined(IRR_RGBM) || defined(ENV_RGBM) || defined(ENV_GAMMA) || defined(IRR_GAMMA)",
                "uniform float envMapExposure;",
            "#endif",

            "#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)",
                "uniform vec4 dbId;",
            "#endif",

            //NOTE: This depends on the specific encoding used.
            //We use the environment preset's built in exposure correction,
            //a gamma of 2.0 and an extra factor of 16
            //when generating the cube map in the modified CubeMapGen tool
            //See this article by Karis for details: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html
            "vec3 RGBMDecode(in vec4 vRGBM, in float exposure) {",
                "vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);", //vairable factor in alpha channel + fixed factor of 16.0
                "ret *= ret;", //remove gamma of 2.0 to go into linear space
                "ret *= exposure;", //apply exposure to get back original intensity
                "return ret;",
            "}",

            //Gamma encoded half-float or float input texture. See DecodeEnvMap in Environments.js for details.
            "vec3 GammaDecode(in vec4 vRGBA, in float exposure) {",
                "return vRGBA.xyz * vRGBA.xyz * exposure;",
            "}",

            "#ifdef USE_ENVMAP",

                "uniform float reflMipIndex;",

                "uniform float reflectivity;",
                "uniform samplerCube envMap;",

                "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

                    "uniform float refractionRatio;",

                "#endif",

                "vec3 sampleReflection(vec3 dir, float mipIndex) {",

                    "vec3 adjDir = adjustLookupVector(dir);",

                    "#ifdef ENV_GAMMA",

                        "#ifdef HAVE_TEXTURE_LOD",
                            "vec4 envTexColor = textureCubeLodEXT( envMap, adjDir, mipIndex );",
                        "#else",
                            //NOTE that the computation in case the -LOD extension is not available is
                            //not really correct as the mip bias is not going to be equivalent in some cases.
                            "vec4 envTexColor = textureCube( envMap, adjDir, mipIndex );",
                        "#endif",

                        "return GammaDecode(envTexColor, envMapExposure);",

                    "#elif defined(ENV_RGBM)",

                        "#ifdef HAVE_TEXTURE_LOD",
                            "vec4 envTexColor = textureCubeLodEXT( envMap, adjDir, mipIndex );",
                        "#else",
                            //NOTE that the computation in case the -LOD extension is not available is
                            //not really correct as the mip bias is not going to be equivalent in some cases.
                            "vec4 envTexColor = textureCube( envMap, adjDir, mipIndex );",
                        "#endif",

                        "return RGBMDecode(envTexColor, envMapExposure);",

                    "#else",

                        //Assumes this code path is non-HDR and non-blurred reflection map, like vanilla three.js

                        "vec4 envTexColor = textureCube( envMap, adjDir );",
                        "vec3 cubeColor = envTexColor.xyz;",

                        "#ifdef GAMMA_INPUT",
                            "cubeColor *= cubeColor;",
                        "#endif",

                        "return cubeColor;",

                    "#endif",

                "}",

            "#endif",


            "uniform vec3 ambientLightColor;",

            "#if MAX_DIR_LIGHTS > 0",

                "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
                "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

            "#endif",

            "#if MAX_POINT_LIGHTS > 0",

                "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",

                "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
                "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

            "#endif",

            "#if MAX_SPOT_LIGHTS > 0",

                "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
                "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
                "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
                "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
                "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

                "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

            "#endif",

            "#ifdef USE_IRRADIANCEMAP",
                "uniform samplerCube irradianceMap;",
            "#endif",

            "#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0",
                "varying highp vec3 vWorldPosition;",
            "#endif",

            "#ifdef WRAP_AROUND",
                "uniform vec3 wrapRGB;",
            "#endif",

            "varying highp vec3 vViewPosition;",
            "#ifndef FLAT_SHADED",
                "varying highp vec3 vNormal;",
            "#endif",

            "#ifdef USE_BUMPMAP",

                "uniform sampler2D bumpMap;",
                "uniform float bumpScale;",

                // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
                //  http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

                // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

                "vec2 dHdxy_fwd() {",

                    "vec2 dSTdx = dFdx( vUvBump );",
                    "vec2 dSTdy = dFdy( vUvBump );",

                    "float Hll = bumpScale * GET_BUMPMAP(vUvBump).x;",
                    "float dBx = bumpScale * GET_BUMPMAP(vUvBump + dSTdx).x - Hll;",
                    "float dBy = bumpScale * GET_BUMPMAP(vUvBump + dSTdy).x - Hll;",

                    "return vec2( dBx, dBy );",

                "}",

                "vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

                    "vec3 vSigmaX = dFdx( surf_pos );",
                    "vec3 vSigmaY = dFdy( surf_pos );",
                    "vec3 vN = surf_norm;",     // normalized

                    "vec3 R1 = cross( vSigmaY, vN );",
                    "vec3 R2 = cross( vN, vSigmaX );",

                    "float fDet = dot( vSigmaX, R1 );",

                    "vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
                    "return normalize( abs( fDet ) * surf_norm - vGrad );",

                "}",

            "#endif",


            "#ifdef USE_NORMALMAP",

                "uniform sampler2D normalMap;",
                "uniform vec2 normalScale;",

                // Per-Pixel Tangent Space Normal Mapping
                // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

                "vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",

                    "vec3 q0 = dFdx( eye_pos.xyz );",
                    "vec3 q1 = dFdy( eye_pos.xyz );",
                    "vec2 st0 = dFdx( vUvBump.st );",
                    "vec2 st1 = dFdy( vUvBump.st );",

                    "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
                    "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
                    "vec3 N = normalize( surf_norm );",

                    "vec3 mapN = GET_NORMALMAP(vUvBump).xyz * 2.0 - 1.0;",
                    "mapN.xy = normalScale * mapN.xy;",
                    "mat3 tsn = mat3( S, T, N );",
                    "return normalize( tsn * mapN );",

                "}",

            "#endif",


            "#ifdef USE_SPECULARMAP",
                "uniform sampler2D specularMap;",
            "#endif",

            "#ifdef USE_ALPHAMAP",
                "uniform sampler2D alphaMap;",
            "#endif",

            avs.HatchPatternShaderChunk,

            "#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)",
                "varying highp float depth;",
                "#define gl_FragColor gl_FragData[0]",
            "#endif",

            "#ifdef USE_LOGDEPTHBUF",
                "uniform float logDepthBufFC;",
                "#ifdef USE_LOGDEPTHBUF_EXT",
                    "#extension GL_EXT_frag_depth : enable",
                    "varying highp float vFragDepth;",
                "#endif",
            "#endif",

            "vec3 Schlick_v3(vec3 v, float cosHV) {",
                "float facing = max(1.0 - cosHV, 0.0);",
                "float facing2 = facing * facing;",
                "return v + (1.0 - v) * facing * facing2 * facing2;",
            "}",

            "float Schlick_f(float v, float cosHV) {",
                "float facing = max(1.0 - cosHV, 0.0);",
                "float facing2 = facing * facing;",
                "return v + ( 1.0 - v ) * facing2 * facing2 * facing;",
            "}",

            avs.CutPlanesShaderChunk,

            "void main() {",

                "#if NUM_CUTPLANES > 0",
                    "checkCutPlanes(vWorldPosition);",
                "#endif",

                "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

                "#ifdef USE_MAP",
                    "vec4 texelColor = GET_MAP(vUv);",
                    "#ifdef MAP_INVERT",
                        "texelColor.xyz = 1.0-texelColor.xyz;",
                    "#endif",
                    "#ifdef GAMMA_INPUT",
                        "texelColor.xyz *= texelColor.xyz;",
                    "#endif",
                    "gl_FragColor = gl_FragColor * texelColor;",
                "#endif",

                "#ifdef USE_ALPHAMAP",
                    "vec4 texelAlpha = GET_ALPHAMAP(vUvAlpha);",
                    "gl_FragColor.a *= texelAlpha.r;",
                "#endif",

                "#ifdef ALPHATEST",
                    "if ( gl_FragColor.a < ALPHATEST ) discard;",
                "#endif",

                "float specularStrength;",

                "#ifdef USE_SPECULARMAP",
                    "vec4 texelSpecular = GET_SPECULARMAP(vUv);",
                    "specularStrength = texelSpecular.r;",
                "#else",
                    "specularStrength = 1.0;",
                "#endif",

                "#ifndef FLAT_SHADED",
                    "vec3 normal = normalize( vNormal );",
                    "#ifdef DOUBLE_SIDED",
                        "normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
                    "#endif",
                "#else",
                    "vec3 fdx = dFdx( vViewPosition );",
                    "vec3 fdy = dFdy( vViewPosition );",
                    "vec3 normal = normalize( cross( fdx, fdy ) );",
                "#endif",

                "vec3 geomNormal = normal;",

                "#ifdef USE_NORMALMAP",
                    "normal = perturbNormal2Arb( -vViewPosition, normal );",
                "#elif defined( USE_BUMPMAP )",
                    "normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",
                "#endif",

                //With ortho projection, the view direction needs to be
                //adjusted so that all view direction rays (for all pixels) are parallel
                //instead of going from the camera position directly to the vertex like
                //in perspective. In view space, this is kind of easy -- the view vector is along Z.
                //TODO: Actially the vViewPosition varying is the position of the camers wrt the vertex
                //so the naming of the variable can be clarified.
                "vec3 viewDirection;",
                "if (projectionMatrix[3][3] == 0.0) {",
                    "viewDirection = normalize( vViewPosition );",
                "} else {",
                    "viewDirection = vec3(0.0, 0.0, 1.0);",
                "}",

                "vec3 totalDiffuse = vec3( 0.0 );",
                "vec3 totalSpecular = vec3( 0.0 );",

                //Convert shininess from Phong to Blinn. The blurred environment is
                //sampled using Phong exponent, while the light math uses Blinn model.
                "float shininessB = shininess * 4.0;",

                "#if MAX_POINT_LIGHTS > 0",

                    "vec3 pointDiffuse  = vec3( 0.0 );",
                    "vec3 pointSpecular = vec3( 0.0 );",

                    "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

                        "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

                        "float lDistance = 1.0;",
                        "if ( pointLightDistance[ i ] > 0.0 )",
                            "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

                        "lVector = normalize( lVector );",

                        // diffuse

                        "float dotProduct = dot( normal, lVector );",

                        "#ifdef WRAP_AROUND",

                            "float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
                            "float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

                            "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

                        "#else",

                            "float pointDiffuseWeight = max( dotProduct, 0.0 );",

                        "#endif",

                        "pointDiffuse  += InputToLinear(diffuse) * InputToLinear(pointLightColor[ i ]) * pointDiffuseWeight * lDistance;",

                        // specular

                        "vec3 pointHalfVector = normalize( lVector + viewDirection );",
                        "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",

                        "float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininessB ), 0.0 );",
                        "float specularNormalization = shininessB * 0.125 + 0.25;", //(shininess+2)/8
                        "vec3 schlick = Schlick_v3(InputToLinear(specular), dot( lVector, pointHalfVector ) );",
                        "pointSpecular += schlick * InputToLinear(pointLightColor[ i ]) * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization ;",

                    "}",

                    "totalDiffuse += pointDiffuse;",
                    "totalSpecular += pointSpecular;",

                "#endif",

                "#if MAX_SPOT_LIGHTS > 0",

                    "vec3 spotDiffuse  = vec3( 0.0 );",
                    "vec3 spotSpecular = vec3( 0.0 );",

                    "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

                        "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

                        "float lDistance = 1.0;",
                        "if ( spotLightDistance[ i ] > 0.0 )",
                            "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

                        "lVector = normalize( lVector );",

                        "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

                        "if ( spotEffect > spotLightAngleCos[ i ] ) {",

                            "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

                            // diffuse

                            "float dotProduct = dot( normal, lVector );",

                            "#ifdef WRAP_AROUND",

                                "float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
                                "float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

                                "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

                            "#else",

                                "float spotDiffuseWeight = max( dotProduct, 0.0 );",

                            "#endif",

                            "spotDiffuse += InputToLinear(diffuse) * InputToLinear(spotLightColor[ i ]) * spotDiffuseWeight * lDistance * spotEffect;",

                            // specular

                            "vec3 spotHalfVector = normalize( lVector + viewDirection );",
                            "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
                            "float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininessB ), 0.0 );",

                            "float specularNormalization = shininessB * 0.125 + 0.25;", //(shininess+2)/8
                            "vec3 schlick = Schlick_v3(InputToLinear(specular), dot( lVector, spotHalfVector ) );",
                            "spotSpecular += schlick * InputToLinear(spotLightColor[ i ]) * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",
                        "}",

                    "}",

                    "totalDiffuse += spotDiffuse;",
                    "totalSpecular += spotSpecular;",

                "#endif",

                "#if MAX_DIR_LIGHTS > 0",

                    "vec3 dirDiffuse  = vec3( 0.0 );",
                    "vec3 dirSpecular = vec3( 0.0 );" ,

                    "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

                        "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
                        "vec3 dirVector = normalize( lDirection.xyz );",

                        // diffuse

                        "float dotProduct = dot( normal, dirVector );",

                        "#ifdef WRAP_AROUND",

                            "float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
                            "float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

                            "vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",

                        "#else",

                            "float dirDiffuseWeight = max( dotProduct, 0.0 );",

                        "#endif",

                        "dirDiffuse  += InputToLinear(diffuse) * InputToLinear(directionalLightColor[ i ]) * dirDiffuseWeight;",

                        // specular

                        "vec3 dirHalfVector = normalize( dirVector + viewDirection );",
                        "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
                        "float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininessB ), 0.0 );",

                        "float specularNormalization = shininessB * 0.125 + 0.25;", //(shininess+2)/8
                        "vec3 schlick = Schlick_v3(InputToLinear(specular), dot( dirVector, dirHalfVector ));",

                        "dirSpecular += schlick * InputToLinear(directionalLightColor[ i ]) * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

                    "}",

                    "totalDiffuse += dirDiffuse;",
                    "totalSpecular += dirSpecular;",

                "#endif",



                "#ifdef USE_IRRADIANCEMAP",
                    "vec3 worldNormal = mat3(viewMatrixInverse) * normal;",

                    "vec4 cubeColor4 = textureCube(irradianceMap, adjustLookupVector(worldNormal));",

                    "#ifdef IRR_GAMMA",

                        "vec3 indirectDiffuse = GammaDecode(cubeColor4, envMapExposure);",

                    "#elif defined(IRR_RGBM)",

                        "vec3 indirectDiffuse = RGBMDecode(cubeColor4, envMapExposure);",

                    "#else",

                        "vec3 indirectDiffuse = cubeColor4.xyz;",

                        "#ifdef GAMMA_INPUT",
                            "indirectDiffuse.xyz *= indirectDiffuse.xyz;",
                        "#endif",

                    "#endif",

                    "totalDiffuse += InputToLinear(diffuse) * indirectDiffuse;",
                "#endif",


                "#ifdef METAL",
                    "gl_FragColor.xyz = gl_FragColor.xyz * ( InputToLinear(emissive) + totalDiffuse + ambientLightColor * InputToLinear(diffuse) + totalSpecular );",
                "#else",
                    "gl_FragColor.xyz = gl_FragColor.xyz * ( InputToLinear(emissive) + totalDiffuse + ambientLightColor * InputToLinear(diffuse) ) + totalSpecular;",
                "#endif",


                //Modulate base color with vertex color, if any
                "#ifdef USE_COLOR",
                    "gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );",
                "#endif",


                "#if defined(USE_ENVMAP)",

                    "vec3 reflectVec;",

                    "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

                        "#ifdef ENVMAP_MODE_REFLECTION",
                            "reflectVec = reflect( -viewDirection, normal );",
                        "#else ",
                            "reflectVec = refract( -viewDirection, normal, refractionRatio );",
                        "#endif",

                    "#else",

                        "reflectVec = reflect( -viewDirection, normal );",

                    "#endif",

                    "reflectVec = mat3(viewMatrixInverse) * reflectVec;",

                    //If the reflection vector points into the ground, we will scale
                    //down the reflection intensity, in order to fake interference with the
                    //ground plane and avoid an eclipse-like light-dark line between the object
                    //and its shadow.
                    //The actual scaling is made up so that it gets very dark near the ground facing faces
                    //"float reflectScale = 1.0 - clamp(-reflectVec.y, 0.0, 1.0);",
                    //"reflectScale *= (reflectScale * reflectScale);",
                    "float reflectScale = 1.0;",

                    //The environment cube map is blurred with the assumption that
                    //max shininess is 2048 and every mip drops that by a factor of 4
                    //"float MipmapIndex = log(shininess / 2048.0) / log(0.25);",
                    //The simplification below was given in the original source for this method.
                    //However, it does not seem to match the equation above, so we use a corrected one.
                    //"float MipmapIndex = max(0.0, -1.66096404744368 * logShiny + 5.5);",
                    //"float logShiny = log(max(1.0+1e-10, shininess));",
                    //"float reflMipIndex = max(0.0, -0.72134752 * logShiny + 5.5);",
                    //NOTE: The mip index is passed in as uniform in case where shininess is constant.
                    //If we get roughness map support, we'd have to sample the roughness map here to get a mip index.

                    "vec3 cubeColor = sampleReflection(reflectVec, reflMipIndex);",

                    "cubeColor *= reflectScale;",

                    "float facing = dot( viewDirection, geomNormal );",

                    //Argh. If facing is very much below the horizon, it's probably
                    //a backwards facing polygon, so turn off Fresnel completely.
                    //Otherwise, if it's just slightly below, it's probably some interpolation
                    //artifact, so we treat it as almost oblique facing.
                    "if (facing < -1e-2)",
                        "facing = 1.0;",
                    "else",
                        "facing = max(1e-6, facing);",

                    "vec3 schlickRefl;",

                    "#ifdef METAL",

                        //Metals do not generally have Fresnel reflection
                        "schlickRefl = InputToLinear(specular);",

                    "#else",

                        //Nonmetals reflect using Fresnel -- so they reflect a lot at grazing angles
                        "schlickRefl = Schlick_v3(InputToLinear(specular), facing);",

                        //Seems appropriate to also reduce transparency of the material as
                        //the view angle is more oblique:
                        //BOGUS: The scaling by reflectivity is not physical -- here
                        //we use reflectivity as a scale to make transparent ghosted objects look good
                        //while still retaining some physical Fresnel for glass materials.
                        //For ghosted objects the reflectivity is 0 while for physical glass
                        //it is a non-zero value.
                        "gl_FragColor.a = mix(gl_FragColor.a, Schlick_f(gl_FragColor.a, facing), reflectivity);",

                        //Scale down diffuse in order to keep energy conservation
                        //at grazing angles, where specular takes over. The actual equation is
                        //given here: http://www.cs.utah.edu/~shirley/papers/jgtbrdf.pdf.
                        //For the environment map, N.V and N.R are equal so we can just square the one factor
                        //instead of computing two and multiplying them, but we use just one factor instead,
                        //because things seem to get too dark otherwise.
                        //TODO: check further on the exact normalization factors needed.
                        //Also note that we drop a factor of PI (we drop that from the specular light as well,
                        //where we use n/8 instead of n/8pi as normalization).
                        "float invSchlick = (1.0 - facing * 0.5);",
                        "float invSchlick2 = invSchlick * invSchlick;",
                        "float norm_factor = 1.0 - invSchlick * invSchlick2 * invSchlick2;",

                        //If contrast is too high, and RaaS complains, set this factor to 1.
                        "norm_factor = (28.0 / 23.0) * norm_factor;",

                        "gl_FragColor.xyz *= norm_factor * (1.0 - InputToLinear(specular));",

                    "#endif",

                    //Add environment contribution to direct lighting
                    "gl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl.xyz;",

                    "#ifdef CLEARCOAT",

                        "vec3 reflectVecClearcoat = reflect( -viewDirection, geomNormal );",
                        "reflectVecClearcoat = mat3(viewMatrixInverse) * reflectVecClearcoat;",

                        "vec3 cubeColorClearcoat = sampleReflection(reflectVecClearcoat, 0.0);",

                        //Fresnel for the clearcoat
                        "float schlickClearcoat = Schlick_f(InputToLinear(reflectivity), facing);",

                        //Mix in specular of the clearcoat -- note the 0.5 factor is hardcoded
                        //from the Prism paint material.
                        "gl_FragColor.xyz = mix(gl_FragColor.xyz, cubeColorClearcoat * schlickClearcoat, 0.5);",

                    "#endif", //CLEARCOAT

                    //DEBUG
                    //"gl_FragColor.xyz = cubeColor.xyz;",

                "#endif", //USE_ENVMAP

                "#if TONEMAP_OUTPUT == 1",
                    "gl_FragColor.xyz = toneMapCanonOGS_WithGamma_WithColorPerserving(exposureBias * gl_FragColor.xyz);",
                "#elif TONEMAP_OUTPUT == 2",
                    "gl_FragColor.xyz = toneMapCanonFilmic_WithGamma( exposureBias * gl_FragColor.xyz );",
                "#endif",

                avs.FinalOutputShaderChunk,

            "}"


        ].join("\n")

};

THREE.ShaderLib['firefly_phong'] = avs.FireflyPhongShader;

}


})();;
(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders,
    avp = av.Private;

avs.init_FireflyPrismShader = function(THREE) {
	'use strict';

if (typeof avs.PrismShader !== "undefined")
    return;

    // This method sets up various uniforms for a given map, putting them
    // in an array called "uniforms" which are accessed by the name, such
    // as "uniforms[surface_albedo_map_texMatrix]".
    function GetPrismMapUniforms(mapName) {
        var mtxName = mapName + "_texMatrix";
        var mapInvt = mapName + "_invert";

        var uniforms = {};
        uniforms[mapName] = { type: "t", value: null };
        uniforms[mtxName] = { type: "m3", value: new THREE.Matrix3() };
        uniforms[mapInvt] = { type: "i", value: 0 };

        return uniforms;
    }

    function GetPrismBumpMapUniforms(mapName) {
        var mtxName = mapName + "_texMatrix";
        var mapScale = mapName + "_bumpScale";
        var mapType = mapName + "_bumpmapType";

        var uniforms = {};
        uniforms[mapName] = { type: "t", value: null };
        uniforms[mtxName] = { type: "m3", value: new THREE.Matrix3() };
        uniforms[mapScale] = { type: "v2", value: new THREE.Vector2( 1, 1 ) };
        uniforms[mapType] = { type: "i", value: 0 };

        return uniforms;
    }

	// If any map type is defined, then do whatever "content" is;
	// typically it's "#define USE_MAP". In other words, if any map
	// is defined, then USE_MAP will also be defined. This constant
	// is then checked and determines whether a UV variable is defined, etc.
    function GetPrismMapsDefinitionChunk( content ) {
        var def = ["#if defined( USE_SURFACE_ALBEDO_MAP )" +
                   " || defined( USE_SURFACE_ROUGHNESS_MAP )" +
                   " || defined( USE_SURFACE_CUTOUT_MAP )" +
                   " || defined( USE_SURFACE_ANISOTROPY_MAP )" +
                   " || defined( USE_SURFACE_ROTATION_MAP )" +
                   " || defined( USE_OPAQUE_ALBEDO_MAP )" +
                   " || defined( USE_OPAQUE_F0_MAP )" +
                   " || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP )" +
                   " || defined( USE_LAYERED_BOTTOM_F0_MAP )" +
                   " || defined( USE_LAYERED_F0_MAP )" +
                   " || defined( USE_LAYERED_DIFFUSE_MAP )" +
                   " || defined( USE_LAYERED_FRACTION_MAP )" +
                   " || defined( USE_LAYERED_ROUGHNESS_MAP )" +
                   " || defined( USE_LAYERED_ANISOTROPY_MAP )" +
                   " || defined( USE_LAYERED_ROTATION_MAP )" +
                   " || defined( USE_METAL_F0_MAP )" +
                   " || defined( USE_SURFACE_NORMAL_MAP )" +
                   " || defined( USE_LAYERED_NORMAL_MAP )",
                   content,
                   "#endif"
                   ].join("\n");

        return def;
    }

    // Set up code for texture access. If USE_SURFACE_ALBEDO_MAP is defined, for example, this texture access code gets executed.
    // If it's not defined, then a simply copy occurs, e.g. "surfaceAlbedo = surface_albedo;" from the variableName and mapType.
    function GetPrismMapSampleChunk( mapType, variableName, isFloat, linearize ) {
        var suffix = isFloat ? "_v3" : "";
        var declare = isFloat ? "vec3 " : "";
        var average = isFloat ? variableName + " = averageOfFloat3(" + variableName + suffix + ");" : "";
        var colorLinearization = linearize ? variableName + suffix + " = SRGBToLinear(" + variableName + suffix + ");" : "";
        var shader = [
                      "#if defined( USE_" + mapType.toUpperCase() +  "_MAP )",
                      "vec2 uv_" + mapType + "_map = (" + mapType + "_map_texMatrix * vec3(vUv, 1.0)).xy;",
                      mapType.toUpperCase()+"_CLAMP_TEST;",
                      declare + variableName + suffix + " = texture2D(" + mapType +"_map, uv_" + mapType + "_map).xyz;",
                      colorLinearization,
                      "if(" + mapType + "_map_invert) " + variableName + suffix +" = vec3(1.0) - " + variableName + suffix + ";",
                      average,
                      "#else",
                      variableName + " = " + mapType + ";",
                      "#endif"
                      ].join("\n");

        return shader;
    }

    function GetPrismMapUniformChunk(mapName) {

        var mtxName = mapName + "_texMatrix";
        var mapInvt = mapName + "_invert";
        var macroName = "USE_" + mapName;

        var uniforms = [
            "#if defined( " + macroName.toUpperCase() + " )",
            "uniform sampler2D " + mapName + ";",
            "uniform mat3 " + mtxName + ";",
            "uniform bool " + mapInvt + ";",
            "#endif",
        ].join("\n");

        return uniforms;
    }

    function GetPrismBumpMapUniformChunk(mapName) {

        var mtxName = mapName + "_texMatrix";
        var mapScale = mapName + "_bumpScale";
        var mapType = mapName + "_bumpmapType";
        var macroName = "USE_" + mapName;

        var uniforms = [
            "#if defined( " + macroName.toUpperCase() + " )",
            "uniform sampler2D " + mapName + ";",
            "uniform mat3 " + mtxName + ";",
            "uniform vec2 " + mapScale + ";",
            "uniform int " + mapType + ";",
            "#endif",
        ].join("\n");

        return uniforms;
    }

avs.PrismShader = {

        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "common" ],
            THREE.UniformsLib[ "lights" ],
            avs.CutPlanesUniforms,
            avs.IdUniforms,

            GetPrismMapUniforms("surface_albedo_map"),
            GetPrismMapUniforms("surface_roughness_map"),
            GetPrismMapUniforms("surface_cutout_map"),
            GetPrismMapUniforms("surface_anisotropy_map"),
            GetPrismMapUniforms("surface_rotation_map"),
            GetPrismMapUniforms("opaque_albedo_map"),
            GetPrismMapUniforms("opaque_f0_map"),
            GetPrismMapUniforms("opaque_luminance_modifier_map"),
            GetPrismMapUniforms("layered_bottom_f0_map"),
            GetPrismMapUniforms("layered_f0_map"),
            GetPrismMapUniforms("layered_diffuse_map"),
            GetPrismMapUniforms("layered_fraction_map"),
            GetPrismMapUniforms("layered_roughness_map"),
            GetPrismMapUniforms("layered_anisotropy_map"),
            GetPrismMapUniforms("layered_rotation_map"),
            GetPrismMapUniforms("metal_f0_map"),

            GetPrismBumpMapUniforms("surface_normal_map"),
            GetPrismBumpMapUniforms("layered_normal_map"),

            {
                //Surface
                "surface_albedo" : { type: "c", value: new THREE.Color( 0x111111 ) },
                "surface_roughness" : { type: "f", value: 1.0 },
                "surface_anisotropy" : { type: "f", value: 1.0 },
                "surface_rotation" : { type: "f", value: 1.0 },

                //Opaque
                "opaque_albedo" : { type: "c", value: new THREE.Color( 0x111111 ) },
                "opaque_f0" : { type: "f", value: 1.0 },
                "opaque_luminance_modifier" : { type: "c", value: new THREE.Color( 0x111111 ) },
                "opaque_luminance" : { type: "f", value: 1.0 },

                //Metal
                "metal_f0" : { type: "c", value: new THREE.Color( 0x111111 ) },

                //Layered
                "layered_f0" : { type: "f", value: 1.0 },
                "layered_diffuse" : { type: "c", value: new THREE.Color( 0x000000 ) },
                "layered_fraction" : { type: "f", value: 1.0 },
                "layered_bottom_f0" : { type: "c", value: new THREE.Color( 0x111111 ) },
                "layered_roughness" : { type: "f", value: 1.0 },
                "layered_anisotropy" : { type: "f", value: 1.0 },
                "layered_rotation" : { type: "f", value: 1.0 },

                //Transparent
                "transparent_ior" : { type: "f", value: 2.0 },
                "transparent_color" : { type: "c", value: new THREE.Color( 0x111111 ) },
                "transparent_distance" : { type: "f", value: 1.0 },

                //Wood
                "wood_fiber_cosine_enable": { type: "i", value: 1 },
                "wood_fiber_cosine_bands": { type: "i", value: 2 },
                "wood_fiber_cosine_weights": { type: "v4", value: new THREE.Vector4(2.5, 0.5, 1, 1) },
                "wood_fiber_cosine_frequencies": { type: "v4", value: new THREE.Vector4(15, 4, 1, 1) },

                "wood_fiber_perlin_enable": { type: "i", value: 1 },
                "wood_fiber_perlin_bands": { type: "i", value: 3 },
                "wood_fiber_perlin_weights": { type: "v4", value: new THREE.Vector4(3.0, 1.0, 0.2, 1) },
                "wood_fiber_perlin_frequencies": { type: "v4", value: new THREE.Vector4(40, 20, 3.5, 1) },
                "wood_fiber_perlin_scale_z": { type: "f", value: 0.3 },

                "wood_growth_perlin_enable": { type: "i", value: 1 },
                "wood_growth_perlin_bands": { type: "i", value: 3 },
                "wood_growth_perlin_weights": { type: "v4", value: new THREE.Vector4(1.0, 2, 1, 1) },
                "wood_growth_perlin_frequencies": { type: "v4", value: new THREE.Vector4(1, 5, 13, 1) },

                "wood_latewood_ratio": { type: "f", value: 0.238 },
                "wood_earlywood_sharpness": { type: "f", value: 0.395 },
                "wood_latewood_sharpness": { type: "f", value: 0.109 },
                "wood_ring_thickness": { type: "f", value: 0.75 },

                "wood_earlycolor_perlin_enable": { type: "i", value: 1 },
                "wood_earlycolor_perlin_bands": { type: "i", value: 2 },
                "wood_earlycolor_perlin_weights": { type: "v4", value: new THREE.Vector4(0.3, 0.5, 0.15, 1) },
                "wood_earlycolor_perlin_frequencies": { type: "v4", value: new THREE.Vector4(8, 3, 0.35, 1) },
                "wood_early_color": { type: "c", value: new THREE.Color(0.286, 0.157, 0.076) },

                "wood_use_manual_late_color": { type: "i", value: 0 },
                "wood_manual_late_color": { type: "c", value: new THREE.Color(0.62, 0.35, 0.127) },

                "wood_latecolor_perlin_enable": { type: "i", value: 1 },
                "wood_latecolor_perlin_bands": { type: "i", value: 1 },
                "wood_latecolor_perlin_weights": { type: "v4", value: new THREE.Vector4(0.75, 0.55, 1, 1) },
                "wood_latecolor_perlin_frequencies": { type: "v4", value: new THREE.Vector4(4.5, 0.05, 1, 1) },
                "wood_late_color_power": { type: "f", value: 1.25 },

                "wood_diffuse_perlin_enable": { type: "i", value: 1 },
                "wood_diffuse_perlin_bands": { type: "i", value: 3 },
                "wood_diffuse_perlin_weights": { type: "v4", value: new THREE.Vector4(0.15, 0.2, 0.05, 1) },
                "wood_diffuse_perlin_frequencies": { type: "v4", value: new THREE.Vector4(0.05, 0.1, 3, 1) },
                "wood_diffuse_perlin_scale_z": { type: "f", value: 0.2 },

                "wood_use_pores": { type: "i", value: 1 },
                "wood_pore_type": { type: "i", value: 0 },
                "wood_pore_radius": { type: "f", value: 0.04 },
                "wood_pore_cell_dim": { type: "f", value: 0.15 },
                "wood_pore_color_power": { type: "f", value: 1.45 },
                "wood_pore_depth": { type: "f", value: 0.02 },

                "wood_use_rays": { type: "i", value: 1 },
                "wood_ray_color_power": { type: "f", value: 1.1 },
                "wood_ray_seg_length_z": { type: "f", value: 5.0 },
                "wood_ray_num_slices": { type: "f", value: 160 },
                "wood_ray_ellipse_z2x": { type: "f", value: 10 },
                "wood_ray_ellipse_radius_x": { type: "f", value: 0.2 },

                "wood_use_latewood_bump": { type: "i", value: 1 },
                "wood_latewood_bump_depth": { type: "f", value: 0.01 },

                "wood_use_groove_roughness": { type: "i", value: 1 },
                "wood_groove_roughness": { type: "f", value: 0.85 },
                "wood_diffuse_lobe_weight": { type: "f", value: 0.9 },

                "permutationMap": { type: "t", value: null },
                "gradientMap": { type: "t", value: null },
                "perm2DMap": { type: "t", value: null },
                "permGradMap": { type: "t", value: null },

                "irradianceMap": { type : "t", value: null },
                "envMap": { type : "t", value: null },
                "exposureBias" : { type:"f", value: 1.0 },
                "envMapExposure" : { type:"f", value: 1.0 },
                "envRotationSin": {type: "f", value: 0.0},
                "envRotationCos": {type: "f", value: 1.0},

                "envExponentMin" : { type:"f", value: 1.0 },
                "envExponentMax" : { type:"f", value: 512.0 },
                "envExponentCount" : { type:"f", value: 10.0 },

            }

        ] ),

        vertexShader: [

            "varying vec3 vViewPosition;",
            "varying vec3 vNormal;",

            "#if defined(PRISMWOOD) && !defined(NO_UVW)",
                "varying vec3 vUvw;",
            "#endif",

            "#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0",
                "varying vec3 vWorldPosition;",
            "#endif",
            GetPrismMapsDefinitionChunk("#define USE_MAP"),
            "#ifdef USE_MAP",
                "varying vec2 vUv;",
            "#endif",
            //TODO: vFragDepth and depth varyings are basically the same ( vFragDepth = 1.0 - depth ) so they can be combined into one
            "#ifdef USE_LOGDEPTHBUF",
                "#ifdef USE_LOGDEPTHBUF_EXT",
                    "varying float vFragDepth;",
                "#endif",
                "uniform float logDepthBufFC;",
            "#endif",

            "#ifdef MRT_NORMALS",
                "varying float depth;",
            "#endif",

            avs.PackNormalsShaderChunk,

            //Prism brdf calculation needs tangent/bitangent. If uv is not available,
            //calculate tangent/bitangent in vertex shader with a simplified algorithm.
            "#if !defined(USE_MAP) " +
            "&& (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0)",
            "varying vec3 vTangent;",
            "varying vec3 vBitangent;",

            "void ComputeTangents(vec3 normal, out vec3 u, out vec3 v)",
            "{",
            "    float scale = normal.z < 0.0 ? -1.0 : 1.0;",
            "    vec3 temp = scale * normal;",
            "    float e    = temp.z;",
            "    float h    = 1.0/(1.0 + e);",
            "    float hvx  = h   *  temp.y;",
            "    float hvxy = hvx * -temp.x;",
            "    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);",
            "    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);",

            "    u *= scale;",
            "    v *= scale;",
            "}",
            "#endif",

            "void main() {",
            "#ifdef USE_MAP",
                "vUv = uv;",
            "#endif",

            "#if defined(PRISMWOOD) && !defined(NO_UVW)",
                "vUvw = uvw;",
            "#endif",

                "#ifdef UNPACK_NORMALS",
                    "vec3 objectNormal = decodeNormal(normal);",
                "#else",
                    "vec3 objectNormal = normal;",
                "#endif",

                "#ifdef FLIP_SIDED",
                    "objectNormal = -objectNormal;",
                "#endif",

                "vec3 transformedNormal = normalMatrix * objectNormal;",

                "vNormal = normalize( transformedNormal );",

                "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

                "gl_Position = projectionMatrix * mvPosition;",

                "vViewPosition = -mvPosition.xyz;",

                "#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0",
                    "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
                    "vWorldPosition = worldPosition.xyz;",
                "#endif",

                "#if !defined(USE_MAP) " +
                "&& (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0)",
                    "vec3 Tu, Tv;",
                    "ComputeTangents(vNormal, Tu, Tv);",
                    "vTangent = Tu;",
                    "vBitangent = Tv;",
                "#endif",
                //TODO: vFragDepth and depth varyings are basically the same ( vFragDepth = 1.0 - depth ) so they can be combined into one
                "#ifdef USE_LOGDEPTHBUF",
                    "if (projectionMatrix[3][3] == 0.0) {",
                        "gl_Position.z = log2(max(1.0e-6, gl_Position.w + 1.0)) * logDepthBufFC;",
                        "#ifdef USE_LOGDEPTHBUF_EXT",
                            "vFragDepth = 1.0 + gl_Position.w;",
                        "#else",
                            "gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;",
                        "#endif",
                    "} else {", //Ortho projection -- do we really want log here, or can we just go with linear depth?
                        //"gl_Position.z = log2(max(1e-6, vViewPosition.z + 1.0)) * logDepthBufFC;",
                        "#ifdef USE_LOGDEPTHBUF_EXT",
                            "vFragDepth = 1.0 + vViewPosition.z;",
                        "#else",
                            //"gl_Position.z = (gl_Position.z - 1.0) * vViewPosition.z;",
                        "#endif",
                    "}",
                "#endif",

                "#ifdef MRT_NORMALS",
                    "depth = mvPosition.z;",
                "#endif",
            "}"


        ].join("\n"),

        fragmentShader: [
            "//**************************************************************************/",
            "// Copyright 2015 Autodesk, Inc. ",
            "// All rights reserved.",
            "// ",
            "// This computer source code and related instructions and comments are the ",
            "// unpublished confidential and proprietary information of Autodesk, Inc. ",
            "// and are protected under Federal copyright and state trade secret law. ",
            "// They may not be disclosed to, copied or used by any third party without",
            "// the prior written consent of Autodesk, Inc. ",
            "//**************************************************************************/ ",
            "#define PI 3.141592654",
            "#define RECIPROCAL_PI 0.318309886",
            "#define RECIPROCAL_2PI 0.159154943",
            "#define ONE 0.00390625",// =1/256.0

            "uniform vec3 surface_albedo;",
            "uniform float surface_roughness;",
            "uniform float surface_anisotropy;",
            "uniform float surface_rotation;",

            "#if defined( PRISMOPAQUE )",
            //Opaque
            "uniform vec3 opaque_albedo;",
            "uniform float opaque_f0;",
            "uniform vec3 opaque_luminance_modifier;",
            "uniform float opaque_luminance;",

            "#elif defined( PRISMMETAL )",
            //Metal
            "uniform vec3 metal_f0;",

            "#elif defined( PRISMLAYERED )",
            //Layered
            "uniform float layered_f0;",
            "uniform vec3 layered_diffuse;",
            "uniform float layered_fraction;",
            "uniform vec3 layered_bottom_f0;",
            "uniform float layered_roughness;",
            "uniform float layered_anisotropy;",
            "uniform float layered_rotation;",

            "#elif defined( PRISMTRANSPARENT )",
            //Transparent
            "uniform float transparent_ior;",
            "uniform vec3 transparent_color;",
            "uniform float transparent_distance;",

            "#elif defined( PRISMWOOD )",
            //Wood
            "uniform bool wood_fiber_cosine_enable;",
            "uniform int wood_fiber_cosine_bands;",
            "uniform vec4 wood_fiber_cosine_weights;",
            "uniform vec4 wood_fiber_cosine_frequencies;",
            "uniform bool wood_fiber_perlin_enable;",
            "uniform int wood_fiber_perlin_bands;",
            "uniform vec4 wood_fiber_perlin_weights;",
            "uniform vec4 wood_fiber_perlin_frequencies;",
            "uniform float wood_fiber_perlin_scale_z;",
            "uniform bool wood_growth_perlin_enable;",
            "uniform int wood_growth_perlin_bands;",
            "uniform vec4 wood_growth_perlin_weights;",
            "uniform vec4 wood_growth_perlin_frequencies;",
            "uniform float wood_latewood_ratio;",
            "uniform float wood_earlywood_sharpness;",
            "uniform float wood_latewood_sharpness;",
            "uniform float wood_ring_thickness;",
            "uniform bool wood_earlycolor_perlin_enable;",
            "uniform int wood_earlycolor_perlin_bands;",
            "uniform vec4 wood_earlycolor_perlin_weights;",
            "uniform vec4 wood_earlycolor_perlin_frequencies;",
            "uniform vec3 wood_early_color;",
            "uniform bool wood_use_manual_late_color;",
            "uniform vec3 wood_manual_late_color;",
            "uniform bool wood_latecolor_perlin_enable;",
            "uniform int wood_latecolor_perlin_bands;",
            "uniform vec4 wood_latecolor_perlin_weights;",
            "uniform vec4 wood_latecolor_perlin_frequencies;",
            "uniform float wood_late_color_power;",
            "uniform bool wood_diffuse_perlin_enable;",
            "uniform int wood_diffuse_perlin_bands;",
            "uniform vec4 wood_diffuse_perlin_weights;",
            "uniform vec4 wood_diffuse_perlin_frequencies;",
            "uniform float wood_diffuse_perlin_scale_z;",
            "uniform bool wood_use_pores;",
            "uniform int wood_pore_type;",
            "uniform float wood_pore_radius;",
            "uniform float wood_pore_cell_dim;",
            "uniform float wood_pore_color_power;",
            "uniform float wood_pore_depth;",
            "uniform bool wood_use_rays;",
            "uniform float wood_ray_color_power;",
            "uniform float wood_ray_seg_length_z;",
            "uniform float wood_ray_num_slices;",
            "uniform float wood_ray_ellipse_z2x;",
            "uniform float wood_ray_ellipse_radius_x;",
            "uniform bool wood_use_latewood_bump;",
            "uniform float wood_latewood_bump_depth;",
            "uniform bool wood_use_groove_roughness;",
            "uniform float wood_groove_roughness;",
            "uniform float wood_diffuse_lobe_weight;",
            "uniform sampler2D permutationMap;",
            "uniform sampler2D gradientMap;",
            "uniform sampler2D perm2DMap;",
            "uniform sampler2D permGradMap;",
            "#endif",

            //Env
            "uniform float envExponentMin;",
            "uniform float envExponentMax;",
            "uniform float envExponentCount;",
            avs.EnvSamplingShaderChunk,

            "#if TONEMAP_OUTPUT > 0",
                "uniform float exposureBias;",
                avs.TonemapShaderChunk,
            "#endif",

            "#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)",
                "varying highp float depth;",
                "#define gl_FragColor gl_FragData[0]",
            "#endif",

            "#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0",
                "varying vec3 vWorldPosition;",
            "#endif",

            "#ifdef USE_LOGDEPTHBUF",
                "uniform float logDepthBufFC;",
                "#ifdef USE_LOGDEPTHBUF_EXT",
                    "#extension GL_EXT_frag_depth : enable",
                    "varying highp float vFragDepth;",
                "#endif",
            "#endif",

            "#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)",
                "uniform vec4 dbId;",
            "#endif",

            GetPrismMapsDefinitionChunk("#define USE_MAP"),
            "#ifdef USE_MAP",
                "varying vec2 vUv;",
            "#endif",

            "#if defined(PRISMWOOD) && !defined(NO_UVW)",
                "varying vec3 vUvw;",
            "#endif",

            GetPrismMapUniformChunk("surface_albedo_map"),
            GetPrismMapUniformChunk("surface_roughness_map"),
            GetPrismMapUniformChunk("surface_cutout_map"),
            GetPrismMapUniformChunk("surface_anisotropy_map"),
            GetPrismMapUniformChunk("surface_rotation_map"),

            GetPrismMapUniformChunk("opaque_albedo_map"),
            GetPrismMapUniformChunk("opaque_f0_map"),
            GetPrismMapUniformChunk("opaque_luminance_modifier_map"),
            GetPrismMapUniformChunk("layered_bottom_f0_map"),
            GetPrismMapUniformChunk("layered_f0_map"),
            GetPrismMapUniformChunk("layered_diffuse_map"),
            GetPrismMapUniformChunk("layered_fraction_map"),
            GetPrismMapUniformChunk("layered_roughness_map"),
            GetPrismMapUniformChunk("layered_anisotropy_map"),
            GetPrismMapUniformChunk("layered_rotation_map"),
            GetPrismMapUniformChunk("metal_f0_map"),

            GetPrismBumpMapUniformChunk("surface_normal_map"),
            GetPrismBumpMapUniformChunk("layered_normal_map"),

            "vec3 RGBMDecode(in vec4 vRGBM, in float exposure) {",
                "vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);", //vairable factor in alpha channel + fixed factor of 16.0
                "ret *= ret;", //remove gamma of 2.0 to go into linear space
                "ret *= exposure;", //apply exposure to get back original intensity
                "return ret;",
            "}",

            "vec3 GammaDecode(in vec4 vRGBA, in float exposure) {",
                "return vRGBA.xyz * vRGBA.xyz * exposure;",
            "}",

            "float SRGBToLinearComponent(float color) {",
                "float result = color;",
                // For the formula to transform sRGB value to linear space, please refer to http://en.wikipedia.org/wiki/SRGB
                "if (result<=0.04045)",
                    "result *= 0.07739938;",
                "else",
                    "result = pow(abs((result+0.055)*0.947867298), 2.4);",
                "return result;",
            "}",

            "vec3 SRGBToLinear(vec3 color) {",
                "vec3 result = color;",
                "result.x = SRGBToLinearComponent(result.x);",
                "result.y = SRGBToLinearComponent(result.y);",
                "result.z = SRGBToLinearComponent(result.z);",
                "return result;",
            "}",

            "#if defined( USE_ENVMAP )",
            "uniform float envMapExposure;",
            "uniform samplerCube envMap;",
            "#endif", //USE_ENVMAP

            "float averageOfFloat3(in vec3 value)",
            "{ ",
            "    const float oneThird = 1.0 / 3.0; ",
            "    return dot(value, vec3(oneThird, oneThird, oneThird)); ",
            "} ",

            "#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )",
            "vec3 heightMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {",
                "vec2 st = (transform * vec3(uv, 1.0)).xy;", 
                "mat3 mtxTangent = mat3(T, B, N);", 
                "T = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));",
                "B = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));",
                "const float oneThird = 1.0 / 3.0;",
                "vec3 avg = vec3(oneThird, oneThird, oneThird);",
                "vec2 offset = fwidth(st);",
                "float h0 = dot(texture2D(bumpTexture, st).xyz, avg);",
                "float hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);",
                "float hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);",
                "vec2 diff = vec2(h0 - hx, h0 - hy) / offset;",
                "return normalize(N + (diff.x * T * bumpScale.x + diff.y * B * bumpScale.y));",
            "}",

            "vec3 normalMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 T, vec3 B, vec3 N) {",
                "vec2 st = (transform * vec3(uv, 1.0)).xy;", 
                "vec3 NMap =  2.0 * texture2D( bumpTexture, st ).xyz - 1.0; ", 
                "return normalize(bumpScale.x * (NMap.x * T + NMap.y * B) + NMap.z * N);",
            "}",
            "#endif",

            "#if !defined(USE_MAP)" +
            "&& (MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0)",
            "varying vec3 vTangent;",
            "varying vec3 vBitangent;",
            "#endif",

            "#if defined( USE_ENVMAP )",
            "vec3 sampleReflection(vec3 N, vec3 V, float mipIndex) {",

                "vec3 dir = (2.0 * dot(V, N)) * N - V;",
                "dir = adjustLookupVector(mat3(viewMatrixInverse) * dir);",

                "#ifdef ENV_GAMMA",

                    "#ifdef HAVE_TEXTURE_LOD",
                        "vec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );",
                    "#else",
                        //NOTE that the computation in case the -LOD extension is not available is
                        //not really correct as the mip bias is not going to be equivalent in some cases.
                        "vec4 envTexColor = textureCube( envMap, dir, mipIndex );",
                    "#endif",

                    "return GammaDecode(envTexColor, envMapExposure);",

                "#elif defined(ENV_RGBM)",
                    "#ifdef HAVE_TEXTURE_LOD",
                        "vec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );",
                    "#else",
                        //NOTE that the computation in case the -LOD extension is not available is
                        //not really correct as the mip bias is not going to be equivalent in some cases.
                        "vec4 envTexColor = textureCube( envMap, dir, mipIndex );",
                    "#endif",

                    "return RGBMDecode(envTexColor, envMapExposure);",

                "#else",

                    //Assumes this code path is non-HDR and non-blurred reflection map, like vanilla three.js

                    "vec4 envTexColor = textureCube( envMap, dir );",
                    "vec3 cubeColor = envTexColor.xyz;",

                    "#ifdef GAMMA_INPUT",
                        "cubeColor *= cubeColor;",
                    "#endif",

                    "return cubeColor;",

                "#endif",

            "}",
            "#endif",

            avs.HatchPatternShaderChunk,

            "#if defined( USE_ENVMAP ) && defined( USE_IRRADIANCEMAP )",
            "uniform samplerCube irradianceMap;",

            "vec3 sampleNormal(vec3 normal) {",
            "vec3 worldNormal = mat3(viewMatrixInverse) * normal;",

            "vec4 cubeColor4 = textureCube(irradianceMap, adjustLookupVector(worldNormal));",

            "#ifdef IRR_GAMMA",

                "vec3 indirectDiffuse = GammaDecode(cubeColor4, envMapExposure);",

            "#elif defined(IRR_RGBM)",

                "vec3 indirectDiffuse = RGBMDecode(cubeColor4, envMapExposure);",

            "#else",

                "vec3 indirectDiffuse = cubeColor4.xyz;",

                "#ifdef GAMMA_INPUT",
                    "indirectDiffuse.xyz *= indirectDiffuse.xyz;",
                "#endif",

            "#endif",

            "return indirectDiffuse;}",
            "#endif",

            "#if MAX_DIR_LIGHTS > 0",

                "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
                "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

            "#endif",

            "#if MAX_POINT_LIGHTS > 0",

                "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
                "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
                "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

            "#endif",

            "#if MAX_SPOT_LIGHTS > 0",

                "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
                "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
                "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
                "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
                "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
                "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

            "#endif",

            "float sqr(float x) {return x*x;}",

            "float aSqrd(float maxAlphaSqr, float cosTheta)",
            "{",
            "   float tan2 = 1.0/sqr(cosTheta) - 1.0;",
            "   return maxAlphaSqr * tan2;",
            "}",

            // Computes the Schlick Fresnel term, based on the normal reflectance (f0) and the cosine of the
            // angle between the light direction and half-angle vector.
            "vec3 Fresnel_Schlick(vec3 f0, float cosAngle)",
            "{",
            "    float x = 1.0 - cosAngle;",
            "    float x2 = x * x;",
            "    float x5 = x * x2 * x2;",
            "    return f0 + (1.0 - f0) * x5;",
            "}",

            // Computes the Schlick Fresnel term, with an adjustment to limit reflectance at grazing angles
            // based on roughness (in alpha units).
            // NOTE: This technically needs two versions, one for Beckman and one for GGX, but here we are
            // simply stopping the function at alpha of 0.7.
            "vec3 Fresnel_Rough(vec3 f0, float cosAngle, float alpha)",
            "{",
            "    float x = 1.0 - cosAngle;",
            "    float x2 = x * x;",
            "    float x5 = x * x2 * x2;",
            "    vec3 maxReflectance = mix(vec3(1.0), f0, vec3(min(0.7, alpha)) / 0.7);",
            "    return f0 + (maxReflectance - f0) * x5;",
            "}",

            // Computes the reflectance for the specified index of refraction.
            "float IORToReflectance(float ior)",
            "{",
            "    return sqr((1.0 - ior)/(1.0 + ior));",
            "}",

            // Converts a roughness value to (internal) alpha values (U and V), with anisotropy if desired.
            // NOTE: Set anisotropy to 0.0 to disable it.
            "vec2 RoughnessToAlpha(float roughness, float anisotropy)",
            "{",
                // Compute alpha as roughness squared.  Also apply anisotropy for the V component, relative to
                // the U component.
            "    vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);",
            "    alpha = alpha * alpha;",

                // Enforce a small (non-zero) lower bound on alpha to avoid highlight aliasing and division by
                // zero.
            "    alpha = clamp(alpha, 0.001, 1.0);",

            "    return alpha;",
            "}",

            // Computes a Phong exponent that is comparable to the specified alpha (roughness).
            "float AlphaToPhong(float alpha)",
            "{",
            "    return max(0.0, 2.56/alpha - 7.0);",// GGX, exponent goes to 1 (diffuse) at alpha = 0.64
            "}",

            // Map the exponent to lmv env mipmap level(0~6?)
            "float ExponentToReflMipIndex(float exponent)",
            "{",
            "    float targetLog = log2(exponent);",
            "    float minLog = log2(envExponentMin); ",
            "    float maxLog = log2(envExponentMax); ",
            "    float deltaLog = clamp(targetLog - minLog, 0.0, maxLog - minLog);  ",
            "    float level = clamp((1.0-(deltaLog + 0.5) / envExponentCount), 0.0, 1.0) * 6.0; ",
            "    return level; ",
            "}",

            "#if defined( PRISMWOOD )",

            "vec3 NoiseWood(inout float roughness_inout)",
            "{",
            "//If the mesh has no uvw, use a const zero vector.",
            "//This is used by section tool.",
            "#ifdef NO_UVW",
            "   vec3 vUvw_uniform = vec3(0.0);",
            "#else",
            "   vec3 vUvw_uniform = vUvw;",
            "#endif",
            "  lowp float surfaceRoughness_1;",
            "  surfaceRoughness_1 = surface_roughness;",
            "  lowp float roughness_2;",
            "  roughness_2 = surfaceRoughness_1;",
            "  lowp vec3 diffAlbedo_3;",
            "  lowp vec3 lateColor_4;",
            "  lowp vec3 earlyColor_5;",
            "  lowp float radiusLength_6;",
            "  lowp vec3 p_7;",
            "  p_7 = vUvw_uniform;",
            "  if (wood_fiber_cosine_enable) {",
            "    lowp vec3 p_8;",
            "    p_8 = p_7;",
            "    lowp vec3 tmpvar_9;",
            "    lowp float weight_10;",
            "    lowp float radiusShift_11;",
            "    lowp float tmpvar_12;",
            "    tmpvar_12 = sqrt(dot (vUvw_uniform.xy, vUvw_uniform.xy));",
            "    if ((tmpvar_12 < 1e-05)) {",
            "      tmpvar_9 = p_7;",
            "    } else {",
            "      lowp vec2 tmpvar_13;",
            "      tmpvar_13 = (vUvw_uniform.xy / tmpvar_12);",
            "      radiusShift_11 = 0.0;",
            "      if ((0 < wood_fiber_cosine_bands)) {",
            "        radiusShift_11 = (wood_fiber_cosine_weights.x * cos((",
            "          (vUvw_uniform.z * 0.1591549)",
            "         * wood_fiber_cosine_frequencies.x)));",
            "        if ((1 < wood_fiber_cosine_bands)) {",
            "          radiusShift_11 = (radiusShift_11 + (wood_fiber_cosine_weights.y * cos(",
            "            ((vUvw_uniform.z * 0.1591549) * wood_fiber_cosine_frequencies.y)",
            "          )));",
            "          if ((2 < wood_fiber_cosine_bands)) {",
            "            radiusShift_11 = (radiusShift_11 + (wood_fiber_cosine_weights.z * cos(",
            "              ((vUvw_uniform.z * 0.1591549) * wood_fiber_cosine_frequencies.z)",
            "            )));",
            "            if ((3 < wood_fiber_cosine_bands)) {",
            "              radiusShift_11 = (radiusShift_11 + (wood_fiber_cosine_weights.w * cos(",
            "                ((vUvw_uniform.z * 0.1591549) * wood_fiber_cosine_frequencies.w)",
            "              )));",
            "            };",
            "          };",
            "        };",
            "      };",
            "      lowp float tmpvar_14;",
            "      tmpvar_14 = clamp ((tmpvar_12 / 1.5), 0.0, 1.0);",
            "      weight_10 = tmpvar_14;",
            "      if ((tmpvar_14 >= 0.5)) {",
            "        weight_10 = ((tmpvar_14 * tmpvar_14) * (3.0 - (tmpvar_14 + tmpvar_14)));",
            "      };",
            "      p_8.xy = (vUvw_uniform.xy + ((tmpvar_13 * radiusShift_11) * weight_10));",
            "      tmpvar_9 = p_8;",
            "    };",
            "    p_7 = tmpvar_9;",
            "  };",
            "  if (wood_fiber_perlin_enable) {",
            "    lowp vec3 p_15;",
            "    p_15 = p_7;",
            "    lowp vec3 tmpvar_16;",
            "    tmpvar_16.xy = p_7.xy;",
            "    tmpvar_16.z = (p_7.z * wood_fiber_perlin_scale_z);",
            "    lowp vec3 p_17;",
            "    p_17 = tmpvar_16;",
            "    highp int bands_18;",
            "    bands_18 = wood_fiber_perlin_bands;",
            "    highp vec4 w_19;",
            "    w_19 = wood_fiber_perlin_weights;",
            "    highp vec4 f_20;",
            "    f_20 = wood_fiber_perlin_frequencies;",
            "    lowp float noise_22;",
            "    noise_22 = 0.0;",
            "    for (int i_21 = 0; i_21 < 4; ++i_21) {",
            "      if ((i_21 >= bands_18)) {",
            "        break;",
            "      };",
            "      lowp vec3 p_23;",
            "      p_23 = (p_17 * f_20[i_21]);",
            "      lowp vec4 AA_24;",
            "      lowp vec3 modp_25;",
            "      lowp vec3 tmpvar_26;",
            "      tmpvar_26 = (vec3(mod (floor(p_23), 256.0)));",
            "      modp_25.z = tmpvar_26.z;",
            "      modp_25.xy = (tmpvar_26.xy * 0.00390625);",
            "      AA_24 = ((texture2D (perm2DMap, modp_25.xy, 0.0) * 255.0) + tmpvar_26.z);",
            "      AA_24 = ((vec4(mod (floor(AA_24), 256.0))) * 0.00390625);",
            "      lowp vec2 tmpvar_27;",
            "      tmpvar_27.y = 0.0;",
            "      tmpvar_27.x = AA_24.x;",
            "      lowp vec2 tmpvar_28;",
            "      tmpvar_28.y = 0.0;",
            "      tmpvar_28.x = AA_24.y;",
            "      lowp vec2 tmpvar_29;",
            "      tmpvar_29.y = 0.0;",
            "      tmpvar_29.x = AA_24.z;",
            "      lowp vec2 tmpvar_30;",
            "      tmpvar_30.y = 0.0;",
            "      tmpvar_30.x = AA_24.w;",
            "      lowp vec2 tmpvar_31;",
            "      tmpvar_31.y = 0.0;",
            "      tmpvar_31.x = (AA_24.x + 0.00390625);",
            "      lowp vec2 tmpvar_32;",
            "      tmpvar_32.y = 0.0;",
            "      tmpvar_32.x = (AA_24.y + 0.00390625);",
            "      lowp vec2 tmpvar_33;",
            "      tmpvar_33.y = 0.0;",
            "      tmpvar_33.x = (AA_24.z + 0.00390625);",
            "      lowp vec2 tmpvar_34;",
            "      tmpvar_34.y = 0.0;",
            "      tmpvar_34.x = (AA_24.w + 0.00390625);",
            "      p_23 = (p_23 - floor(p_23));",
            "      lowp vec3 tmpvar_35;",
            "      tmpvar_35 = (((p_23 * p_23) * p_23) * ((p_23 *",
            "        ((p_23 * 6.0) - 15.0)",
            "      ) + 10.0));",
            "      noise_22 = (noise_22 + (w_19[i_21] * mix (",
            "        mix (mix (dot ((",
            "          (texture2D (permGradMap, tmpvar_27, 0.0).xyz * 2.0)",
            "         - 1.0), p_23), dot ((",
            "          (texture2D (permGradMap, tmpvar_29, 0.0).xyz * 2.0)",
            "         - 1.0), (p_23 + vec3(-1.0, 0.0, 0.0))), tmpvar_35.x), mix (dot ((",
            "          (texture2D (permGradMap, tmpvar_28, 0.0).xyz * 2.0)",
            "         - 1.0), (p_23 + vec3(0.0, -1.0, 0.0))), dot ((",
            "          (texture2D (permGradMap, tmpvar_30, 0.0).xyz * 2.0)",
            "         - 1.0), (p_23 + vec3(-1.0, -1.0, 0.0))), tmpvar_35.x), tmpvar_35.y)",
            "      ,",
            "        mix (mix (dot ((",
            "          (texture2D (permGradMap, tmpvar_31, 0.0).xyz * 2.0)",
            "         - 1.0), (p_23 + vec3(0.0, 0.0, -1.0))), dot ((",
            "          (texture2D (permGradMap, tmpvar_33, 0.0).xyz * 2.0)",
            "         - 1.0), (p_23 + vec3(-1.0, 0.0, -1.0))), tmpvar_35.x), mix (dot ((",
            "          (texture2D (permGradMap, tmpvar_32, 0.0).xyz * 2.0)",
            "         - 1.0), (p_23 + vec3(0.0, -1.0, -1.0))), dot ((",
            "          (texture2D (permGradMap, tmpvar_34, 0.0).xyz * 2.0)",
            "         - 1.0), (p_23 + vec3(-1.0, -1.0, -1.0))), tmpvar_35.x), tmpvar_35.y)",
            "      , tmpvar_35.z)));",
            "    };",
            "    p_15.xy = (p_7.xy + noise_22);",
            "    p_7 = p_15;",
            "  };",
            "  lowp float tmpvar_36;",
            "  tmpvar_36 = sqrt(dot (p_7.xy, p_7.xy));",
            "  radiusLength_6 = tmpvar_36;",
            "  if (wood_growth_perlin_enable) {",
            "    lowp float radiusLength_37;",
            "    radiusLength_37 = tmpvar_36;",
            "    lowp float noise_38;",
            "    noise_38 = 0.0;",
            "    if ((0 < wood_growth_perlin_bands)) {",
            "      lowp float p_39;",
            "      p_39 = (tmpvar_36 * wood_growth_perlin_frequencies.x);",
            "      lowp float modp_40;",
            "      modp_40 = (((float(mod (",
            "        floor(p_39)",
            "      , 256.0))) + 256.0) * 0.00390625);",
            "      lowp vec2 tmpvar_41;",
            "      tmpvar_41.y = 0.0;",
            "      tmpvar_41.x = modp_40;",
            "      lowp vec2 tmpvar_42;",
            "      tmpvar_42.y = 0.0;",
            "      tmpvar_42.x = texture2D (permutationMap, tmpvar_41, 0.0).x;",
            "      lowp vec2 tmpvar_43;",
            "      tmpvar_43.y = 0.0;",
            "      tmpvar_43.x = (modp_40 + 0.00390625);",
            "      lowp vec2 tmpvar_44;",
            "      tmpvar_44.y = 0.0;",
            "      tmpvar_44.x = texture2D (permutationMap, tmpvar_43, 0.0).x;",
            "      p_39 = (p_39 - floor(p_39));",
            "      noise_38 = (wood_growth_perlin_weights.x * mix ((",
            "        ((texture2D (gradientMap, tmpvar_42, 0.0).x * 2.0) - 1.0)",
            "       * p_39), (",
            "        ((texture2D (gradientMap, tmpvar_44, 0.0).x * 2.0) - 1.0)",
            "       *",
            "        (p_39 - 1.0)",
            "      ), (",
            "        ((p_39 * p_39) * p_39)",
            "       *",
            "        ((p_39 * ((p_39 * 6.0) - 15.0)) + 10.0)",
            "      )));",
            "      if ((1 < wood_growth_perlin_bands)) {",
            "        lowp float p_45;",
            "        p_45 = (tmpvar_36 * wood_growth_perlin_frequencies.y);",
            "        lowp float modp_46;",
            "        modp_46 = (((float(mod (",
            "          floor(p_45)",
            "        , 256.0))) + 256.0) * 0.00390625);",
            "        lowp vec2 tmpvar_47;",
            "        tmpvar_47.y = 0.0;",
            "        tmpvar_47.x = modp_46;",
            "        lowp vec2 tmpvar_48;",
            "        tmpvar_48.y = 0.0;",
            "        tmpvar_48.x = texture2D (permutationMap, tmpvar_47, 0.0).x;",
            "        lowp vec2 tmpvar_49;",
            "        tmpvar_49.y = 0.0;",
            "        tmpvar_49.x = (modp_46 + 0.00390625);",
            "        lowp vec2 tmpvar_50;",
            "        tmpvar_50.y = 0.0;",
            "        tmpvar_50.x = texture2D (permutationMap, tmpvar_49, 0.0).x;",
            "        p_45 = (p_45 - floor(p_45));",
            "        noise_38 = (noise_38 + (wood_growth_perlin_weights.y * mix (",
            "          (((texture2D (gradientMap, tmpvar_48, 0.0).x * 2.0) - 1.0) * p_45)",
            "        ,",
            "          (((texture2D (gradientMap, tmpvar_50, 0.0).x * 2.0) - 1.0) * (p_45 - 1.0))",
            "        ,",
            "          (((p_45 * p_45) * p_45) * ((p_45 * (",
            "            (p_45 * 6.0)",
            "           - 15.0)) + 10.0))",
            "        )));",
            "        if ((2 < wood_growth_perlin_bands)) {",
            "          lowp float p_51;",
            "          p_51 = (tmpvar_36 * wood_growth_perlin_frequencies.z);",
            "          lowp float modp_52;",
            "          modp_52 = (((float(mod (",
            "            floor(p_51)",
            "          , 256.0))) + 256.0) * 0.00390625);",
            "          lowp vec2 tmpvar_53;",
            "          tmpvar_53.y = 0.0;",
            "          tmpvar_53.x = modp_52;",
            "          lowp vec2 tmpvar_54;",
            "          tmpvar_54.y = 0.0;",
            "          tmpvar_54.x = texture2D (permutationMap, tmpvar_53, 0.0).x;",
            "          lowp vec2 tmpvar_55;",
            "          tmpvar_55.y = 0.0;",
            "          tmpvar_55.x = (modp_52 + 0.00390625);",
            "          lowp vec2 tmpvar_56;",
            "          tmpvar_56.y = 0.0;",
            "          tmpvar_56.x = texture2D (permutationMap, tmpvar_55, 0.0).x;",
            "          p_51 = (p_51 - floor(p_51));",
            "          noise_38 = (noise_38 + (wood_growth_perlin_weights.z * mix (",
            "            (((texture2D (gradientMap, tmpvar_54, 0.0).x * 2.0) - 1.0) * p_51)",
            "          ,",
            "            (((texture2D (gradientMap, tmpvar_56, 0.0).x * 2.0) - 1.0) * (p_51 - 1.0))",
            "          ,",
            "            (((p_51 * p_51) * p_51) * ((p_51 * (",
            "              (p_51 * 6.0)",
            "             - 15.0)) + 10.0))",
            "          )));",
            "          if ((3 < wood_growth_perlin_bands)) {",
            "            lowp float p_57;",
            "            p_57 = (tmpvar_36 * wood_growth_perlin_frequencies.w);",
            "            lowp float modp_58;",
            "            modp_58 = (((float(mod (",
            "              floor(p_57)",
            "            , 256.0))) + 256.0) * 0.00390625);",
            "            lowp vec2 tmpvar_59;",
            "            tmpvar_59.y = 0.0;",
            "            tmpvar_59.x = modp_58;",
            "            lowp vec2 tmpvar_60;",
            "            tmpvar_60.y = 0.0;",
            "            tmpvar_60.x = texture2D (permutationMap, tmpvar_59, 0.0).x;",
            "            lowp vec2 tmpvar_61;",
            "            tmpvar_61.y = 0.0;",
            "            tmpvar_61.x = (modp_58 + 0.00390625);",
            "            lowp vec2 tmpvar_62;",
            "            tmpvar_62.y = 0.0;",
            "            tmpvar_62.x = texture2D (permutationMap, tmpvar_61, 0.0).x;",
            "            p_57 = (p_57 - floor(p_57));",
            "            noise_38 = (noise_38 + (wood_growth_perlin_weights.w * mix (",
            "              (((texture2D (gradientMap, tmpvar_60, 0.0).x * 2.0) - 1.0) * p_57)",
            "            ,",
            "              (((texture2D (gradientMap, tmpvar_62, 0.0).x * 2.0) - 1.0) * (p_57 - 1.0))",
            "            ,",
            "              (((p_57 * p_57) * p_57) * ((p_57 * (",
            "                (p_57 * 6.0)",
            "               - 15.0)) + 10.0))",
            "            )));",
            "          };",
            "        };",
            "      };",
            "    };",
            "    radiusLength_37 = (tmpvar_36 + noise_38);",
            "    if ((radiusLength_37 < 0.0)) {",
            "      radiusLength_37 = 0.0;",
            "    };",
            "    radiusLength_6 = radiusLength_37;",
            "  };",
            "  lowp float earlyWoodRatio_63;",
            "  highp float tmpvar_64;",
            "  tmpvar_64 = (1.0 - wood_latewood_ratio);",
            "  highp float tmpvar_65;",
            "  tmpvar_65 = (wood_earlywood_sharpness * tmpvar_64);",
            "  highp float tmpvar_66;",
            "  tmpvar_66 = (wood_latewood_sharpness * wood_latewood_ratio);",
            "  highp float tmpvar_67;",
            "  tmpvar_67 = (tmpvar_64 - tmpvar_65);",
            "  highp float tmpvar_68;",
            "  tmpvar_68 = (tmpvar_64 + tmpvar_66);",
            "  highp float tmpvar_69;",
            "  tmpvar_69 = (wood_latewood_ratio - tmpvar_66);",
            "  lowp float tmpvar_70;",
            "  tmpvar_70 = ((float(mod (radiusLength_6, wood_ring_thickness))) / wood_ring_thickness);",
            "  earlyWoodRatio_63 = 0.0;",
            "  if ((tmpvar_70 <= tmpvar_65)) {",
            "    earlyWoodRatio_63 = 1.0;",
            "  } else {",
            "    if ((tmpvar_70 <= tmpvar_64)) {",
            "      earlyWoodRatio_63 = (1.0 - ((tmpvar_70 - tmpvar_65) / tmpvar_67));",
            "    } else {",
            "      if ((tmpvar_70 <= tmpvar_68)) {",
            "        earlyWoodRatio_63 = 0.0;",
            "      } else {",
            "        earlyWoodRatio_63 = ((tmpvar_70 - tmpvar_68) / tmpvar_69);",
            "      };",
            "    };",
            "  };",
            "  earlyColor_5 = wood_early_color;",
            "  if (wood_earlycolor_perlin_enable) {",
            "    lowp float noise_71;",
            "    noise_71 = 0.0;",
            "    if ((0 < wood_earlycolor_perlin_bands)) {",
            "      lowp float p_72;",
            "      p_72 = (radiusLength_6 * wood_earlycolor_perlin_frequencies.x);",
            "      lowp float modp_73;",
            "      modp_73 = (((float(mod (",
            "        floor(p_72)",
            "      , 256.0))) + 256.0) * 0.00390625);",
            "      lowp vec2 tmpvar_74;",
            "      tmpvar_74.y = 0.0;",
            "      tmpvar_74.x = modp_73;",
            "      lowp vec2 tmpvar_75;",
            "      tmpvar_75.y = 0.0;",
            "      tmpvar_75.x = texture2D (permutationMap, tmpvar_74, 0.0).x;",
            "      lowp vec2 tmpvar_76;",
            "      tmpvar_76.y = 0.0;",
            "      tmpvar_76.x = (modp_73 + 0.00390625);",
            "      lowp vec2 tmpvar_77;",
            "      tmpvar_77.y = 0.0;",
            "      tmpvar_77.x = texture2D (permutationMap, tmpvar_76, 0.0).x;",
            "      p_72 = (p_72 - floor(p_72));",
            "      noise_71 = (wood_earlycolor_perlin_weights.x * mix ((",
            "        ((texture2D (gradientMap, tmpvar_75, 0.0).x * 2.0) - 1.0)",
            "       * p_72), (",
            "        ((texture2D (gradientMap, tmpvar_77, 0.0).x * 2.0) - 1.0)",
            "       *",
            "        (p_72 - 1.0)",
            "      ), (",
            "        ((p_72 * p_72) * p_72)",
            "       *",
            "        ((p_72 * ((p_72 * 6.0) - 15.0)) + 10.0)",
            "      )));",
            "      if ((1 < wood_earlycolor_perlin_bands)) {",
            "        lowp float p_78;",
            "        p_78 = (radiusLength_6 * wood_earlycolor_perlin_frequencies.y);",
            "        lowp float modp_79;",
            "        modp_79 = (((float(mod (",
            "          floor(p_78)",
            "        , 256.0))) + 256.0) * 0.00390625);",
            "        lowp vec2 tmpvar_80;",
            "        tmpvar_80.y = 0.0;",
            "        tmpvar_80.x = modp_79;",
            "        lowp vec2 tmpvar_81;",
            "        tmpvar_81.y = 0.0;",
            "        tmpvar_81.x = texture2D (permutationMap, tmpvar_80, 0.0).x;",
            "        lowp vec2 tmpvar_82;",
            "        tmpvar_82.y = 0.0;",
            "        tmpvar_82.x = (modp_79 + 0.00390625);",
            "        lowp vec2 tmpvar_83;",
            "        tmpvar_83.y = 0.0;",
            "        tmpvar_83.x = texture2D (permutationMap, tmpvar_82, 0.0).x;",
            "        p_78 = (p_78 - floor(p_78));",
            "        noise_71 = (noise_71 + (wood_earlycolor_perlin_weights.y * mix (",
            "          (((texture2D (gradientMap, tmpvar_81, 0.0).x * 2.0) - 1.0) * p_78)",
            "        ,",
            "          (((texture2D (gradientMap, tmpvar_83, 0.0).x * 2.0) - 1.0) * (p_78 - 1.0))",
            "        ,",
            "          (((p_78 * p_78) * p_78) * ((p_78 * (",
            "            (p_78 * 6.0)",
            "           - 15.0)) + 10.0))",
            "        )));",
            "        if ((2 < wood_earlycolor_perlin_bands)) {",
            "          lowp float p_84;",
            "          p_84 = (radiusLength_6 * wood_earlycolor_perlin_frequencies.z);",
            "          lowp float modp_85;",
            "          modp_85 = (((float(mod (",
            "            floor(p_84)",
            "          , 256.0))) + 256.0) * 0.00390625);",
            "          lowp vec2 tmpvar_86;",
            "          tmpvar_86.y = 0.0;",
            "          tmpvar_86.x = modp_85;",
            "          lowp vec2 tmpvar_87;",
            "          tmpvar_87.y = 0.0;",
            "          tmpvar_87.x = texture2D (permutationMap, tmpvar_86, 0.0).x;",
            "          lowp vec2 tmpvar_88;",
            "          tmpvar_88.y = 0.0;",
            "          tmpvar_88.x = (modp_85 + 0.00390625);",
            "          lowp vec2 tmpvar_89;",
            "          tmpvar_89.y = 0.0;",
            "          tmpvar_89.x = texture2D (permutationMap, tmpvar_88, 0.0).x;",
            "          p_84 = (p_84 - floor(p_84));",
            "          noise_71 = (noise_71 + (wood_earlycolor_perlin_weights.z * mix (",
            "            (((texture2D (gradientMap, tmpvar_87, 0.0).x * 2.0) - 1.0) * p_84)",
            "          ,",
            "            (((texture2D (gradientMap, tmpvar_89, 0.0).x * 2.0) - 1.0) * (p_84 - 1.0))",
            "          ,",
            "            (((p_84 * p_84) * p_84) * ((p_84 * (",
            "              (p_84 * 6.0)",
            "             - 15.0)) + 10.0))",
            "          )));",
            "          if ((3 < wood_earlycolor_perlin_bands)) {",
            "            lowp float p_90;",
            "            p_90 = (radiusLength_6 * wood_earlycolor_perlin_frequencies.w);",
            "            lowp float modp_91;",
            "            modp_91 = (((float(mod (",
            "              floor(p_90)",
            "            , 256.0))) + 256.0) * 0.00390625);",
            "            lowp vec2 tmpvar_92;",
            "            tmpvar_92.y = 0.0;",
            "            tmpvar_92.x = modp_91;",
            "            lowp vec2 tmpvar_93;",
            "            tmpvar_93.y = 0.0;",
            "            tmpvar_93.x = texture2D (permutationMap, tmpvar_92, 0.0).x;",
            "            lowp vec2 tmpvar_94;",
            "            tmpvar_94.y = 0.0;",
            "            tmpvar_94.x = (modp_91 + 0.00390625);",
            "            lowp vec2 tmpvar_95;",
            "            tmpvar_95.y = 0.0;",
            "            tmpvar_95.x = texture2D (permutationMap, tmpvar_94, 0.0).x;",
            "            p_90 = (p_90 - floor(p_90));",
            "            noise_71 = (noise_71 + (wood_earlycolor_perlin_weights.w * mix (",
            "              (((texture2D (gradientMap, tmpvar_93, 0.0).x * 2.0) - 1.0) * p_90)",
            "            ,",
            "              (((texture2D (gradientMap, tmpvar_95, 0.0).x * 2.0) - 1.0) * (p_90 - 1.0))",
            "            ,",
            "              (((p_90 * p_90) * p_90) * ((p_90 * (",
            "                (p_90 * 6.0)",
            "               - 15.0)) + 10.0))",
            "            )));",
            "          };",
            "        };",
            "      };",
            "    };",
            "    earlyColor_5 = pow (abs(wood_early_color), vec3((1.0 + noise_71)));",
            "  };",
            "  if (wood_use_manual_late_color) {",
            "    lateColor_4 = wood_manual_late_color;",
            "  } else {",
            "    lateColor_4 = pow (abs(earlyColor_5), vec3(wood_late_color_power));",
            "  };",
            "  if (wood_latecolor_perlin_enable) {",
            "    lowp float noise_96;",
            "    noise_96 = 0.0;",
            "    if ((0 < wood_latecolor_perlin_bands)) {",
            "      lowp float p_97;",
            "      p_97 = (radiusLength_6 * wood_latecolor_perlin_frequencies.x);",
            "      lowp float modp_98;",
            "      modp_98 = (((float(mod (",
            "        floor(p_97)",
            "      , 256.0))) + 256.0) * 0.00390625);",
            "      lowp vec2 tmpvar_99;",
            "      tmpvar_99.y = 0.0;",
            "      tmpvar_99.x = modp_98;",
            "      lowp vec2 tmpvar_100;",
            "      tmpvar_100.y = 0.0;",
            "      tmpvar_100.x = texture2D (permutationMap, tmpvar_99, 0.0).x;",
            "      lowp vec2 tmpvar_101;",
            "      tmpvar_101.y = 0.0;",
            "      tmpvar_101.x = (modp_98 + 0.00390625);",
            "      lowp vec2 tmpvar_102;",
            "      tmpvar_102.y = 0.0;",
            "      tmpvar_102.x = texture2D (permutationMap, tmpvar_101, 0.0).x;",
            "      p_97 = (p_97 - floor(p_97));",
            "      noise_96 = (wood_latecolor_perlin_weights.x * mix ((",
            "        ((texture2D (gradientMap, tmpvar_100, 0.0).x * 2.0) - 1.0)",
            "       * p_97), (",
            "        ((texture2D (gradientMap, tmpvar_102, 0.0).x * 2.0) - 1.0)",
            "       *",
            "        (p_97 - 1.0)",
            "      ), (",
            "        ((p_97 * p_97) * p_97)",
            "       *",
            "        ((p_97 * ((p_97 * 6.0) - 15.0)) + 10.0)",
            "      )));",
            "      if ((1 < wood_latecolor_perlin_bands)) {",
            "        lowp float p_103;",
            "        p_103 = (radiusLength_6 * wood_latecolor_perlin_frequencies.y);",
            "        lowp float modp_104;",
            "        modp_104 = (((float(mod (",
            "          floor(p_103)",
            "        , 256.0))) + 256.0) * 0.00390625);",
            "        lowp vec2 tmpvar_105;",
            "        tmpvar_105.y = 0.0;",
            "        tmpvar_105.x = modp_104;",
            "        lowp vec2 tmpvar_106;",
            "        tmpvar_106.y = 0.0;",
            "        tmpvar_106.x = texture2D (permutationMap, tmpvar_105, 0.0).x;",
            "        lowp vec2 tmpvar_107;",
            "        tmpvar_107.y = 0.0;",
            "        tmpvar_107.x = (modp_104 + 0.00390625);",
            "        lowp vec2 tmpvar_108;",
            "        tmpvar_108.y = 0.0;",
            "        tmpvar_108.x = texture2D (permutationMap, tmpvar_107, 0.0).x;",
            "        p_103 = (p_103 - floor(p_103));",
            "        noise_96 = (noise_96 + (wood_latecolor_perlin_weights.y * mix (",
            "          (((texture2D (gradientMap, tmpvar_106, 0.0).x * 2.0) - 1.0) * p_103)",
            "        ,",
            "          (((texture2D (gradientMap, tmpvar_108, 0.0).x * 2.0) - 1.0) * (p_103 - 1.0))",
            "        ,",
            "          (((p_103 * p_103) * p_103) * ((p_103 * (",
            "            (p_103 * 6.0)",
            "           - 15.0)) + 10.0))",
            "        )));",
            "        if ((2 < wood_latecolor_perlin_bands)) {",
            "          lowp float p_109;",
            "          p_109 = (radiusLength_6 * wood_latecolor_perlin_frequencies.z);",
            "          lowp float modp_110;",
            "          modp_110 = (((float(mod (",
            "            floor(p_109)",
            "          , 256.0))) + 256.0) * 0.00390625);",
            "          lowp vec2 tmpvar_111;",
            "          tmpvar_111.y = 0.0;",
            "          tmpvar_111.x = modp_110;",
            "          lowp vec2 tmpvar_112;",
            "          tmpvar_112.y = 0.0;",
            "          tmpvar_112.x = texture2D (permutationMap, tmpvar_111, 0.0).x;",
            "          lowp vec2 tmpvar_113;",
            "          tmpvar_113.y = 0.0;",
            "          tmpvar_113.x = (modp_110 + 0.00390625);",
            "          lowp vec2 tmpvar_114;",
            "          tmpvar_114.y = 0.0;",
            "          tmpvar_114.x = texture2D (permutationMap, tmpvar_113, 0.0).x;",
            "          p_109 = (p_109 - floor(p_109));",
            "          noise_96 = (noise_96 + (wood_latecolor_perlin_weights.z * mix (",
            "            (((texture2D (gradientMap, tmpvar_112, 0.0).x * 2.0) - 1.0) * p_109)",
            "          ,",
            "            (((texture2D (gradientMap, tmpvar_114, 0.0).x * 2.0) - 1.0) * (p_109 - 1.0))",
            "          ,",
            "            (((p_109 * p_109) * p_109) * ((p_109 * (",
            "              (p_109 * 6.0)",
            "             - 15.0)) + 10.0))",
            "          )));",
            "          if ((3 < wood_latecolor_perlin_bands)) {",
            "            lowp float p_115;",
            "            p_115 = (radiusLength_6 * wood_latecolor_perlin_frequencies.w);",
            "            lowp float modp_116;",
            "            modp_116 = (((float(mod (",
            "              floor(p_115)",
            "            , 256.0))) + 256.0) * 0.00390625);",
            "            lowp vec2 tmpvar_117;",
            "            tmpvar_117.y = 0.0;",
            "            tmpvar_117.x = modp_116;",
            "            lowp vec2 tmpvar_118;",
            "            tmpvar_118.y = 0.0;",
            "            tmpvar_118.x = texture2D (permutationMap, tmpvar_117, 0.0).x;",
            "            lowp vec2 tmpvar_119;",
            "            tmpvar_119.y = 0.0;",
            "            tmpvar_119.x = (modp_116 + 0.00390625);",
            "            lowp vec2 tmpvar_120;",
            "            tmpvar_120.y = 0.0;",
            "            tmpvar_120.x = texture2D (permutationMap, tmpvar_119, 0.0).x;",
            "            p_115 = (p_115 - floor(p_115));",
            "            noise_96 = (noise_96 + (wood_latecolor_perlin_weights.w * mix (",
            "              (((texture2D (gradientMap, tmpvar_118, 0.0).x * 2.0) - 1.0) * p_115)",
            "            ,",
            "              (((texture2D (gradientMap, tmpvar_120, 0.0).x * 2.0) - 1.0) * (p_115 - 1.0))",
            "            ,",
            "              (((p_115 * p_115) * p_115) * ((p_115 * (",
            "                (p_115 * 6.0)",
            "               - 15.0)) + 10.0))",
            "            )));",
            "          };",
            "        };",
            "      };",
            "    };",
            "    lateColor_4 = pow (abs(lateColor_4), vec3((1.0 + noise_96)));",
            "  };",
            "  lowp vec3 tmpvar_121;",
            "  tmpvar_121 = ((earlyWoodRatio_63 * earlyColor_5) + ((1.0 - earlyWoodRatio_63) * lateColor_4));",
            "  diffAlbedo_3 = tmpvar_121;",
            "  if (wood_diffuse_perlin_enable) {",
            "    lowp vec3 p_122;",
            "    p_122.xy = p_7.xy;",
            "    p_122.z = (p_7.z * wood_diffuse_perlin_scale_z);",
            "    lowp vec3 p_123;",
            "    p_123 = p_122;",
            "    highp int bands_124;",
            "    bands_124 = wood_diffuse_perlin_bands;",
            "    highp vec4 w_125;",
            "    w_125 = wood_diffuse_perlin_weights;",
            "    highp vec4 f_126;",
            "    f_126 = wood_diffuse_perlin_frequencies;",
            "    lowp float noise_128;",
            "    noise_128 = 0.0;",
            "    for (int i_127 = 0; i_127 < 4; ++i_127) {",
            "      if ((i_127 >= bands_124)) {",
            "        break;",
            "      };",
            "      lowp vec3 p_129;",
            "      p_129 = (p_123 * f_126[i_127]);",
            "      lowp vec4 AA_130;",
            "      lowp vec3 modp_131;",
            "      lowp vec3 tmpvar_132;",
            "      tmpvar_132 = (vec3(mod (floor(p_129), 256.0)));",
            "      modp_131.z = tmpvar_132.z;",
            "      modp_131.xy = (tmpvar_132.xy * 0.00390625);",
            "      AA_130 = ((texture2D (perm2DMap, modp_131.xy, 0.0) * 255.0) + tmpvar_132.z);",
            "      AA_130 = ((vec4(mod (floor(AA_130), 256.0))) * 0.00390625);",
            "      lowp vec2 tmpvar_133;",
            "      tmpvar_133.y = 0.0;",
            "      tmpvar_133.x = AA_130.x;",
            "      lowp vec2 tmpvar_134;",
            "      tmpvar_134.y = 0.0;",
            "      tmpvar_134.x = AA_130.y;",
            "      lowp vec2 tmpvar_135;",
            "      tmpvar_135.y = 0.0;",
            "      tmpvar_135.x = AA_130.z;",
            "      lowp vec2 tmpvar_136;",
            "      tmpvar_136.y = 0.0;",
            "      tmpvar_136.x = AA_130.w;",
            "      lowp vec2 tmpvar_137;",
            "      tmpvar_137.y = 0.0;",
            "      tmpvar_137.x = (AA_130.x + 0.00390625);",
            "      lowp vec2 tmpvar_138;",
            "      tmpvar_138.y = 0.0;",
            "      tmpvar_138.x = (AA_130.y + 0.00390625);",
            "      lowp vec2 tmpvar_139;",
            "      tmpvar_139.y = 0.0;",
            "      tmpvar_139.x = (AA_130.z + 0.00390625);",
            "      lowp vec2 tmpvar_140;",
            "      tmpvar_140.y = 0.0;",
            "      tmpvar_140.x = (AA_130.w + 0.00390625);",
            "      p_129 = (p_129 - floor(p_129));",
            "      lowp vec3 tmpvar_141;",
            "      tmpvar_141 = (((p_129 * p_129) * p_129) * ((p_129 *",
            "        ((p_129 * 6.0) - 15.0)",
            "      ) + 10.0));",
            "      noise_128 = (noise_128 + (w_125[i_127] * mix (",
            "        mix (mix (dot ((",
            "          (texture2D (permGradMap, tmpvar_133, 0.0).xyz * 2.0)",
            "         - 1.0), p_129), dot ((",
            "          (texture2D (permGradMap, tmpvar_135, 0.0).xyz * 2.0)",
            "         - 1.0), (p_129 + vec3(-1.0, 0.0, 0.0))), tmpvar_141.x), mix (dot ((",
            "          (texture2D (permGradMap, tmpvar_134, 0.0).xyz * 2.0)",
            "         - 1.0), (p_129 + vec3(0.0, -1.0, 0.0))), dot ((",
            "          (texture2D (permGradMap, tmpvar_136, 0.0).xyz * 2.0)",
            "         - 1.0), (p_129 + vec3(-1.0, -1.0, 0.0))), tmpvar_141.x), tmpvar_141.y)",
            "      ,",
            "        mix (mix (dot ((",
            "          (texture2D (permGradMap, tmpvar_137, 0.0).xyz * 2.0)",
            "         - 1.0), (p_129 + vec3(0.0, 0.0, -1.0))), dot ((",
            "          (texture2D (permGradMap, tmpvar_139, 0.0).xyz * 2.0)",
            "         - 1.0), (p_129 + vec3(-1.0, 0.0, -1.0))), tmpvar_141.x), mix (dot ((",
            "          (texture2D (permGradMap, tmpvar_138, 0.0).xyz * 2.0)",
            "         - 1.0), (p_129 + vec3(0.0, -1.0, -1.0))), dot ((",
            "          (texture2D (permGradMap, tmpvar_140, 0.0).xyz * 2.0)",
            "         - 1.0), (p_129 + vec3(-1.0, -1.0, -1.0))), tmpvar_141.x), tmpvar_141.y)",
            "      , tmpvar_141.z)));",
            "    };",
            "    diffAlbedo_3 = pow (abs(tmpvar_121), vec3((1.0 + noise_128)));",
            "  };",
            "  if (wood_use_pores) {",
            "    lowp float woodWeight_142;",
            "    woodWeight_142 = 0.0;",
            "    if ((wood_pore_type == 0)) {",
            "      woodWeight_142 = 1.0;",
            "    } else {",
            "      if ((wood_pore_type == 1)) {",
            "        woodWeight_142 = earlyWoodRatio_63;",
            "      } else {",
            "        if ((wood_pore_type == 2)) {",
            "          woodWeight_142 = (1.0 - earlyWoodRatio_63);",
            "        } else {",
            "          woodWeight_142 = -1.0;",
            "        };",
            "      };",
            "    };",
            "    lowp vec3 p_143;",
            "    p_143 = p_7;",
            "    lowp float tmpvar_144;",
            "    lowp float invRsq_146;",
            "    lowp float weight_147;",
            "    lowp vec2 right_148;",
            "    lowp vec2 left_149;",
            "    if ((woodWeight_142 < 0.0)) {",
            "      tmpvar_144 = 0.0;",
            "    } else {",
            "      lowp float tmpvar_150;",
            "      tmpvar_150 = (wood_pore_radius * woodWeight_142);",
            "      left_149 = floor(((p_7.xy - tmpvar_150) / wood_pore_cell_dim));",
            "      right_148 = floor(((p_7.xy + tmpvar_150) / wood_pore_cell_dim));",
            "      weight_147 = 0.0;",
            "      invRsq_146 = (1.0/((tmpvar_150 * tmpvar_150)));",
            "      for (int j_145 = 0; j_145 <= 4; ++j_145) {",
            "        if ((j_145 > int((right_148.y - left_149.y)))) {",
            "          continue;",
            "        };",
            "        for (int i_151 = 0; i_151 <= 4; ++i_151) {",
            "          lowp float impPosY_152;",
            "          lowp float impPosX_153;",
            "          if ((i_151 > int((right_148.x - left_149.x)))) {",
            "            continue;",
            "          };",
            "          lowp vec2 tmpvar_154;",
            "          tmpvar_154.x = (float(i_151) + left_149.x);",
            "          tmpvar_154.y = (float(j_145) + left_149.y);",
            "          lowp float tmpvar_155;",
            "          lowp vec2 k_156;",
            "          k_156 = ((vec2(mod (tmpvar_154, vec2(256.0, 256.0)))) * 0.00390625);",
            "          lowp vec2 tmpvar_157;",
            "          tmpvar_157.y = 0.0;",
            "          tmpvar_157.x = k_156.x;",
            "          lowp vec2 tmpvar_158;",
            "          tmpvar_158.y = 0.0;",
            "          tmpvar_158.x = (texture2D (permutationMap, tmpvar_157).x + k_156.y);",
            "          tmpvar_155 = (texture2D (permutationMap, tmpvar_158).x * 255.0);",
            "          impPosX_153 = ((tmpvar_154.x + (",
            "            (float(mod (tmpvar_155, 16.0)))",
            "           * 0.06666667)) * wood_pore_cell_dim);",
            "          impPosY_152 = ((tmpvar_154.y + (",
            "            floor((tmpvar_155 / 16.0))",
            "           * 0.06666667)) * wood_pore_cell_dim);",
            "          lowp float rsq_159;",
            "          rsq_159 = (((",
            "            (p_143.x - impPosX_153)",
            "           *",
            "            (p_143.x - impPosX_153)",
            "          ) + (",
            "            (p_143.y - impPosY_152)",
            "           *",
            "            (p_143.y - impPosY_152)",
            "          )) * invRsq_146);",
            "          lowp float tmpvar_160;",
            "          if ((rsq_159 >= 1.0)) {",
            "            tmpvar_160 = 0.0;",
            "          } else {",
            "            lowp float tmpvar_161;",
            "            tmpvar_161 = (1.0 - rsq_159);",
            "            tmpvar_160 = ((tmpvar_161 * tmpvar_161) * tmpvar_161);",
            "          };",
            "          weight_147 = (weight_147 + tmpvar_160);",
            "        };",
            "      };",
            "      tmpvar_144 = weight_147;",
            "    };",
            "    diffAlbedo_3 = pow (abs(diffAlbedo_3), vec3(((",
            "      (wood_pore_color_power - 1.0)",
            "     * tmpvar_144) + 1.0)));",
            "  };",
            "  if (wood_use_rays) {",
            "    lowp vec3 p_162;",
            "    p_162 = p_7;",
            "    lowp float radialLength_164;",
            "    lowp float weight_165;",
            "    lowp ivec2 arrSegs_166;",
            "    lowp float sliceIdx_167;",
            "    lowp int segIdx1_168;",
            "    lowp int tmpvar_169;",
            "    tmpvar_169 = int(floor((p_7.z / wood_ray_seg_length_z)));",
            "    lowp float tmpvar_170;",
            "    tmpvar_170 = ((p_7.z / wood_ray_seg_length_z) - float(tmpvar_169));",
            "    segIdx1_168 = (tmpvar_169 - 1);",
            "    if ((tmpvar_170 > 0.5)) {",
            "      segIdx1_168 = (tmpvar_169 + 1);",
            "    };",
            "    lowp float tmpvar_171;",
            "    lowp float tmpvar_172;",
            "    tmpvar_172 = (min (abs(",
            "      (p_7.y / p_7.x)",
            "    ), 1.0) / max (abs(",
            "      (p_7.y / p_7.x)",
            "    ), 1.0));",
            "    lowp float tmpvar_173;",
            "    tmpvar_173 = (tmpvar_172 * tmpvar_172);",
            "    tmpvar_173 = (((",
            "      ((((",
            "        ((((-0.01213232 * tmpvar_173) + 0.05368138) * tmpvar_173) - 0.1173503)",
            "       * tmpvar_173) + 0.1938925) * tmpvar_173) - 0.3326756)",
            "     * tmpvar_173) + 0.9999793) * tmpvar_172);",
            "    tmpvar_173 = (tmpvar_173 + (float(",
            "      (abs((p_7.y / p_7.x)) > 1.0)",
            "    ) * (",
            "      (tmpvar_173 * -2.0)",
            "     + 1.570796)));",
            "    tmpvar_171 = (tmpvar_173 * sign((p_7.y / p_7.x)));",
            "    if ((abs(p_7.x) > (1e-08 * abs(p_7.y)))) {",
            "      if ((p_7.x < 0.0)) {",
            "        if ((p_7.y >= 0.0)) {",
            "          tmpvar_171 += 3.141593;",
            "        } else {",
            "          tmpvar_171 = (tmpvar_171 - 3.141593);",
            "        };",
            "      };",
            "    } else {",
            "      tmpvar_171 = (sign(p_7.y) * 1.570796);",
            "    };",
            "    lowp float tmpvar_174;",
            "    tmpvar_174 = floor(((",
            "      (tmpvar_171 + 3.141593)",
            "     * 0.1591549) * wood_ray_num_slices));",
            "    sliceIdx_167 = tmpvar_174;",
            "    if ((tmpvar_174 == wood_ray_num_slices)) {",
            "      sliceIdx_167 = (tmpvar_174 - 1.0);",
            "    };",
            "    lowp ivec2 tmpvar_175;",
            "    tmpvar_175.x = tmpvar_169;",
            "    tmpvar_175.y = segIdx1_168;",
            "    arrSegs_166 = tmpvar_175;",
            "    weight_165 = 0.0;",
            "    radialLength_164 = sqrt(dot (p_7.xy, p_7.xy));",
            "    for (int seg_163 = 0; seg_163 < 2; ++seg_163) {",
            "      lowp vec3 p1_176;",
            "      lowp float rayTheta_177;",
            "      lowp vec2 tmpvar_178;",
            "      tmpvar_178.x = sliceIdx_167;",
            "      tmpvar_178.y = float(arrSegs_166[seg_163]);",
            "      lowp float tmpvar_179;",
            "      lowp vec2 k_180;",
            "      k_180 = ((vec2(mod (tmpvar_178, vec2(256.0, 256.0)))) * 0.00390625);",
            "      lowp vec2 tmpvar_181;",
            "      tmpvar_181.y = 0.0;",
            "      tmpvar_181.x = k_180.x;",
            "      lowp vec2 tmpvar_182;",
            "      tmpvar_182.y = 0.0;",
            "      tmpvar_182.x = (texture2D (permutationMap, tmpvar_181).x + k_180.y);",
            "      tmpvar_179 = (texture2D (permutationMap, tmpvar_182).x * 255.0);",
            "      lowp float tmpvar_183;",
            "      tmpvar_183 = ((float(mod (tmpvar_179, 16.0))) * 0.06666667);",
            "      if ((radialLength_164 < (5.0 * tmpvar_183))) {",
            "        continue;",
            "      };",
            "      rayTheta_177 = (((",
            "        (sliceIdx_167 + tmpvar_183)",
            "       / wood_ray_num_slices) * 6.283185) - 3.141593);",
            "      lowp vec3 tmpvar_184;",
            "      tmpvar_184.z = 0.0;",
            "      tmpvar_184.x = cos(rayTheta_177);",
            "      tmpvar_184.y = sin(rayTheta_177);",
            "      p1_176.xy = p_162.xy;",
            "      p1_176.z = (p_162.z - ((",
            "        float(arrSegs_166[seg_163])",
            "       +",
            "        ((tmpvar_179 / 16.0) * 0.06666667)",
            "      ) * wood_ray_seg_length_z));",
            "      p1_176.z = (p1_176.z / wood_ray_ellipse_z2x);",
            "      lowp vec3 tmpvar_185;",
            "      tmpvar_185 = -(p1_176);",
            "      lowp vec3 tmpvar_186;",
            "      tmpvar_186 = ((tmpvar_184.yzx * tmpvar_185.zxy) - (tmpvar_184.zxy * tmpvar_185.yzx));",
            "      lowp float tmpvar_187;",
            "      tmpvar_187 = (sqrt(dot (tmpvar_186, tmpvar_186)) / sqrt(dot (tmpvar_184, tmpvar_184)));",
            "      lowp float rsq_188;",
            "      rsq_188 = ((tmpvar_187 * tmpvar_187) * (1.0/((wood_ray_ellipse_radius_x * wood_ray_ellipse_radius_x))));",
            "      lowp float tmpvar_189;",
            "      if ((rsq_188 >= 1.0)) {",
            "        tmpvar_189 = 0.0;",
            "      } else {",
            "        lowp float tmpvar_190;",
            "        tmpvar_190 = (1.0 - rsq_188);",
            "        tmpvar_189 = ((tmpvar_190 * tmpvar_190) * tmpvar_190);",
            "      };",
            "      weight_165 = (weight_165 + tmpvar_189);",
            "    };",
            "    diffAlbedo_3 = pow (abs(diffAlbedo_3), vec3(((",
            "      (wood_ray_color_power - 1.0)",
            "     * weight_165) + 1.0)));",
            "  };",
            "  if (wood_use_groove_roughness) {",
            "    roughness_2 = ((earlyWoodRatio_63 * wood_groove_roughness) + ((1.0 - earlyWoodRatio_63) * surface_roughness));",
            "  };",
            "  roughness_inout = roughness_2;",
            "  return diffAlbedo_3;",
            "}",

            "#endif",

            "#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0",
            "vec3 DiffuseLobe(vec3 diffuseColor)",
            "{",
               "return diffuseColor * RECIPROCAL_PI;",
            "}",

            "vec3 Rotate(vec3 vec, float angle)",
            "{",
                "float s = sin(angle);",
                "float c = cos(angle);",
                "return vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);",
            "}",

            // Computes the GGX normal distribution function term, using a tangent-space normal.
            // NOTE: Based on the evaluation code from the Spectrum renderer.
            "float NDF_GGX(float alphaU, float alphaV, vec3 normal)",
            "{",
                "float nx2 = sqr(normal.x);",
                "float ny2 = sqr(normal.y);",
                "float nz2 = sqr(normal.z);",
                "float scale = 1.0/(alphaU * alphaV * PI);",
                "return scale/sqr(nx2/sqr(alphaU) + ny2/sqr(alphaV) + nz2);",
            "}",

            // Computes the shadowing / masking term (G1) appropriate for the GGX NDF.
            // NOTE: Based on "Microfacet Models for Refraction through Rough Surfaces" (Walter, EGSR07).
            "float G1_GGX(float aSqrd)",
            "{",
            "    return 2.0 / (1.0 + sqrt(1.0 + aSqrd));",
            "}",

            "vec3 MicrofacetLobe(",
            "vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,",
            "float roughness, float anisotropy, float rotation, vec3 reflectance)",
            "{",
                // Determine the "alpha" in each direction, based on anisotropy.
                "vec2 alpha = RoughnessToAlpha(roughness, anisotropy);",

                // Rotate the local half-angle vector.
                "Hlocal = Rotate(Hlocal, rotation);",

                // Compute the Fresnel (F) term.
                "vec3 F = Fresnel_Schlick(reflectance, VdotH);",

                // Compute the normal distribution function (D) term.
                "float D = NDF_GGX(alpha.x, alpha.y, Hlocal);",

                // Compute the shadowing / masking (G) term.
                // NOTE: Based on "Microfacet Models for Refraction through Rough Surfaces" (Walter, EGSR07).
                "float alpha2 = max(sqr(alpha.x), sqr(alpha.y));",
                "float alpha2NL = aSqrd(alpha2, NdotL);",
                "float alpha2NV = aSqrd(alpha2, NdotV);",
                "float G = G1_GGX(alpha2NL) * G1_GGX(alpha2NV);",

                // Compute and return the specular term using the microfacet model.
                "return max(F * D * G / (4.0 * NdotL * NdotV), vec3(0.0));",
            "}",

            "#if defined( PRISMOPAQUE )",
            // ==============================================
            // Opaque Material Type
            // ==============================================

            // Computes the BRDF for the Opaque material type.
            "vec3 BRDF_Opaque(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, ",
            "                 vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, ",
            "                 float opaqueF0, vec3 opaqueAlbedo)",
            "{",
                // Compute the diffuse term with a diffuse lobe.
            "    vec3 diffuse = DiffuseLobe(opaqueAlbedo);",
                // Compute the specular term with a microfacet lobe, scaled by the surface albedo.
            "    vec3 specular = surfaceAlbedo * MicrofacetLobe(",
            "        Hlocal, NdotL, NdotH, NdotV, VdotH,",
            "        surfaceRoughness, surfaceAnisotropy, surfaceRotation, vec3(opaqueF0));",

                // Return the sum of the diffuse and specular terms.
            "    return (specular+diffuse)*NdotL;",
            "}",
            "#elif defined( PRISMMETAL )",
            // ==============================================
            // Metal Material Type
            // ==============================================

            // Computes the BRDF for the Opaque material type
            "vec3 BRDF_Metal(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, ",
            "                vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, ",
            "                vec3 metalF0)",
            "{",
                // Compute the specular term with a microfacet lobe, scaled by the surface albedo.
            "    vec3 specular = surfaceAlbedo * MicrofacetLobe(",
            "        Hlocal, NdotL, NdotH, NdotV, VdotH,",
            "        surfaceRoughness, surfaceAnisotropy, surfaceRotation, metalF0);",

                // Return the specular term.
                // NOTE: Metal *only* reflects light, no scattering.
            "    return specular*NdotL;",
            "}",
            "#elif defined( PRISMLAYERED )",
            // ==============================================
            // Layered Material Type
            // ==============================================

            // Computes the BRDF for the Layered material type.
            "vec3 BRDF_Layered(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, ",
            "                  vec3 Hlocal2, float N2dotL, float N2dotH, float N2dotV, ",
            "                  vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,",
            "                  float layeredF0, vec3 layeredDiffuse, float layeredRoughness, float layeredAnisotropy,",
            "                  float layeredRotation, vec3 bottom_f0, float layeredFraction)",
            "{",
                // Compute the Fresnel reflectance of the top surface, using the incoming and outgoing
                // directions and the normal.  Use this to compute the amount of light passing into the surface
                // *and* not coming back out.
            "    vec3 Fl = Fresnel_Schlick(vec3(layeredF0), NdotL);",
            "    vec3 Fv = Fresnel_Schlick(vec3(layeredF0), NdotV);",
            "    vec3 amount = (1.0 - Fl) * (1.0 - Fv);",

                // Compute the specular term of the top layer, scaled by the surface albedo.
            "    vec3 topSpecular = surfaceAlbedo * MicrofacetLobe(",
            "        Hlocal, NdotL, NdotH, NdotV, VdotH,",
            "        surfaceRoughness, surfaceAnisotropy, surfaceRotation,",
            "        vec3(layeredF0));",

                // Compute the diffuse term of the top layer with a diffuse lobe.
            "    vec3 topDiffuse = DiffuseLobe(layeredDiffuse);",

                // Compute the specular term of the bottom (metal) layer.
            "    vec3 botSpecular = MicrofacetLobe(",
            "        Hlocal2, N2dotL, N2dotH, N2dotV, VdotH,",
            "        layeredRoughness, layeredAnisotropy, layeredRotation,",
            "        bottom_f0);",

                // Return the top specular term, added to a linear combination of the top diffuse term and
                // bottom specular term, using the fraction parameter, and scaled by the light amount.
            "    return topSpecular*NdotL + amount * mix(topDiffuse*NdotL, botSpecular*N2dotL, layeredFraction);",
            "}",

            "#elif defined( PRISMTRANSPARENT )",
            "vec3 BRDF_Transparent(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, ",
            "                vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation)",
            "{",
                // Compute reflectance from the index of refraction.
            "    vec3 reflectance = vec3(IORToReflectance(transparent_ior));",

                // Compute the specular term with a microfacet lobe, scaled by the surface albedo.
            "    vec3 specular = surfaceAlbedo * MicrofacetLobe(",
            "        Hlocal, NdotL, NdotH, NdotV, VdotH,",
            "        surfaceRoughness, surfaceAnisotropy, surfaceRotation, reflectance);",

                // Return the specular term.
                // NOTE: The absorption color is handled as part of the environment component.
            "    return specular*NdotL;",
            "}",

            "#elif defined( PRISMWOOD )",
            // ==============================================
            // 3D Wood Material Type
            // ==============================================

            // Computes the BRDF for the 3D Wood material type.
            "vec3 BRDF_Wood(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, ",
            "                 vec3 surfaceAlbedo, float surfaceRoughness, vec3 woodDiffuse)",
            "{",
                // Compute the diffuse term with a diffuse lobe.
            "    vec3 diffuse = DiffuseLobe(woodDiffuse);",
                // Compute the specular term with a microfacet lobe.
            "    vec3 specular = surfaceAlbedo * MicrofacetLobe(",
            "        Hlocal, NdotL, NdotH, NdotV, VdotH,",
            "        surfaceRoughness, 0.0, 0.0, vec3(0.04));",

                // Return the sum of the diffuse and specular terms.
            "    return (specular+diffuse)*NdotL;",
            "}",
            "#endif",
            "#endif",

            "#if defined( USE_ENVMAP )",
            "#if defined( PRISMOPAQUE )",
            // ==============================================
            // Opaque Material Type
            // ==============================================
            // Computes the radiance for the Opaque material type under an image-based environment light.
            "vec3 Environment_Opaque(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness,",
            "                        float opaqueF0, vec3 opaqueAlbedo)",
            "{",
                // Convert alpha to roughness, and convert that to a comparable Phong exponent.
            "    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;",
            "    float exponent = AlphaToPhong(alpha);",
            "    float reflMipIndex = ExponentToReflMipIndex(exponent);",

                // Compute the Fresnel (F) term from the mirror reflection angle.
            "    vec3 F = Fresnel_Rough(vec3(opaqueF0), NdotV, alpha);",

            "#if defined( USE_IRRADIANCEMAP )",
                // Sample the irradiance environment map using the surface normal, multiply by the diffuse
                // and balance with the Fresnel term to produce the diffuse term.
            "    vec3 envIrradiance = sampleNormal(N);",
            "#else",
            "    vec3 envIrradiance = vec3(1.0);",
            "#endif",
            "    vec3 diffuse = (1.0 - F) * opaqueAlbedo * envIrradiance;",

            "     vec3 luminanceModifier;",
            GetPrismMapSampleChunk("opaque_luminance_modifier", "luminanceModifier", false, true),
            "    vec3 emission = luminanceModifier * opaque_luminance;",

                // Sample the specular (glossy and radiance) environment maps, and multiply by the Fresnel term
                // and surface albedo to produce the specular term.
            "    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);",
            "    vec3 specular = F* surfaceAlbedo * envSpecular;",

                // Return the sum of the diffuse and specular terms.
            "    return diffuse + specular + emission;",
            "}",

            "#elif defined( PRISMMETAL )",
            // ==============================================
            // Metal Material Type
            // ==============================================

            // Computes the radiance for the Metal material type under an image-based environment light.
            "vec3 Environment_Metal(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 metalF0)",
            "{",
                // Convert alpha to roughness, and convert that to a comparable Phong exponent.
            "    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;",
            "    float exponent = AlphaToPhong(alpha);",
            "    float reflMipIndex = ExponentToReflMipIndex(exponent);",

                // Compute the Fresnel (F) term from the mirror reflection angle.
            "    vec3 F = Fresnel_Rough(metalF0, NdotV, alpha);",

                // Sample the specular (glossy and radiance) environment maps, and multiply by the Fresnel term
                // and surface albedo to produce the specular term.
            "    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);",
            "    vec3 specular = F * surfaceAlbedo * envSpecular;",

                // Return the specular term.
            "    return specular;",
            "}",

            "#elif defined( PRISMLAYERED )",
            // ==============================================
            // Layered Material Type
            // ==============================================

            // Computes the radiance for the Layered material type under an image-based environment light.
            "vec3 Environment_Layered(vec3 N, vec3 V, float NdotV, vec3 N2, float N2dotV, vec3 surfaceAlbedo, float surfaceRoughness,",
            "                         float layeredF0, vec3 layeredDiffuse, float layeredRoughness, float layeredAnisotropy,",
            "                         float layeredRotation, vec3 bottom_f0, float layeredFraction)",
            "{",
                // Compute the specular term of the top layer.
                // NOTE: See the Opaque implementation for detailed comments.
                // NOTE: This does not use the "rough" Fresnel term, just the Schlick one.
            "    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;",
            "    float exponent = AlphaToPhong(alpha);",
            "    float reflMipIndex = ExponentToReflMipIndex(exponent);",
            "    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);",
            "    vec3 F = Fresnel_Schlick(vec3(layeredF0), NdotV);",
            "    vec3 topSpecular = F * surfaceAlbedo * envSpecular;",

                // Compute the amount of light passing into the surface.
            "    vec3 amount = (1.0 - F);",

                // Compute the diffuse term of the top layer.
                // NOTE: See the Opaque implementation for detailed comments.    
            "#if defined( USE_IRRADIANCEMAP )",
                // Sample the irradiance environment map using the surface normal.
            "    vec3 envIrradiance = sampleNormal(N);",
            "#else",
            "    vec3 envIrradiance = vec3(1.0);",
            "#endif",
            "    vec3 topDiffuse = layeredDiffuse * envIrradiance;",

                // Compute the specular term of the bottom layer.
                // NOTE: See the Opaque implementation for detailed comments.
            "    alpha = RoughnessToAlpha(layeredRoughness, 0.0).x;",
            "    exponent = AlphaToPhong(alpha);",
            "    reflMipIndex = ExponentToReflMipIndex(exponent);",
            "    envSpecular = sampleReflection(N2, V, reflMipIndex);",
            "    F = Fresnel_Rough(bottom_f0, N2dotV, alpha);",
            "    vec3 botSpecular = F * envSpecular;",

                // Return the top specular term, added to a linear combination of the top diffuse term and
                // bottom specular term, using the fraction parameter, and scaled the light amount.
            "    return topSpecular + amount * mix(topDiffuse, botSpecular, layeredFraction);",
            "}",

            "#elif defined( PRISMTRANSPARENT )",
            // ==============================================
            // Transparent Material Type
            // ==============================================

            "vec3 Environment_Transparent(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness)",
            "{",
                // Convert alpha to roughness, and convert that to a comparable Phong exponent.
            "    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;",
            "    float exponent = AlphaToPhong(alpha);",
            "    float reflMipIndex = ExponentToReflMipIndex(exponent);",

                // Compute the Fresnel (F) term from the mirror reflection angle.
            "    vec3 reflectance = vec3(IORToReflectance(transparent_ior));",
            "    vec3 F = Fresnel_Rough(reflectance, NdotV, alpha);",

                // Sample the specular (glossy and radiance) environment maps, and multiply by the Fresnel term
                // and surface albedo to produce the specular term.
            "    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);",
            "    vec3 specular = F * surfaceAlbedo * envSpecular;",

            "#if defined( USE_IRRADIANCEMAP )",
                // Sample the irradiance environment map using the surface normal.
            "    vec3 envIrradiance = sampleNormal(N);",
            "#else",
            "    vec3 envIrradiance = vec3(1.0);",
            "#endif",

                // Add a "color" term that take the absorption color into account.  This is basically a diffuse
                // component, so that some kind of lighting is included, which is needed for HDR consistency.
                // NOTE: This is *not* physical, and is just a cheap way to include the absorption color.
            "    vec3 color = 0.5 * (1.0 - F) * transparent_color * envIrradiance;",

                // Return the specular term, with the "color" term added.
            "    return specular + color;",
            "}",

            "#elif defined( PRISMWOOD )",
            // ==============================================
            // Wood Material Type
            // ==============================================
            "vec3 Environment_Wood(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 woodDiffuse)",
            "{",
                // Convert alpha to roughness, and convert that to a comparable Phong exponent.
            "    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;",
            "    float exponent = AlphaToPhong(alpha);",
            "    float reflMipIndex = ExponentToReflMipIndex(exponent);",

                // Compute the Fresnel (F) term from the mirror reflection angle.
            "    vec3 F = Fresnel_Rough(vec3(0.04), NdotV, alpha);",

            "#if defined( USE_IRRADIANCEMAP )",
                // Sample the irradiance environment map using the surface normal, multiply by the diffuse
                // and balance with the Fresnel term to produce the diffuse term.
            "    vec3 envIrradiance = sampleNormal(N);",
            "#else",
            "    vec3 envIrradiance = vec3(1.0);",
            "#endif",
            "    vec3 diffuse = (1.0 - F) * woodDiffuse * envIrradiance;",
                // Sample the specular (glossy and radiance) environment maps, and multiply by the Fresnel term
                // and surface albedo to produce the specular term.
            "    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);",
            "    vec3 specular = F * surfaceAlbedo * envSpecular;",

                // Return the sum of the diffuse and specular terms.
            "    return diffuse + specular;",
            "}",
            "#endif",
            "#endif",

            "varying vec3 vNormal;",
            "varying vec3 vViewPosition;",
            avs.CutPlanesShaderChunk,

            "void main() {",
            "#if NUM_CUTPLANES > 0",
                "checkCutPlanes(vWorldPosition);",
            "#endif",
                "vec3 N = normalize(vNormal);",
            "#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )" +
            " || MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0",
            "#ifndef USE_MAP",
                "vec3 Tu = normalize(vTangent);",
                "vec3 Tv = normalize(vBitangent);",
            "#else",
                // Per-Pixel Tangent Space Normal Mapping
                // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html
                "vec3 q0 = dFdx( -vViewPosition );",
                "vec3 q1 = dFdy( -vViewPosition );",
                "vec2 st0 = dFdx( vUv );",
                "vec2 st1 = dFdy( vUv );",

                "vec3 Tu = normalize(  q0 * st1.t - q1 * st0.t );",
                "vec3 Tv = normalize( -q0 * st1.s + q1 * st0.s );",
            "#endif",
            "#endif",
                //With ortho projection, the view direction needs to be
                //adjusted so that all view direction rays (for all pixels) are parallel
                //instead of going from the camera position directly to the vertex like
                //in perspective. In view space, this is kind of easy -- the view vector is along Z.
                //TODO: Actially the vViewPosition varying is the position of the camers wrt the vertex
                //so the naming of the variable can be clarified.
                "vec3 V;",
                "if (projectionMatrix[3][3] == 0.0) {",
                    "V = normalize( vViewPosition );",
                "} else {",
                    "V = vec3(0.0, 0.0, 1.0);",
                "}",
                "N = faceforward(N, -V, N);",

            "#if defined(PRISMLAYERED)",
                "vec3 N2 = N;",
            "#endif",

                "#ifndef FLAT_SHADED",
                    "vec3 normal = normalize( vNormal );",
                    "#ifdef DOUBLE_SIDED",
                        "normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
                    "#endif",
                "#else",
                    "vec3 fdx = dFdx( vViewPosition );",
                    "vec3 fdy = dFdy( vViewPosition );",
                    "vec3 normal = normalize( cross( fdx, fdy ) );",
                "#endif",

                "vec3 geomNormal = normal;",

                "#if defined( USE_SURFACE_NORMAL_MAP )",
                "if (surface_normal_map_bumpmapType == 0)",
                "     N = heightMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);",
                "else",
                "     N = normalMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);",
                "#endif",

                "#if defined( USE_LAYERED_NORMAL_MAP )",
                "if (layered_normal_map_bumpmapType == 0)",
                "     N2 = heightMapTransform(layered_normal_map, vUv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);",
                "else",
                "     N2 = normalMapTransform(layered_normal_map, vUv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);",
                "#endif",

                // Compute NdotV, cosine of the angle between the normal and the view direction.  Clamp this to
                // avoid negative values, which would cause artifacts.
                // NOTE: The view direction could be below the surface normal due to interpolated normals or
                // bump mapping, even if the surface itself is visible.
                "float NdotV = dot(N, V);",
            "#if defined(PRISMLAYERED)",
                "float N2dotV = dot(N2, V);",
            "#endif",

                "vec3 surfaceAlbedo;",
                GetPrismMapSampleChunk("surface_albedo", "surfaceAlbedo", false, true),
                "float surfaceRoughness;",
                GetPrismMapSampleChunk("surface_roughness", "surfaceRoughness", true, false),
                "float surfaceAnisotropy;",
                GetPrismMapSampleChunk("surface_anisotropy", "surfaceAnisotropy", true, false),
                "float surfaceRotation;",
                GetPrismMapSampleChunk("surface_rotation", "surfaceRotation", true, false),

                "#if defined(PRISMOPAQUE)",
                "float opaqueF0;",
                GetPrismMapSampleChunk("opaque_f0", "opaqueF0", true, false),
                "vec3 opaqueAlbedo;",
                GetPrismMapSampleChunk("opaque_albedo", "opaqueAlbedo", false, true),

                "#elif defined(PRISMMETAL)",
                "vec3 metalF0;",
                GetPrismMapSampleChunk("metal_f0", "metalF0", false, true),

                "#elif defined(PRISMLAYERED)",
                "float layeredF0;",
                GetPrismMapSampleChunk("layered_f0", "layeredF0", true, false),
                "vec3 layeredDiffuse;",
                GetPrismMapSampleChunk("layered_diffuse", "layeredDiffuse", false, true),
                "float layeredRoughness;",
                GetPrismMapSampleChunk("layered_roughness", "layeredRoughness", true, false),
                "float layeredAnisotropy;",
                GetPrismMapSampleChunk("layered_anisotropy", "layeredAnisotropy", true, false),
                "float layeredRotation;",
                GetPrismMapSampleChunk("layered_rotation", "layeredRotation", true, false),
                "vec3 bottom_f0;",
                GetPrismMapSampleChunk("layered_bottom_f0", "bottom_f0", false, true),
                "float layeredFraction;",
                GetPrismMapSampleChunk("layered_fraction", "layeredFraction", true, false),
                "#elif defined(PRISMWOOD)",
                "vec3 woodDiffuse = NoiseWood(surfaceRoughness);",
                "#endif",

                "vec3 outRadianceLight = vec3(0.0);",
                "#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0",
                "vec3 lightDirection[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];",
                "vec3 lightColor[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];",

                "#if MAX_DIR_LIGHTS > 0",
                "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

                    "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
                    "lightDirection[i] = normalize( lDirection.xyz );",
                    "lightColor[i] = SRGBToLinear(directionalLightColor[ i ]);",
                "}",
                "#endif",

                "#if MAX_POINT_LIGHTS > 0",
                "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
                    "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
                    "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
                    "lightDirection[MAX_DIR_LIGHTS + i] = normalize( lVector );",
                    "float lDistance = 1.0;",
                    "if ( pointLightDistance[ i ] > 0.0 )",
                        "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
                    "lightColor[MAX_DIR_LIGHTS + i] = SRGBToLinear(pointLightColor[ i ]) * lDistance;",
                "}",
                "#endif",

                "#if MAX_SPOT_LIGHTS > 0",
                "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
                    "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
                    "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
                    "lightDirection[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = normalize( lVector );",
                    "float lDistance = 1.0;",
                    "if ( spotLightDistance[ i ] > 0.0 )",
                        "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
                    "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
                    "if ( spotEffect > spotLightAngleCos[ i ] )",
                            "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
                    "lightColor[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = SRGBToLinear(spotLightColor[ i ]) * lDistance * spotEffect;",
                "}",
                "#endif",

                "for( int i = 0; i < MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS; i ++ ) {",
                    "vec3 L = lightDirection[i];",
                    "float NdotL = dot(N, L);",
                    "vec3 H = normalize(L + V);",
                    "float NdotH = dot(N, H);",
                    "float VdotH = dot(V, H);",
                    "float Hu = dot(H, Tu);",
                    "float Hv = dot(H, Tv);",
                    "vec3 Hlocal = vec3(Hu, Hv, NdotH);",
                    "#if defined(PRISMLAYERED)",
                        "float N2dotL = dot(N2, L);",
                        "float N2dotH = dot(N2, H);",
                        "vec3 Hlocal2 = vec3(Hu, Hv, N2dotH);",
                    "#endif",
                    "vec3 brdf = lightColor[i] * ",
                    "#if defined(PRISMOPAQUE)",
                    "    BRDF_Opaque(Hlocal, NdotL, NdotH, NdotV, VdotH,",
                    "                surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,",
                    "                opaqueF0, opaqueAlbedo);",
                    "#elif defined(PRISMMETAL)",
                    "    BRDF_Metal(Hlocal, NdotL, NdotH, NdotV, VdotH, ",
                    "               surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, ",
                    "               metalF0);",
                    "#elif defined(PRISMLAYERED)",
                    "    BRDF_Layered(Hlocal, NdotL, NdotH, NdotV, VdotH, Hlocal2, N2dotL, N2dotH, N2dotV,",
                    "                 surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,",
                    "                 layeredF0, layeredDiffuse, layeredRoughness, layeredAnisotropy,",
                    "                 layeredRotation, bottom_f0, layeredFraction);",
                    "#elif defined(PRISMTRANSPARENT)",
                    "    BRDF_Transparent(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation);",
                    "#elif defined(PRISMWOOD)",
                    "    BRDF_Wood(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, woodDiffuse);",
                    "#endif",
                    "outRadianceLight += max(vec3(0.0), brdf);",
                "}",
                "#endif",

                "vec3 outRadianceEnv = vec3(0.0);",
                "#if defined( USE_ENVMAP )",
                // Compute the outgoing radiance due to the environment light.
                "outRadianceEnv =",
                "#if defined(PRISMOPAQUE)",
                "    Environment_Opaque(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,",
                "                        opaqueF0, opaqueAlbedo);",
                "#elif defined(PRISMMETAL)",
                "    Environment_Metal(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, metalF0);",
                "#elif defined(PRISMLAYERED)",
                "    Environment_Layered(N, V, clamp(NdotV, 0.0, 1.0), N2, clamp(N2dotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,",
                "                layeredF0, layeredDiffuse, layeredRoughness, layeredAnisotropy,",
                "                layeredRotation, bottom_f0, layeredFraction);",
                "#elif defined(PRISMTRANSPARENT)",
                "    Environment_Transparent(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness);",
                "#elif defined(PRISMWOOD)",
                "    Environment_Wood(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, woodDiffuse);",
                "#endif",
                "#endif",
                // Opacity is 1.0 by default.
                "float opacity = 1.0;",

                "float surface_cutout = 1.0;",
                GetPrismMapSampleChunk("surface_cutout", "surface_cutout", true, false),
                "#if defined( USE_SURFACE_CUTOUT_MAP )",
                "if(surface_cutout < 0.01) discard;",
                "#endif",

                // For transparent materials, vary the opacity based on the angle between the normal and view
                // vectors.  Also, increase opacity with surface roughness, and have a minimum opacity to avoid
                // dimming the specular component too much.
                // NOTE: This is *not* physical, and is just a cheap way to have opacity change with roughness.
                "#if defined(PRISMTRANSPARENT)",
                "if (transparent_ior == 1.0 && transparent_color == vec3(1.0,1.0,1.0))",//Prism Air, set alpha to 0;
                    "opacity = 0.0;",
                "else",
                    "opacity = max(0.5, mix(1.0, surfaceRoughness, NdotV));",
                "#endif",

                "gl_FragColor = vec4( outRadianceLight + outRadianceEnv, opacity*surface_cutout );",

                "#if TONEMAP_OUTPUT == 1",
                    "gl_FragColor.xyz = toneMapCanonOGS_WithGamma_WithColorPerserving(exposureBias * gl_FragColor.xyz);",
                "#elif TONEMAP_OUTPUT == 2",
                    "gl_FragColor.xyz = toneMapCanonFilmic_WithGamma(exposureBias * gl_FragColor.xyz);",
                "#endif",

                avs.FinalOutputShaderChunk,
            "}"


        ].join("\n")

};
	// currently not used
    function createShaderMaterial(shader) {
        return new THREE.ShaderMaterial({
            uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            defines: THREE.UniformsUtils.clone( shader.defines )
        });
    }
THREE.ShaderLib['prism'] = avs.PrismShader;

avp.createPrismMaterial = function() {
    var prismMat = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone( avs.PrismShader.uniforms ),
                vertexShader: avs.PrismShader.vertexShader,
                fragmentShader: avs.PrismShader.fragmentShader
            });
    prismMat.defaultAttributeValues['uvw'] = [0,0,0];
    prismMat.mapList = {};
    prismMat.isPrismMaterial = true;

    return prismMat;
};

avp.clonePrismMaterial = function (mat) {

    var prismMat = avp.createPrismMaterial();
    prismMat.mapList = mat.mapList;

    prismMat.prismType = mat.prismType;

    //Prism common properties.
    prismMat.surface_albedo = mat.surface_albedo;
    prismMat.surface_albedo_map = mat.surface_albedo_map;
    prismMat.surface_roughness = mat.surface_roughness;
    prismMat.surface_roughness_map = mat.surface_roughness_map;
    prismMat.surface_anisotropy = mat.surface_anisotropy;
    prismMat.surface_anisotropy_map = mat.surface_anisotropy_map;
    prismMat.surface_rotation = mat.surface_rotation;
    prismMat.surface_rotation_map = mat.surface_rotation_map;
    prismMat.surface_cutout_map = mat.surface_cutout_map;
    prismMat.surface_normal_map = mat.surface_normal_map;

    //Set Prism properties according to the material type.
    switch (prismMat.prismType) {
        case 'PrismOpaque':
            prismMat.opaque_albedo = new THREE.Color().copy(mat.opaque_albedo);
            prismMat.opaque_luminance_modifier = new THREE.Color().copy(mat.opaque_luminance_modifier);
            prismMat.opaque_f0 = mat.opaque_f0;
            prismMat.opaque_luminance = mat.opaque_luminance;

            prismMat.opaque_albedo_map = mat.opaque_albedo_map;
            prismMat.opaque_luminance_modifier_map = mat.opaque_luminance_modifier_map;
            prismMat.opaque_f0_map = mat.opaque_f0_map;

            break;

        case 'PrismMetal':
            prismMat.metal_f0 = new THREE.Color().copy(mat.metal_f0);
            prismMat.metal_f0_map = mat.metal_f0_map;

            break;

        case 'PrismLayered':
            prismMat.layered_f0 = mat.layered_f0;
            prismMat.layered_diffuse = new THREE.Color().copy(mat.layered_diffuse);
            prismMat.layered_fraction = mat.layered_fraction;
            prismMat.layered_bottom_f0 = new THREE.Color().copy(mat.layered_bottom_f0);
            prismMat.layered_roughness = mat.layered_roughness;
            prismMat.layered_anisotropy = mat.layered_anisotropy;
            prismMat.layered_rotation = mat.layered_rotation;

            prismMat.layered_bottom_f0_map = mat.layered_bottom_f0_map;
            prismMat.layered_f0_map = mat.layered_f0_map;
            prismMat.layered_diffuse_map = mat.layered_diffuse_map;
            prismMat.layered_fraction_map = mat.layered_fraction_map;
            prismMat.layered_rotationlayered_roughness_map = mat.layered_rotationlayered_roughness_map;
            prismMat.layered_anisotropy_map = mat.layered_anisotropy_map;
            prismMat.layered_rotation_map = mat.layered_rotation_map;
            prismMat.layered_normal_map = mat.layered_normal_map;

            break;

        case 'PrismTransparent':
            prismMat.transparent_color = new THREE.Color().copy(mat.transparent_color);
            prismMat.transparent_distance = mat.transparent_distance;
            prismMat.transparent_ior = mat.transparent_ior;

            break;

        case 'PrismWood':
            prismMat.wood_fiber_cosine_enable = mat.wood_fiber_cosine_enable;
            prismMat.wood_fiber_cosine_bands = mat.wood_fiber_cosine_bands;
            prismMat.wood_fiber_cosine_weights = new THREE.Vector4().copy(mat.wood_fiber_cosine_weights);
            prismMat.wood_fiber_cosine_frequencies = new THREE.Vector4().copy(mat.wood_fiber_cosine_frequencies);

            prismMat.wood_fiber_perlin_enable = mat.wood_fiber_perlin_enable;
            prismMat.wood_fiber_perlin_bands = mat.wood_fiber_perlin_bands;
            prismMat.wood_fiber_perlin_weights = new THREE.Vector4().copy(mat.wood_fiber_perlin_weights);
            prismMat.wood_fiber_perlin_frequencies = new THREE.Vector4().copy(mat.wood_fiber_perlin_frequencies);
            prismMat.wood_fiber_perlin_scale_z = mat.wood_fiber_perlin_scale_z;

            prismMat.wood_growth_perlin_enable = mat.wood_growth_perlin_enable;
            prismMat.wood_growth_perlin_bands = mat.wood_growth_perlin_bands;
            prismMat.wood_growth_perlin_weights = new THREE.Vector4().copy(mat.wood_growth_perlin_weights);
            prismMat.wood_growth_perlin_frequencies = new THREE.Vector4().copy(mat.wood_growth_perlin_frequencies);

            prismMat.wood_latewood_ratio = mat.wood_latewood_ratio;
            prismMat.wood_earlywood_sharpness = mat.wood_earlywood_sharpness;
            prismMat.wood_latewood_sharpness = mat.wood_latewood_sharpness;
            prismMat.wood_ring_thickness = mat.wood_ring_thickness;

            prismMat.wood_earlycolor_perlin_enable = mat.wood_earlycolor_perlin_enable;
            prismMat.wood_earlycolor_perlin_bands = mat.wood_earlycolor_perlin_bands;
            prismMat.wood_earlycolor_perlin_weights = new THREE.Vector4().copy(mat.wood_earlycolor_perlin_weights);
            prismMat.wood_earlycolor_perlin_frequencies = new THREE.Vector4().copy(mat.wood_earlycolor_perlin_frequencies);
            prismMat.wood_early_color = new THREE.Color().copy(mat.wood_early_color);

            prismMat.wood_use_manual_late_color = mat.wood_use_manual_late_color;
            prismMat.wood_manual_late_color = new THREE.Color().copy(mat.wood_manual_late_color);

            prismMat.wood_latecolor_perlin_enable = mat.wood_latecolor_perlin_enable;
            prismMat.wood_latecolor_perlin_bands = mat.wood_latecolor_perlin_bands;
            prismMat.wood_latecolor_perlin_weights = new THREE.Vector4().copy(mat.wood_latecolor_perlin_weights);
            prismMat.wood_latecolor_perlin_frequencies = new THREE.Vector4().copy(mat.wood_latecolor_perlin_frequencies);
            prismMat.wood_late_color_power = mat.wood_late_color_power;

            prismMat.wood_diffuse_perlin_enable = mat.wood_diffuse_perlin_enable;
            prismMat.wood_diffuse_perlin_bands = mat.wood_diffuse_perlin_bands;
            prismMat.wood_diffuse_perlin_weights = new THREE.Vector4().copy(mat.wood_diffuse_perlin_weights);
            prismMat.wood_diffuse_perlin_frequencies = new THREE.Vector4().copy(mat.wood_diffuse_perlin_frequencies);
            prismMat.wood_diffuse_perlin_scale_z = mat.wood_diffuse_perlin_scale_z;

            prismMat.wood_use_pores = mat.wood_use_pores;
            prismMat.wood_pore_type = mat.wood_pore_type;
            prismMat.wood_pore_radius = mat.wood_pore_radius;
            prismMat.wood_pore_cell_dim = mat.wood_pore_cell_dim;
            prismMat.wood_pore_color_power = mat.wood_pore_color_power;
            prismMat.wood_pore_depth = mat.wood_pore_depth;

            prismMat.wood_use_rays = mat.wood_use_rays;
            prismMat.wood_ray_color_power = mat.wood_ray_color_power;
            prismMat.wood_ray_seg_length_z = mat.wood_ray_seg_length_z;
            prismMat.wood_ray_num_slices = mat.wood_ray_num_slices;
            prismMat.wood_ray_ellipse_z2x = mat.wood_ray_ellipse_z2x;
            prismMat.wood_ray_ellipse_radius_x = mat.wood_ray_ellipse_radius_x;

            prismMat.wood_use_latewood_bump = mat.wood_use_latewood_bump;
            prismMat.wood_latewood_bump_depth = mat.wood_latewood_bump_depth;

            prismMat.wood_use_groove_roughness = mat.wood_use_groove_roughness;
            prismMat.wood_groove_roughness = mat.wood_groove_roughness;
            prismMat.wood_diffuse_lobe_weight = mat.wood_diffuse_lobe_weight;

            prismMat.permutationMap = mat.permutationMap;
            prismMat.gradientMap = mat.gradientMap;
            prismMat.perm2DMap = mat.perm2DMap;
            prismMat.permGradMap = mat.permGradMap;

            break;

        default:
            console.warn('Unknown prism type: ' + mat.prismType);
    }

    prismMat.envExponentMin = mat.envExponentMin;
    prismMat.envExponentMax = mat.envExponentMax;
    prismMat.envExponentCount = mat.envExponentCount;
    prismMat.envMap = mat.envMap;

    prismMat.defines = mat.defines;
    return prismMat;
};

}


})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_NormalsShader = function(THREE) {

if (typeof avs.NormalsShader !== "undefined")
    return;

avs.NormalsShader = {

        uniforms: {

            //"opacity" : { type: "f", value: 1.0 }
            "cutplanes" : { type:"v4v", value: [] }
        },

        vertexShader: [

            "varying vec3 vNormal;",
            "varying float depth;",

            "#if NUM_CUTPLANES > 0",
                "varying vec3 vWorldPosition;",
            "#endif",

            avs.PackNormalsShaderChunk,
            
            "void main() {",

                "#ifdef UNPACK_NORMALS",
                    "vec3 objectNormal = decodeNormal(normal);",
                "#else",
                    "vec3 objectNormal = normal;",
                "#endif",

                "#ifdef FLIP_SIDED",
                    "objectNormal = -objectNormal;",
                "#endif",

                "vec3 transformedNormal = normalMatrix * objectNormal;",

                "vNormal = normalize( transformedNormal );",

            "#if NUM_CUTPLANES > 0",
            "    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
            "    vWorldPosition = worldPosition.xyz;",
            "#endif",

                "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
                "depth = mvPosition.z;",

                "vec4 p_Position = projectionMatrix * mvPosition;",
                "gl_Position = p_Position;",
            "}"

        ].join("\n"),

        fragmentShader: [

            "varying highp vec3 vNormal;",
            "varying highp float depth;",

            "#if NUM_CUTPLANES > 0",
                "varying vec3 vWorldPosition;",
            "#endif",
            avs.CutPlanesShaderChunk,

            "void main() {",
                "#if NUM_CUTPLANES > 0",
                    "checkCutPlanes(vWorldPosition);",
                "#endif",

                "vec3 n = vNormal;",
                //Invert normal in case of back side
                //"#ifdef DOUBLE_SIDED",
                "n = n * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
                //"#endif",

                //TODO: it's possible that we have to clamp the values
                //to range 0-1 -- check no weaker GL ES platforms.
                "n = normalize( n );",

                //NOTE: Dropping the Z coordinate of the normal entirely means
                //that we lose information about its sign (we use sqrt to restore it later).
                //This is OK in this case because in view space surfaces that we see will have
                //positive Z component in all cases. If that changes we have to also
                //encode the sign bit in the x or y.
                "gl_FragColor = vec4(n.x, n.y, depth, 1.0);",
            "}"

        ].join("\n")

};

}

})();;
(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_BackgroundShader = function(THREE) {

"use strict";

if (typeof avs.BackgroundShader !== "undefined")
    return;

avs.BackgroundShader = {

    uniforms: {
        "color1": {type: "v3", value: new THREE.Vector3(41.0/255.0, 76.0/255.0, 120.0/255.0) },
        "color2": {type: "v3", value: new THREE.Vector3( 1.0/255.0,  2.0/255.0,   3.0/255.0) },
        //"irradianceMap": {type: "t", value: 1.0},
        "envMap": {type: "t", value: null},
        "envRotationSin": {type: "f", value: 0.0},
        "envRotationCos": {type: "f", value: 1.0},
        "exposure" : { type:"f", value: 1.0 },
        "uCamDir": {type: "v3", value: new THREE.Vector3() },
        "uCamUp": {type: "v3", value: new THREE.Vector3() },
        "uResolution": {type: "v2", value: new THREE.Vector2(600, 400) },
        "uHalfFovTan": {type: "f", value: 0.5},
        "envMapBackground": {type: "i", value: 0}

    },

    vertexShader: [
        "uniform vec3 color1;",
        "uniform vec3 color2;",

        "varying vec2 vUv;",
        "varying vec3 vColor;",

        "void main() {",

            "if (uv.y == 0.0)",
                "vColor = color2;",
            "else",
                "vColor = color1;",

            "vUv = uv;",

            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "varying vec3 vColor;",
        "varying vec2 vUv;",

        //"uniform samplerCube irradianceMap;",
        "uniform samplerCube envMap;",
        "uniform float exposure;",
        "uniform vec3 uCamDir;",
        "uniform vec3 uCamUp;",
        "uniform vec2 uResolution;",
        "uniform float uHalfFovTan;",
        "uniform bool envMapBackground;",

        avs.EnvSamplingShaderChunk,

        "const int bloomRange = 4;",

        avs.OrderedDitheringShaderChunk,

        //NOTE: This depends on the specific encoding used.
        //We use the environment preset's built in exposure correction,
        //a gamma of 2.0 and an extra factor of 16
        //when generating the cube map in the modified CubeMapGen tool
        //See this article by Karis for details: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html
        "vec3 RGBMDecode(in vec4 vRGBM, in float exposure) {",
            "vec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);", //vairable factor in alpha channel + fixed factor of 16.0
            "ret *= ret;", //remove gamma of 2.0 to go into linear space
            "ret *= exposure;", //apply exposure to get back original intensity
            "return ret;",
        "}",

        "vec3 rayDir(in vec2 vUv) {",
            "vec3 A = (uResolution.x/uResolution.y)*normalize(cross(uCamDir,uCamUp)) * (uHalfFovTan * 2.0);",
            "vec3 B = normalize(uCamUp) * (uHalfFovTan * 2.0);",
            "vec3 C = normalize(uCamDir);",

            "vec3 ray = normalize( C + (2.0*vUv.x-1.0)*A + (2.0*vUv.y-1.0)*B );",
            "return ray;",
        "}",

        "vec4 getColor(in vec3 rd) {",
            "return vec4(RGBMDecode(textureCube(envMap, adjustLookupVector(rd)), exposure), 1.0);",
        "}",

        "void main() {",
            "vec3 rd = rayDir(vUv);",

            "if (envMapBackground) {",
                "gl_FragColor = getColor(rd);",
            "}",
            "else {",
                "gl_FragColor = vec4(orderedDithering(vColor), 1.0);",
            "}",

            // For the bloom effect for background
            //"vec4 sum = vec4(0);",
            //
            //"for ( int i = -bloomRange; i < bloomRange; i++ ) {",
            //    "for ( int j = -bloomRange + 1; j < bloomRange - 1; j++ ) {",
            //        "vec3 sRay = rayDir(vUv + vec2(j, i) * 0.004);",
            //        "sum += getColor(sRay) * 0.25;",
            //    "}",
            //"}",
            //"if (getColor(rd).r < 0.3) {",
            //    "gl_FragColor = sum * sum * 0.012 + getColor(rd);",
            //"}",
            //"else if (getColor(rd).r < 0.5) {",
            //    "gl_FragColor = sum * sum * 0.009 + getColor(rd);",
            //"}",
            //"else {",
            //    "gl_FragColor = sum * sum * 0.0075 + getColor(rd);",
            //"}",

        "}",

    ].join("\n")

};

}

})();;(function() {

"use strict";

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_FireflyBasicShader = function(THREE) {

    //Replacement for the THREE BasicMaterial adding
    //cut plane support

    THREE.ShaderLib['firefly_basic'] = {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ],
			avs.CutPlanesUniforms
		] ),

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],
			
            "#if NUM_CUTPLANES > 0",
                "varying vec3 vWorldPosition;",
            "#endif",

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

			"	#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				
                "#if NUM_CUTPLANES > 0",
                    "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
                    "vWorldPosition = worldPosition.xyz;",
                "#endif",
				
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

            "#if NUM_CUTPLANES > 0",
                "varying highp vec3 vWorldPosition;",
            "#endif",

			avs.CutPlanesShaderChunk,

			"void main() {",

                "#if NUM_CUTPLANES > 0",
                    "checkCutPlanes(vWorldPosition);",
                "#endif",

			"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
			"	vec4 diffuseColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

			"	outgoingLight = diffuseColor.rgb;", // simple shader

				THREE.ShaderChunk[ "lightmap_fragment" ],		// TODO: Light map on an otherwise unlit surface doesn't make sense.
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],		// TODO: Shadows on an otherwise unlit surface doesn't make sense.

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

			"}"

		].join("\n")

	};

}

})();;/**
 * Created by stanevt on 4/26/14.
 */

(function() {

var av = Autodesk.Viewing,
    avs = av.Shaders;

avs.init_LineShader = function(THREE) {

"use strict";

if (typeof avs.LineShader !== "undefined")
    return;

var COMMON_DEFINES = [
    "#define TAU     6.28318530718",
    "#define PI      3.14159265358979",
    "#define HALF_PI 1.57079632679",

    "#define PI_0_5  HALF_PI",       // 0.5 * PI
    "#define PI_1_5  4.71238898038"  // 1.5 * PI
].join('\n');

var GEOMETRY_TYPES_DEFINES = [
    "#define VBB_GT_TRIANGLE_INDEXED  0.0",
    "#define VBB_GT_LINE_SEGMENT      1.0",
    "#define VBB_GT_ARC_CIRCULAR      2.0",
    "#define VBB_GT_ARC_ELLIPTICAL    3.0",
    "#define VBB_GT_TEX_QUAD          4.0",
    "#define VBB_GT_ONE_TRIANGLE      5.0"
].join('\n');

var VERTEX_ID_DEFINES = [
    "#define VBB_INSTANCED_FLAG   0.0",
    "#define VBB_SEG_START_RIGHT  0.0",
    "#define VBB_SEG_START_LEFT   1.0",
    "#define VBB_SEG_END_RIGHT    2.0",
    "#define VBB_SEG_END_LEFT     3.0"
].join('\n');

// pass these attributes from the VS to the FS
var VARYINGS = [
    "varying vec4 fsColor;",
    "varying vec4 dbId;", // this name is required by avs.IdOutputShaderChunk

    "varying vec2 fsOffsetDirection;",
    "varying vec4 fsMultipurpose;",

    "varying float fsGeomType;",
    "varying float fsHalfWidth;",

    "varying vec2 fsVpTC;"
].join('\n');

avs.LineShader = {

        uniforms: {

            "pixelsPerUnit":     { type: "f",  value: 1.0 },
            "aaRange":           { type: "f",  value: 0.5 }, //aaRange = 0.5/pixelsPerUnit
            "tLayerMask":        { type: "t",  value: null },
            "tLineStyle":        { type: "t",  value: null },
            "vLineStyleTexSize": { type: "v2", value: new THREE.Vector2(13, 70) },
            "tRaster":           { type: "t",  value: null},
            "tSelectionTexture": { type: "t",  value: null},
            "vSelTexSize":       { type: "v2", value: new THREE.Vector2(4096, 1) },
            "displayPixelRatio": { type: "f",  value: 1.0 },
            "opacity":           { type: "f",  value: 1.0 },
            "selectionColor":    { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) },
            "viewportId":        { type: "f",  value: 0.0 }  // the viewport id of the first selection in measure

            //This is handled as special case by the renderer, like all other camera matrices
            //since it's shared between material instances
            //"mvpMatrix" : {type: "m4", value: new THREE.Matrix4() }
        },

        attributes: {
            "fields1":     0,
            "fields2":     0,
            "color4b":     0,
            "dbId4b":      0,
            "flags4b":     0,
            "layerVp4b":   0,
            "extraParams": 0,
            "instFlags4b": 0
        },

        defines : {
            //"MRT_ID_BUFFER":      1,
            //"ID_COLOR":           1,
            //"SELECTION_RENDERER": 1,
            //"HAS_RASTER_QUADS":   1,
            //"HAS_ELLIPTICALS":    1,
            //"HAS_CIRCLES":        1,
            //"HAS_TRIANGLE_GEOMS": 1,
            //"USE_INSTANCING":     1
        },

        vertexShader: [
/*
Precision and extensions headers added by FrieflyWebGLProgram
Might be good to convert this to RawShader at some point.
 */

            COMMON_DEFINES,
            GEOMETRY_TYPES_DEFINES,
            VERTEX_ID_DEFINES,

            VARYINGS,

            "attribute vec3 fields1;",
            "attribute vec3 fields2;",
            "attribute vec4 color4b;",
            "attribute vec4 dbId4b;",
            "attribute vec4 flags4b;",
            "attribute vec4 layerVp4b;",

        "#ifdef HAS_ELLIPTICALS",
            "attribute vec3 extraParams;",
        "#endif",

        "#ifdef USE_INSTANCING",
            "attribute vec4 instFlags4b;",
        "#endif",

            "uniform mat4 mvpMatrix;",

            "uniform float pixelsPerUnit;",
            "uniform float aaRange;",

            //The layer and object selection mask textures
            //can be sampled in the vertex shader since they only vary per geometry.
            //So far we have not encountered a device that fails
            //on this, but if we do, we may have to move those to the fragment shader.
        "#ifdef HAS_LAYERS",
            "uniform sampler2D tLayerMask;",
        "#endif",

        "#ifdef SELECTION_RENDERER",
            "uniform sampler2D tSelectionTexture;",
            "uniform vec2 vSelTexSize;",
            "uniform vec4 selectionColor;",
        "#endif",

            // used internally by the VS
            "vec2 centralVertex;",
            "vec2 offsetPosition;",

            "vec2 cos_sin(const float angle) { return vec2(cos(angle), sin(angle)); }",

            "void min_max(inout vec2 minPt, inout vec2 maxPt, const vec2 p) {",
                "minPt = min(minPt, p);",
                "maxPt = max(maxPt, p);",
            "}",

        "#if defined(USE_INSTANCING)",
            "float getVertexId() { return instFlags4b.x; }",
        "#else", // defined(USE_INSTANCING)",
            "float getVertexId() { return flags4b.x; }",
        "#endif", // defined(USE_INSTANCING)",

            "bool isStartVertex() { return (getVertexId() < VBB_SEG_END_RIGHT); }",
            "bool isLeftVertex()  { float id = getVertexId(); return ((id == VBB_SEG_END_LEFT || id == VBB_SEG_START_LEFT)); }",

            "struct SegmentData { float angle, distAlong, distTotal, lineWidthHalf, lineType; };",
            "void decodeSegmentData(out SegmentData seg) {",
                "seg.angle         = fields1.z;",
                "seg.distAlong     = fields2.x;",
                "seg.distTotal     = fields2.z;",
                "seg.lineWidthHalf = fields2.y;",
                "seg.lineType      = flags4b.z;",
            "}",

            "void strokeLineSegment() {",
                "SegmentData seg; decodeSegmentData(seg);",

                "float isStartCapVertex = isStartVertex() ? -1.0 :  1.0;",
                "float isLeftSide       = isLeftVertex( ) ?  1.0 : -1.0;",

                //Apply transverse line width offset
                "float angleTransverse = seg.angle + isLeftSide * HALF_PI;",
                "float lwAdjustment = fsHalfWidth + aaRange;",
                "vec2 transverseOffset = cos_sin(angleTransverse) * lwAdjustment;",
                "offsetPosition.xy += transverseOffset;",

                //Compute end point based on start point plus segment length and direction
                //This is because the line segment's 4 vertices are all equal to the start
                //point to begin with. Note for the start point, we just move by 0, to avoid doing an if().
                "float distanceFromStart = max(isStartCapVertex, 0.0) * seg.distAlong;",
                "vec2 along = distanceFromStart * cos_sin(seg.angle);",
                "offsetPosition.xy += along;",
                "centralVertex.xy  += along;",

                //Apply start/end-cap extension offsets if needed
                "vec2 moveOffset = isStartCapVertex * isLeftSide * vec2(-transverseOffset.y, transverseOffset.x);",
                "offsetPosition.xy -= moveOffset;",
                "centralVertex.xy  -= moveOffset;",

                //Distance we care about beyond the actual line segment vertex.
                //For start vertex, this is negative and equal to half a line weight
                //For end vertex this is the segment length plus the half line weight adjustment.
                "fsMultipurpose.x = (isStartCapVertex * lwAdjustment) + distanceFromStart;", //distance after end point that we want to fill with cap/join
                "fsMultipurpose.y = seg.distAlong;",
                "fsMultipurpose.z = seg.distTotal;",
                "fsMultipurpose.w = seg.lineType;",

                "if (seg.lineWidthHalf < 0.0)",
                    "fsHalfWidth = -fsHalfWidth;",
            "}",


        "#ifdef HAS_TRIANGLE_GEOMS",
            "struct TriangleData { vec2 p0, p1, p2; };",
            "void decodeTriangleData(out TriangleData tri) {",
                "// tri.p0 = fields1.xy; // not used in shader...",
                "tri.p1 = vec2(fields1.z, fields2.x);",
                "tri.p2 = fields2.yz;",
            "}",

            "void strokeOneTriangle() {",
                "TriangleData tri; decodeTriangleData(tri);",

                // Note, that a degenerated triangle is created for the
                // second triangle of the instancing quad. But that is
                // exactly what we want, since we have just a single
                // triangle!

                //this is already done at the beginning of main()
                //so we skip it here
                //"offsetPosition.xy = tri.p0;",

                "float vertexId = getVertexId();",
                "if      (vertexId == VBB_SEG_END_RIGHT) offsetPosition.xy = tri.p1;",
                "else if (vertexId == VBB_SEG_END_LEFT)  offsetPosition.xy = tri.p2;",
            "}",
        "#endif",


            //The vertex format used for quads is specifying the center of the quad,
            //a rotation angle and the overall size of the quad (width, height).
        "#ifdef HAS_RASTER_QUADS",
            "struct TexQuadData { float angle; vec2 size; };",
            "void decodeTexQuadData(out TexQuadData quad) {",
                "quad.angle     = fields1.z;",
                "quad.size   = fields2.xy;",
            "}",

            "void strokeTexQuad() {",
                "TexQuadData quad; decodeTexQuadData(quad);",

                "vec2 corner = vec2(isLeftVertex() ? -1.0 : 1.0, isStartVertex() ? -1.0 : 1.0);",

                "vec2 p      = 0.5 * corner * quad.size;",
                "vec2 rot    = cos_sin(quad.angle);",
                "vec2 offset = vec2(p.x * rot.x - p.y * rot.y, p.x * rot.y + p.y * rot.x);",

                "offsetPosition.xy += offset;",

                "fsMultipurpose.xy = max(vec2(0.0), corner);",  // tex coords xy
            "}",
        "#endif", //HAS_RASTER_QUADS

        "#if defined(HAS_CIRCLES) || defined(HAS_ELLIPTICALS)",
            "struct ArcData { vec2 c; float start, end, major, minor, tilt; };",
            "void decodeArcData(out ArcData arc) {",
                "arc.c     = fields1.xy;",
                "arc.start = fields1.z;",
                "arc.end   = fields2.x;",
                "arc.major = fields2.z;",
            "#if defined(HAS_ELLIPTICALS)",
                "arc.minor = extraParams.x;",
                "arc.tilt  = extraParams.y;",
            "#endif // defined(HAS_ELLIPTICALS)",
            "}",

            "void strokeArc(const ArcData arc) {",
                //TODO: rotation/tilt

                "float isStart = isStartVertex() ? -1.0 : 1.0;",
                "float isLeft  = isLeftVertex()  ? -1.0 : 1.0;",

                //Compute a tighter bounding quad for arcs if possible,
                //to avoid massive overdraw in case of very small angular range

                "vec2 minPt;",
                "vec2 maxPt;",

                "vec2 angles = vec2(arc.start, arc.end);",
                "vec2 endsX = vec2(arc.c.x) + arc.major * cos(angles);",
                "vec2 endsY = vec2(arc.c.y) + arc.minor * sin(angles);",
                "minPt = maxPt = vec2(endsX.x, endsY.x);",
                "min_max(minPt, maxPt, vec2(endsX.y, endsY.y));",

                "if (arc.end > arc.start) {",
                    "if (arc.start < PI_0_5 && arc.end > PI_0_5) {",
                        "min_max(minPt, maxPt, vec2(arc.c.x, arc.c.y + arc.minor));",
                    "}",
                    "if (arc.start < PI && arc.end > PI) {",
                        "min_max(minPt, maxPt, vec2(arc.c.x - arc.major, arc.c.y));",
                    "}",
                    "if (arc.start < PI_1_5 && arc.end > PI_1_5) {",
                        "min_max(minPt, maxPt, vec2(arc.c.x, arc.c.y - arc.minor));",
                    "}",
                "} else {",
                    //In this case, CW arcs, we know it passes through angle 0:
                    "min_max(minPt, maxPt, vec2(arc.c.x + arc.major, arc.c.y));",

                    //All other checks are also reversed
                    //TODO: verify this logic -- it might be overestimating
                    "if (arc.start < PI_0_5 || arc.end > PI_0_5) {",
                        "min_max(minPt, maxPt, vec2(arc.c.x, arc.c.y + arc.minor));",
                    "}",
                    "if (arc.start < PI || arc.end > PI) {",
                        "min_max(minPt, maxPt, vec2(arc.c.x - arc.major, arc.c.y));",
                    "}",
                    "if (arc.start < PI_1_5 || arc.end > PI_1_5) {",
                        "min_max(minPt, maxPt, vec2(arc.c.x, arc.c.y - arc.minor));",
                    "}",
                "}",

                "minPt -= fsHalfWidth + aaRange;",
                "maxPt += fsHalfWidth + aaRange;",

                "offsetPosition.x = (isStart < 0.0) ? minPt.x : maxPt.x;",
                "offsetPosition.y = (isLeft < 0.0)  ? minPt.y : maxPt.y;",

                //Whole box code path (slow, used for debugging)
                //"vec2 offset = vec2((major + fsHalfWidth + aaRange) * isStart, (minor + fsHalfWidth + aaRange) * isLeft);",
                //"offsetPosition.xy += offset;",

                "fsMultipurpose.x = arc.start;",
                "fsMultipurpose.y = arc.end;",
                "fsMultipurpose.z = arc.major;",
                "fsMultipurpose.w = arc.minor;",
            "}",
        "#endif // defined(HAS_CIRCLES) || defined(HAS_ELLIPTICALS)",

        "#if defined(HAS_CIRCLES)",

            "void strokeCircularArc() {",
                "ArcData arc; decodeArcData(arc);",

                "float r = arc.major;",
                "if (r * pixelsPerUnit < 0.125)",
                    "r = 0.25 * aaRange;",
                "arc.major = arc.minor = r;",

                "strokeArc(arc);",
            "}",

        "#endif", // defined(HAS_CIRCLES)

        "#if defined(HAS_ELLIPTICALS)",
            "void strokeEllipticalArc() {",
                "ArcData arc; decodeArcData(arc);",
                "strokeArc(arc);",
            "}",
        "#endif", // defined(HAS_ELLIPTICALS)

        "struct CommonAttribs { vec2 pos; vec4 color; vec2 layerTC, vpTC; float lineWidthHalf, geomType; };",
        "void decodeCommonAttribs(out CommonAttribs attribs) {",
            "attribs.pos           = fields1.xy;",
            "attribs.color         = color4b;",
            "attribs.geomType      = flags4b.y;",
            "attribs.layerTC       = layerVp4b.xy / 255.0;",
            "attribs.vpTC          = layerVp4b.zw / 255.0;",
            "attribs.lineWidthHalf = fields2.y;",
        "}",

        "void strokeIndexedTriangle() {",
            // nothing to go, since "centralVertex = attribs.pos" already happened in main()...
        "}",

        "#ifdef SELECTION_RENDERER",
            "bool isSelected(const CommonAttribs attribs) {",
                //This math assumes that vSelTexSize.x = 4096 (byte and a half) for easy computation.

                "vec3 oid = dbId4b.rgb;",

                //A byte and a half for the horizontal coord
                "float id01 = oid.r + oid.g * 256.0;",
                "float t = (id01 + 0.5) * (1.0 / 4096.0);",
                "float flrt = floor(t);",
                "float texU = t - flrt;",

                //A byte and a half for the vertical coord
                "float id23 = oid.b * (65536.0 / 4096.0) + flrt;",
                "t = (id23 + 0.5) / vSelTexSize.y;",
                "float texV = fract(t);",

                "vec4 selBit = texture2D(tSelectionTexture, vec2(texU, texV));",
                "return selBit.r == 1.0;",
            "}",
        "#endif", //SELECTION_RENDERER

            "bool isLayerOff(const CommonAttribs attribs) {",
        "#ifdef HAS_LAYERS",
                "vec4 layerBit = texture2D(tLayerMask, attribs.layerTC);",
                "return layerBit.r == 0.0;",
        "#else",
                "return false;",
        "#endif",
            "}",

            "vec4 getColor(const CommonAttribs attribs) {",
                //Check layer visibility
                "if (isLayerOff(attribs)) { return vec4(0.0); }",
        "#ifdef SELECTION_RENDERER",
                "if (isSelected(attribs)) { return selectionColor; }", //Item is selected -- draw it with selection highlight color
                "return vec4(0.0);", //Item is not selected -- hide it
        "#else", // SELECTION_RENDERER
                "return attribs.color;",
        "#endif", // SELECTION_RENDERER
            "}",

            "void main() {",
                "CommonAttribs attribs; decodeCommonAttribs(attribs);",

                "fsColor = getColor(attribs);",

                //[TS] Collpasing of vertices into degenerate quads commented out
                //because it does not work on iPhone 6 and 6+ (and only those). 
                //Somehow sampling the layer texture in isLayerOff confuses the logic here.
                /*
                "if(fsColor.a == 0.0) {",
                    // If the feature is fully transparent collapse all
                    // the vertices of it into a single degenerated one.
                    // This avoids rasterization of the whole feature.
                    "gl_Position = vec4(0.0);",
                    "return;",
                "}",
                */

                "centralVertex = offsetPosition = attribs.pos;",

                "float lineWeight = attribs.lineWidthHalf;",
                "if (lineWeight > 0.0) {",
                    //Do not go below a line width of one pixel
                    //Since we store, half-widths, the comparison is to 0.5 instead of 1.0
                    "if(lineWeight < 0.5 / pixelsPerUnit) {",
                        "lineWeight = 0.5 / pixelsPerUnit;",
                    "}",
                "}",
                "else {",
                    //Negative line weight means device space (pixel) width.
                    //Currently used for antialiasing of polygon outlines.
                    "lineWeight = abs(lineWeight) / pixelsPerUnit;",
                "}",

                "fsHalfWidth = lineWeight;",
                "dbId = dbId4b / 255.0;", // normalize for using it as a color

                "if      (attribs.geomType == VBB_GT_LINE_SEGMENT)     strokeLineSegment();",
            "#ifdef HAS_CIRCLES",
                "else if (attribs.geomType == VBB_GT_ARC_CIRCULAR)     strokeCircularArc();",
            "#endif",
            "#ifdef HAS_ELLIPTICALS",
                "else if (attribs.geomType == VBB_GT_ARC_ELLIPTICAL)   strokeEllipticalArc();",
            "#endif",
            "#ifdef HAS_RASTER_QUADS",
                "else if (attribs.geomType == VBB_GT_TEX_QUAD)         strokeTexQuad();",
            "#endif",
            "#ifdef HAS_TRIANGLE_GEOMS",
                "else if (attribs.geomType == VBB_GT_ONE_TRIANGLE)     strokeOneTriangle();",
            "#endif",
                "else if (attribs.geomType == VBB_GT_TRIANGLE_INDEXED) strokeIndexedTriangle();",

                "fsGeomType = attribs.geomType;",

                "fsVpTC = attribs.vpTC;",

                "fsOffsetDirection = offsetPosition - centralVertex;",

                //Now apply MVP matrix
                "gl_Position = mvpMatrix * modelMatrix * vec4( offsetPosition.xy, 0.0, 1.0 );",
            "}"

        ].join("\n"),

        fragmentShader: [

/*
Precision and extensions headers added by FrieflyWebGLProgram
Might be good to convert this to RawShader at some point.
 */

            COMMON_DEFINES,
            GEOMETRY_TYPES_DEFINES,
            VERTEX_ID_DEFINES,

            VARYINGS,

            "uniform highp float pixelsPerUnit;",
            "uniform highp float aaRange;",
            //"float aaRange = 0.5 * unitsPerPixel;",
            "uniform float opacity;",
            "uniform float viewportId;",

        "#ifdef HAS_RASTER_QUADS",
            "uniform sampler2D tRaster;",
        "#endif",

        "#ifdef HAS_LINESTYLES",
            "uniform sampler2D tLineStyle;",
            "uniform vec2 vLineStyleTexSize;",
        "#endif",

            //Gaussian falloff function
            "float curveGaussian(float r, float invWidth) {",
                "float amt = clamp(r * invWidth, 0.0, 1.0);",

                "float exponent = amt * 2.0;",

                "return exp(-exponent*exponent);",

            //Below is the full original from AutoCAD:
            /*
                "float amt = clamp(abs(r / (width * 1.0)), 0.0, 1.0);",
                "amt = max(amt - 0.0, 0.0);",

                "float exponent = amt * 3.5;",

                "return clamp(exp(-exponent*exponent), 0.0, 1.0);",
                */
            "}",

        "#ifdef HAS_LINESTYLES",
            "float getLinePatternPixel(int i, int j) {",
                //texel fetch would be nice here
                "return texture2D(tLineStyle, (vec2(i, j) + 0.5) / vLineStyleTexSize).x * 255.0;",
            "}",

            "float getPatternLength(int whichPattern) {",
                "float p1 = getLinePatternPixel(0, whichPattern);",
                "float p2 = getLinePatternPixel(1, whichPattern);",
                "return (p2 * 256.0 + p1);",
            "}",
        "#endif",


            "void fillLineSegment() {",

                "float radius = abs(fsHalfWidth);",
                "float parametricDistance = fsMultipurpose.x;",
                "float segmentLength      = fsMultipurpose.y;",
                "float totalDistance      = fsMultipurpose.z;",

            //Apply any dot/dash linetype
            "#ifdef HAS_LINESTYLES",
                "int whichPattern         = int(fsMultipurpose.w);",

                "if (whichPattern > 0) {",
                    "const float TEX_TO_UNIT = 1.0 / 96.0;",

                    //Line patterns are assumed to be defined for LTSCALE = 1
                    //AutCAD will scale patterns based on the LTSCALE setting, and
                    //currently this is ignored here.
                    "float LTSCALE = 1.0;",
                    "float patternScale;",

                    //If line width is negative it means device space line style (zoom invariant)
                    //line width, which also implies the same about the line pattern -- check for this here.
                    "if (fsHalfWidth < 0.0) {",
                        "patternScale = LTSCALE;",
                    "} else {",
                        "patternScale = LTSCALE * TEX_TO_UNIT * pixelsPerUnit;",
                    "}",

                    "float patLen = patternScale * getPatternLength(whichPattern);",
                    "float phase = mod((totalDistance + parametricDistance) * pixelsPerUnit, patLen);",

                    "bool onPixel = true;",
                    "float radiusPixels = radius * pixelsPerUnit;",

                    "for (int i=2; i<MAX_LINESTYLE_LENGTH; i+=2) {",

                        "float on = getLinePatternPixel(i, whichPattern);",
                        "if (on == 1.0) on = 0.0;", //special handling for dots, map length 1 to 0
                        "on *= patternScale;",

                        "onPixel = true;",
                        "phase -= on;",
                        "if (phase < 0.0) {",
                            "break;",
                        "}",
                        "else if (phase <= radiusPixels) {",
                            "onPixel = false;",
                            "break;",
                        "}",

                        "float off = getLinePatternPixel(i+1, whichPattern);",
                        "if (off <= 1.0) off = 0.0;", //special handling for dots, map length 1 to 0
                        "off *= patternScale;",

                        "onPixel = false;",
                        "phase -= off;",
                        "if (phase < -radiusPixels)",
                            "discard;",
                        "if (phase <= 0.0)",
                            "break;",
                    "}",

                    //Modify the parametricDistance value used for round cap
                    //rendering to reflect the current position along the dash,
                    //so that dashes get caps also.
                    "if (!onPixel && (abs(phase) <= radiusPixels)) {",
                        "segmentLength = 0.0;",
                        "parametricDistance = phase / pixelsPerUnit;",
                    "}",
                "}",
            "#endif", // HAS_LINESTYLES

                //Check for end cap or join region -- here we reduce
                ///allowed distance from centerline in a circular way
                //to get a round cap/join
                "float dist;",
                "float offsetLength2 = dot(fsOffsetDirection, fsOffsetDirection);",

                /*
                "if (parametricDistance < 0.0) {",
                    "float d = parametricDistance;",
                    "dist = sqrt(d * d + offsetLength2);",
                "} else if (parametricDistance >= segmentLength) {",
                    "float d = parametricDistance - segmentLength;",
                    "dist = sqrt(d * d + offsetLength2);",
                "} else {",
                    "dist = sqrt(offsetLength2);",
                "}",
                */

                //Branchless version of the above ifs (because who doesn't like to do boolean logic with float ops?):
                "float ltz = max(0.0, sign(-parametricDistance));",
                "float gtsl = max(0.0, sign(parametricDistance - segmentLength));",
                "float d = (ltz + gtsl) * (parametricDistance - gtsl * segmentLength);",
                "dist = sqrt(max(0.0, offsetLength2 + d*d));",


                //pixel is too far out of the line center
                //so discard it
                "float range =  dist - radius;",

                "if (range > aaRange) {",
                    "discard;",
                "}",
                //Non-branching discard (by setting alpha to zero if pixel is outside the line)
                //But can only be used if we don't care about z-writes.
                //"float makeTransparent = 1.0 - max(0.0, sign(range - aaRange));",
                //gl_FragColor.a *= makeTransparent;

                //The geometry covers this pixel -- do AA.
                "gl_FragColor = fsColor;",
                "gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);",
            "}",

        "#ifdef HAS_CIRCLES",
            "void fillCircularArc() {",

                "float dist   = length(fsOffsetDirection);",
                "vec2 angles  = fsMultipurpose.xy;", // (start, end) angles
                "float radius = fsMultipurpose.z;",
                "float range  =  abs(dist - radius);",
                "range -= fsHalfWidth;",

                //pixel is too far out of the line center
                //so discard it
                "if (range > aaRange) {",
                    "discard;",
                "}",

                "vec2 direction = fsOffsetDirection;",
                "float angle = atan(direction.y, direction.x);",

                //Handle clockwise arcs, which happpen when the arc
                //crosses the X axis -- convert to CCW arc starting
                //at negative angle instead.
                "if (angles.x > angles.y)",
                    "angles.x -= TAU;",
                "else if (angle < 0.0)",
                    "angle += TAU;",

                //Are we in the exact range of the arc?
                "if (angle > angles.x && angle < angles.y) {",
                    "gl_FragColor = fsColor;",
                    "gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);",
                "}",

                "else {",
                    "discard;",
                "}",

            "}",
        "#endif",


/*
            "float DistancePointEllipseApprox(vec2 e, vec2 pos) { ",

                //Get position derivatives
                "vec2 dx = dFdx(pos);",
                "vec2 dy = dFdy(pos);",

                //Preparatory calculations for the ellipse equation
                "vec2 esqr = e * e;",
                "vec2 possqr = pos * pos;",
                "vec2 posDivEsqr = pos / esqr;",
                "vec2 pos2DivE2 = pos * posDivEsqr;",

                //Ellipse function derivative with chain rule
                "vec2 dPos = 2.0 * posDivEsqr;",
                "vec2 dPosx = dPos * dx;",
                "vec2 dPosy = dPos * dy;",
                "vec2 dfdxy = vec2(dPosx.x + dPosx.y, dPosy.x + dPosy.y);",

                // Approximate signed distance from curve with f(u,v) / |gradient(f(u,v))|
                "float sd = (pos2DivE2.x + pos2DivE2.y - 1.0) / length(dfdxy);",

                "return abs(sd) * aaRange * 2.0 * 0.745;",
            "}",
*/


//============================================================================
// Iterative distance to ellipse from Geometric Tools by Eberly
// See Page 11 of the document:
// http://www.geometrictools.com/Documentation/DistancePointEllipseEllipsoid.pdf

        "#ifdef HAS_ELLIPTICALS",
            //----------------------------------------------------------------------------
            // The ellipse is (x0/e0)^2 + (x1/e1)^2 = 1 with e0 >= e1. The query point is
            // (y0,y1) with y0 >= 0 and y1 >= 0. The function returns the distance from
            // the query point to the ellipse. It also computes the ellipse point (x0,x1)
            // in the first quadrant that is closest to (y0,y1).
            //----------------------------------------------------------------------------
            "float EllipticalApprox(",
                "const int iters,",
                "inout float t0, inout float t1,",
                "const vec2 y,   out   vec2 x,",
                "const vec2 e,   const vec2 ey, const vec2 esqr",
            ") {",
                "vec2 r;",
                "for (int i = 0; i < 10; ++i) {", // maximum 10 iterations
                    "if(i >= iters) break;", // early out if we don't want the max number of iterations

                    "float t = mix(t0, t1, 0.5);", // 0.5*(t0 + t1);
                    "r = ey / (vec2(t) + esqr);",

                    "vec2 rsq = r * r;",
                    "float f = rsq.x + rsq.y - 1.0;",

                    "if(f > 0.0) { t0 = t; } else { t1 = t; }",
                "}",

                "x = e * r;",
                "return distance(x, y);",
            "}",

            "float DistancePointEllipseSpecial (vec2 e, vec2 y, out vec2 x, float width, float aaRange) {",
                "float dist;",

                // Bisect to compute the root of F(t) for t >= -e1*e1.
                "vec2 esqr = e * e;",
                "vec2 ey   = e * y;",
                "float t0 = -esqr[1] + ey[1];",
                "float t1 = -esqr[1] + length(ey);",

                //Do a few initial iterations without loop break checks
                //to get approximately close to the result
                "dist = EllipticalApprox(6, t0, t1, y, x, e, ey, esqr);",

                //Early out -- point is going to be too far to matter for the ellipse outline
                "if (dist > max(2.0 * (width + aaRange), e[0] * 0.05))",
                    "return dist;",

                //Do a few more iterations to get really close to the result...
                "dist = EllipticalApprox(6, t0, t1, y, x, e, ey, esqr);",

                //Early out -- point is too far to matter for the ellipse outline
                //The bigger the eccentricity, the worse the estimate, so increse
                //the tolerance based on that.
                "float ecc = 1.0 +  0.1 * e[0] / e[1];",

                "if (dist > max(ecc * (width + aaRange), e[0] * 0.001))",
                    "return dist;",
                "if (dist < (width - aaRange) / ecc)",
                    "return dist;",


                //Finally get an almost exact answer since
                //we are near the line width boundary
                "dist = EllipticalApprox(10, t0, t1, y, x, e, ey, esqr);",
                "return dist;",
            "}",

            //----------------------------------------------------------------------------
            // The ellipse is (x0/e0)^2 + (x1/e1)^2 = 1. The query point is (y0,y1).
            // The function returns the distance from the query point to the ellipse.
            // It also computes the ellipse point (x0,x1) that is closest to (y0,y1).
            //----------------------------------------------------------------------------
            "float DistancePointEllipse(vec2 e, vec2 y, out vec2 locX, float width, float aaRange) {",
                "vec2 locE, locY;",
/*
                "locE = e; locY = y;",
                "if (e[0] < e[1]) {",
                    // Determine the axis order for decreasing extents
                    "locE.xy = locE.yx;",
                    "locY.xy = locY.yx;",
                "}",
*/

                //This will not works if e[0] == e[1], but that would be a circle
                //and should not be going thru this code path.
                "float diff = sign(e[0] - e[1]);",
                "vec2 swizzle = vec2(max(diff, 0.0), -min(diff, 0.0));",
                "locE.x = dot(e, swizzle.xy);",
                "locE.y = dot(e, swizzle.yx);",
                "locY.x = dot(y, swizzle.xy);",
                "locY.y = dot(y, swizzle.yx);",

                // Determine reflections for y to the first quadrant.
                "vec2 refl = sign(locY);",
                "locY *= refl;",

                "vec2 x;",
                "float distance = DistancePointEllipseSpecial(locE, locY, x, width, aaRange);",

                "x *= refl;",
/*
                "if (e[0] < e[1]) {",
                    "x.xy = x.yx;",
                "}",
                 "locX = x;",
*/
                "locX.x = dot(x, swizzle.xy);",
                "locX.y = dot(x, swizzle.yx);",

                "return distance;",
            "}",

//============================================================================




            "void fillEllipticalArc() {",
                "vec2 angles = fsMultipurpose.xy;", // (start, end) angles
                "vec2 radii  = fsMultipurpose.zw;", // (major, minor)
                "vec2 dir    = fsOffsetDirection;",

                //TODO: Handle arc rotation
/*
                //Quick cull of the inside circle
                "float lenDirSq = dot(dir, dir);",
                "float minRad = min(radii.x, radii.y) - (fsHalfWidth + aaRange);",
                "if (lenDirSq < minRad * minRad)",
                    "discard;",
*/
                //"float range = DistancePointEllipseApprox(radii, dir);",
                "vec2 pos;",
                "float range = DistancePointEllipse(radii, dir, pos, fsHalfWidth, aaRange);",
                "range -= fsHalfWidth;",

                "if (range > aaRange)",
                    "discard;",

                "float ar = radii[0] / radii[1];", //TODO: can be done in the vertex shader or otherwise precomputed

                //Get the parametric angle at the ellipse intersection point
                // -- note that for ellipses this is not just atan of the direction,
                //and needs to be scaled by aspect ratio.
                "float angle = atan(ar * pos.y, pos.x);",

                //Handle clockwise arcs, which happpen when the arc
                //crosses the X axis -- convert to CCW arc starting
                //at negative angle instead.
                "if (angles.x > angles.y)",
                    "angles.x -= TAU;",
                "else if (angle < 0.0)",
                    "angle += TAU;",

                //Are we in the exact range of the arc?
                "if (angle > angles.x && angle < angles.y) {",
                    "gl_FragColor = fsColor;",
                    "gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);",
                "}",
                "else {",
                    "discard;",
                "}",
            "}",
        "#endif", //HAS_ELLIPTICALS

        "#ifdef HAS_RASTER_QUADS",
            "void fillTexQuad() { gl_FragColor = texture2D(tRaster, fsMultipurpose.xy); }",
        "#endif",

            "void fillTriangle() { gl_FragColor = fsColor; }",

            "void main() {",

                //Is visibility off?
                "if (fsColor.a == 0.0) {",
                    "discard;",
                "}",

/*
                //Filled triangle, not a line, no need for extra math
                "if (fsHalfWidth == 0.0) {",
            "#ifdef HAS_RASTER_QUADS",
                    "if (fsMultipurpose.z != 0.0)",
                        "fillTexQuad();",
                    "else",
            "#endif",
                        "fillTriangle();",
                "}",
                "else if (fsMultipurpose.y < 0.0) {",
                    "#ifdef HAS_CIRCLES",
                    "#ifdef HAS_ELLIPTICALS",
                        "if (fsMultipurpose.y == fsMultipurpose.w)",
                    "#endif",
                            "fillCircularArc();",
                    "#endif",
                    "#ifdef HAS_ELLIPTICALS",
                     "#ifdef HAS_CIRCLES",
                        "else",
                     "#endif",
                            "fillEllipticalArc();",
                    "#endif",
                "}",
                "else",
                    "fillLineSegment();",
*/

                "if      (abs(fsGeomType - VBB_GT_LINE_SEGMENT) < 0.5)     fillLineSegment();",
            "#ifdef HAS_CIRCLES",
                "else if (abs(fsGeomType - VBB_GT_ARC_CIRCULAR) < 0.5)     fillCircularArc();",
            "#endif",
            "#ifdef HAS_ELLIPTICALS",
                "else if (abs(fsGeomType - VBB_GT_ARC_ELLIPTICAL) < 0.5)   fillEllipticalArc();",
            "#endif",
            "#ifdef HAS_RASTER_QUADS",
                "else if (abs(fsGeomType - VBB_GT_TEX_QUAD) < 0.5)         fillTexQuad();",
            "#endif",
            "#ifdef HAS_TRIANGLE_GEOMS",
                "else if (abs(fsGeomType - VBB_GT_ONE_TRIANGLE) < 0.5)     fillTriangle();",
            "#endif",
                "else fillTriangle();",

            "#ifdef MRT_NORMALS",
                //We cannot avoid blending in the depth target when blending
                //to the color target is on, so
                //we pack the normal and depth in the first three elements
                //and use 0 or 1 as the alpha.
                //NOTE: Dropping the Z coordinate of the normal entirely means
                //that we lose information about its sign (we use sqrt to restore it later).
                //This is OK in this case because in view space surfaces that we see will have
                //positive Z component in all cases. If that changes we have to also
                //encode the sign bit in the x or y.
                //In the case of 2D: we just write with alpha=0 so that it does not affect the normals buffer.
                "gl_FragData[1] = vec4(0.0);",
            "#endif",

                // Make those geometries which belong to a different viewport with the first selection transparent in 2d measure mode
                "if (viewportId != 0.0) {",
                    "if (abs(fsVpTC.x * 255.0 + fsVpTC.y) < 0.5 || abs(fsVpTC.x * 255.0 + fsVpTC.y - viewportId) < 0.5)",
                        "gl_FragColor.a *= opacity;",
                    "else",
                        "gl_FragColor.a *= opacity * 0.1;",
                "} else {",
                    "gl_FragColor.a *= opacity;",
                "}",

                avs.IdOutputShaderChunk,
            "}"

        ].join("\n")

};

}

})();;//Based on THREE.WebGLProgram, with some defines added / removed.
FireflyWebGLProgram = ( function () {
    'use strict';

	var programIdCount = 0;

	var generateDefines = function ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	var cacheUniformLocations = function ( gl, program, identifiers ) {

		var uniforms = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			uniforms[ id ] = gl.getUniformLocation( program, id );

		}

		return uniforms;

	};

	var cacheAttributeLocations = function ( gl, program, identifiers ) {

		var attributes = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			attributes[ id ] = gl.getAttribLocation( program, id );

		}

		return attributes;

	};

	// Add clamping and inversion code for the simple Phong material perform any operations needed.
	// This is done here because we have access to the clamp and inversion parameters. The macro #defined
	// by this method can then be used elsewhere without knowledge of these parameters.
	var getMapChunk = function(name, clampS, clampT, invert, emptyChunk) {
		var invertChunk = invert ? "1.0-" : "";
		var readChunk = "texture2D("+name+", (UV))";
		var conditionChunk = "";
		emptyChunk = emptyChunk || "vec4(0.0)";
		if (clampS && clampT)
			conditionChunk = "((UV).x < 0.0 || (UV).x > 1.0 || (UV).y < 0.0 || (UV).y > 1.0) ? "+emptyChunk+" : ";
		else if (clampS)
			conditionChunk = "((UV).x < 0.0 || (UV).x > 1.0) ? "+emptyChunk+" : ";
		else if (clampT)
			conditionChunk = "((UV).y < 0.0 || (UV).y > 1.0) ? "+emptyChunk+" : ";
		return "#define GET_"+name.toUpperCase()+"(UV) ("+conditionChunk+invertChunk+readChunk+")";
	};

	// We test if the UVs are in the bounds when clamping; if not, discard!
	// This is done here because we have access to the clamp parameters. The macro #defined
	// by this method can then be used elsewhere, e.g. GetPrismMapSampleChunk, without knowledge of these parameters.
	// Here is a typical result returned when clamping is on and "opaque_albedo" is passed in for the name:
	// #define OPAQUE_ALBEDO_CLAMP_TEST if (uv_opaque_albedo_map.x < 0.0 || uv_opaque_albedo_map.x > 1.0 || uv_opaque_albedo_map.y < 0.0 || uv_opaque_albedo_map.y > 1.0) { discard; }
	var getPrismMapChunk = function(name, clampS, clampT) {
		var uv = "uv_"+name+"_map";
		var conditionChunk = "";
		if (clampS && clampT)
			conditionChunk = "if ("+uv+".x < 0.0 || "+uv+".x > 1.0 || "+uv+".y < 0.0 || "+uv+".y > 1.0) { discard; }";
		else if (clampS)
			conditionChunk = "if ("+uv+".x < 0.0 || "+uv+".x > 1.0) { discard; }";
		else if (clampT)
			conditionChunk = "if ("+uv+".y < 0.0 || "+uv+".y > 1.0) { discard; }";
		return "#define "+name.toUpperCase()+"_CLAMP_TEST "+conditionChunk;
	};

	return function ( renderer, code, material, parameters ) {

		var _this = renderer;
		var _gl = _this.context;

		var defines = material.defines;
		var uniforms = material.__webglShader.uniforms;
		var attributes = material.attributes;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var index0AttributeName = material.index0AttributeName;

		if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0

			index0AttributeName = 'position';

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {
			//This will make more sense when we update three.js to R70
			//Currently we don't need any of it anyway, because we only
			//reflect and use cube maps.
/*
			switch ( material.envMap.mapping ) {

				case THREE.CubeReflectionMapping:
				case THREE.CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case THREE.EquirectangularReflectionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case THREE.SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case THREE.CubeRefractionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}


			switch ( material.combine ) {

				case THREE.MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case THREE.MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case THREE.AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}
*/
		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		var program = _gl.createProgram();

		var prefix_vertex, prefix_fragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefix_vertex = '';
			prefix_fragment = '';

		} else {

			prefix_vertex = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				customDefines,

				parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				parameters.mrtNormals ? "#define MRT_NORMALS" : "", //FY
				parameters.mrtIdBuffer ? "#define MRT_ID_BUFFER" : "", //FY

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				"#define MAX_BONES " + parameters.maxBones,

				"#define NUM_CUTPLANES " + parameters.numCutplanes,

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.irradianceMap ? "#define USE_IRRADIANCEMAP" : "", //FY
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.skinning ? "#define USE_SKINNING" : "",
				parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

				parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
				parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				parameters.useFragDepthExt ? "#define USE_LOGDEPTHBUF_EXT" : "",

				parameters.packedNormals ? "#define UNPACK_NORMALS" : "",

				// "#define FLAT_SHADED",  // TODO_NOP: hook up to param

				"uniform mat4 modelMatrix;",
				"uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;",
				"uniform mat4 viewMatrix;",
				"uniform mat3 normalMatrix;",
				"uniform vec3 cameraPosition;",

				"attribute vec3 position;",

				"#ifdef UNPACK_NORMALS",
					"attribute vec2 normal;",
				"#else"	,
					"attribute vec3 normal;",
				"#endif",

				"attribute vec2 uv;",
				"attribute vec2 uv2;",

				"#ifdef PRISMWOOD",
					"attribute vec3 uvw;",
				"#endif",

				"#ifdef USE_COLOR",

				"	attribute vec3 color;",

				"#endif",

				""

			].join( '\n' );

			prefix_fragment = [
				( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",
				((parameters.mrtIdBuffer || parameters.mrtNormals) && (typeof _isIE11 === "undefined" || !_isIE11)) ? "#extension GL_EXT_draw_buffers : enable" : "",
				parameters.mrtIdBuffer ? "#define gl_FragColor gl_FragData[0]" : "",

                parameters.haveTextureLod ? "#define HAVE_TEXTURE_LOD" : "",

				customDefines,

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				"#define NUM_CUTPLANES " + parameters.numCutplanes,

				parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				parameters.mrtNormals ? "#define MRT_NORMALS" : "", //FY
				parameters.mrtIdBuffer ? "#define MRT_ID_BUFFER" : "", //FY
				'#define TONEMAP_OUTPUT ' + (parameters.tonemapOutput || 0),

				( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
				( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.irradianceMap ? "#define USE_IRRADIANCEMAP" : "", //FY
				parameters.envGammaEncoded ? "#define ENV_GAMMA": "", //FY
				parameters.irrGammaEncoded ? "#define IRR_GAMMA": "", //FY
				parameters.envRGBM ? "#define ENV_RGBM": "", //FY
				parameters.irrRGBM ? "#define IRR_RGBM": "", //FY
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.metal ? "#define METAL" : "",
				parameters.clearcoat ? "#define CLEARCOAT": "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				//parameters.useFragDepthExt ? "#define USE_LOGDEPTHBUF_EXT" : "",

				parameters.hatchPattern ? "#define HATCH_PATTERN" : "",

				parameters.mapInvert ? "#define MAP_INVERT" : "",
				getMapChunk("map", parameters.mapClampS, parameters.mapClampT),
				getMapChunk("bumpMap", parameters.bumpMapClampS, parameters.bumpMapClampT),
				getMapChunk("normalMap", parameters.normalMapClampS, parameters.normalMapClampT),
				getMapChunk("specularMap", parameters.specularMapClampS, parameters.specularMapClampT),
				getMapChunk("alphaMap", parameters.alphaMapClampS, parameters.alphaMapClampT, parameters.alphaMapInvert),

				// "#define FLAT_SHADED",  // TODO_NOP: hook up to param

				"#ifdef USE_ENVMAP",
				"#ifdef HAVE_TEXTURE_LOD",
				"#extension GL_EXT_shader_texture_lod : enable",
				"#endif",
				'#endif',

				"#extension GL_OES_standard_derivatives : enable",

				"precision " + parameters.precisionFragment + " float;",
				"precision " + parameters.precisionFragment + " int;",

				"uniform highp mat4 viewMatrix;",
				"uniform highp mat4 projectionMatrix;",
				"uniform highp vec3 cameraPosition;",

	            "#ifdef USE_ENVMAP",

                	"uniform mat4 viewMatrixInverse;",

            	"#endif",
				
				// now get map chunks for PRISM material
				// mapPrismOpaqueLuminanceModifierClampS etc. are set in FireflyWebGLRenderer.js in the parameters
				getPrismMapChunk( "opaque_luminance_modifier", parameters.mapPrismOpaqueLuminanceModifierClampS, parameters.mapPrismOpaqueLuminanceModifierClampT ),
				
				getPrismMapChunk( "surface_albedo", parameters.mapPrismSurfaceAlbedoClampS, parameters.mapPrismSurfaceAlbedoClampT ),
				getPrismMapChunk( "surface_roughness", parameters.mapPrismSurfaceRoughnessClampS, parameters.mapPrismSurfaceRoughnessClampT ),
				getPrismMapChunk( "surface_anisotropy", parameters.mapPrismSurfaceAnisotropyClampS, parameters.mapPrismSurfaceAnisotropyClampT ),
				getPrismMapChunk( "surface_rotation", parameters.mapPrismSurfaceRotationClampS, parameters.mapPrismSurfaceRotationClampT ),
				getPrismMapChunk( "opaque_f0", parameters.mapPrismOpaqueF0ClampS, parameters.mapPrismOpaqueF0ClampT ),
				getPrismMapChunk( "opaque_albedo", parameters.mapPrismOpaqueAlbedoClampS, parameters.mapPrismOpaqueAlbedoClampT ),
				getPrismMapChunk( "metal_f0", parameters.mapPrismMetalF0ClampS, parameters.mapPrismMetalF0ClampT ),
				getPrismMapChunk( "layered_f0", parameters.mapPrismLayeredF0ClampS, parameters.mapPrismLayeredF0ClampT ),
				getPrismMapChunk( "layered_diffuse", parameters.mapPrismLayeredDiffuseClampS, parameters.mapPrismLayeredDiffuseClampT ),
				getPrismMapChunk( "layered_roughness", parameters.mapPrismLayeredRoughnessClampS, parameters.mapPrismLayeredRoughnessClampT ),
				getPrismMapChunk( "layered_anisotropy", parameters.mapPrismLayeredAnisotropyClampS, parameters.mapPrismLayeredAnisotropyClampT ),
				getPrismMapChunk( "layered_rotation", parameters.mapPrismLayeredRotationClampS, parameters.mapPrismLayeredRotationClampT ),
				getPrismMapChunk( "layered_bottom_f0", parameters.mapPrismLayeredBottomF0ClampS, parameters.mapPrismLayeredBottomF0ClampT ),
				getPrismMapChunk( "layered_fraction", parameters.mapPrismLayeredFractionClampS, parameters.mapPrismLayeredFractionClampT ),
				
				getPrismMapChunk( "surface_cutout", parameters.mapPrismSurfaceCutoutClampS, parameters.mapPrismSurfaceCutoutClampT ),

				""

			].join( '\n' );

		}

		var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
		var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		if ( index0AttributeName !== undefined ) {

			// Force a particular attribute to index 0.
			// because potentially expensive emulation is done by browser if attribute 0 is disabled.
			// And, color, for example is often automatically bound to index 0 so disabling it

			_gl.bindAttribLocation( program, 0, index0AttributeName );

		}

		_gl.linkProgram( program );

		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

			console.error( 'THREE.WebGLProgram: Could not initialise shader.' );
			console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
			console.error( 'gl.getError()', _gl.getError() );

		}

		if ( _gl.getProgramInfoLog( program ) !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

		}

		// clean up

		_gl.deleteShader( glVertexShader );
		_gl.deleteShader( glFragmentShader );

		// cache uniform locations

		var identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'viewMatrixInverse', 'mvpMatrix', 'dbId'//FY

		];

		if ( parameters.logarithmicDepthBuffer ) {

			identifiers.push('logDepthBufFC');

		}


		for ( var u in uniforms ) {

			identifiers.push( u );

		}

		this.uniforms = cacheUniformLocations( _gl, program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"lineDistance", "uvw"

		];

		for ( var a in attributes ) {

			identifiers.push( a );

		}

		this.attributes = cacheAttributeLocations( _gl, program, identifiers );
		this.attributesKeys = Object.keys( this.attributes );

		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();
;/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 *
 * @author stanevt -- Modified for Autodesk LMV web viewer
 */
/*global THREE, Autodesk, FireflyWebGLRenderer, FireflyWebGLProgram, rescueFromPolymer, isMobileDevice*/

var av = Autodesk.Viewing,
    avp = av.Private;

var FireflyWebGLRenderer = function ( parameters ) {
	'use strict';
	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),

	pixelRatio = window.devicePixelRatio || 1,

	_precisionVertex = parameters.precision !== undefined ? parameters.precision : 'highp',
	_precisionFragment = parameters.precision !== undefined ? parameters.precision : av.isMobileDevice() ? 'mediump' : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : true, //change it to true for the screen capture api
	_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,


	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var lights = [];
	var _webglObjects = {};
	var _webglObjectsImmediate = [];
	var _objectModelViewMatrix = new THREE.Matrix4();
	var _objectNormalMatrix = new THREE.Matrix3();


	var opaqueObjects = [];
	var transparentObjects = [];


	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapAutoUpdate = true;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentCamera = null,

	_currentGeometryProgram = '',

	_usedTextureUnits = 0,

	// GL state cache

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

    _dynamicBuffers = {}, //gl buffers used for streaming draw

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_viewInverseEnv = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: [], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	};

	// initialize

	var _gl;

    var _glExtensionDrawBuffers;
    var _glExtensionInstancedArrays;
    var _glExtensionVAO;

	try {

		var attributes = {
			alpha: _alpha,
			premultipliedAlpha: _premultipliedAlpha,
			antialias: _antialias,
			stencil: _stencil,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl') !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		_gl = rescueFromPolymer(_gl);

		_canvas.addEventListener( 'webglcontextlost', function ( event ) {

			event.preventDefault();

			resetGLState();
			setDefaultGLState();

			_webglObjects = {};

		}, false);

	} catch ( error ) {

		console.error( error );

	}

	var state = new THREE.WebGLState( _gl, paramThreeToGL );

	if ( _gl.getShaderPrecisionFormat === undefined ) {

		_gl.getShaderPrecisionFormat = function() {

			return {
				"rangeMin"  : 1,
				"rangeMax"  : 1,
				"precision" : 1
			};

		};
	}

	var extensions = new THREE.WebGLExtensions( _gl );

	//We know we are going to be using some extensions for sure
	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'EXT_shader_texture_lod' );
	extensions.get( 'EXT_texture_filter_anisotropic' );
	extensions.get( 'WEBGL_compressed_texture_s3tc' );

	_glExtensionDrawBuffers = extensions.get( 'WEBGL_draw_buffers' );
	_glExtensionInstancedArrays = null;//extensions.get('ANGLE_instanced_arrays');
	_glExtensionVAO = extensions.get('OES_vertex_array_object');


	if ( _logarithmicDepthBuffer ) {

		extensions.get( 'EXT_frag_depth' );

	}

	var glClearColor = function ( r, g, b, a ) {

		if ( _premultipliedAlpha === true ) {

			r *= a; g *= a; b *= a;

		}

		_gl.clearColor( r, g, b, a );

	};

	var setDefaultGLState = function() {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	var resetGLState = function () {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		_lightsNeedUpdate = true;

		state.reset();

	};


	setDefaultGLState();

	this.context = _gl;
	this.state = state;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _supportsVertexTextures = _maxVertexTextures > 0;
	// not used, though used in three.js's version:
	//var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );


	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	//var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	//var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );


	var getCompressedTextureFormats = ( function () {

		var array;

		return function () {

			if ( array !== undefined ) {

				return array;

			}

			array = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

				var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ){

					array.push( formats[ i ] );

				}

			}

			return array;

		};

	} )();


	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0;

	if ( _precisionVertex === "highp" && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precisionVertex = "mediump";
			console.warn( "WebGLRenderer: highp not supported, using mediump" );

		} else {

			_precisionVertex = "lowp";
			console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );

		}

	}

	if ( _precisionVertex === "mediump" && ! mediumpAvailable ) {

		_precisionVertex = "lowp";
		console.warn( "WebGLRenderer: mediump not supported, using lowp" );
		
	}
	
	highpAvailable = _fragmentShaderPrecisionHighpFloat.precision > 0;
	mediumpAvailable = _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precisionFragment === "highp" && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precisionFragment = "mediump";
			console.warn( "WebGLRenderer: highp not supported, using mediump" );

		} else {

			_precisionFragment = "lowp";
			console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );

		}

	}

	if ( _precisionFragment === "mediump" && ! mediumpAvailable ) {

		_precisionFragment = "lowp";
		console.warn( "WebGLRenderer: mediump not supported, using lowp" );

	}

	

	// API

	this.getContext = function () {

		return _gl;

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return extensions.get( 'OES_texture_float' );

	};

	this.supportsHalfFloatTextures = function() {

		return extensions.get( 'OES_texture_half_float_linear' );

	};

	this.supportsStandardDerivatives = function () {

		return extensions.get( 'OES_standard_derivatives' );

	};

	this.supportsCompressedTextureS3TC = function () {

		return extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

    this.supportsMRT = function() {
        return _glExtensionDrawBuffers;
    };

	this.supportsBlendMinMax = function () {

		return extensions.get( 'EXT_blend_minmax' );

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function () {

			if ( value !== undefined ) {

				return value;

			}

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

			return value;

		};

	} )();

	this.getPixelRatio = function () {

		return pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		pixelRatio = value;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * pixelRatio;
		_viewportY = y * pixelRatio;

		_viewportWidth = width * pixelRatio;
		_viewportHeight = height * pixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * pixelRatio,
			y * pixelRatio,
			width * pixelRatio,
			height * pixelRatio
		);

	};

	this.enableScissorTest = function ( enable ) {

		if ( enable ) {
			_gl.enable( _gl.SCISSOR_TEST );
		} else {
			_gl.disable( _gl.SCISSOR_TEST );
		}

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};


	// Reset

	this.resetGLState = resetGLState;

	// Rendering

	this.updateShadowMap = function ( scene, camera ) {

		_currentProgram = null;
		_currentGeometryProgram = '';
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;

		// there is no such method currently: initObjects( scene );

		//shadowMapPlugin.update( scene, camera );

	};

	// Internal functions

	// Buffer allocation

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	}

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	}

	// Events

	var onObjectRemoved = function ( event ) {

		var object = event.target;

		object.traverse( function ( child ) {

			child.removeEventListener( 'remove', onObjectRemoved );

			removeObject( child );

		} );

	};

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {

		if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var name in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

			}

		}

		_this.info.memory.geometries --;

	};


	var deallocateGeometry = function ( geometry ) {

		geometry.__webglInit = undefined;
		
		var i, len, m, ml;

		if ( geometry instanceof THREE.BufferGeometry ) {

			//[Firefly] Delete interleaved buffer
            if (geometry.vbbuffer !== undefined)
                _gl.deleteBuffer(geometry.vbbuffer);

			//[Firefly] Delete index buffer (if not stored in vertex attribute object)
			if (geometry.ibbuffer !== undefined)
				_gl.deleteBuffer(geometry.ibbuffer);

            //[Firefly] Delete vertex array objects.
            if (geometry.vaos) {
                for (i=0; i<geometry.vaos.length; i++) {
                    _glExtensionVAO.deleteVertexArrayOES(geometry.vaos[i].vao);
                }
            }

			var attributes = geometry.attributes;

			for ( var key in attributes ) {

				if ( attributes[ key ].buffer !== undefined ) {

					_gl.deleteBuffer( attributes[ key ].buffer );

				}

			}

			_this.info.memory.geometries --;

		} else {

			var geometryGroupsList = geometryGroups[ geometry.id ];

			if ( geometryGroupsList !== undefined ) {

				for ( i = 0, len = geometryGroupsList.length; i < len; i ++ ) {

					var geometryGroup = geometryGroupsList[ i ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphTargetsBuffers;

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphNormalsBuffers;

					}

					deleteBuffers( geometryGroup );

				}

				delete geometryGroups[ geometry.id ];

			} else {

				deleteBuffers( geometry );

			}

		}

	};

	this.deallocateGeometry = deallocateGeometry;

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture.__webglInit ) return;

			texture.__webglInit = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

        _gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
        _gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		var material = object.material;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	}

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	}

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup ),

			uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		// console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceVertexUvs.length > 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

		geometryGroup.__typeArray = UintArray;
		geometryGroup.__faceArray = new UintArray( ntris * 3 );
		geometryGroup.__lineArray = new UintArray( nlines * 2 );

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if( attribute.type === "v2" ) size = 2;
					else if( attribute.type === "v3" ) size = 3;
					else if( attribute.type === "v4" ) size = 4;
					else if( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	}

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial ?
			object.material.materials[ geometryGroup.materialIndex ] : object.material;

	}

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	}

	function bufferGuessNormalType ( material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {

			return false;

		}

		if ( materialNeedsSmoothNormals( material ) ) {

			return THREE.SmoothShading;

		} else {

			return THREE.FlatShading;

		}

	}

	function bufferGuessVertexColorType( material ) {

		if ( material.vertexColors ) {

			return material.vertexColors;

		}

		return false;

	}

	function bufferGuessUVType( material ) {

		// material must use some texture to require uvs

		if ( material.map ||
		     material.lightMap ||
		     material.bumpMap ||
		     material.normalMap ||
		     material.specularMap ||
             material.alphaMap ||
		     material instanceof THREE.ShaderMaterial ) {

			return true;

		}

		return false;

	}


	// Buffer setting


	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === THREE.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, t1, t2, t3,
		c1, c2, c3,
		i, il,
		vn, uvi, uv2i,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ];

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}


		if ( dirtyColors && vertexColorType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals && normalType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	}


	//[Firefly] This function is different from Three.js -- it adds
	//support for interleaved buffers and drawing from system memory
	//using a shared dynamic buffer.
	function setDirectBuffers ( geometry ) {

		//[Firefly]
        //Geometries that will draw directly
        //from system memory skip alocations of
        //GPU side GL buffers.
        if (geometry.streamingDraw) {

            //Do we want just the index buffer on the GPU?
            if (!geometry.streamingIndex) {
                var index = geometry.attributes.index;
                if (index) {
                    index.buffer = _gl.createBuffer();
                    _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
                    _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array || geometry.ib, _gl.STATIC_DRAW );
                }
            }

            return;
        }


        //[Firefly]
        //Does the geometry have an interleaved
        //vertex buffer?
        if (geometry.vb && geometry.vbbuffer === undefined) {

            geometry.vbbuffer = _gl.createBuffer();
            geometry.vbNeedsUpdate = true;
        }
		//[Firefly] Is there an .ib property outside the index attribute (since we use globally shared attributes)?
		if (geometry.ib && geometry.ibbuffer === undefined) {
			geometry.ibbuffer = _gl.createBuffer();
			_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometry.ibbuffer);
			_gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geometry.ib, _gl.STATIC_DRAW);
		}

		var attributes = geometry.attributes;
		var attributesKeys = geometry.attributesKeys;

		for ( var i = 0, len = attributesKeys.length; i < len; i ++ ) {

			var attributeName = attributesKeys[ i ];
			var attributeItem = attributes[ attributeName ];
			var isIndex = ( attributeName === 'index' );

			if ( attributeItem.array &&
				attributeItem.buffer === undefined ) {

				attributeItem.buffer = _gl.createBuffer();
				attributeItem.needsUpdate = true;

			}

			if ( attributeItem.needsUpdate === true ) {

				var bufferType = isIndex ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

				_gl.bindBuffer( bufferType, attributeItem.buffer );
				_gl.bufferData( bufferType, attributeItem.array, _gl.STATIC_DRAW );

				attributeItem.needsUpdate = false;

			}

		}

        //Update the common interleaved vb if needed
        if (geometry.vbNeedsUpdate) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.vbbuffer);
            _gl.bufferData( _gl.ARRAY_BUFFER, geometry.vb, _gl.STATIC_DRAW);
            geometry.vbNeedsUpdate = false;

        }

	}

	// Buffer rendering

    //[Firefly] Setup rendering of static model data using Vertex Array Objects
    //Currently we only do this for buffer geometry that is on GPU memory and has no
    //default material attributes and has a single draw batch (offsets array has length 1).
    //Other geometry passes through setupVertexAttributes instead, to set up
    //the vertex layout on every draw.
    function setupVAO( material, program, geometry, uvChannel) {

        var vao;

        if (geometry.streamingDraw) {
            geometry.vaos = null;
            return false;
        }

        if (geometry.offsets && geometry.offsets.length > 1) {
            geometry.vaos = null;
            return false;
        }

        if (!_glExtensionVAO) {
            geometry.vaos = null;
            return false;
        }

        if (geometry.vaos === undefined)
            geometry.vaos = [];

        //Set up a VAO for this object
        vao = _glExtensionVAO.createVertexArrayOES();
        geometry.vaos.push( { geomhash : program.id, uv : uvChannel, vao : vao } );
        _glExtensionVAO.bindVertexArrayOES(vao);

        //bind the index buffer
        var index = geometry.attributes.index;
        if (index)
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometry.ibbuffer || index.buffer );


        //Bind the vertex attributes used by the current program
        var boundBuffer = null;
        var programAttributes = program.attributes;
		var programAttributesKeys = program.attributesKeys;

        var stride = geometry.vbstride;
        var startIndex = (geometry.offsets && geometry.offsets.length) ? geometry.offsets[0].index : 0;

        //Set up vertex attributes
        for ( var i = 0, len = programAttributesKeys.length; i < len; i ++ ) {

			var key = programAttributesKeys[ i ];
            var programAttribute = programAttributes[ key ];

            if ( programAttribute >= 0 ) {

	            var geometryAttribute = geometry.attributes[ key ];

                // Override 'uv' attribute mapping if uvChannel is specified
                // (account for the 1-based indexing used for the additional UV channel attributes)
                if (key === 'uv' && uvChannel) {
                    geometryAttribute = geometry.attributes['uv' + (uvChannel + 1)];
                }

                if (geometryAttribute) {

                    var type = _gl.FLOAT;
					var itemWidth = geometryAttribute.bytesPerItem || 4;
                    if (itemWidth === 1) {
                        type = _gl.UNSIGNED_BYTE;
                    } else if (itemWidth === 2) {
                    	type = _gl.UNSIGNED_SHORT;
                    }

                    _gl.enableVertexAttribArray(programAttribute);

                    if (geometryAttribute.itemOffset !== undefined) //it's part of the interleaved VB, so process it here
                    {
                        if (boundBuffer != geometry.vbbuffer) {
                            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.vbbuffer );
                            boundBuffer = geometry.vbbuffer;
                        }

                        _gl.vertexAttribPointer( programAttribute, geometryAttribute.itemSize, type, !!geometryAttribute.normalize, stride * 4, (geometryAttribute.itemOffset + startIndex * stride) * 4 );
                    }
                    else {
                        _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );
                        boundBuffer = geometryAttribute.buffer;

                        _gl.vertexAttribPointer( programAttribute, geometryAttribute.itemSize, type, !!geometryAttribute.normalize, 0, startIndex * geometryAttribute.itemSize * itemWidth ); // 4 bytes per Float32
                    }

                    if (_glExtensionInstancedArrays && geometry.numInstances)
                        _glExtensionInstancedArrays.vertexAttribDivisorANGLE(programAttribute, geometryAttribute.divisor || 0);

                } else {

                    //Default material attributes cannot be set in VAO, so we have to abort the VAO setup
                    //and fall back to the regular setupVertexAttributes in draw loop way.
                    //This is hopefully very rare.
                    _glExtensionVAO.bindVertexArrayOES(null);

                    for ( var j=0; j<geometry.vaos.length; j++)
                        _glExtensionVAO.deleteVertexArrayOES(geometry.vaos[j].vao);

                    geometry.vaos = null; //Flag it so we don't pass through here again.

                    return false;
                }

            }
        }

        return true;
    }

    function activateVAO( material, program, geometry, uvChannel) {
        var vaos = geometry.vaos;

        if (vaos) {
            //The assumption is that this array is rarely bigger than one or two items,
            //so it's faster to do a search than use object hashmap based on geomhash.
            for (var i = 0, len = vaos.length; i < len; i++) {
                var cache = vaos[i];
                if (cache.geomhash === program.id && cache.uv === uvChannel) {
                    _glExtensionVAO.bindVertexArrayOES(cache.vao);
                    return true;
                }
            }
        } else if (vaos === null) {
			return false;
		}

		return setupVAO(material, program, geometry, uvChannel);
    }


    function bindDynamic(dynBufName, srcData) {
        var boundBuffer = _dynamicBuffers[dynBufName];
        if (!boundBuffer) {
            boundBuffer = _gl.createBuffer();
            _dynamicBuffers[dynBufName] = boundBuffer;
        }

        _gl.bindBuffer( _gl.ARRAY_BUFFER, boundBuffer);
        _gl.bufferData( _gl.ARRAY_BUFFER, srcData, _gl.DYNAMIC_DRAW);

        return boundBuffer;
    }


	//[Firefly] This function is different from Three.js -- it adds
	//support for interleaved buffers and drawing from system memory
	//using a shared dynamic buffer.
    function setupVertexAttributes( material, program, geometry, startIndex, indices) {

		var programAttributes = program.attributes;
		var programAttributesKeys = program.attributesKeys;

        //Those two need to be unequal to begin with...
        var boundBuffer = 0;
        var interleavedBuffer;
        

        if (indices) {
            // indices (they can have a VBO even if the geometry part is streamed)
            if (!indices.buffer && geometry.streamingDraw) {
                var buffer = _dynamicBuffers.index;
                if (!buffer) {
                    buffer = _gl.createBuffer();
                    _dynamicBuffers.index = buffer;
                }

                //_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, null);
                _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, buffer);
                _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, indices.array || geometry.ib, _gl.DYNAMIC_DRAW);
            }
            else
                _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometry.ibbuffer || indices.buffer );
        }


        //Set attributes
        for ( var i = 0, len = programAttributesKeys.length; i < len; i ++ ) {

			var key = programAttributesKeys[ i ];
            var programAttribute = programAttributes[ key ];
			
            if ( programAttribute >= 0 ) {

	            var geometryAttribute = geometry.attributes[ key ];

                if ( geometryAttribute ) {

                    var isInterleaved = (geometryAttribute.itemOffset !== undefined);

                    var stride, itemOffset;

                    if (isInterleaved) {

                        stride = geometry.vbstride;
                        itemOffset = geometryAttribute.itemOffset;

                        if (boundBuffer !== interleavedBuffer) {
                            if (geometry.streamingDraw) {

                                boundBuffer = bindDynamic('interleavedVB', geometry.vb);

                            } else {

                                boundBuffer = geometry.vbbuffer;
                                _gl.bindBuffer(_gl.ARRAY_BUFFER, boundBuffer);

                            }

                            interleavedBuffer = boundBuffer;
                        }

                    } else {

                        stride = geometryAttribute.itemSize;
                        itemOffset = 0;

                        if (geometry.streamingDraw) {

                            boundBuffer = bindDynamic(key, geometryAttribute.array);

                        } else {

                            boundBuffer = geometryAttribute.buffer;
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, boundBuffer);

                        }
                    }

                    var type = _gl.FLOAT;
					var itemWidth = geometryAttribute.bytesPerItem || 4;
                    if (itemWidth === 1) {
                        type = _gl.UNSIGNED_BYTE;
                    } else if (itemWidth === 2) {
                    	type = _gl.UNSIGNED_SHORT;
                    }

					if (isInterleaved)
						itemWidth = 4; //our interleaved buffers define stride in multiples of 4 bytes

                    state.enableAttribute( programAttribute );
                    _gl.vertexAttribPointer( programAttribute, geometryAttribute.itemSize, type, geometryAttribute.normalize, stride * itemWidth, (itemOffset + startIndex * stride) * itemWidth );

                    if (_glExtensionInstancedArrays && geometry.numInstances)
                        _glExtensionInstancedArrays.vertexAttribDivisorANGLE(programAttribute, geometryAttribute.divisor || 0);


                } else if (material.defaultAttributeValues) {

                    var attr = material.defaultAttributeValues[ key ];

                    if ( attr && attr.length === 2 ) {

                        _gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

                    } else if ( attr && attr.length === 3 ) {

                        _gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

                    }

                }
            }
        }

		state.disableUnusedAttributes();

    }


	// Buffer rendering

	this.renderBufferDirect = function(camera, lights, fog, material, geometry, object, uvChannel) {

		if ( material.visible === false ) return;

		//updateObject(object);
		setDirectBuffers(object.geometry);

		var program = setProgram( camera, lights, fog, material, object );

		var geometryAttributes = geometry.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = 'direct_' + geometry.id + (uvChannel ? '/' + uvChannel : '') + '_' + program.id + '_' + wireframeBit;

		if ( geometryHash !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryHash;
			updateBuffers = true;

		}

		var vao = activateVAO(material, program, geometry, uvChannel || 0);
		updateBuffers = updateBuffers && !vao;

		if ( updateBuffers ) {

			state.initAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var index = geometryAttributes.index;

			// indexed triangles

			if ( index ) {

				var type, size;
				var ib = index.array ? index.array : geometry.ib;

				if ( ib instanceof Uint32Array && extensions.get( 'OES_element_index_uint' )) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}


				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets && offsets.length > 1 ) updateBuffers = true;

                var i = 0;
                do
                {
                    var startIndex, startOffset, count;
                    if (offsets && offsets.length)
                    {
                        startIndex = offsets[ i ].index;
                        startOffset = offsets[ i ].start;
                        count = offsets[ i ].count;
                    }
                    else
                    {
                        startIndex = 0;
                        startOffset = 0;
                        count = ib.length;
                    }

                    if ( updateBuffers ) {

                        setupVertexAttributes(material, program, geometry, startIndex, index);

                    }

                    // render indexed triangles
                    if (geometry.numInstances)
                        _glExtensionInstancedArrays.drawElementsInstancedANGLE( geometry.isLines ? _gl.LINES : _gl.TRIANGLES, count, type, startOffset * size, geometry.numInstances ); // 2 bytes per Uint16
                    else
                        _gl.drawElements( geometry.isLines ? _gl.LINES : _gl.TRIANGLES, count, type, startOffset * size ); // 2 bytes per Uint16

                } while(offsets && ++i < offsets.length);

			// non-indexed triangles

			} else {

				if ( updateBuffers ) {

                    setupVertexAttributes(material, program, geometry, 0);
				}

				var position = geometry.attributes.position;

				// render non-indexed triangles
                if (geometry.numInstances)
    				_glExtensionInstancedArrays.drawArraysInstancedANGLE( geometry.isLines ? _gl.LINE_STRIP : _gl.TRIANGLES, 0, position.array.length / 3, geometry.numInstances );
    		    else
    				_gl.drawArrays( geometry.isLines ? _gl.LINE_STRIP : _gl.TRIANGLES, 0, position.array.length / position.itemSize );

			}
		}
        else
        {
            console.log ("Only THREE.Mesh can be rendered by the Firefly renderer. Use THREE.Mesh to draw lines.");
        }

        if (vao)
            _glExtensionVAO.bindVertexArrayOES(null);
	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		updateObject(object);

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = geometryGroup.id + '_' + program.id + '_' + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			state.initAttributes();

		}

		// vertices

		if ( !material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				state.enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					var attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						state.enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					state.enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				state.enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				state.enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[0] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					state.enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[1] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					state.enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				state.enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		state.disableUnusedAttributes();


		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

			// wireframe

			if ( material.wireframe ) {

				state.setLineWidth( material.wireframeLinewidth * pixelRatio );
				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

			}

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			state.setLineWidth( material.linewidth * pixelRatio );

			_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

		// render particles

		}

	};


	// Sorting

	// This method is for transparency
	function painterSortStable ( a, b ) {

		// first see if there's a render order set - if so, this takes precedence
		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		// If render order are the same, then use z distance.
		// We want to render from farthest to nearest.
		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		// if z distances match, then use id, for a consistent result
		} else {

			return a.id - b.id;

		}

	}

	// This method is for opaque objects
	function reversePainterSortStable ( a, b ) {

		// first see if there's a render order set - if so, this takes precedence
		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		// Next, sort by material, for efficiency, to avoid state changes.
		// (Note this is not done for transparency, as back to front order is more significant.)
		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		// If render order and material are the same, then use z distance.
		// To minimize processing fragments, we render roughly from nearest to farthest.
		// In this way, the closer objects cover pixels and so hide more distance objects.
		} if ( a.z !== b.z ) {

			return b.z - a.z;

		// if z distances match, then use id, for a consistent sorted result
		} else {

			return a.id - b.id;

		}

	}

	/* currently not used
	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	}
	*/


	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear, customLights ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = -1;
		_currentCamera = null;

		if (customLights !== undefined) {
			lights.length = 0;
			_lightsNeedUpdate = true;
		}

		var fog = scene.fog;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        if (camera.worldUpTransform)
            _viewInverseEnv.multiplyMatrices(camera.worldUpTransform, camera.matrixWorld);
        else
            _viewInverseEnv.copy(camera.matrixWorld);

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// update WebGL objects
		var renderImmediate = (scene instanceof Autodesk.Viewing.Private.RenderBatch) && scene.renderImmediate;

		if (!renderImmediate) {
			opaqueObjects.length = 0;
			transparentObjects.length = 0;

			projectObject( scene, _this.sortObjects === true, scene.forceVisible === true );

            // note: the following flag is never set in FireflyWebGLRenderer; this may change in the future
			if (_this.sortObjects === true) {
				opaqueObjects.sort( reversePainterSortStable );
				transparentObjects.sort( painterSortStable );
			}
		}

		if (_lightsNeedUpdate) {
			if (customLights && customLights.length)
				lights = customLights.slice();
			setupLights(lights);
		}

		this.resetGLState();

		//

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			setMaterial( overrideMaterial );

			if (!renderImmediate) {
				renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );
			} else {
				renderObjectsImmediate(scene, "", camera, lights, fog, overrideMaterial);
			}

		} else {

			if (!renderImmediate) {
				// opaque pass (front-to-back order)
				state.setBlending( THREE.NoBlending );

				renderObjects( opaqueObjects, camera, lights, fog, null );

				// transparent pass (back-to-front order)

				renderObjects( transparentObjects, camera, lights, fog, null );
			} else {
				renderObjectsImmediate(scene, "", camera, lights, fog, null);
			}

		}


		this.resetGLState();

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.setDepthTest( true );
		state.setDepthWrite( true );

		// _gl.finish();

	};

	function renderBatchIterSort(m) {
		projectObject(m, true);
	}

	function renderBatchIterNoSort(m) {
		projectObject(m, false);
	}

	function projectObject( object, sortObjects, forceVisible ) {

		var i, len;

		if ( !forceVisible && object.visible === false )
			return;

		if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

			// skip

		} else if (object instanceof Autodesk.Viewing.Private.RenderBatch) {

				object.forEach(sortObjects ? renderBatchIterSort : renderBatchIterNoSort);

		} else {

			initObject( object );

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else {

				var webglObjects = _webglObjects[ object.id ];

				if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

					for ( i = 0, len = webglObjects.length; i < len; i ++ ) {

						var webglObject = webglObjects[i];

						unrollBufferMaterial( webglObject );

						webglObject.render = true;

						if ( sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );
							webglObject.z = _vector3.z;

						}

					}

				}

			}

		}

		if (object.children) {

			for ( i = 0, len = object.children.length; i < len; i ++ ) {

				projectObject( object.children[ i ], sortObjects, forceVisible );

			}

		}

	}


	function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

		var material;

		//TODO: we have to iterate upwards in order to preserve draw order for 2d
		//without having to sort the scene. Figure out how to keep the reverse iteration so that
		//we are consistent with three.js
		for ( var i = 0, iEnd = renderList.length; i < iEnd; i ++ ) {
		//for ( var i = renderList.length - 1; i !== - 1; i -- ) {

			var webglObject = renderList[ i ];

			var object = webglObject.object;
			var buffer = webglObject.buffer;

			if ( overrideMaterial ) {

                var cutplanes = webglObject.material.cutplanes ? webglObject.material.cutplanes.length : 0;
                if (cutplanes === 0 && overrideMaterial._noCutplanesMaterial) {
                    material = overrideMaterial._noCutplanesMaterial;
                } else {
                    material = overrideMaterial;
                }

			} else {

				material = webglObject.material;

				if ( ! material ) continue;

				setMaterial( material );
			}

			// If the object is double-sided and transparent, render it in two passes:
			// backfaces, then frontfaces. This helps avoid out-of-order sorting
			// transparency blending artifacts (these still can occur for pixels where
			// four or more triangles in a single mesh overlap the same pixel).
			// Also, check that depth testing is on; if not, we're in 2D mode and draw
			// order matters so we should not use this mode.
			// Else render normally.
			if ( material.transparent && (material.side === THREE.DoubleSide) && material.depthTest )
			{
				material.side = THREE.BackSide;
				renderObjectsFace( material, camera, lights, fog, buffer, overrideMaterial, object );
				material.side = THREE.FrontSide;
				renderObjectsFace( material, camera, lights, fog, buffer, overrideMaterial, object );
				material.side = THREE.DoubleSide;
			}
			else
			{
				renderObjectsFace( material, camera, lights, fog, buffer, overrideMaterial, object );
			}
		}
	}

	function renderObjectsFace( material, camera, lights, fog, buffer, overrideMaterial, object )
	{
		_this.setMaterialFaces( material );

		if ( buffer instanceof THREE.BufferGeometry ) {
			_this.renderBufferDirect( camera, lights, fog, material, buffer, object );
		} else {
			_this.renderBuffer( camera, lights, fog, material, buffer, object );
		}

		if (material.decals) {
			var decals = material.decals;
			for (var di = 0, dlen = decals.length; di < dlen; di++) {
				var decal = decals[di];
				material = decal.material;
				setMaterial(material);
				_this.setMaterialFaces(material);
				if (buffer instanceof THREE.BufferGeometry) {
					_this.renderBufferDirect(camera, lights, fog, material, buffer, object, decal.uv);
				}
			}
		}
	}
	
	var roi_materialType, roi_camera, roi_lights, roi_fog, roi_overrideMaterial;

	function renderImmediateCallback(m, idx) {

		if ( m.visible && !m.hide) {
			var material;

			if ( roi_overrideMaterial ) {

                var cutplanes = m.material.cutplanes ? m.material.cutplanes.length : 0;
                if (cutplanes === 0 && roi_overrideMaterial._noCutplanesMaterial) {
                    material = roi_overrideMaterial._noCutplanesMaterial;
                } else {
                    material = roi_overrideMaterial;
                }

			} else {

				material = m.material;

				if ( ! material ) return;

				setMaterial(material);
			}
	
			// If the object is double-sided and transparent, render it in two passes:
			// backfaces, then frontfaces. This helps avoid out-of-order sorting
			// transparency blending artifacts (these still can occur for pixels where
			// four or more triangles in a single mesh overlap the same pixel).
			// Also, check that depth testing is on; if not, we're in 2D mode and draw
			// order matters so we should not use this mode.
			// Else render normally.
			if ( material.transparent && (material.side === THREE.DoubleSide) && material.depthTest )
			{
				material.side = THREE.BackSide;
				renderImmediateFace( m, material );
				material.side = THREE.FrontSide;
				renderImmediateFace( m, material );
				material.side = THREE.DoubleSide;
			}
			else
			{
				renderImmediateFace( m, material );
			}
		}
	}

	function renderImmediateFace( m, material )
	{
		_this.setMaterialFaces( material );
		_this.renderBufferDirect( roi_camera, roi_lights, roi_fog, material, m.geometry, m );

		if (material.decals) {
			var decals = material.decals;
			for (var di = 0, dlen = decals.length; di < dlen; di++) {
				var decal = decals[di];
				material = decal.material;
				setMaterial(material);
				_this.setMaterialFaces(material);
				_this.renderBufferDirect(roi_camera, roi_lights, roi_fog, material, m.geometry, m, decal.uv);
			}
		}
	}
		
	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {

		roi_materialType = materialType;
		roi_camera = camera;
		roi_lights = lights;
		roi_overrideMaterial = overrideMaterial || null;

		// not really "forceVisible"
		// it's really only for ground shadows, or custom modelQueue iteration passes
		// In such cases we use the MESH_VISIBLE bit instead of the actual current visibility of the mesh (which is dependent on the render pass being done)
		renderList.forEach(renderImmediateCallback, renderList.forceVisible ? 1 : 0x80, false);

	}


	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;

		if ( material instanceof THREE.MeshFaceMaterial ) {

			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

			material = material.materials[ materialIndex ];

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		} else if ( material ) {

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		}

	}



	// Objects adding

	function initObject( object ) {

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;

			object.addEventListener( 'removed', onObjectRemoved );

		}

		var geometry = object.geometry;

		if ( geometry === undefined ) {

			// ImmediateRenderObject

		} else if ( geometry.__webglInit === undefined ) {

			geometry.__webglInit = true;
			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry instanceof THREE.BufferGeometry ) {

				//

			} else if ( object instanceof THREE.Mesh ) {

				initGeometryGroups( object, geometry );

			} else if ( object instanceof THREE.Line ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined) {

			object.__webglActive = true;

			if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( _webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					var geometryGroupsList = geometryGroups[ geometry.id ];

					for ( var i = 0,len = geometryGroupsList.length; i < len; i ++ ) {

						addBuffer( _webglObjects, geometryGroupsList[ i ], object );

					}

				}

			} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

				addBuffer( _webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( _webglObjectsImmediate, object );

			}

		}

	}


	// Geometry splitting

	var geometryGroups = {};
	var geometryGroupCounter = 0;

	function makeGroups( geometry, usesFaceMaterial ) {

		var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

		var groupHash, hash_map = {};

		var numMorphTargets = geometry.morphTargets ? geometry.morphTargets.length : 0;
		var numMorphNormals = geometry.morphNormals ? geometry.morphNormals.length : 0;

		var group;
		var groups = {};
		var groupsList = [];

		for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			var face = geometry.faces[ f ];
			var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

			if ( ! ( materialIndex in hash_map ) ) {

				hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

			}

			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

			if ( ! ( groupHash in groups ) ) {

				group = {
					id: geometryGroupCounter ++,
					faces3: [],
					materialIndex: materialIndex,
					vertices: 0,
					numMorphTargets: numMorphTargets,
					numMorphNormals: numMorphNormals
				};

				groups[ groupHash ] = group;
				groupsList.push( group );

			}

			if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

				hash_map[ materialIndex ].counter += 1;
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in groups ) ) {

					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};

					groups[ groupHash ] = group;
					groupsList.push( group );

				}

			}

			groups[ groupHash ].faces3.push( f );
			groups[ groupHash ].vertices += 3;

		}

		return groupsList;

	}

	function initGeometryGroups( object, geometry ) {

		var material = object.material, addBuffers = false;

		if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

			delete _webglObjects[ object.id ];

			geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial);

			geometry.groupsNeedUpdate = false;

		}

		var geometryGroupsList = geometryGroups[ geometry.id ];

		// create separate VBOs per geometry chunk

		for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

			var geometryGroup = geometryGroupsList[ i ];

			// initialise VBO on the first access

			if ( geometryGroup.__webglVertexBuffer === undefined ) {

				createMeshBuffers( geometryGroup );
				initMeshBuffers( geometryGroup, object );

				geometry.verticesNeedUpdate = true;
				geometry.morphTargetsNeedUpdate = true;
				geometry.elementsNeedUpdate = true;
				geometry.uvsNeedUpdate = true;
				geometry.normalsNeedUpdate = true;
				geometry.tangentsNeedUpdate = true;
				geometry.colorsNeedUpdate = true;

				addBuffers = true;

			} else {

				addBuffers = false;

			}

			if ( addBuffers || object.__webglActive === undefined ) {

				addBuffer( _webglObjects, geometryGroup, object );

			}

		}

		object.__webglActive = true;

	}


	function addBuffer( objlist, buffer, object ) {

		var id = object.id;
		objlist[id] = objlist[id] || [];
		objlist[id].push(
			{
				id: id,
				buffer: buffer,
				object: object,
				material: null,
				z: 0
			}
		);

	}

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	}

	// Objects updates

	// Objects updates

	function updateObject( object ) {

		var geometry = object.geometry, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			if ( geometry.groupsNeedUpdate === true ) {

				initGeometryGroups( object, geometry );

			}

			var geometryGroupsList = geometryGroups[ geometry.id ];

			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

				var geometryGroup = geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	}

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var name in material.attributes ) {

			if ( material.attributes[ name ].needsUpdate ) return true;

		}

		return false;

	}

	function clearCustomAttributes( material ) {

		for ( var name in material.attributes ) {

			material.attributes[ name ].needsUpdate = false;

		}

	}

	// Objects removal

	function removeObject( object ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.PointCloud ||
			 object instanceof THREE.Line ) {

			delete _webglObjects[ object.id ];

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( _webglObjectsImmediate, object );

		}

		delete object.__webglInit;
		delete object.__webglActive;

	}

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	}

	// Materials

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'firefly_basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'firefly_phong',
		LineBasicMaterial: 'firefly_basic',
		LineDashedMaterial: 'dashed',
		PointCloudMaterial: 'particle_basic'
	};

	function initMaterial( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var shaderID = shaderIDs[ material.type ];

		if ( shaderID ) {

			var shader = THREE.ShaderLib[ shaderID ];

			material.__webglShader = {
				uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			};

		} else {

			material.__webglShader = {
				uniforms: material.uniforms,
				vertexShader: material.vertexShader,
				fragmentShader: material.fragmentShader
			};
		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxLightCount = allocateLights( lights );

		var maxShadows = allocateShadows( lights );

		//var maxBones = 0;//allocateBones( object );

		var parameters = {

            precision: _precisionVertex,
            precisionFragment: _precisionFragment,
			supportsVertexTextures: _supportsVertexTextures,
            haveTextureLod: !!extensions.get("EXT_shader_texture_lod"),

			map: !!material.map,
			envMap: !!material.envMap,
            irradianceMap: !!material.irradianceMap,
            envIsSpherical: (material.envMap && material.envMap.mapping == THREE.SphericalReflectionMapping),
            envGammaEncoded: material.envMap && material.envMap.GammaEncoded,
            irrGammaEncoded: material.irradianceMap && material.irradianceMap.GammaEncoded,
            envRGBM: material.envMap && material.envMap.RGBM,
            irrRGBM: material.irradianceMap && material.irradianceMap.RGBM,
			lightMap: !!material.lightMap,
			bumpMap: extensions.get("OES_standard_derivatives") && !!material.bumpMap,
			normalMap: extensions.get("OES_standard_derivatives") && !!material.normalMap,
			specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: _logarithmicDepthBuffer,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow,
			shadowMapType: _this.shadowMapType,
			shadowMapDebug: _this.shadowMapDebug,
			shadowMapCascade: _this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
            clearcoat: material.clearcoat,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide,

            mrtNormals: (material.mrtNormals),
            mrtIdBuffer: (material.mrtIdBuffer),
            tonemapOutput : material.tonemapOutput,
            packedNormals : material.packedNormals,
            hatchPattern : !!material.hatchParams,

            // TODO_NOP should not be per mat
			numCutplanes: (material.cutplanes ? material.cutplanes.length : 0),

			// texture flags for clamp and invert for simple phong material
			// add as wanted/necessary
			mapInvert: material.map && material.map.invert,
			mapClampS: material.map && material.map.clampS,
			mapClampT: material.map && material.map.clampT,
			bumpMapClampS: material.bumpMap && material.bumpMap.clampS,
			bumpMapClampT: material.bumpMap && material.bumpMap.clampT,
			normalMapClampS: material.normalMap && material.normalMap.clampS,
			normalMapClampT: material.normalMap && material.normalMap.clampT,
			specularMapClampS: material.specularMap && material.specularMap.clampS,
			specularMapClampT: material.specularMap && material.specularMap.clampT,
			alphaMapInvert: material.alphaMap && material.alphaMap.invert,
			alphaMapClampS: material.alphaMap && material.alphaMap.clampS,
			alphaMapClampT: material.alphaMap && material.alphaMap.clampT,

			// texture flags for clamp for PRISM shader
            mapPrismOpaqueLuminanceModifierClampS: material.textureMaps && material.textureMaps.opaque_luminance_modifier_map && !material.textureMaps.opaque_luminance_modifier_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismOpaqueLuminanceModifierClampT: material.textureMaps && material.textureMaps.opaque_luminance_modifier_map && !material.textureMaps.opaque_luminance_modifier_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismSurfaceAlbedoClampS: material.textureMaps && material.textureMaps.surface_albedo_map && !material.textureMaps.surface_albedo_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismSurfaceAlbedoClampT: material.textureMaps && material.textureMaps.surface_albedo_map && !material.textureMaps.surface_albedo_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismSurfaceRoughnessClampS: material.textureMaps && material.textureMaps.surface_roughness_map && !material.textureMaps.surface_roughness_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismSurfaceRoughnessClampT: material.textureMaps && material.textureMaps.surface_roughness_map && !material.textureMaps.surface_roughness_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismSurfaceAnisotropyClampS: material.textureMaps && material.textureMaps.surface_anisotropy_map && !material.textureMaps.surface_anisotropy_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismSurfaceAnisotropyClampT: material.textureMaps && material.textureMaps.surface_anisotropy_map && !material.textureMaps.surface_anisotropy_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismSurfaceRotationClampS: material.textureMaps && material.textureMaps.surface_rotation_map && !material.textureMaps.surface_rotation_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismSurfaceRotationClampT: material.textureMaps && material.textureMaps.surface_rotation_map && !material.textureMaps.surface_rotation_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismOpaqueF0ClampS: material.textureMaps && material.textureMaps.opaque_f0_map && !material.textureMaps.opaque_f0_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismOpaqueF0ClampT: material.textureMaps && material.textureMaps.opaque_f0_map && !material.textureMaps.opaque_f0_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismOpaqueAlbedoClampS: material.textureMaps && material.textureMaps.opaque_albedo_map && !material.textureMaps.opaque_albedo_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismOpaqueAlbedoClampT: material.textureMaps && material.textureMaps.opaque_albedo_map && !material.textureMaps.opaque_albedo_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismMetalF0ClampS: material.textureMaps && material.textureMaps.metal_f0_map && !material.textureMaps.metal_f0_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismMetalF0ClampT: material.textureMaps && material.textureMaps.metal_f0_map && !material.textureMaps.metal_f0_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismLayeredF0ClampS: material.textureMaps && material.textureMaps.layered_f0_map && !material.textureMaps.layered_f0_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismLayeredF0ClampT: material.textureMaps && material.textureMaps.layered_f0_map && !material.textureMaps.layered_f0_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismLayeredDiffuseClampS: material.textureMaps && material.textureMaps.layered_diffuse_map && !material.textureMaps.layered_diffuse_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismLayeredDiffuseClampT: material.textureMaps && material.textureMaps.layered_diffuse_map && !material.textureMaps.layered_diffuse_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismLayeredRoughnessClampS: material.textureMaps && material.textureMaps.layered_roughness_map && !material.textureMaps.layered_roughness_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismLayeredRoughnessClampT: material.textureMaps && material.textureMaps.layered_roughness_map && !material.textureMaps.layered_roughness_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismLayeredAnisotropyClampS: material.textureMaps && material.textureMaps.layered_anisotropy_map && !material.textureMaps.layered_anisotropy_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismLayeredAnisotropyClampT: material.textureMaps && material.textureMaps.layered_anisotropy_map && !material.textureMaps.layered_anisotropy_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismLayeredRotationClampS: material.textureMaps && material.textureMaps.layered_rotation_map && !material.textureMaps.layered_rotation_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismLayeredRotationClampT: material.textureMaps && material.textureMaps.layered_rotation_map && !material.textureMaps.layered_rotation_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismLayeredBottomF0ClampS: material.textureMaps && material.textureMaps.layered_bottom_f0_map && !material.textureMaps.layered_bottom_f0_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismLayeredBottomF0ClampT: material.textureMaps && material.textureMaps.layered_bottom_f0_map && !material.textureMaps.layered_bottom_f0_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismLayeredFractionClampS: material.textureMaps && material.textureMaps.layered_fraction_map && !material.textureMaps.layered_fraction_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismLayeredFractionClampT: material.textureMaps && material.textureMaps.layered_fraction_map && !material.textureMaps.layered_fraction_map.textureObj.properties.booleans.texture_VRepeat.values[0],

            mapPrismSurfaceCutoutClampS: material.textureMaps && material.textureMaps.surface_cutout_map && !material.textureMaps.surface_cutout_map.textureObj.properties.booleans.texture_URepeat.values[0],
            mapPrismSurfaceCutoutClampT: material.textureMaps && material.textureMaps.surface_cutout_map && !material.textureMaps.surface_cutout_map.textureObj.properties.booleans.texture_VRepeat.values[0],

		};


		var chunks = [];

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		// The "defines" array is set by the MaterialConverter.js and the indices
		// contain the various #define strings to set for the shader.
		// Oddly, these "defines" are just raw strings put at the end of the shader,
		// which I guess defines them? e.g. "USE_OPAQUE_ALBEDO_MAP" is simply listed.
		for ( var d in material.defines ) {

			chunks.push( d );
			chunks.push( material.defines[ d ] );

		}

		var p, pl;
		for ( p in parameters ) {

			chunks.push( p );
			chunks.push( parameters[ p ] );

		}

		var code = chunks.join();

		var program;

		// Check if code has been already compiled

		for ( p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				program.usedTimes ++;

				break;

			}

		}

		if ( program === undefined ) {

			program = new FireflyWebGLProgram( _this, code, material, parameters );
			_programs.push( program );

			_this.info.memory.programs = _programs.length;

		}

		material.program = program;


		material.uniformsList = [];

		for ( var u in material.__webglShader.uniforms ) {

			var location = material.program.uniforms[ u ];

			if ( location ) {
				material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
			}

		}

	}

	function setMaterial( material ) {

		if ( material.transparent === true ) {

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

		}

		state.setDepthTest( material.depthTest );
		state.setDepthWrite( material.depthWrite );
		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}


	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}


		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === -1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( _logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( camera !== _currentCamera ) _currentCamera = camera;


			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.isPrismMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.isPrismMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

                //NOTE: viewMatrixInverse is only used for transforming normal vectors
                //for sampling environment textures. This is why we do not use camera.matrixWorld here,
                //but a combination of camera.matrixWorld plus a rotation to make Y the up vector, so that
                //the top of the scene (whichever axis is up) results in sampling the top of the environment map.
                //If viewMatrixInverse is needed for other things in the shader, then we will need a second
                //uniform that does not include the world-up rotation, or apply a consistent world up rotation
                //to all geometries in the scene.
				if ( p_uniforms.viewMatrixInverse !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrixInverse, false, _viewInverseEnv.elements );

				}

				if ( p_uniforms.mvpMatrix ) {

					_gl.uniformMatrix4fv( p_uniforms.mvpMatrix, false, _projScreenMatrix.elements );

				}

				if ( refreshLights ) {
					refreshUniformsIBL(m_uniforms, material);
					markUniformsIBLNeedsUpdate(m_uniforms, true);
				} else {
					markUniformsIBLNeedsUpdate(m_uniforms, false);
				}

			}

		}


		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.isPrismMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights );
					_lightsNeedUpdate = false;

				}

				if ( refreshLights ) {
					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );
				} else {
					markUniformsLightsNeedsUpdate( m_uniforms, false );
				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );
				refreshUniformsIBL(m_uniforms, material);
			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			} else if ( material.isPrismMaterial ) {

				refreshUniformsPrism( m_uniforms, material );
				refreshUniformsIBL(m_uniforms, material);

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// TODO_NOP: direct assignment dangerous?
			var ucp = m_uniforms.cutplanes;
			if (material.cutplanes && material.cutplanes.length > 0 && ucp) {
				ucp.value = material.cutplanes;
				// Currently, Prism is implemented as shader material, its uniform is just init for once.
				// Remove the array component if cutplanes's length changed so it can be re-init.
				if (ucp._array && ucp._array.length != 4 * material.cutplanes)
					ucp._array = undefined;
			}

			if (material.hatchParams && m_uniforms.hatchParams) {
				m_uniforms.hatchParams.value.copy(material.hatchParams);
				m_uniforms.hatchTintColor.value.copy(material.hatchTintColor);
				m_uniforms.hatchTintIntensity.value = material.hatchTintIntensity;
			}

			// load common uniforms

			loadUniformsGeneric( material.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object, camera );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		if ( p_uniforms.dbId !== null ) {

			var dbId = object.dbId || object.fragId || 0;
			_gl.uniform4f( p_uniforms.dbId, (dbId & 0xff) / 255,
											((dbId >> 8) & 0xff) / 255,
											((dbId >> 16) & 0xff) / 255,
											((dbId >> 24) & 0xff) / 255);

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;


		uniforms.diffuse.value.copy(material.color);


		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. normal map
		//	4. bump map
        //  5. alpha map

        //NOTE: We deviate from Three.js in that we allow
        //separate scales for diffuse/specular, alpha, and bump

        function setTexTransforms(uniforms, texMatrix, texture) {
        	var offset = texture.offset;
            var repeat = texture.repeat;

            if (texMatrix) {
            	var uMatrix = texMatrix.value;

	        	if (texture.matrix)
	        		uMatrix.copy(texture.matrix);
	        	else
		            uMatrix.identity();

	        	uMatrix.elements[6] += offset.x;
	    		uMatrix.elements[7] += offset.y;
	    		uMatrix.elements[0] *= repeat.x;
	    		uMatrix.elements[3] *= repeat.x;
	    		uMatrix.elements[1] *= repeat.y;
	    		uMatrix.elements[4] *= repeat.y;
	    	}
	    	else {
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	    	}
        }

        if (material.alphaMap) {
        	setTexTransforms(uniforms, uniforms.texMatrixAlpha, material.alphaMap);
        }

        var uvScaleMapBump;
        if ( material.normalMap ) {
			uvScaleMapBump = material.normalMap;
		} else if ( material.bumpMap ) {
			uvScaleMapBump = material.bumpMap;
		}
        if ( uvScaleMapBump !== undefined ) {
        	setTexTransforms(uniforms, uniforms.texMatrixBump, uvScaleMapBump);
        }

		var uvScaleMap;
		if ( material.map ) {
			uvScaleMap = material.map;
		} else if ( material.specularMap ) {
			uvScaleMap = material.specularMap;
		}
        if ( uvScaleMap !== undefined ) {
        	setTexTransforms(uniforms, uniforms.texMatrix, uvScaleMap);
        }

		uniforms.envMap.value = material.envMap;
		//uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;
		if (uniforms.irradianceMap) {
			uniforms.irradianceMap.value = material.irradianceMap;
		}

		uniforms.reflectivity.value = material.reflectivity;


		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsIBL( uniforms, material) {
		if (uniforms.envMap)
			uniforms.envMap.value = material.envMap;
		//uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;
		if (uniforms.irradianceMap)
			uniforms.irradianceMap.value = material.irradianceMap;
		if (uniforms.envMapExposure)
			uniforms.envMapExposure.value = material.envMapExposure;
		if (uniforms.envRotationSin && uniforms.envRotationCos) {
			uniforms.envRotationSin.value = material.envRotationSin;
			uniforms.envRotationCos.value = material.envRotationCos;
        }
	}

	function markUniformsIBLNeedsUpdate ( uniforms, boolean ) {

		if (uniforms.envMap)
			uniforms.envMap.needsUpdate = boolean;
		//uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;
		if (uniforms.irradianceMap)
			uniforms.irradianceMap.needsUpdate = boolean;
		if (uniforms.envMapExposure)
			uniforms.envMapExposure.needsUpdate = boolean;
	}


	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

        //The environment cube map is blurred with the assumption that
        //max shininess is 2048 and every mip drops that by a factor of 4
        //"float MipmapIndex = log(shininess / 2048.0) / log(0.25);",
        //The simplification below was given in the original source for this method.
        //However, it does not seem to match the equation above, so we use a corrected one.
        //"float MipmapIndex = max(0.0, -1.66096404744368 * logShiny + 5.5);",
        //NOTE: Once roughness maps are supported, the computation will have to move to the shader.
        var logShiny = Math.log(Math.max(1.0+1e-10, material.shininess));
        uniforms.reflMipIndex.value = Math.max(0.0, -0.72134752 * logShiny + 5.5);

		uniforms.emissive.value.copy(material.emissive);
		uniforms.specular.value.copy(material.specular);


		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

		uniforms.exposureBias.value = material.exposureBias;
	}

	function refreshUniformsPrism ( uniforms, material ) {

		function refreshPrismMapUniforms ( uniforms, material, mapName ) {
			uniforms[mapName].value = material[mapName];
			// yes, we want "!=" here, not "!==", as we test for both undefined and null
			if (material[mapName] != null)
			{
				uniforms[mapName + "_texMatrix"].value = new THREE.Matrix3().copy(material[mapName].matrix);
				uniforms[mapName + "_invert"].value = material[mapName].invert;
			}
		}

		function refreshPrismBumpMapUniforms ( uniforms, material, mapName ) {
			uniforms[mapName].value = material[mapName];
			// yes, we want "!=" here, not "!==", as we test for both undefined and null
			if (material[mapName] != null)
			{
				uniforms[mapName + "_texMatrix"].value = new THREE.Matrix3().copy(material[mapName].matrix);
				uniforms[mapName + "_bumpScale"].value = new THREE.Vector2().copy(material[mapName].bumpScale);
				uniforms[mapName + "_bumpmapType"].value = material[mapName].bumpmapType;
			}
		}

		uniforms.exposureBias.value = material.exposureBias;

		//Prism common properties.
		uniforms.surface_albedo.value = new THREE.Color().copy(material.surface_albedo);
		uniforms.surface_roughness.value = material.surface_roughness;
		uniforms.surface_anisotropy.value = material.surface_anisotropy;
		uniforms.surface_rotation.value = material.surface_rotation;

		refreshPrismMapUniforms(uniforms, material, "surface_albedo_map");
		refreshPrismMapUniforms(uniforms, material, "surface_roughness_map");
		refreshPrismMapUniforms(uniforms, material, "surface_cutout_map");
		refreshPrismMapUniforms(uniforms, material, "surface_anisotropy_map");
		refreshPrismMapUniforms(uniforms, material, "surface_rotation_map");

		refreshPrismBumpMapUniforms(uniforms, material, "surface_normal_map");

		//Update Prism properties according to the material type.
		switch ( material.prismType ) {
			case 'PrismOpaque':
				uniforms.opaque_albedo.value = new THREE.Color().copy(material.opaque_albedo);
				uniforms.opaque_luminance_modifier.value = new THREE.Color().copy(material.opaque_luminance_modifier);
				uniforms.opaque_f0.value = material.opaque_f0;
				uniforms.opaque_luminance.value = material.opaque_luminance;

				refreshPrismMapUniforms(uniforms, material, "opaque_albedo_map");
				refreshPrismMapUniforms(uniforms, material, "opaque_luminance_modifier_map");
				refreshPrismMapUniforms(uniforms, material, "opaque_f0_map");

				break;

			case 'PrismMetal':
				uniforms.metal_f0.value = new THREE.Color().copy(material.metal_f0);

				refreshPrismMapUniforms(uniforms, material, "metal_f0_map");

				break;

			case 'PrismLayered':
				uniforms.layered_f0.value = material.layered_f0;
				uniforms.layered_diffuse.value = new THREE.Color().copy(material.layered_diffuse);
				uniforms.layered_fraction.value = material.layered_fraction;
				uniforms.layered_bottom_f0.value = new THREE.Color().copy(material.layered_bottom_f0);
				uniforms.layered_roughness.value = material.layered_roughness;
				uniforms.layered_anisotropy.value = material.layered_anisotropy;
				uniforms.layered_rotation.value = material.layered_rotation;

				refreshPrismMapUniforms(uniforms, material, "layered_bottom_f0_map");
				refreshPrismMapUniforms(uniforms, material, "layered_f0_map");
				refreshPrismMapUniforms(uniforms, material, "layered_diffuse_map");
				refreshPrismMapUniforms(uniforms, material, "layered_fraction_map");
				refreshPrismMapUniforms(uniforms, material, "layered_roughness_map");
				refreshPrismMapUniforms(uniforms, material, "layered_anisotropy_map");
				refreshPrismMapUniforms(uniforms, material, "layered_rotation_map");

				refreshPrismBumpMapUniforms(uniforms, material, "layered_normal_map");

				break;

			case 'PrismTransparent':
				uniforms.transparent_color.value = new THREE.Color().copy(material.transparent_color);
				uniforms.transparent_distance.value = material.transparent_distance;
				uniforms.transparent_ior.value = material.transparent_ior;

				break;

			case 'PrismWood':
				uniforms.wood_fiber_cosine_enable.value = material.wood_fiber_cosine_enable;
				uniforms.wood_fiber_cosine_bands.value = material.wood_fiber_cosine_bands;
				uniforms.wood_fiber_cosine_weights.value = new THREE.Vector4().copy(material.wood_fiber_cosine_weights);
				uniforms.wood_fiber_cosine_frequencies.value = new THREE.Vector4().copy(material.wood_fiber_cosine_frequencies);

				uniforms.wood_fiber_perlin_enable.value = material.wood_fiber_perlin_enable;
				uniforms.wood_fiber_perlin_bands.value = material.wood_fiber_perlin_bands;
				uniforms.wood_fiber_perlin_weights.value = new THREE.Vector4().copy(material.wood_fiber_perlin_weights);
				uniforms.wood_fiber_perlin_frequencies.value = new THREE.Vector4().copy(material.wood_fiber_perlin_frequencies);
				uniforms.wood_fiber_perlin_scale_z.value = material.wood_fiber_perlin_scale_z;

				uniforms.wood_growth_perlin_enable.value = material.wood_growth_perlin_enable;
				uniforms.wood_growth_perlin_bands.value = material.wood_growth_perlin_bands;
				uniforms.wood_growth_perlin_weights.value = new THREE.Vector4().copy(material.wood_growth_perlin_weights);
				uniforms.wood_growth_perlin_frequencies.value = new THREE.Vector4().copy(material.wood_growth_perlin_frequencies);

				uniforms.wood_latewood_ratio.value = material.wood_latewood_ratio;
				uniforms.wood_earlywood_sharpness.value = material.wood_earlywood_sharpness;
				uniforms.wood_latewood_sharpness.value = material.wood_latewood_sharpness;
				uniforms.wood_ring_thickness.value = material.wood_ring_thickness;

				uniforms.wood_earlycolor_perlin_enable.value = material.wood_earlycolor_perlin_enable;
				uniforms.wood_earlycolor_perlin_bands.value = material.wood_earlycolor_perlin_bands;
				uniforms.wood_earlycolor_perlin_weights.value = new THREE.Vector4().copy(material.wood_earlycolor_perlin_weights);
				uniforms.wood_earlycolor_perlin_frequencies.value = new THREE.Vector4().copy(material.wood_earlycolor_perlin_frequencies);
				uniforms.wood_early_color.value = new THREE.Color().copy(material.wood_early_color);

				uniforms.wood_use_manual_late_color.value = material.wood_use_manual_late_color;
				uniforms.wood_manual_late_color.value = new THREE.Color().copy(material.wood_manual_late_color);

				uniforms.wood_latecolor_perlin_enable.value = material.wood_latecolor_perlin_enable;
				uniforms.wood_latecolor_perlin_bands.value = material.wood_latecolor_perlin_bands;
				uniforms.wood_latecolor_perlin_weights.value = new THREE.Vector4().copy(material.wood_latecolor_perlin_weights);
				uniforms.wood_latecolor_perlin_frequencies.value = new THREE.Vector4().copy(material.wood_latecolor_perlin_frequencies);
				uniforms.wood_late_color_power.value = material.wood_late_color_power;

				uniforms.wood_diffuse_perlin_enable.value = material.wood_diffuse_perlin_enable;
				uniforms.wood_diffuse_perlin_bands.value = material.wood_diffuse_perlin_bands;
				uniforms.wood_diffuse_perlin_weights.value = new THREE.Vector4().copy(material.wood_diffuse_perlin_weights);
				uniforms.wood_diffuse_perlin_frequencies.value = new THREE.Vector4().copy(material.wood_diffuse_perlin_frequencies);
				uniforms.wood_diffuse_perlin_scale_z.value = material.wood_diffuse_perlin_scale_z;

				uniforms.wood_use_pores.value = material.wood_use_pores;
				uniforms.wood_pore_type.value = material.wood_pore_type;
				uniforms.wood_pore_radius.value = material.wood_pore_radius;
				uniforms.wood_pore_cell_dim.value = material.wood_pore_cell_dim;
				uniforms.wood_pore_color_power.value = material.wood_pore_color_power;
				uniforms.wood_pore_depth.value = material.wood_pore_depth;

				uniforms.wood_use_rays.value = material.wood_use_rays;
				uniforms.wood_ray_color_power.value = material.wood_ray_color_power;
				uniforms.wood_ray_seg_length_z.value = material.wood_ray_seg_length_z;
				uniforms.wood_ray_num_slices.value = material.wood_ray_num_slices;
				uniforms.wood_ray_ellipse_z2x.value = material.wood_ray_ellipse_z2x;
				uniforms.wood_ray_ellipse_radius_x.value = material.wood_ray_ellipse_radius_x;

				uniforms.wood_use_latewood_bump.value = material.wood_use_latewood_bump;
				uniforms.wood_latewood_bump_depth.value = material.wood_latewood_bump_depth;

				uniforms.wood_use_groove_roughness.value = material.wood_use_groove_roughness;
				uniforms.wood_groove_roughness.value = material.wood_groove_roughness;
				uniforms.wood_diffuse_lobe_weight.value = material.wood_diffuse_lobe_weight;

				break;

			default:
				console.warn( 'Unknown prism type: ' + material.prismType );
		}

		uniforms.envExponentMin.value = material.envExponentMin;
		uniforms.envExponentMax.value = material.envExponentMax;
		uniforms.envExponentCount.value = material.envExponentCount;
	}

	function refreshUniformsLambert ( uniforms, material ) {

		uniforms.emissive.value.copy(material.emissive);


		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {

		uniforms.ambientLightColor.needsUpdate = boolean;

		uniforms.directionalLightColor.needsUpdate = boolean;
		uniforms.directionalLightDirection.needsUpdate = boolean;

		uniforms.pointLightColor.needsUpdate = boolean;
		uniforms.pointLightPosition.needsUpdate = boolean;
		uniforms.pointLightDistance.needsUpdate = boolean;

		uniforms.spotLightColor.needsUpdate = boolean;
		uniforms.spotLightPosition.needsUpdate = boolean;
		uniforms.spotLightDistance.needsUpdate = boolean;
		uniforms.spotLightDirection.needsUpdate = boolean;
		uniforms.spotLightAngleCos.needsUpdate = boolean;
		uniforms.spotLightExponent.needsUpdate = boolean;

		uniforms.hemisphereLightSkyColor.needsUpdate = boolean;
		uniforms.hemisphereLightGroundColor.needsUpdate = boolean;
		uniforms.hemisphereLightDirection.needsUpdate = boolean;

	}

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	}

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object, camera ) {

		_objectModelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, _objectModelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_objectNormalMatrix.getNormalMatrix( _objectModelViewMatrix );

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, _objectNormalMatrix.elements );

		}

	}

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit, offset;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];
			
			var i, il;

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 2;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 3;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 4;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
						uniform._array[ offset + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
					   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						_this.setTexture( texture, textureUnit );

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	}

	//

	/* not used
	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	}
	*/

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	function setupLights ( lights ) {

		var l, ll, light,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

					r += color.r;
					g += color.g;
					b += color.b;

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				setColorLinear( dirColors, dirOffset, color, intensity );

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;


				setColorLinear( pointColors, pointOffset, color, intensity );


				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				setColorLinear( spotColors, spotOffset, color, intensity );

				_vector3.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_direction.copy( _vector3 );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
				setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};


	this.setMaterialFaces = function ( material ) {

		state.setDoubleSided( material.side === THREE.DoubleSide );
		state.setFlipSided( material.side === THREE.BackSide );

	};

	// Textures


	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		var extension;

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	}


	this.uploadTexture = function ( texture ) {

		if ( texture.__webglInit === undefined ) {

			texture.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			texture.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

		}

		_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		texture.image = clampToMaxSize( texture.image, _maxTextureSize );

		var image = texture.image,
		isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

		var mipmap, mipmaps = texture.mipmaps;
		var i, il;

		if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "Attempt to load unsupported compressed texture format" );

					}

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}
			}

			// make sure compressed texture pyramids are complete (i.e. include all levels 
			// between what ever was the coarsest level in file and 1x1)
			if(mipmaps.length > 1 && getCompressedTextureFormats().indexOf( glFormat ) > -1 )
			{
				var w = mipmap.width >> 1,
					h = mipmap.height >> 1,
					l = mipmaps.length;

				var view;
				
				while(w >= 1 || h >= 1) {
					view = (mipmap.width == 4 && mipmap.height == 4) ? mipmap.data : new DataView(
						mipmap.data.buffer, 
						mipmap.data.byteOffset, 
						mipmap.data.byteLength * (Math.max(w, 4) * Math.max(h, 4)) / (mipmap.width * mipmap.height)
					);

					_gl.compressedTexImage2D( _gl.TEXTURE_2D, l, glFormat, Math.max(w, 1), Math.max(h, 1), 0, view);
					w = w >> 1;
					h = h >> 1;
					++l;
				}
			}

		} else { // regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = rescueFromPolymer(mipmaps[ i ]);
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, rescueFromPolymer(texture.image) );

			}

		}

		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

		texture.needsUpdate = false;

		if ( texture.onUpdate ) texture.onUpdate();

	};

	this.setTexture = function ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );

		if ( texture.needsUpdate ) {

			_this.uploadTexture( texture );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width <= maxSize && image.height <= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = Math.floor( image.width * maxSize / maxDimension );
		var newHeight = Math.floor( image.height * maxSize / maxDimension );

		var canvas = document.createElement( 'canvas' );
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.getContext( "2d" );
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];
				
				var i;

				for ( i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

									_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "Attempt to load unsupported compressed texture format" );

								}

							} else {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	}

	// Render targets

    this.initFrameBufferMRT = function ( renderTargets, verifyFrameBufferWorks ) {

        var primaryTarget = renderTargets[0];
        var clearState = false;

        //For MRT, the frame and depth buffer are owned
        //by the first target.
        if ( primaryTarget && ! primaryTarget.__webglFramebuffer ) {

            if ( primaryTarget.depthBuffer === undefined ) primaryTarget.depthBuffer = true;
            if ( primaryTarget.stencilBuffer === undefined ) primaryTarget.stencilBuffer = true;

            primaryTarget.__webglFramebuffer = _gl.createFramebuffer();

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, primaryTarget.__webglFramebuffer );

            var renderbuffer;

            //Allocate depth buffer if needed

            if (primaryTarget.shareDepthFrom) {

                renderbuffer = primaryTarget.__webglRenderbuffer = primaryTarget.shareDepthFrom.__webglRenderbuffer;

            } else {

                if ( primaryTarget.depthBuffer && ! primaryTarget.stencilBuffer ) {

                    renderbuffer = primaryTarget.__webglRenderbuffer = _gl.createRenderbuffer();

                    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

                    _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, primaryTarget.width, primaryTarget.height );

                } else if ( primaryTarget.depthBuffer && primaryTarget.stencilBuffer ) {

                    renderbuffer = primaryTarget.__webglRenderbuffer = _gl.createRenderbuffer();

                    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

                    _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, primaryTarget.width, primaryTarget.height );

                } else {

                    //_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, primaryTarget.width, primaryTarget.height );

                }

            }

            //Bind depth buffer

            if ( primaryTarget.depthBuffer && ! primaryTarget.stencilBuffer ) {

                _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            } else if ( primaryTarget.depthBuffer && primaryTarget.stencilBuffer ) {

                _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            } else {

            }

            clearState = true;
        }

        var tmpBuf = _currentFramebuffer;
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, primaryTarget.__webglFramebuffer);

        //Create backing textures for all the targets and attach them
        //to the frame buffer.
		var i;
        for (i=0; i<renderTargets.length; i++) {
            var rt = renderTargets[i];

            if (!rt.__webglTexture) {

                var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( rt.width ) && THREE.Math.isPowerOfTwo( rt.height ),
                    glFormat = paramThreeToGL( rt.format ),
                    glType = paramThreeToGL( rt.type );

                rt.addEventListener( 'dispose', onRenderTargetDispose );

                rt.__webglTexture = _gl.createTexture();

                _this.info.memory.textures ++;

                _gl.bindTexture( _gl.TEXTURE_2D, rt.__webglTexture );

                setTextureParameters( _gl.TEXTURE_2D, rt, isTargetPowerOfTwo );

                _gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, rt.width, rt.height, 0, glFormat, glType, null );

                if ( isTargetPowerOfTwo && rt.generateMipmaps)
                    _gl.generateMipmap( _gl.TEXTURE_2D );
            }

            _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, rt.__webglTexture, 0 );

        }

        if (_glExtensionDrawBuffers) {
        	var bufs = [_glExtensionDrawBuffers.COLOR_ATTACHMENT0_WEBGL];
        	for (i=1; i<renderTargets.length; i++) {
        		bufs.push(_glExtensionDrawBuffers.COLOR_ATTACHMENT0_WEBGL + i);
        	}
            _glExtensionDrawBuffers.drawBuffersWEBGL(bufs);
        }

        if (verifyFrameBufferWorks) {
            var status = _gl.checkFramebufferStatus(_gl.FRAMEBUFFER);
            if (status !== _gl.FRAMEBUFFER_COMPLETE) {
                console.log("Can't use multiple render targets. Falling back to two passes. " + status);
                delete primaryTarget.__webglFramebuffer;
                verifyFrameBufferWorks = false;
            }
        }

        _gl.bindFramebuffer(_gl.FRAMEBUFFER, tmpBuf);


        if (clearState) {
            // Release everything
            _gl.bindTexture( _gl.TEXTURE_2D, null );
            _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
            _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
        }

        return verifyFrameBufferWorks;
    };


	//[Firefly] This function is different from Three.js -- it adds
	//support for binding multiple render targets.
    this.setRenderTarget = function(renderTargets) {

        var renderTarget;

        if (Array.isArray(renderTargets)) {
            this.initFrameBufferMRT(renderTargets);
            renderTarget = renderTargets[0];
        } else if (renderTargets) {
			var fb = renderTargets.__webglFramebuffer;
        	if (!fb || _currentFramebuffer !== fb) {
            	this.initFrameBufferMRT([renderTargets]);
			}
            renderTarget = renderTargets;
        }

        var framebuffer, width, height, vx, vy;

        if ( renderTarget ) {


            framebuffer = renderTarget.__webglFramebuffer;


            width = renderTarget.width;
            height = renderTarget.height;

            vx = 0;
            vy = 0;

        } else {

            framebuffer = null;

            width = _viewportWidth;
            height = _viewportHeight;

            vx = _viewportX;
            vy = _viewportY;

        }

        if ( framebuffer !== _currentFramebuffer ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
            _gl.viewport( vx, vy, width, height );

            _currentFramebuffer = framebuffer;

        }

        _currentWidth = width;
        _currentHeight = height;

    };


    //We need to use more than WebGL 1.0 technically allows -- we use
    //different bit depth sizes for the render targets, which is not
    //legal WebGL 1.0, but will work eventually and some platforms/browsers
    //already allow it. For others, we have to try, check for failure, and disable use of MRT dynamically.
    this.verifyMRTWorks = function(renderTargets) {
        if (_glExtensionDrawBuffers) {
            return this.initFrameBufferMRT(renderTargets, true);
        }
        return false;
    };


	this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

		if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		if ( renderTarget.__webglFramebuffer ) {

//Our ID target is RGB, but it still seems to work if we call readPixels with RGBA, so the check is commented out
/*
			if ( renderTarget.format !== THREE.RGBAFormat ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
				return;

			}
*/
			var restore = false;

			if ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );

				restore = true;

			}

			if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

				_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

			} else {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

			}

			if ( restore ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

			}

		}

	};


	function updateRenderTargetMipmap ( renderTarget ) {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;
        if ( p === THREE.HalfFloatType) return 0x8D61;//_gl.HALF_FLOAT_OES;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

	// Allocations

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };

	}

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	}


};
;
(function () {

    'use strict';

    var av = Autodesk.Viewing,
        avp = av.Private;

    avp.BackgroundPresets = {
        "Fusion Grey":      [230, 230, 230, 150, 150, 150],
        "Sky Blue":         [226, 244, 255, 156, 172, 180],
        "Snow":             [181, 186, 199, 181, 186, 199],
        "Midnight":         [ 41,  76, 120,   1,   2,   3],
        "White":            [255, 255, 255, 255, 255, 255],
        "AutoCADModel":     [ 30,  40,  48,  30,  40,  48],
        "Dark Grey":        [ 51,  51,  51,  51,  51,  51],
        "Dark Sky":         [ 51,  51,  51,  51,  51,  51],
        "Infinity Pool":    [255, 255, 255, 255, 255, 255],
        "Tranquility":      [  0,  84, 166,   0,  84, 166],
        "Grey Room":        [129, 129, 129, 129, 129, 129],
        "Photo Booth":      [237, 237, 237, 237, 237, 237],
        "RaaS SBS":         [  1,   1,   1,  90,  90,  90],
        "Plaza":            [ 79, 102, 130,  79, 102, 130],

        //This will get modified when the user changes the background
        //using the color picker.
        "Custom":           [230, 230, 230, 150, 150, 150]
    };

    var bg = avp.BackgroundPresets;

    avp.LightPresets = [
        //Notes: tonemap = which tone map method to use. Any tonemap method other than zero will cause colors to be linearized before use.
        //              0 = None, 1 = Prism Cannon-Lum (color preserving), 2 = OGC Cannon RGB (non-color preserving)
        //       exposure = exponential bias to use as pre-tonemap multiplier for all rendered colors, including background
        //       lightMultiplier = linear scale of direct light intensity (diffuse only, not ambient)
        //       bgColorGradient = which background color preset to use as default for the environment map
        //       illuminance     = cosine-weighted integral of the upper-hemisphere (i.e., actual lux)

        //Image-based lighting from RaaS. Initial exposure is empirically obtained.
        //These do not normally require any extra lights, because they have the lights fully baked into
        //the environment maps.

        //Simple ***non-HDR*** environment.
        {
            name: "Simple Grey",    // localized in viewer-environments.loc.json
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor:     [0.8, 0.9,  1.0],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: false,
            rotation: 0.0
        },

        //Fusion Environments which require extra lights

        // The E_bias value for the Fusion render-space environments is setup such that
        // the default values match the preset values of brightness (in lux) and EV.
        // The EV value from Fusion follows the Canon standard for luminance and middle-gray
        // https://en.wikipedia.org/wiki/Exposure_value#EV_as_a_measure_of_luminance_and_illuminance [September 2015]
        //
        // Rationale (using the canon tonemap as a guide, based on documentation by Adam Arbree):
        // 1. BaseExposure (B) in the canon tonemap is the negative log2 luminance of the
        //    white point (W) so B = -log2(W)
        // 2. To match the target illuminance from Fusion, the environment needs
        //    to be scaled by the ratio between the target and its actual illuminance, thus
        //    S = target_illuminance / actual_illuminance
        // 3. Then by the definition of middle grey W = L / (0.18*S) where L is the middle grey
        //    luminance and 0.18 is the standard reflection of middle grey.
        // 4. As per the Wikipedia entry, we have L = 2^(EV-3)
        // 5. Putting this all together we have
        //      B = -log2( 2^(EV-3) / (0.18*S)) 
        //        = log2(0.18) + log2(S) – (EV – 3)
        //        = (3+log2(0.18)) – EV + log2(S)
        //        = 0.526069 – EV + log2(S)

        {
            name: "Sharp Highlights",    // localized in viewer-environments.loc.json
            path:"SharpHighlights",
            type:"logluv",
            tonemap:1,
            // illuminance currently is not used elsewhere in LMV, its effect is folded into E_bias.
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            //lightDirection: [0.5, -0.2, -0.06], //world space, not view space!
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Dark Sky",     // "Dark Sky", localized in viewer-environments.loc.json
            path:"DarkSky",
            type:"logluv",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8], //0.25 with gain of 0.125
            lightMultiplier: 1.0,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Dark Sky"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Grey Room",    // "Grey Room", localized in viewer-environments.loc.json
            path:"GreyRoom",
            type:"logluv",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.5,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Grey Room"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Photo Booth",     // "Photo Booth", localized in viewer-environments.loc.json
            path:"PhotoBooth",
            type:"logluv",
            tonemap:1,
            E_bias:0,
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.5,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Tranquility",     // "Tranquility", localized in viewer-environments.loc.json
            path:"TranquilityBlue",
            type:"logluv",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.5,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Tranquility"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Infinity Pool",     // "Infinity Pool", localized in viewer-environments.loc.json
            path: "InfinityPool",
            type:"logluv",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.5,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Infinity Pool"],
            darkerFade: false,
            rotation: 0.0
        },

        // Non fusion environments

        //White background, no HDR -- for cases like SIM360 models
        {
            name: "Simple White",     //"Simple White", localized in viewer-environments.loc.json
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1,1,1],
            ambientColor: [0.9,0.9,0.9],
            lightMultiplier: 1.0,
            bgColorGradient: bg["White"],
            saoRadius: 0.06,
            saoIntensity: 0.15,
            darkerFade: true,
            rotation: 0.0
        },
/*
        {
            name: "Simple Black",
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor:     [0.8, 0.9,  1.0],
            lightMultiplier: 1.0,
            bgColorGradient: bg["AutoCADModel"],
            darkerFade: false
        },
  */
        //RaaS environments
        {
            name: "Riverbank",     // "Riverbank", localized in viewer-environments.loc.json
            path:"riverbank",
            type:"logluv",
            tonemap:1,
            E_bias:-5.7,
            directLightColor: [1,1,1],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Sky Blue"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Contrast",     // "Contrast", localized in viewer-environments.loc.json
            path:"IDViz",
            type:"logluv",
            tonemap:1,
            E_bias:0,
            directLightColor: [1,1,1],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Midnight"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Rim Highlights",     //  localized in viewer-environments.loc.json
            path:"RimHighlights",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            //lightDirection: [0.35, -0.35, -0.5], //world space, not view space!
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true,
            rotation: 0.0
        },
        {
            name: "Cool Light",     // "Cool Light", localized in viewer-environments.loc.json
            path:"CoolLight",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            //lightDirection: [-0.0, -0.15, -0.5],
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Warm Light",     // "Warm Light", localized in viewer-environments.loc.json
            path:"WarmLight",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            //lightDirection: [-0.0, -0.15, -0.5], //world space, not view space!
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Soft Light",     // "Soft Light", localized in viewer-environments.loc.json
            path:"SoftLight",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            //lightDirection: [-0.5, -0.5, 0.0],
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Grid Light",     // "Grid Light", localized in viewer-environments.loc.json
            path:"GridLight",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            //lightDirection: [-0.5, -0.6, 0.0],
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Plaza",             //  "Plaza", localized in viewer-environments.loc.json
            path:"Plaza",
            type:"logluv",
            tonemap:1,
            //illuminance: 24157.736,
            E_bias: -14.0, // FIXME: EV 14.526, 50000.0 lux in the GUI, yet it does not seem to use illuminance
            directLightColor: [0.9, 0.9, 1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0, //8000.0, Turned off -- until we support world space light positioning.
            //lightDirection: [-0.2, -0.18, 0.72], //world space, not view space!
            bgColorGradient: bg["Plaza"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Snow Field",            //  "Snow Field", localized in viewer-environments.loc.json
            path:"SnowField",
            type:"logluv",
            tonemap:1,
            //illuminance: 4302.7773,
            E_bias: -10.461343,  // EV 14.526, 50000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0, //800.0, Turned off -- until we support world space light positioning.
            //lightDirection: [0.0, -1.0, 0.0], //world space, not view space!
            bgColorGradient: bg["Snow"],
            darkerFade: false,
            rotation: 0.0
        }
    ];

    avp.DebugEnvironments = [
             //More RaaS ones

            {
                name: "Field",            //  "Field", localized in viewer-environments.loc.json
                path:"field",
                type:"logluv",
                tonemap:1,
                E_bias:-2.9,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                darkerFade: false,
                rotation: 0.0
            },
            {
                name: "Crossroads",         //  "Crossroads", localized in viewer-environments.loc.json
                path:"crossroads",
                type:"logluv",
                tonemap:1,
                E_bias:-5.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                darkerFade: false,
                rotation: 0.0
            },

            {
                name: "Seaport",            //  "Seaport", localized in viewer-environments.loc.json
                path:"seaport",
                type:"logluv",
                tonemap:1,
                E_bias:-6.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                darkerFade: false,
                rotation: 0.0
            },

            {
                name: "Glacier",            //  "Glacier", localized in viewer-environments.loc.json
                path:"glacier",
                type:"logluv",
                tonemap:1,
                E_bias:0,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Midnight"],
                darkerFade: false,
                rotation: 0.0
            },

            {
                name: "Boardwalk",           //  "Boardwalk", localized in viewer-environments.loc.json
                path:"boardwalk",
                type:"logluv",
                tonemap:1,
                E_bias:-7.0,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                darkerFade: false,
                rotation: 0.0
            },

            {
                name: "RaaS Test Env",      // localized in viewer-environments.loc.json
                path:"Reflection",
                type:"logluv",
                tonemap:2,
                E_bias:-1.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["RaaS SBS"],
                darkerFade: false,
                rotation: 0.0
            }
    ];

    if (ENABLE_DEBUG) {
        avp.LightPresets = avp.LightPresets.concat(avp.DebugEnvironments);
    }


    avp.CreateCubeMapFromColors = function(ctop, cbot) {
        var r1 = ctop.x * 255, g1 = ctop.y * 255, b1 = ctop.z * 255,
            r2 = cbot.x * 255, g2 = cbot.y * 255, b2 = cbot.z * 255;

        var pixelsTop = new Uint8Array(16);
        var pixelsBot = new Uint8Array(16);
        var pixelsSide = new Uint8Array(16);

        for (var i=0; i<4; i++) {
            pixelsTop[i*4] = r1;
            pixelsTop[i*4+1] = g1;
            pixelsTop[i*4+2] = b1;
            pixelsTop[i*4+3] = 255;

            pixelsBot[i*4] = r2;
            pixelsBot[i*4+1] = g2;
            pixelsBot[i*4+2] = b2;
            pixelsBot[i*4+3] = 255;

            // was this, which is wild: if (0 | (i / 2)) {
            if ( i > 1 ) {
				// color sides 2 and 3 with the first color
                pixelsSide[i*4] = r1;
                pixelsSide[i*4+1] = g1;
                pixelsSide[i*4+2] = b1;
                pixelsSide[i*4+3] = 255;
            }
            else {
				// color sides 0 and 1 with the second color
                pixelsSide[i*4] = r2;
                pixelsSide[i*4+1] = g2;
                pixelsSide[i*4+2] = b2;
                pixelsSide[i*4+3] = 255;
            }
        }

        var x_neg = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var x_pos = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var y_neg = new THREE.DataTexture( pixelsBot, 2, 2, THREE.RGBAFormat );
        var y_pos = new THREE.DataTexture( pixelsTop, 2, 2, THREE.RGBAFormat );
        var z_neg = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var z_pos = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );

        var texture = new THREE.Texture(null, THREE.CubeReflectionMapping,
                                        THREE.RepeatWrapping, THREE.RepeatWrapping,
                                        THREE.LinearFilter, THREE.LinearFilter,
                                        //THREE.NearestFilter, THREE.NearestFilter,
                                        THREE.RGBAFormat);
        texture.image = [x_pos, x_neg, y_pos, y_neg, z_pos, z_neg];
        texture.needsUpdate = true;

        return texture;
    };


    var M = [6.0014, -2.7008, -1.7996, -1.3320,  3.1029, -5.7721, 0.3008, -1.0882,  5.6268];

    function LogLuvDecode(dst, src) {

        var Le = src[2] * 255.0 + src[3];
        var Xp_Y_XYZp_y = Math.pow(2.0, (Le - 127.0) / 2.0);
        var Xp_Y_XYZp_z = Xp_Y_XYZp_y / (src[1]);
        var Xp_Y_XYZp_x = (src[0]) * Xp_Y_XYZp_z;

        var r = M[0] * Xp_Y_XYZp_x + M[3] * Xp_Y_XYZp_y + M[6] * Xp_Y_XYZp_z;
        var g = M[1] * Xp_Y_XYZp_x + M[4] * Xp_Y_XYZp_y + M[7] * Xp_Y_XYZp_z;
        var b = M[2] * Xp_Y_XYZp_x + M[5] * Xp_Y_XYZp_y + M[8] * Xp_Y_XYZp_z;

        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;

        dst[0] = r;
        dst[1] = g;
        dst[2] = b;
    }

    function RGBMEncode(dst, src, expScale) {

        var r = Math.sqrt(src[0]*expScale)*0.0625; // 1/16 = 0.0625
        var g = Math.sqrt(src[1]*expScale)*0.0625;
        var b = Math.sqrt(src[2]*expScale)*0.0625;

        var maxL = Math.max( Math.max(r, g), Math.max(b, 1e-6));
        if (maxL > 1.0)
            maxL = 1.0;

        var w = Math.ceil( maxL * 255.0 ) / 255.0;

        if (r > 1.0)
            r = 1.0;
        if (g > 1.0)
            g = 1.0;
        if (b > 1.0)
            b = 1.0;

        dst[3] = w;
        var a = 1.0 / w;

        dst[0] = r * a;
        dst[1] = g * a;
        dst[2] = b * a;
    }

    function RGB16Encode(dst, src, expScale) {

        var r = Math.sqrt(src[0]*expScale);
        var g = Math.sqrt(src[1]*expScale);
        var b = Math.sqrt(src[2]*expScale);

        //That's pretty unlikely to happen...
        var MAX_HALF = 65504;
        if (r > MAX_HALF)
            r = MAX_HALF;
        if (g > MAX_HALF)
            g = MAX_HALF;
        if (b > MAX_HALF)
            b = MAX_HALF;

        dst[0] = r;
        dst[1] = g;
        dst[2] = b;

    }

    var fbuf = new Float32Array(1);
    var ibuf = new Uint32Array(fbuf.buffer);
    var tmp = new Uint16Array(1);
    var hp = new Uint16Array(1);

    function FloatToHalf(f) {

        fbuf[0] = f;
        var x = ibuf[0];
        var i=0;

        if( (x & 0x7FFFFFFF) === 0 ) {  // Signed zero
            hp[i++] = (x >> 16);  // Return the signed zero
        } else { // Not zero
            var xs = x & 0x80000000;  // Pick off sign bit
            var xe = x & 0x7F800000;  // Pick off exponent bits
            var xm = x & 0x007FFFFF;  // Pick off mantissa bits
            if( xe === 0 ) {  // Denormal will underflow, return a signed zero
                hp[i++] = (xs >> 16);
            } else if( xe == 0x7F800000 ) {  // Inf or NaN (all the exponent bits are set)
                if( xm === 0 ) { // If mantissa is zero ...
                    hp[i++] = ((xs >> 16) | 0x7C00); // Signed Inf
                } else {
                    hp[i++] = 0xFE00; // NaN, only 1st mantissa bit set
                }
            } else { // Normalized number
                var hm, he;
                var hs = (xs >> 16); // Sign bit
                var hes = (0|(xe >> 23)) - 127 + 15; // Exponent unbias the single, then bias the halfp
                if( hes >= 0x1F ) {  // Overflow
                    hp[i++] = ((xs >> 16) | 0x7C00); // Signed Inf
                } else if( hes <= 0 ) {  // Underflow
                    if( (14 - hes) > 24 ) {  // Mantissa shifted all the way off & no rounding possibility
                        hm = 0;  // Set mantissa to zero
                    } else {
                        xm |= 0x00800000;  // Add the hidden leading bit
                        hm = (xm >> (14 - hes)); // Mantissa
                        tmp[0] = hm; hm = tmp[0];

                        if( (xm >> (13 - hes)) & 0x00000001 ) // Check for rounding
                            hm += 1; // Round, might overflow into exp bit, but this is OK
                    }
                    hp[i++] = (hs | hm); // Combine sign bit and mantissa bits, biased exponent is zero
                } else {
                    he = (hes << 10); // Exponent
                    tmp[0] = he; he = tmp[0];

                    hm = (xm >> 13); // Mantissa
                    tmp[0] = hm; hm = tmp[0];

                    if( xm & 0x00001000 ) // Check for rounding
                        hp[i++] = (hs | he | hm) + 1; // Round, might overflow to inf, this is OK
                    else
                        hp[i++] = (hs | he | hm);  // No rounding
                }
            }
        }

        return hp[0];
    }


    function HalfToFloat(source)
    {
        var target;

        var h = source & 0xFFFF;
        if( (h & 0x7FFF) === 0 ) {  // Signed zero
            target = h << 16;  // Return the signed zero
        } else { // Not zero
            var hs = h & 0x8000;  // Pick off sign bit
            var he = h & 0x7C00;  // Pick off exponent bits
            var hm = h & 0x03FF;  // Pick off mantissa bits
            if( he === 0 ) {  // Denormal will convert to normalized
                var e = -1; // The following loop figures out how much extra to adjust the exponent
                do {
                    e++;
                    hm <<= 1;
                } while( (hm & 0x0400) === 0 ); // Shift until leading bit overflows into exponent bit
                var xs = (hs) << 16; // Sign bit
                var xes = ((he << 16) >> 26) - 15 + 127 - e; // Exponent unbias the halfp, then bias the single
                var xe = (xes << 23); // Exponent
                var xm = ((hm & 0x03FF)) << 13; // Mantissa
                target = (xs | xe | xm); // Combine sign bit, exponent bits, and mantissa bits
            } else if( he == 0x7C00 ) {  // Inf or NaN (all the exponent bits are set)
                if( hm === 0 ) { // If mantissa is zero ...
                    target = ((hs) << 16) | (0x7F800000); // Signed Inf
                } else {
                    target = 0xFFC00000; // NaN, only 1st mantissa bit set
                }
            } else { // Normalized number
                xs = (hs) << 16; // Sign bit
                xes = ((he << 16) >> 26) - 15 + 127; // Exponent unbias the halfp, then bias the single
                xe = (xes << 23); // Exponent
                xm = (hm) << 13; // Mantissa
                target = (xs | xe | xm); // Combine sign bit, exponent bits, and mantissa bits
            }
        }

        ibuf[0] = target;
        return fbuf[0];
    }


    var tmpSrc = new Float32Array(4);
    var tmpDst = new Float32Array(4);

    //Converts incoming environment cube maps to image format suitable for use by the shader.
    avp.DecodeEnvMap = function(map, exposure, useHalfFloat) {

        if (!map.LogLuv) {
            stderr("Environment map expected to be in LogLuv format.");
            return;
        }

        var scale = Math.pow(2.0, exposure);

		// if `map.image` is an array, use it as it is, otherwise create an array with single item (`map.image`) in it
        var images = Array.isArray(map.image) ? map.image : [map.image];

        for (var i=0; i<images.length; i++) {

            var image = images[i];

            for (var j=0; j<image.mipmaps.length; j++) {

                var mipmap = image.mipmaps[j];

                var src = mipmap.data;

                var dst;
                if (useHalfFloat) {
                    //var dst = new Float32Array(src.length / 4 * 3);
                    dst = new Uint16Array(src.length / 4 * 3);
                    mipmap.data = dst;
                }
                else
                    dst = src.buffer;

                var m=0;

                for (var k=0; k<src.length; k+=4) {

                    tmpSrc[0] = src[k] / 255.0;
                    tmpSrc[1] = src[k+1] / 255.0;
                    tmpSrc[2] = src[k+2] / 255.0;
                    tmpSrc[3] = src[k+3] / 255.0;

                    LogLuvDecode(tmpDst, tmpSrc);

                    if (useHalfFloat) {
                        //Use sqrt to gamma-compress the data to help the texture filtering
                        //hardware.
                        RGB16Encode(tmpSrc, tmpDst, scale);
                        dst[m++] = FloatToHalf(tmpSrc[0]);
                        dst[m++] = FloatToHalf(tmpSrc[1]);
                        dst[m++] = FloatToHalf(tmpSrc[2]);
                    } else {
                        //Temporary: decode incoming LogLUV environments and convert them
                        //to RGBM format for use by the shader. Eventually we will use half-float format
                        //instead, but that has to be better tested.
                        RGBMEncode(tmpSrc, tmpDst, scale);

                        src[k] = Math.round(tmpSrc[0] * 255.0);
                        src[k+1] = Math.round(tmpSrc[1] * 255.0);
                        src[k+2] = Math.round(tmpSrc[2] * 255.0);
                        src[k+3] = Math.round(tmpSrc[3] * 255.0);
                    }
                }

            }

        }

        map.LogLuv = false;

        if (useHalfFloat) {
            map.type = THREE.HalfFloatType;
            map.format = THREE.RGBFormat;
            map.RGBM = false;
            map.GammaEncoded = true;
        }
        else
            map.RGBM = true;

    };

    avp.DefaultLightPreset = 1;
    avp.DefaultLightPreset2d = 0;


})();
;
(function(ns) {

"use strict";


var LineStyleDefs = [

{
    id: "SOLID",
    name: "Solid",
    ascii_art: "_______________________________________",
    def: [1]
},

//Line types from acad.lin below. Definitions are kept the same
//as the original except the format is JSON-ified to avoid parsing .LIN

//
//  AutoCAD Linetype Definition file
//  Version 2.0
//  Copyright 1991, 1992, 1993, 1994, 1996 by Autodesk, Inc.
//

//List of line type definitions from ACAD.lin.

//[TS] The units for these items seem to be inches or drawing units with dot
// being represented by 0, i.e. pen width = 0. (see note about ISO patterns below)

{
    id: "BORDER",
    name: "Border",
    ascii_art: "__ __ . __ __ . __ __ . __ __ . __ __ .",
    def: [.5,-.25,.5,-.25,0,-.25]
},
{
    id: "BORDER2",
    name: "Border (.5x)",
    ascii_art: "__ __ . __ __ . __ __ . __ __ . __ __ .",
    def: [.25,-.125,.25,-.125,0,-.125]
},
{
    id: "BORDERX2",
    name: "Border (2x)",
    ascii_art: "____  ____  .  ____  ____  .  ___",
    def: [1.0,-.5,1.0,-.5,0,-.5]
},


{
    id: "CENTER",
    name: "Center",
    ascii_art: "____ _ ____ _ ____ _ ____ _ ____ _ ____",
    def: [1.25,-.25,.25,-.25]
},
{
    id: "CENTER2",
    name: "Center (.5x)",
    ascii_art: "___ _ ___ _ ___ _ ___ _ ___ _ ___",
    def: [.75,-.125,.125,-.125]
},    
{
    id: "CENTERX2",
    name: "Center (2x)",
    ascii_art: "________  __  ________  __  _____",
    def: [2.5,-.5,.5,-.5]
},

{
    id: "DASHDOT",
    name : "Dash dot",
    ascii_art: "__ . __ . __ . __ . __ . __ . __ . __",
    def: [.5,-.25,0,-.25]
},
{
    id: "DASHDOT2",
    name: "Dash dot (.5x)",
    ascii_art : "_._._._._._._._._._._._._._._.",
    def: [.25,-.125,0,-.125]
},
{
    id: "DASHDOTX2",
    name : "Dash dot (2x)",
    ascii_art: "____  .  ____  .  ____  .  ___",
    def: [1.0,-.5,0,-.5]
},

{
    id: "DASHED",
    name: "Dashed",
    ascii_art: "__ __ __ __ __ __ __ __ __ __ __ __ __ _",
    def: [.5,-.25]
},
{
    id: "DASHED2",
    name: "Dashed (.5x)",
    ascii_art: "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _", 
    def: [.25,-.125]
},
{
    id: "DASHEDX2",
    name: "Dashed (2x)",
    ascii_art: "____  ____  ____  ____  ____  ___",
    def: [1.0,-.5]
},

{
    id: "DIVIDE",
    name: "Divide",
    ascii_art: "____ . . ____ . . ____ . . ____ . . ____",
    def: [.5,-.25,0,-.25,0,-.25]
},
{
    id: "DIVIDE2",
    name: "Divide (.5x)",
    ascii_art: "__..__..__..__..__..__..__..__.._",
    def: [.25,-.125,0,-.125,0,-.125]
},
{
    id: "DIVIDEX2",
    name: "Divide (2x)",
    ascii_art: "________  .  .  ________  .  .  _",
    def: [1.0,-.5,0,-.5,0,-.5]
},

{
    id: "DOT",
    name: "Dot",
    ascii_art: ". . . . . . . . . . . . . . . . . . . . . . . .",
    def: [0,-.25]
},
{
    id: "DOT2",
    name: "Dot (.5x)",
    ascii_art: "........................................",
    def: [0,-.125]
},
{
    id: "DOTX2",
    name: "Dot (2x)",
    ascii_art: ".  .  .  .  .  .  .  .  .  .  .  .  .  .",
    def: [0,-.5]
},

{
    id: "HIDDEN",
    name: "Hidden",
    ascii_art: "__ __ __ __ __ __ __ __ __ __ __ __ __ __",
    def: [.25,-.125]
},
{ 
    id: "HIDDEN2",
    name: "Hidden (.5x)",
    ascii_art: "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _", 
    def: [.125,-.0625]
},
{
    id: "HIDDENX2",
    name: "Hidden (2x)",
    ascii_art: "____ ____ ____ ____ ____ ____ ____",
    def: [.5,-.25]
},

{
    id: "PHANTOM",
    name: "Phantom",
    ascii_art: "______  __  __  ______  __  __  ______",
    def: [1.25,-.25,.25,-.25,.25,-.25]
},

{ 
    id: "PHANTOM2",
    name: "Phantom (.5x)",
    ascii_art: "___ _ _ ___ _ _ ___ _ _ ___ _ _",
    def: [.625,-.125,.125,-.125,.125,-.125]
},

{
    id: "PHANTOMX2",
    name: "Phantom (2x)",
    ascii_art: "____________    ____    ____   _",
    def: [2.5,-.5,.5,-.5,.5,-.5]
},

//
//  ISO 128 (ISO/DIS 12011) linetypes
//
//  The size of the line segments for each defined ISO line, is
//  defined for an usage with a pen width of 1 mm. To use them with
//  the other ISO predefined pen widths, the line has to be scaled
//  with the appropriate value (e.g. pen width 0,5 mm -> ltscale 0.5).
//

//[TS] Added pen_width and unit properties to make this explicit

{
    id: "ACAD_ISO02W100",
    name: "ISO dash",
    ascii_art: "__ __ __ __ __ __ __ __ __ __ __ __ __",
    def: [12,-3],
    
    pen_width: 1,
    unit: "mm"
},

{
    id: "ACAD_ISO03W100",
    name: "ISO dash space",
    ascii_art: "__    __    __    __    __    __",
    def: [12,-18],

    pen_width: 1,
    unit: "mm"
},

{
    id: "ACAD_ISO04W100",
    name: "ISO long-dash dot",
    ascii_art: "____ . ____ . ____ . ____ . _",
    def: [24,-3,.5,-3],
    
    pen_width: 1,
    unit: "mm"
},

{
    id: "ACAD_ISO05W100",
    name: "ISO long-dash double-dot",
    ascii_art: "____ .. ____ .. ____ .",
    def: [24,-3,.5,-3,.5,-3],

    pen_width: 1,
    unit: "mm"
},

{
    id: "ACAD_ISO06W100",
    name: "ISO long-dash triple-dot",
    ascii_art: "____ ... ____ ... ____",
    def: [24,-3,.5,-3,.5,-3,.5,-3],

    pen_width: 1,
    unit: "mm"
},

{
    id: "ACAD_ISO07W100",
    name: "ISO dot",
    ascii_art: ". . . . . . . . . . . . . . . . . . . .",
    def: [.5,-3],

    pen_width: 1,
    unit: "mm"
},

{
    id: "ACAD_ISO08W100",
    name: "ISO long-dash short-dash",
    ascii_art: "____ __ ____ __ ____ _",
    def: [24,-3,6,-3],
    
    pen_width: 1,
    unit: "mm"    
},

{
    id: "ACAD_ISO09W100",
    name: "ISO long-dash double-short-dash",
    ascii_art: "____ __ __ ____",
    def: [24,-3,6,-3,6,-3],

    pen_width: 1,
    unit: "mm"
},
{
    id: "ACAD_ISO10W100",
    name: "ISO dash dot",
    ascii_art: "__ . __ . __ . __ . __ . __ . __ . ",
    def: [12,-3,.5,-3],
    
    pen_width: 1,
    unit: "mm"    
},

{
    id: "ACAD_ISO11W100",
    name: "ISO double-dash dot",
    ascii_art: "__ __ . __ __ . __ __ . __ _",
    def: [12,-3,12,-3,.5,-3],
    
    pen_width: 1,
    unit: "mm"    
},
{
    id: "ACAD_ISO12W100",
    name: "ISO dash double-dot",
    ascii_art: "__ . . __ . . __ . . __ . .", 
    def: [12,-3,.5,-3,.5,-3],
    
    pen_width: 1,
    unit: "mm"    
},
{
    id: "ACAD_ISO13W100",
    name: "ISO double-dash double-dot",
    ascii_art: "__ __ . . __ __ . . _",
    def: [12,-3,12,-3,.5,-3,.5,-3],
    
    pen_width: 1,
    unit: "mm"    
},

{
    id: "ACAD_ISO14W100",
    name: "ISO dash triple-dot",
    ascii_art: "__ . . . __ . . . __ . . . _",
    def: [12,-3,.5,-3,.5,-3,.5,-3],
    
    pen_width: 1,
    unit: "mm"    
},

{
    id: "ACAD_ISO15W100",
    name: "ISO double-dash triple-dot",
    ascii_art: "__ __ . . . __ __ . .",
    def: [12,-3,12,-3,.5,-3,.5,-3,.5,-3],
    
    pen_width: 1,
    unit: "mm"    
},

//  Complex linetypes
//
//  Complex linetypes have been added to this file.
//  These linetypes were defined in LTYPESHP.LIN in
//  Release 13, and are incorporated in ACAD.LIN in
//  Release 14.
//  
//  These linetype definitions use LTYPESHP.SHX.
//

//[TS] These do not work, we can only render linear types.

{
    id: "FENCELINE1",
    name: "Fenceline circle",
    ascii_art: "----0-----0----0-----0----0-----0--",
    def: [.25,-.1,["CIRC1","ltypeshp.shx","x=-.1","s=.1"],-.1,1] //TODO: Does not work
},

{
    id: "FENCELINE2",
    name: "Fenceline square",
    ascii_art: "----[]-----[]----[]-----[]----[]---",
    def: [.25,-.1,["BOX","ltypeshp.shx","x=-.1","s=.1"],-.1,1] //TODO: Does not work
},

{
    id: "TRACKS",
    name: "Tracks",
    ascii_art: "-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-",
    def: [.15,["TRACK1","ltypeshp.shx","s=.25"],.15] //TODO: Does not work
},

{
    id: "BATTING",
    name: "Batting",
    ascii_art: "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS",
    def: [.0001,-.1,["BAT","ltypeshp.shx","x=-.1","s=.1"],-.2,["BAT","ltypeshp.shx","r=180","x=.1","s=.1"],-.1] //TODO: Does not work
},

{
    id: "HOT_WATER_SUPPLY",
    name: "Hot water supply",
    ascii_art: "---- HW ---- HW ---- HW ----",
    def: [.5,-.2,["HW","STANDARD","S=.1","R=0.0","X=-0.1","Y=-.05"],-.2] //TODO: Does not work
},

{
    id: "GAS_LINE",
    name: "Gas line",
    ascii_art: "----GAS----GAS----GAS----GAS----GAS----GAS--",
    def: [.5,-.2,["GAS","STANDARD","S=.1","R=0.0","X=-0.1","Y=-.05"],-.25] //TODO: Does not work
},


{
    id: "ZIGZAG",
    name: "Zig zag",
    ascii_art: "/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/",
    def: [.0001,-.2,["ZIG","ltypeshp.shx","x=-.2","s=.2"],-.4,["ZIG","ltypeshp.shx","r=180","x=.2","s=.2"],-.2] //TODO: Does not work
}


];


var CreateLinePatternTexture = function() {

    var h = LineStyleDefs.length;
    var w=0;

    for (var i=0; i<h; i++) {
        var ls = LineStyleDefs[i];

        if (ls.def.length > w)
            w = ls.def.length;
    }

    var pw = w+3;
    var ph = h;

    var pot = 1;
    while (pot < pw)
        pot *= 2;
    pw = pot;

    pot = 1;
    while (pot < ph)
        pot *= 2;
    ph = pot;

    var tex = new Uint8Array(pw * ph);

    for (var j=0; j<h; j++) {
        var off = j * pw;

        var ls = LineStyleDefs[j];

        //NOTE: The pattern scaling here just makes
        //the definitions in the texture consistent throughout in units of logical pixels (96 pixels per inch).
        //It does not apply scaling based on pen width or LTSCALE which should be done in shader.
        //Because we use a Byte texture, the maximum dash length at 96 dpi is about 2.5 inches, which
        //is enough for the patterns we have today. This can be easily fixed by changing to e.g. rgba8

        var dpi = 96;
        var unitScale = (ls.unit && ls.unit == "mm") ? 1.0 / 25.4 : 1.0;
        var penWidth = ls.pen_width || 0;

        var segs = ls.def;
        var patLen = 0;
        for (var i=0; i<segs.length; i++) {

            var len = Math.abs(segs[i]);

            var isDot = (len <= penWidth * 0.5);
            //Is it a dot? (the ISO patterns define dot as segment with half a pen width)
            if (isDot)
                len = 0;

            var ilen = 0 | (len * dpi * unitScale);

            patLen += ilen;

            //dot handling, set to 1 logical pixel in texture, since we need the 0 to indicate pattern end
            //the shader will interpret 1 as dot.
            tex[off+i+2] = ilen ? ilen : 1;
        }

        //Two bytes to store total pattern length in the first two bytes of the texture row
        tex[off] = patLen % 256;
        tex[off+1] = patLen / 256;

        //null terminate the pattern def in the texture so we know when to stop in the shader
        tex[off+segs.length+2] = 0;
    }

    var lineStyleTex = new THREE.DataTexture(tex, pw, ph,
                                             THREE.LuminanceFormat,
                                             THREE.UnsignedByteType,
                                             THREE.UVMapping,
                                             THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
                                             THREE.NearestFilter, THREE.NearestFilter, 0);

    lineStyleTex.generateMipmaps = false;
    lineStyleTex.flipY = false;
    lineStyleTex.needsUpdate = true;

    return lineStyleTex;
};


ns.LineStyleDefs = LineStyleDefs;
ns.CreateLinePatternTexture = CreateLinePatternTexture;


})(Autodesk.Viewing.Private);;(function() {
	'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

// Helper functions to parse ugly Protein JSON
function parseMaterialColor(props, name) {
    if (!props || !props["colors"])
        return new THREE.Color(1, 0, 0); //error -- return red

    var cobj = props["colors"][name];
    if (!cobj)
        return new THREE.Color(0, 0, 0); //ok -- color is not defined
        //which in the C++ LMVTK is equal to DEFAULT_COLOR, which is black

    var vals = cobj["values"];
    if (!vals || !vals.length)
        return new THREE.Color(1, 0, 0); //error

    var rgb = vals[0];
    return new THREE.Color(rgb["r"], rgb["g"], rgb["b"]);
}

function parseMaterialScalar(props, name, undefVal) {
    if (!props || !props["scalars"])
        return undefVal;

    var vobj = props["scalars"][name];
    if (!vobj)
        return undefVal;

    return vobj["values"][0];
}

function parseMaterialBoolean(props, name, undefVal) {
    if (!props || !props["booleans"])
        return undefVal;

    var vobj = props["booleans"];
    if (!vobj)
        return undefVal;

    return vobj[name];
}

function parseMaterialGeneric(props, category, name, undefVal) {
    if (!props || !props[category])
        return undefVal;

    var vobj = props[category][name];
    if (!vobj)
        return undefVal;

    return vobj["values"][0];
}

function parseWoodProfile(props, category, name) {
    //Init a default object.
    var ret = {
        bands: 0,
        weights: new THREE.Vector4(1, 1, 1, 1),
        frequencies: new THREE.Vector4(1, 1, 1, 1)
    };

    if (!props || !props[category])
        return ret;

    var vobj = props[category][name];
    if (!vobj || !vobj.values || !(vobj.values instanceof Array))
        return ret;

    var values = vobj.values;
    ret.bands = values.length / 2;
    for (var i = 0; i < ret.bands; ++i) {
        ret.frequencies.setComponent(i, 1 / values[2 * i]);
        ret.weights.setComponent(i, values[2 * i + 1]);
    }

    return ret;
}

function parseMaterialScalarWithSceneUnit(props, name, sceneUnit, undefVal) {
    if (!props || !props["scalars"])
        return undefVal;

    var vobj = props["scalars"][name];
    if (!vobj)
        return undefVal;

    return ConvertDistance(vobj["values"][0], vobj["units"], sceneUnit);
}

function parseMaterialGenericConnection(props, category, name, undefVal) {
    if (!props || !props[category])
        return undefVal;

    var vobj = props[category][name];
    if (!vobj)
        return undefVal;

    var connections = vobj["connections"];
    if (!connections)
        return undefVal;

    return vobj["connections"][0];
}

function SRGBToLinearFloat(component) {
    var result = component;

    if (result <= 0.04045)
        result /= 12.92;
    else
        result = Math.pow((result + 0.055) / 1.055, 2.4);

    return result;
}

function SRGBToLinear(color) {
    var r, g, b;

    r = SRGBToLinearFloat(color.r);
    g = SRGBToLinearFloat(color.g);
    b = SRGBToLinearFloat(color.b);

    return new THREE.Color(r, g, b);
}

// TODO, since web doesn't use AdCoreUnits dependencies, only 9 units are supported in web now.
var UnitPerMeter = {
    MilliMeter: 1000,  mm: 1000,      8206: 1000,
    DeciMeter: 10,     dm : 10,       8204: 10,
    CentiMeter: 100,   cm: 100,       8205: 100,
    Meter: 1,          m: 1,          8193: 1,
    KiloMeter: 0.001,  km: 0.001,     8201: 0.001,
    Inch: 39.37008,    in: 39.37008,  8214: 39.37008,
    Foot: 3.28084,     ft: 3.28084,   8215: 3.28084,
    Mile: 0.00062137,  mi: 0.00062137,8225: 0.00062137,
    Yard: 1.09361,     yard:1.09361,  8221: 1.09361
};

// Convert meter to the new unit.
function ConvertDistance(distance, currentUnit, newUnit) {

    var factor = UnitPerMeter[newUnit];
    if (!factor) {
        factor = 1;
        console.warn('Unsupported unit: ' + newUnit);
    }

    var divisor = UnitPerMeter[currentUnit];
    if (!divisor) {
        divisor = 1;
        console.warn('Unsupported unit: ' + currentUnit);
    }

    return distance * factor / divisor;
}

function GetBumpScale(props, type, sceneUnit) {
    if (type === 0) {
        var depth = parseMaterialScalarWithSceneUnit(props, "bumpmap_Depth", sceneUnit, 0);

        var scale_x = 1;
        var scale_y = 1;
        if (parseMaterialGeneric(props, "scalars", "texture_RealWorldScale") != null) {
            scale_x = scale_y = parseMaterialScalarWithSceneUnit(props, "texture_RealWorldScale", sceneUnit, 1);
        }
        else {
            scale_x = parseMaterialScalarWithSceneUnit(props, "texture_RealWorldScaleX", sceneUnit, 1);
            scale_y = parseMaterialScalarWithSceneUnit(props, "texture_RealWorldScaleY", sceneUnit, 1);
        }
        scale_x = (scale_x === 0) ? 1 : 1 / scale_x;
        scale_y = (scale_y === 0) ? 1 : 1 / scale_y;

        return new THREE.Vector2(scale_x * depth, scale_y * depth);
    }
    else {
        var normalScale = parseMaterialGeneric(props, "scalars", "bumpmap_NormalScale", 1);
        return new THREE.Vector2(normalScale, normalScale);
    }
}

function Get2DMapTransform(props, sceneUnit) {

    var offset_x = parseMaterialScalarWithSceneUnit(props, "texture_RealWorldOffsetX", sceneUnit, 0);
    var offset_y = parseMaterialScalarWithSceneUnit(props, "texture_RealWorldOffsetY", sceneUnit, 0);
    var uoffset = parseMaterialGeneric(props, "scalars", "texture_UOffset", 0);
    var voffset = parseMaterialGeneric(props, "scalars", "texture_VOffset", 0);

    // include the additional U and V Offsets
    offset_x += uoffset;
    offset_y += voffset;

    // Get the real-world size, i.e. the size of the map in a real unit, and use the reciprocal as
    // the scale.  If the scale is zero, use one instead.
    var scale_x = 1;
    var scale_y = 1;
    if (parseMaterialGeneric(props, "scalars", "texture_RealWorldScale") != null) {
        scale_x = scale_y = parseMaterialScalarWithSceneUnit(props, "texture_RealWorldScale", sceneUnit, 1);
    }
    else {
        scale_x = parseMaterialScalarWithSceneUnit(props, "texture_RealWorldScaleX", sceneUnit, 1);
        scale_y = parseMaterialScalarWithSceneUnit(props, "texture_RealWorldScaleY", sceneUnit, 1);
    }
    scale_x = (scale_x === 0) ? 1 : 1 / scale_x;
    scale_y = (scale_y === 0) ? 1 : 1 / scale_y;

    // include the additional U and V scales
    var uscale = parseMaterialGeneric(props, "scalars", "texture_UScale", 1);
    var vscale = parseMaterialGeneric(props, "scalars", "texture_VScale", 1);
    scale_x *= uscale;
    scale_y *= vscale;

    // Get the rotation angle and convert it from degrees to radians.
    var angle = parseMaterialGeneric(props, "scalars", "texture_WAngle", 1);
    angle *= Math.PI / 180.0;

    var matrix = {
        elements: [
            Math.cos(angle) * scale_x, Math.sin(angle) * scale_y, 0,
           -Math.sin(angle) * scale_x, Math.cos(angle) * scale_y, 0,
            offset_x, offset_y, 1
        ]
    };

    return matrix;
}


var PrismWoodTexture;
//Init the prism wood textures. They are used in all prism 3d wood materials, so keep them
//in the material manager.
function InitPrism3DWoodTextures() {
    var permutation = [
        151, 160, 137,  91,  90,  15, 131,  13, 201,  95,  96,  53, 194, 233,   7, 225,
        140,  36, 103,  30,  69, 142,   8,  99,  37, 240,  21,  10,  23, 190,   6, 148,
        247, 120, 234,  75,   0,  26, 197,  62,  94, 252, 219, 203, 117,  35,  11,  32,
         57, 177,  33,  88, 237, 149,  56,  87, 174,  20, 125, 136, 171, 168,  68, 175,
         74, 165,  71, 134, 139,  48,  27, 166,  77, 146, 158, 231,  83, 111, 229, 122,
         60, 211, 133, 230, 220, 105,  92,  41,  55,  46, 245,  40, 244, 102, 143,  54,
         65,  25,  63, 161,   1, 216,  80,  73, 209,  76, 132, 187, 208,  89,  18, 169,
        200, 196, 135, 130, 116, 188, 159,  86, 164, 100, 109, 198, 173, 186,   3,  64,
         52, 217, 226, 250, 124, 123,   5, 202,  38, 147, 118, 126, 255,  82,  85, 212,
        207, 206,  59, 227,  47,  16,  58,  17, 182, 189,  28,  42, 223, 183, 170, 213,
        119, 248, 152,   2,  44, 154, 163,  70, 221, 153, 101, 155, 167,  43, 172,   9,
        129,  22,  39, 253,  19,  98, 108, 110,  79, 113, 224, 232, 178, 185, 112, 104,
        218, 246,  97, 228, 251,  34, 242, 193, 238, 210, 144,  12, 191, 179, 162, 241,
         81,  51, 145, 235, 249,  14, 239, 107,  49, 192, 214,  31, 181, 199, 106, 157,
        184,  84, 204, 176, 115, 121,  50,  45, 127,   4, 150, 254, 138, 236, 205,  93,
        222, 114,  67,  29,  24,  72, 243, 141, 128, 195,  78,  66, 215,  61, 156, 180
    ];
    var permutationBuffer = new Uint8Array(permutation);
    var permutationTex = new THREE.DataTexture(permutationBuffer, 256, 1,
                                            THREE.LuminanceFormat,
                                            THREE.UnsignedByteType,
                                            THREE.UVMapping,
                                            THREE.RepeatWrapping, THREE.RepeatWrapping,
                                            THREE.NearestFilter, THREE.NearestFilter, 0);
    permutationTex.generateMipmaps = false;
    permutationTex.flipY = false;
    permutationTex.needsUpdate = true;
    //This is different with OGS desktop. OGS uses a float texture. I map these number to
    //unsight byte, since some platform may not support float texture. Test result shows that
    //the pixel diffrence is very small.
    var gradientData = [
        225,  39, 122, 231,  29, 173,  15, 159,  75,  88, 233,  19, 179,  79,  72,  94,
         54,  73, 151, 161, 171, 113, 221, 144, 127,  83, 168,  19,  88, 122,  62, 225,
        109, 128, 246, 247, 172, 101,  61, 139, 211, 168,  64, 210, 224,  82,  87,  97,
        119, 250, 201,  44, 242, 239, 154,  99, 126,  13,  44,  70, 246, 170, 100,  52,
        135,  28, 187,  22, 207, 119, 199,   1, 235, 187,  55, 131, 190, 124, 222, 249,
        236,  53, 225, 231,  71,  30, 173, 185, 153,  47,  79, 133, 225,  10, 140,  62,
         17,  99, 100,  29, 137,  95, 142, 244,  76,   5,  83, 124,  38, 216, 253, 195,
         44, 210, 148, 185, 188,  39,  78, 195, 132,  30,  60,  73,  92, 223, 133,  80,
        230,  56, 118, 207,  79,  15, 251, 211, 111,  21,  79,  23, 240, 146, 150, 207,
          3,  61, 103,  27, 148,   6,  31, 127, 235,  58, 173, 244, 116,  81,  34, 120,
        192, 213, 188, 226,  97,  23,  16, 161, 106,  80, 242, 148,  35,  37,  91, 117,
         51, 216,  97, 193, 126, 222,  39,  38, 133, 217, 215,  23, 237,  57, 205,  42,
        222, 165, 126, 133,  33,   8, 227, 154,  27,  18,  56,  11, 192, 120,  80,  92,
        236,  38, 210, 207, 128,  31, 135,  39, 123,   5,  49, 127, 107, 200,  34,  14,
        153, 239, 134,  19, 248, 162,  58, 201, 159, 198, 243, 158,  72,   5, 138, 184,
        222, 200,  34, 141, 233,  40, 195, 238, 191, 122, 171,  32,  66, 254, 229, 197
    ];
    var gradientBuffer = new Uint8Array(gradientData);
    var gradientTex = new THREE.DataTexture(gradientBuffer, 256, 1,
                                            THREE.LuminanceFormat,
                                            THREE.UnsignedByteType,
                                            THREE.UVMapping,
                                            THREE.RepeatWrapping, THREE.RepeatWrapping,
                                            THREE.NearestFilter, THREE.NearestFilter, 0);

    gradientTex.generateMipmaps = false;
    gradientTex.flipY = false;
    gradientTex.needsUpdate = true;

    var perm = function (x) {
        return permutation[x % 256];
    };

    var perm2D = new Array(256 * 256 * 4);
    var A, AA, AB, B, BA, BB, index, x;
    for (var y = 0; y < 256; ++y)
        for (x = 0; x < 256; ++x) {
            A = perm(x) + y;
            AA = perm(A);
            AB = perm(A + 1);
            B = perm(x + 1) + y;
            BA = perm(B);
            BB = perm(B + 1);

            // Store (AA, AB, BA, BB) in pixel (x,y)
            index = 4 * (y * 256 + x);
            perm2D[index] = AA;
            perm2D[index + 1] = AB;
            perm2D[index + 2] = BA;
            perm2D[index + 3] = BB;
        }
    var perm2DBuffer = new Uint8Array(perm2D);
    var perm2DTex = new THREE.DataTexture(perm2DBuffer, 256, 256,
                                            THREE.RGBAFormat,
                                            THREE.UnsignedByteType,
                                            THREE.UVMapping,
                                            THREE.RepeatWrapping, THREE.RepeatWrapping,
                                            THREE.NearestFilter, THREE.NearestFilter, 0);
    perm2DTex.generateMipmaps = false;
    perm2DTex.flipY = false;
    perm2DTex.needsUpdate = true;

    var gradients3D = [
        1,1,0,    -1,1,0,    1,-1,0,    -1,-1,0,
        1,0,1,    -1,0,1,    1,0,-1,    -1,0,-1,
        0,1,1,    0,-1,1,    0,1,-1,    0,-1,-1,
        1,1,0,    0,-1,1,    -1,1,0,    0,-1,-1
    ];
    var permGrad = new Array(1024);
    for (x = 0; x < 256; ++x) {
        var i = permutation[x] % 16;
        // Convert the gradient to signed-normalized int.
        permGrad[x * 4] = gradients3D[i * 3] * 127 + 128;
        permGrad[x * 4 + 1] = gradients3D[i * 3 + 1] * 127 + 128;
        permGrad[x * 4 + 2] = gradients3D[i * 3 + 2] * 127 + 128;
        permGrad[x * 4 + 3] = 0;
    }
    var permGradBuffer = new Uint8Array(permGrad);
    var permGradTex = new THREE.DataTexture(permGradBuffer, 256, 1,
                                            THREE.RGBAFormat,
                                            THREE.UnsignedByteType,
                                            THREE.UVMapping,
                                            THREE.RepeatWrapping, THREE.RepeatWrapping,
                                            THREE.NearestFilter, THREE.NearestFilter, 0);
    permGradTex.generateMipmaps = false;
    permGradTex.flipY = false;
    permGradTex.needsUpdate = true;

    PrismWoodTexture = {
        permutation: permutationTex,
        gradient: gradientTex,
        perm2D: perm2DTex,
        permGrad: permGradTex
    };
}

function parseWoodMap(tm, props, name) {
    tm[name + "_enable"] = parseMaterialGeneric(props, "booleans", name + "_enable", 0);
    var prof = parseWoodProfile(props, "scalars", name + "_prof");
    tm[name + "_bands"] = prof.bands;
    tm[name + "_weights"] = prof.weights;
    tm[name + "_frequencies"] = prof.frequencies;
}



function convertMaterial(matObj, isPrism) {

    var innerMats = matObj["materials"];
    var innerMat = innerMats[matObj["userassets"][0]];
    var props = innerMat["properties"];

    var tm = isPrism ? avp.createPrismMaterial() : new THREE.MeshPhongMaterial();
    var map, texProps;
    tm.proteinMat = matObj;
    tm.packedNormals = true;

    if (innerMat && isPrism) {
        tm.tag = innerMat["tag"];
        tm.prismType = innerMat["definition"];
        if (tm.prismType === undefined)
            tm.prismType = "";

        var mapList = tm.mapList;

        tm.transparent = false;
        tm.envExponentMin = 1.0;
        tm.envExponentMax = 512.0;
        tm.envExponentCount = 10.0;

		// among other things, set up mapList and note what map, if any, is attached to each property such as "surface_albedo".
        tm.surface_albedo = SRGBToLinear(parseMaterialColor(props, "surface_albedo", new THREE.Color(1, 0, 0)));
        mapList.surface_albedo_map = parseMaterialGenericConnection(props, "colors", "surface_albedo", null);

        tm.surface_anisotropy = parseMaterialGeneric(props, "scalars", "surface_anisotropy", 0);
        mapList.surface_anisotropy_map = parseMaterialGenericConnection(props, "scalars", "surface_anisotropy", null);

        tm.surface_rotation = parseMaterialGeneric(props, "scalars", "surface_rotation", 0);
        mapList.surface_rotation_map = parseMaterialGenericConnection(props, "scalars", "surface_rotation", null);

        tm.surface_roughness = parseMaterialGeneric(props, "scalars", "surface_roughness", 0);
        mapList.surface_roughness_map = parseMaterialGenericConnection(props, "scalars", "surface_roughness", null);

        mapList.surface_cutout_map = parseMaterialGenericConnection(props, "textures", "surface_cutout", null);
        mapList.surface_normal_map = parseMaterialGenericConnection(props, "textures", "surface_normal", null);

        switch (tm.prismType) {
            case 'PrismOpaque':
                tm.opaque_albedo = SRGBToLinear(parseMaterialColor(props, "opaque_albedo", new THREE.Color(1, 0, 0)));
                mapList.opaque_albedo_map = parseMaterialGenericConnection(props, "colors", "opaque_albedo", null);

                tm.opaque_luminance_modifier = SRGBToLinear(parseMaterialColor(props, "opaque_luminance_modifier", new THREE.Color(0, 0, 0)));
                mapList.opaque_luminance_modifier_map = parseMaterialGenericConnection(props, "colors", "opaque_luminance_modifier", null);

                tm.opaque_f0 = parseMaterialGeneric(props, "scalars", "opaque_f0", 0);
                mapList.opaque_f0_map = parseMaterialGenericConnection(props, "scalars", "opaque_f0", null);

                tm.opaque_luminance = parseMaterialGeneric(props, "scalars", "opaque_luminance", 0);

                break;
            case 'PrismMetal':
                tm.metal_f0 = SRGBToLinear(parseMaterialColor(props, "metal_f0", new THREE.Color(1, 0, 0)));
                mapList.metal_f0_map = parseMaterialGenericConnection(props, "colors", "metal_f0", null);

                break;
            case 'PrismLayered':
                tm.layered_bottom_f0 = SRGBToLinear(parseMaterialColor(props, "layered_bottom_f0", new THREE.Color(1, 1, 1)));
                mapList.layered_bottom_f0_map = parseMaterialGenericConnection(props, "colors", "layered_bottom_f0", null);

                tm.layered_diffuse = SRGBToLinear(parseMaterialColor(props, "layered_diffuse", new THREE.Color(1, 0, 0)));
                mapList.layered_diffuse_map = parseMaterialGenericConnection(props, "colors", "layered_diffuse", null);

                tm.layered_anisotropy = parseMaterialGeneric(props, "scalars", "layered_anisotropy", 0);
                mapList.layered_anisotropy_map = parseMaterialGenericConnection(props, "scalars", "layered_anisotropy", null);

                tm.layered_f0 = parseMaterialGeneric(props, "scalars", "layered_f0", 0);
                mapList.layered_f0_map = parseMaterialGenericConnection(props, "scalars", "layered_f0", null);

                tm.layered_fraction = parseMaterialGeneric(props, "scalars", "layered_fraction", 0);
                mapList.layered_fraction_map = parseMaterialGenericConnection(props, "scalars", "layered_fraction", null);

                tm.layered_rotation = parseMaterialGeneric(props, "scalars", "layered_rotation", 0);
                mapList.layered_rotation_map = parseMaterialGenericConnection(props, "scalars", "layered_rotation", null);

                tm.layered_roughness = parseMaterialGeneric(props, "scalars", "layered_roughness", 0);
                mapList.layered_roughness_map = parseMaterialGenericConnection(props, "scalars", "layered_roughness", null);

                mapList.layered_normal_map = parseMaterialGenericConnection(props, "textures", "layered_normal", null);

                break;
            case 'PrismTransparent':
                tm.transparent_color = SRGBToLinear(parseMaterialColor(props, "transparent_color", new THREE.Color(1, 0, 0)));

                tm.transparent_distance = parseMaterialGeneric(props, "scalars", "transparent_distance", 0);

                tm.transparent_ior = parseMaterialGeneric(props, "scalars", "transparent_ior", 0);

                tm.transparent = true;

                break;

            case 'PrismWood':
                parseWoodMap(tm, props, "wood_fiber_cosine");

                parseWoodMap(tm, props, "wood_fiber_perlin");
                tm.wood_fiber_perlin_scale_z = parseMaterialGeneric(props, "scalars", "wood_fiber_perlin_scale_z", 0);

                parseWoodMap(tm, props, "wood_growth_perlin");

                tm.wood_latewood_ratio = parseMaterialGeneric(props, "scalars", "wood_latewood_ratio", 0);
                tm.wood_earlywood_sharpness = parseMaterialGeneric(props, "scalars", "wood_earlywood_sharpness", 0);
                tm.wood_latewood_sharpness = parseMaterialGeneric(props, "scalars", "wood_latewood_sharpness", 0);
                tm.wood_ring_thickness = parseMaterialGeneric(props, "scalars", "wood_ring_thickness", 0);

                parseWoodMap(tm, props, "wood_earlycolor_perlin");
                tm.wood_early_color = SRGBToLinear(parseMaterialColor(props, "wood_early_color", new THREE.Color(1, 0, 0)));

                tm.wood_use_manual_late_color = parseMaterialGeneric(props, "booleans", "wood_use_manual_late_color", 0);
                tm.wood_manual_late_color = SRGBToLinear(parseMaterialColor(props, "wood_manual_late_color", new THREE.Color(1, 0, 0)));

                parseWoodMap(tm, props, "wood_latecolor_perlin");
                tm.wood_late_color_power = parseMaterialGeneric(props, "scalars", "wood_late_color_power", 0);

                parseWoodMap(tm, props, "wood_diffuse_perlin");
                tm.wood_diffuse_perlin_scale_z = parseMaterialGeneric(props, "scalars", "wood_diffuse_perlin_scale_z", 0);

                tm.wood_use_pores = parseMaterialGeneric(props, "booleans", "wood_use_pores", 0);
                tm.wood_pore_type = parseMaterialGeneric(props, "choicelists", "wood_pore_type", 0);
                tm.wood_pore_radius = parseMaterialGeneric(props, "scalars", "wood_pore_radius", 0);
                tm.wood_pore_cell_dim = parseMaterialGeneric(props, "scalars", "wood_pore_cell_dim", 0);
                tm.wood_pore_color_power = parseMaterialGeneric(props, "scalars", "wood_pore_color_power", 0);
                tm.wood_pore_depth = parseMaterialGeneric(props, "scalars", "wood_pore_depth", 0);

                tm.wood_use_rays = parseMaterialGeneric(props, "booleans", "wood_use_rays", 0);
                tm.wood_ray_color_power = parseMaterialGeneric(props, "scalars", "wood_ray_color_power", 0);
                tm.wood_ray_seg_length_z = parseMaterialGeneric(props, "scalars", "wood_ray_seg_length_z", 0);
                tm.wood_ray_num_slices = parseMaterialGeneric(props, "integers", "wood_ray_num_slices", 0);
                tm.wood_ray_ellipse_z2x = parseMaterialGeneric(props, "scalars", "wood_ray_ellipse_z2x", 0);
                tm.wood_ray_ellipse_radius_x = parseMaterialGeneric(props, "scalars", "wood_ray_ellipse_radius_x", 0);

                tm.wood_use_latewood_bump = parseMaterialGeneric(props, "booleans", "wood_use_latewood_bump", 0);
                tm.wood_latewood_bump_depth = parseMaterialGeneric(props, "scalars", "wood_latewood_bump_depth", 0);

                tm.wood_use_groove_roughness = parseMaterialGeneric(props, "booleans", "wood_use_groove_roughness", 0);
                tm.wood_groove_roughness = parseMaterialGeneric(props, "scalars", "wood_groove_roughness", 0);
                tm.wood_diffuse_lobe_weight = parseMaterialGeneric(props, "scalars", "wood_diffuse_lobe_weight", 0);

                tm.transparent = false;

                //Create the wood noise textures. They are used for all wood materials.
                if (!PrismWoodTexture)
                    InitPrism3DWoodTextures();

                tm.uniforms.permutationMap.value = PrismWoodTexture['permutation'];
                tm.uniforms.gradientMap.value = PrismWoodTexture['gradient'];
                tm.uniforms.perm2DMap.value = PrismWoodTexture['perm2D'];
                tm.uniforms.permGradMap.value = PrismWoodTexture['permGrad'];

                break;

            default:
                console.warn('Unknown prism type: ' + tm.prismType);
        }

		// now that the mapList is set up, populate it
        tm.defines = {};
        tm.textureMaps = {};
        for (var p in mapList) {
			// does the map exist? If not, continue on.
            if (!mapList[p])
                continue;

			// the map exists for this property, so set the various values.
            var textureObj = innerMats[mapList[p]];
            texProps = textureObj["properties"];

            var uriType = textureObj["definition"] == "BumpMap" ?
                          "bumpmap_Bitmap" :
                          "unifiedbitmap_Bitmap";

            var uri = texProps["uris"][uriType]["values"][0];
            if (!uri)
                continue;

            map = {
                mapName: p,
                uri: uri,
                textureObj: textureObj,
                isPrism: true
            };
            tm.textureMaps[map.mapName] = map;

			// This array gives the various #defines that are associated with this instance of
			// the PRISM material.
            tm.defines["USE_" + p.toUpperCase()] = "";
        }

        tm.defines[tm.prismType.toUpperCase()] = "";


        return tm;
    }
    else if (innerMat && !isPrism && innerMat["definition"] == "SimplePhong") {

        tm.tag = innerMat["tag"];
        tm.proteinType = innerMat["proteinType"];
        if (tm.proteinType === undefined)
            tm.proteinType = null;

        var a = tm.ambient =  parseMaterialColor(props, "generic_ambient");
        var d = tm.color =    parseMaterialColor(props, "generic_diffuse");
        var s = tm.specular = parseMaterialColor(props, "generic_specular");
        var e = tm.emissive = parseMaterialColor(props, "generic_emissive");

        //If the material is completely black, use a default material.
        if (  d.r === 0 && d.g === 0 && d.b === 0 &&
            s.r === 0 && s.g === 0 && s.b === 0 &&
            a.r === 0 && a.g === 0 && a.b === 0 &&
            e.r === 0 && e.g === 0 && e.b === 0)
            d.r = d.g = d.b = 0.4;

        tm.shininess = parseMaterialScalar(props, "generic_glossiness", 30);
        tm.opacity = 1.0 - parseMaterialScalar(props, "generic_transparency", 0);
        tm.reflectivity = parseMaterialScalar(props, "generic_reflectivity_at_0deg", 0);

        var isNormal = parseMaterialBoolean(props, "generic_bump_is_normal");
        var scale = parseMaterialScalar(props, "generic_bump_amount", 0);

        // If cannot read the scale, set the scale to 1 which is the default value for prism and protein.
        if (scale == null)
            scale = 1;

        if (isNormal) {
            if (scale > 1)
                scale = 1;
            tm.normalScale = new THREE.Vector2(scale, scale);
        }
        else {
            if (scale >= 1.0)
                scale = 0.03;
            tm.bumpScale = scale;
        }

        var isMetal = parseMaterialBoolean(props, "generic_is_metal");
        if (isMetal !== undefined)
            tm.metal = isMetal;

        var backfaceCulling = parseMaterialBoolean(props, "generic_backface_cull");
        if (backfaceCulling !== undefined && !backfaceCulling)
            tm.side = THREE.DoubleSide;

        tm.transparent = innerMat["transparent"];

        tm.textureMaps = {};
        var textures = innerMat["textures"];
        for (var texType in textures) {

            map = {};

            map.textureObj = innerMats[ textures[texType]["connections"][0] ];
            texProps = map.textureObj["properties"];

            // Grab URI
            map.uri = texProps["uris"]["unifiedbitmap_Bitmap"]["values"][0];
            if (!map.uri)
                continue;

            // Figure out map name

            if (texType == "generic_diffuse") {
                map.mapName = "map";

                if (!tm.color || (tm.color.r === 0 && tm.color.g === 0 && tm.color.b === 0))
                    tm.color.setRGB(1, 1, 1);
            }
            else if (texType == "generic_bump") {
                if (isNormal)
                    map.mapName = "normalMap";
                else
                    map.mapName = "bumpMap";
            }
            else if (texType == "generic_specular") {
                map.mapName = "specularMap";
            }
            else if (texType == "generic_alpha") {
                map.mapName = "alphaMap";
                tm.transparent = true;
            }
            // Environment maps from SVF turned off since we have better defaults
            // else if (texType == "generic_reflection") {
            //     mapName = "envMap";
            // }
            else {
                // no map name recognized, skip
                continue;
            }

            tm.textureMaps[map.mapName] = map;
        }

    }
    else {
        // unknown material, use default colors
        tm.ambient = 0x030303;
        tm.color = 0x777777;
        tm.specular = 0x333333;
        tm.shininess = 30;
        tm.shading = THREE.SmoothShading;
    }

    return tm;
}



function convertPrismTexture(textureObj, texture, sceneUnit) {

    var texProps = textureObj["properties"];

	// Note that the format of these booleans is different for Protein than for regular materials:
	// Prism: "texture_URepeat": { "values": [ false ] },
	// simple texture: "texture_URepeat":    false,
    texture.clampS = !parseMaterialGeneric(texProps, "booleans", "texture_URepeat", false);
    texture.clampT = !parseMaterialGeneric(texProps, "booleans", "texture_VRepeat", false);
    texture.wrapS = !texture.clampS ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
    texture.wrapT = !texture.clampT ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;

    texture.matrix = Get2DMapTransform(texProps, sceneUnit);

    if (textureObj["definition"] == "UnifiedBitmap") {
        texture.invert = parseMaterialGeneric(texProps, "booleans", "unifiedbitmap_Invert", false);
    }

    if (textureObj["definition"] == "BumpMap") {
        texture.bumpmapType = parseMaterialGeneric(texProps, "choicelists", "bumpmap_Type", 0);
        texture.bumpScale = GetBumpScale(texProps, texture.bumpmapType, sceneUnit);
    }

}

function convertSimpleTexture(textureObj, texture) {

    var texProps = textureObj["properties"];

	// Note that the format of these booleans is different for Protein than for regular materials:
	// Prism: "texture_URepeat": { "values": [ false ] },
	// simple texture: "texture_URepeat":    false,
    texture.invert = parseMaterialBoolean(texProps, "unifiedbitmap_Invert");
    texture.clampS = !parseMaterialBoolean(texProps, "texture_URepeat", true);  // defaults to wrap
    texture.clampT = !parseMaterialBoolean(texProps, "texture_VRepeat", true);
    texture.wrapS = !texture.clampS ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
    texture.wrapT = !texture.clampT ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;

    var uscale = parseMaterialScalar(texProps, "texture_UScale", 1);
    var vscale = parseMaterialScalar(texProps, "texture_VScale", 1);
    var uoffset = parseMaterialScalar(texProps, "texture_UOffset", 0);
    var voffset = parseMaterialScalar(texProps, "texture_VOffset", 0);
    var wangle = parseMaterialScalar(texProps, "texture_WAngle", 0);

    texture.matrix = { elements:[
        Math.cos(wangle) * uscale, Math.sin(wangle) * vscale, 0,
       -Math.sin(wangle) * uscale, Math.cos(wangle) * vscale, 0,
        uoffset, voffset, 1
    ]};
}

function convertTexture(textureObj, texture, sceneUnit, isPrism) {
    if (isPrism)
        convertPrismTexture(textureObj, texture, sceneUnit);
    else
        convertSimpleTexture(textureObj, texture);
}


function isPrismMaterial(material) {
    var innerMats = material['materials'];
    var innerMat = innerMats[material['userassets'][0]];
    if (innerMat) {
        var definition = innerMat['definition'];
        return definition == 'PrismLayered' ||
            definition == 'PrismMetal' ||
            definition == 'PrismOpaque' ||
            definition == 'PrismTransparent' ||
            definition == 'PrismWood';
    }
    return false;
}


avp.MaterialConverter = {
	convertMaterial: convertMaterial,
    convertTexture: convertTexture,
    isPrismMaterial: isPrismMaterial
};

})();;
(function() {
	'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

function loadTextureWithSecurity(path, mapping, callback) {

    if (auth) {
        // TODO: We should actually ALSO consider the case where texture is being loaded from
        // the same domain as the SVF being served. With such a change, we will be taking into
        // account developers exposing SVF's through their own proxy servers.
        var useCredentials = path.indexOf('://') === -1 ||
            path.indexOf(window.location.host) !== -1 ||
            avp.urlIsApiViewingOrDev(path);

        if (useCredentials) { //if you're sending to your own host or to autodesk views and data api, then use credentials
            THREE.ImageUtils.crossOrigin = 'use-credentials';
        } else { //otherwise do not
            THREE.ImageUtils.crossOrigin = 'anonymous';
        }
    }

    var index = path.indexOf('urn:');
    if (index != -1) {
        path = path.substr(0, index) + encodeURIComponent(path.substr(index));
        path += "?domain=" + encodeURIComponent(window.location.origin);
        if (Autodesk.Viewing.ACM_SESSION_ID)
            path += "&acmsession=" + Autodesk.Viewing.ACM_SESSION_ID;
    }

    // If the textures are stored on OSS, directly stream it from OSS instead of going through items API.
    var ossPrefix = "urn:adsk.objects:os.object:";
    var decodedPath = decodeURIComponent(path);
    var ossIndex = decodedPath.indexOf(ossPrefix);
    if (ossIndex !== -1) {
        var ossPath = decodedPath.substr(ossIndex + ossPrefix.length);
        var bucket = ossPath.substr(0, ossPath.indexOf("/"));
        var object = ossPath.substr(ossPath.indexOf("/") + 1);
        // Extract query string, encode the rest of the URL, then append the query string.
        // Otherwise, the encoded query string would confuse OSS.
        var queryStringIndex = object.indexOf('?');
        if (queryStringIndex !== -1) {
            object = encodeURIComponent(object.substr(0, queryStringIndex)) + object.substr(queryStringIndex);
        }
        path = OSS_URL + "/buckets/" + bucket + "/objects/" + object;
    }

    if (path.slice(path.length-4).toLocaleLowerCase() === ".dds")
        return new THREE.DDSLoader().load(path, callback);
    else if (!LMV_THIRD_PARTY_COOKIE && useCredentials)
        return loadTextureWithToken(path, mapping, callback);
    else
        return THREE.ImageUtils.loadTexture(path, mapping, callback);
}

// For texture loading, three.js expects loadable URL for the image.
// When we put the token in request header instead of cookie, we need AJAX the
// texture and base64 encode it to create a data URI and feed it to three.js.
function loadTextureWithToken(path, mapping, callback) {

    var texture = new THREE.Texture( undefined, mapping );

    var options = { headers : av.HTTP_REQUEST_HEADERS, withCredentials : !!auth, responseType : "arraybuffer" };

    function onSuccess(data) {
        return loadTextureBinary(data, texture, callback);
    }

    function onFailure(statusCode, statusText, data) {
        var errorMsg = "Error: " + statusCode + " (" + statusText + ")";
        console.log(errorMsg);
    }

    avp.ViewingService.get(VIEWING_URL, 'items', path, onSuccess, onFailure, options);

    return texture;
}

function loadTextureBinary( data, texture, callback ) {

    function arrayBufferToDataUri( buffer ) {
        var binary = '';
        var bytes = new Uint8Array( buffer );
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++) {
            binary += String.fromCharCode( bytes[ i ] );
        }

        var uri = "data:image/jpeg;base64," + window.btoa( binary );
        return uri;
    }

    var image = new Image();
    texture.image = image;

    image.onload = function () {
        texture.needsUpdate = true;
        if ( callback ) callback( texture );
    };
    image.onerror = function (e) {
        console.log("Error!!!" + e);
    };

    image.src = arrayBufferToDataUri(data);

}

function resizeImage(img) {

    var ow = img.width;
    var oh = img.height;

    //It's a power of two already
    if ( ((ow & (ow - 1)) === 0) && ((oh & (oh - 1)) === 0)) {
        return img;
    }

    var w = 1; while (w*2 < ow) w*=2;
    var h = 1; while (h*2 < oh) h*=2;

    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    canvas.width = w;
    canvas.height = h;

    ctx.drawImage(img, 0, 0, w, h);

    return canvas;

}






/** @constructor */
function MaterialManager(viewer)
{
    this.viewer = viewer;
    var _this = this;

    var _materials = this.materials = {};
    var _materialsNonHDR = this.materialsNonHDR = {};
    this.textures = {};
    this.layerMaskTex = null;
    this.reflectionCube = null;
    this.irradianceMap = null;
    var _envMapExposure = 1;
    var _envRotationSin = 0.0;
    var _envRotationCos = 1.0;
    var _texturesToUpdate = [];
    this.hasPrism = false;
    this.renderPrism = true; //matches the default preferences setting

    // cutplanes array where all materials refer to
    var _cutplanes = [];

    this.defaultMaterial = new THREE.MeshPhongMaterial({
                    ambient: 0x030303,
                    color: 0x777777,
                    specular: 0x333333,
                    shininess: 30,
                    shading: THREE.SmoothShading,
                    reflectivity: 0
                });


    function is2dMaterial(name) {
        return name.indexOf("__lineMaterial__") != -1;
    }


    function getMaterialHash(svf, name) {

        if (is2dMaterial(name))
            return name;

        //In the Protein file, the materials have unhelpful names
        //like 0, 1, 2, so we prefix them with the SVF path to make them unique
        return svf.basePath + "|mat|" + name;
    }


    this.dtor = function() {

        this.cleanup();
        THREE.Cache.clear();
        this.viewer = null;
        _this = null;

    };


    this.findMaterial = function(model, name) {
        var mat = _materials[getMaterialHash(model, name)];

        //It's not expected that the material is null here, but in case
        //it is, warn and pick the first one available.
        if (!mat) {
            stderr("Unknown material " + name + ". Using default.");
            mat = this.defaultMaterial;
        }

        return mat;
    };

    this.setRenderPrism = function (value) {
        this.renderPrism = value;
    };

    // Convert from LMV materials json to THREE.js materials
    this.convertMaterials = function (svf) {
        if (!svf.materials) {
            return 0;
        }

        // get outer Protein materials block
        var prmats = svf.materials["materials"];
        var prismmats = svf.proteinMaterials ? svf.proteinMaterials["materials"] : null;
        var _renderPrism = this.renderPrism;
        var totalAdded = 0;

        for (var p in prmats) {

            var isPrism = false;

            if (prismmats) {
                isPrism = _renderPrism && avp.MaterialConverter.isPrismMaterial(prismmats[p]);
            }

            //If the definition is prism, use the prism object.
            var matObj = isPrism ? prismmats[p] : prmats[p];

            var phongMat = avp.MaterialConverter.convertMaterial(matObj, isPrism);

            // TODO: do we want to check the global flag or drop that and rely on material only?
            if (!av.isIE11 && svf.doubleSided)
                phongMat.side = THREE.DoubleSide;

            var matName = getMaterialHash(svf, p);
            this.addMaterial(matName, phongMat, isPrism);
            totalAdded++;

            // Process decals
            if (matObj.decals) {
                phongMat.decals = [];
                for (var di = 0, dlen = matObj.decals.length; di < dlen; di++) {
                    var decal = matObj.decals[di];
                    isPrism = _renderPrism && avp.MaterialConverter.isPrismMaterial(decal.material);
                    var material = avp.MaterialConverter.convertMaterial(decal.material, isPrism);
                    phongMat.decals.push({
                        uv: decal.uv || 0,
                        material: material
                    });
                    this.addMaterial(matName + '|decal|' + di, material, isPrism);
                }
            }
        }

        return totalAdded;
    };

    //Called at the beginning of every frame, to perform pending
    //operations like texture updates. This function also
    //has a chance to request full repaint at that time.
    this.updateMaterials = function() {

        while(_texturesToUpdate.length)
        {
            var def = _texturesToUpdate.pop();
            for (var j=0; j<def.mats.length; j++) {
                def.mats[j][def.slot] = def.tex;
                def.mats[j].needsUpdate = true;

                //If we knew that there are no transparent materials in the scene,
                //we could just do a needsRender here instead of needsClear, to avoid flashing the model
                //while loading textures.
                this.viewer.invalidate(true/*clear*/, false/*render*/, false/*overlay*/);
            }
        }

    };



    this.loadTexture = function(material, svf) {
        if (!material.textureMaps)
            return;

        //NODE
        if (typeof document === "undefined")
            return;

        // iterate and parse textures from ugly JSON
        // for each texture type in material
        //   if has URI and valid mapName
        //     load and initialize that texture
        var textures = material.textureMaps;
        for (var mapName in textures) {

            var map = textures[mapName];

            //TODO : It's possible that a texture is used as bitmap and bumpmap. In this situation,
            //if the bitmap is loaded first, the bumpscale won't be updated. To fix this, I added the
            //definition as part of the key. This is a easy fix but will make the texture loaded twice.
            //Ideally, we need to improve the current cache to save the texture properties like matrix,
            //invert flag, separately, because a texture can be used in many places and each of them can
            //have different properties.
            var texName = svf.basePath + map.uri + map.mapName/*this is the TODO above*/;

            var texEntry = _this.textures[texName];
            if (texEntry) {
                //Is texture already loaded, then update the material immediately?
                if (texEntry.tex) {
                    material[map.mapName] = texEntry.tex;
                    material.needsUpdate = true;
                } else {
                    _this.textures[texName].mats.push(material);
                    _this.textures[texName].slots.push(map.mapName);
                }
            } else {
                var texPath = null;

                //Of course, Prism uses a different CDN endpoint from Protein, so
                //we have to distinguish between the two...
                var isProteinMat = material.proteinType && material.proteinType.length;
                var isPrism = isProteinMat && (material.proteinType.indexOf("Prism") === 0);

                var isSharedTexture = (isPrism && PRISM_ROOT || isProteinMat && PROTEIN_ROOT) &&
                    (map.uri.indexOf("1/Mats") === 0 || map.uri.indexOf("2/Mats") === 0 || map.uri.indexOf("3/Mats") === 0);

                if (isSharedTexture) {
                    if (isPrism) {
                        texPath = PRISM_ROOT + map.uri;
                    } else {
                        texPath = PROTEIN_ROOT + map.uri;
                    }
                } else {

                    for(var j=0; j<svf.manifest.assets.length; ++j)
                    {
                        var asset = svf.manifest.assets[j];
                        if(asset.id == map.uri) {
                            texPath = avp.pathToURL(svf.basePath + asset.URI);
                            break;
                        }
                    }

                    if(!texPath) {
                        texPath = avp.pathToURL(svf.basePath + map.uri);
                    }
                }

                _this.textures[texName] = { mats: [material], slots: [map.mapName], tex: null };

                //Annoying closure to capture the mutable loop variable texName for
                //use in the load callback
                var texture = (function(textureName, texturePath) {
                    return loadTextureWithSecurity(texturePath, THREE.UVMapping, function (tex) {

                        //It's possible MaterialManager got destroyed before the texture loads
                        if (!_this)
                            return;

                        tex.image = resizeImage(tex.image);

                        //Texture loaded successfully
                        var def = _this.textures[textureName];

                        //If the model was unloaded before the texture loaded,
                        //the texture def will no longer exist.
                        if (!def)
                            return;

                        if (!def.tex)
                            def.tex = tex;

                        //Set it on all materials that use it
                        for (var i = 0; i < def.mats.length; i++)
                            def.mats[i][def.slots[i]] = tex;

                        //Keep track of materials that need updating on the
                        //next frame. We can use this to throttle texture GPU upload
                        _texturesToUpdate.push(def);
                    });
                })(texName, texPath);

                if (map.mapName == "bumpMap" || map.mapName == "normalMap") {
                    texture.anisotropy = 0;
                }
                else {
                    texture.anisotropy = this.viewer.renderer().getMaxAnisotropy();
                }

                // default params
                texture.flipY = true;
                texture.invert = false;
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;

                // extract / construct texture params from JSON
                avp.MaterialConverter.convertTexture(map.textureObj, texture, svf.materials.scene.SceneUnit, map.isPrism);
            }
        }
    };


    //Textures delayed until all geometry is loaded,
    //hence not done in convertMaterials
    this.loadTextures = function(svf) {
        for (var p in _materials) {

            //Prevent textures for already loaded models from being loaded
            //again. Not elegant, and we can somehow only process the materials
            //per model.
            if (p.indexOf(svf.basePath) == -1)
                continue;

            var material = _materials[p];
            this.loadTexture(material, svf);
        }
    };


    this.create2DMaterial = function(svf, material, isIdMaterial, isSelectionMaterial) {

        //Create a hash string of the material to see if we have
        //already created it
        var hash = "__lineMaterial__";
        if (material.image)
            hash += "|image:" + material.image.name;
        if (material.clip)
            hash += "|clip:" + JSON.stringify(material.clip);
        if (isIdMaterial)
            hash += "|id";
        if (isSelectionMaterial)
            hash += "|selection";
        if (material.skipEllipticals)
            hash += "|skipEllipticals";
        if (material.skipCircles)
            hash += "|skipCircles";
        if (material.skipTriangleGeoms)
            hash += "|skipTriangleGeoms";
        if (material.useInstancing)
            hash += "|useInstancing";
        if (svf)
            hash += "|" + svf ? svf.basePath : "runtime";

        hash = getMaterialHash(null, hash);

        if (!_materials.hasOwnProperty(hash))
        {
            var avs = Autodesk.Viewing.Shaders;
            var lineMaterial = new THREE.ShaderMaterial(
                {
                    fragmentShader: avs.LineShader.fragmentShader,
                    vertexShader: avs.LineShader.vertexShader,
                    uniforms: THREE.UniformsUtils.clone( avs.LineShader.uniforms ),
                    attributes: avs.LineShader.attributes,
                    defines: THREE.UniformsUtils.clone(avs.LineShader.defines),
                    transparent: true
                }
            );

            lineMaterial.depthWrite = false;
            lineMaterial.depthTest = false;
            lineMaterial.side = THREE.DoubleSide;
            lineMaterial.blending = THREE.NormalBlending;

            if (isIdMaterial) {
                //Is the caller requesting the special case of
                //shader that outputs just IDs (needed when MRT not available)?
                lineMaterial.defines["ID_COLOR"] = 1;
                lineMaterial.blending = THREE.NoBlending;
            }
            else if (isSelectionMaterial) {
                lineMaterial.defines["SELECTION_RENDERER"] = 1;
                lineMaterial.uniforms["selectionColor"].value = new THREE.Vector4(0, 0, 1, 1);
            }
            else if (this.viewer.renderer().hasMRT()){
                //If the renderer can do MRT, enable it in the shader
                //so we don't have to draw the ID buffer separately.
                lineMaterial.mrtIdBuffer = 1;
            }

            if (!material.skipEllipticals) {
                lineMaterial.defines["HAS_ELLIPTICALS"] = 1;
            }

            if (!material.skipCircles) {
                lineMaterial.defines["HAS_CIRCLES"] = 1;
            }

            if (!material.skipTriangleGeoms) {
                lineMaterial.defines["HAS_TRIANGLE_GEOMS"] = 1;
            }

            if (material.useInstancing) {
                lineMaterial.defines["USE_INSTANCING"] = 1;
            }

            if (this.layerMaskTex) {
                lineMaterial.defines["HAS_LAYERS"] = 1;
                lineMaterial.uniforms["tLayerMask"].value = _this.layerMaskTex;
            }

            if (this.lineStyleTex) {
                lineMaterial.defines["HAS_LINESTYLES"] = 1;
                lineMaterial.defines["MAX_LINESTYLE_LENGTH"] = _this.lineStyleTex.image.width;
                lineMaterial.uniforms["tLineStyle"].value = _this.lineStyleTex;
                lineMaterial.uniforms["vLineStyleTexSize"].value.set(_this.lineStyleTex.image.width, _this.lineStyleTex.image.height);
            }

            if (material.image) {

                var scope = this;

                var onTexLoad = function(texture) {

                    //Possibly, viewer was destroyed before texture load completed.
                    if (!scope.viewer)
                        return;

                    texture.image = resizeImage(texture.image);

                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.minFilter = THREE.LinearMipMapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = 1;//this.viewer.renderer().getMaxAnisotropy();
                    texture.flipY = true;
                    texture.generateMipmaps = true;

                    texture.needsUpdate = true;

                    lineMaterial.defines["HAS_RASTER_QUADS"] = 1;
                    lineMaterial.uniforms["tRaster"].value = texture;
                    if (material.image.dataURI.indexOf("png") != -1)
                        lineMaterial.transparent = true;
                    lineMaterial.needsUpdate = true;
                    scope.viewer.invalidate(false, true, false);
                };

                loadTextureWithSecurity(material.image.dataURI, THREE.UVMapping, onTexLoad);
            }

            lineMaterial.modelScale = material.modelScale || 1;

            _materials[hash] = lineMaterial;
        }

        return hash;
    };


    //TODO: unify this logic with inittMaterials
    this.addMaterial = function(name, mat, skipHeuristics) {

        //Using post-gamma luminance, since input colors are assumed to
        //have gamma (non-linearized).
        function luminance(c) {
            return (0.299 * c.r) + (0.587 * c.g) + (0.114 * c.b);
        }

        var proteinMaterial = mat.proteinMat ? mat.proteinMat : null;
        var isPrism = (mat.proteinType && mat.proteinType.indexOf("Prism") != -1);

        this.hasPrism = isPrism || this.hasPrism;

        //apply various modifications to fit our rendering pipeline
        if (!skipHeuristics){

            //This pile of crazy hacks maps the various flavors of materials
            //to the shader parameters that we can handle.

            if (mat.metal) {

                if (!mat.reflectivity) {
                    mat.reflectivity = luminance(mat.specular);
                }

                //Special handling for Protein and Prism metals
                if (proteinMaterial)
                {
                    //For Prism metals, reflectivity is set to 1 and
                    //the magnitude of the specular component acts
                    //as reflectivity.
                    if (mat.reflectivity === 1)
                        mat.reflectivity = luminance(mat.specular);

                    if (mat.color.r === 0 && mat.color.g === 0 && mat.color.b === 0) {
                        //Prism metals have no diffuse at all, but we need a very small
                        //amount of it to look reasonable
                        //mat.color.r = mat.specular.r * 0.1;
                        //mat.color.g = mat.specular.g * 0.1;
                        //mat.color.b = mat.specular.b * 0.1;
                    }
                    else {
                        //For Protein metals, we get a diffuse that is full powered, so we
                        //scale it down
                        mat.color.r *= 0.1;
                        mat.color.g *= 0.1;
                        mat.color.b *= 0.1;
                    }
                }
            }
            else {
                //Non-metal materials

                if (isPrism)
                {
                    var isMetallic = false;

                    if (mat.proteinType == "PrismLayered")
                    {
                        //For layered materials, the Prism->Simple translator
                        //stores something other than reflectivity in the
                        //reflectivity term. We also do special handling
                        //for paint clearcoat, and metallic paint. Longer term,
                        //the good solution is to add things we do support to the Simple
                        //representation, or failing that, support native Prism definitions.
                        mat.clearcoat = true;
                        mat.reflectivity = 0.06;

                        if (proteinMaterial) {
                            var matDef = proteinMaterial["materials"][proteinMaterial["userassets"][0]];
                            var cats = matDef.categories;
                            if (cats && cats.length && cats[0].indexOf("Metal") != -1)
                            {
                                isMetallic = true;
                            }
                        }
                    }

                    //De-linearize this value in case of Prism, since there it
                    //seems to be physical (unlike the color values)
                    mat.reflectivity = Math.sqrt(mat.reflectivity);

                    if (isMetallic)
                    {
                        //metallic paint has specular = diffuse in Prism.
                        mat.specular.copy(mat.color);
                    }
                    else
                    {
                        //Prism non-metals just leave the specular term as 1,
                        //relying on reflectivity alone, but our shader needs
                        //both in different code paths.
                        mat.specular.r = mat.reflectivity;
                        mat.specular.g = mat.reflectivity;
                        mat.specular.b = mat.reflectivity;
                    }
                }
                else
                {
                    //Get a reasonable reflectivity value if there isn't any
                    if (!mat.reflectivity) {
                        if (mat.color.r === 1 && mat.color.g === 1 && mat.color.b === 1 &&
                            mat.specular.r === 1 && mat.specular.g === 1 && mat.specular.b === 1 &&
                            (!mat.textureMaps || (!mat.textureMaps.map && !mat.textureMaps.specularMap)))
                        {
                            //This covers specific cases in DWF where metals get diffuse=specular=1.
                            mat.metal = true;
                            mat.reflectivity = 0.7;

                            mat.color.r *= 0.1;
                            mat.color.g *= 0.1;
                            mat.color.b *= 0.1;
                        } else {

                            //General case
                            //For non-metallic materials, reflectivity
                            //varies very little in the range 0.03-0.06 or so
                            //and is never below 0.02.
                            mat.reflectivity = 0.01 + 0.06 * luminance(mat.specular);

                            //For non-metals, reflectivity is either set
                            //correctly or we estimate it above, and the specular color
                            //just carries the hue
                            //Note: Protein (but not Prism) seems to have consistently high reflectivity
                            //values for its non-metals.
                            mat.specular.r *= mat.reflectivity;
                            mat.specular.g *= mat.reflectivity;
                            mat.specular.b *= mat.reflectivity;
                        }

                    } else  if (mat.reflectivity > 0.3) {
                        //If reflectivity is set explicitly to a high value, but metal is not, assume
                        //the material is metallic anyway and set specular=diffuse
                        //This covers specific cases in DWF.

                        mat.metal = true;
                        mat.specular.r = mat.color.r;
                        mat.specular.g = mat.color.g;
                        mat.specular.b = mat.color.b;

                        mat.color.r *= 0.1;
                        mat.color.g *= 0.1;
                        mat.color.b *= 0.1;
                    } else {
                        //For non-metals, reflectivity is either set
                        //correctly or we estimate it above, and the specular color
                        //just carries the hue
                        //Note: Protein (but not Prism) seems to have consistently high reflectivity
                        //values for its non-metals.
                        mat.specular.r *= mat.reflectivity;
                        mat.specular.g *= mat.reflectivity;
                        mat.specular.b *= mat.reflectivity;
                    }

                    //For transparent non-layered materials, the reflectivity uniform is
                    //used for scaling the Fresnel reflection at oblique angles
                    //This is a non-physical hack to make stuff like ghosting
                    //look reasonable, while having glass still reflect at oblique angles
                    if (mat.opacity < 1)
                        mat.reflectivity = 1.0;
                }
            }

            //Alpha test for materials with textures that are potentially opacity maps
            if (mat.transparent ||
                (mat.textureMaps && ((mat.textureMaps.map && mat.textureMaps.map.uri.toLowerCase().indexOf(".png") != -1) ||
                                      mat.textureMaps.opacityMap))) {
                mat.alphaTest = 0.01;
            }
        }

        if (mat.textureMaps && mat.textureMaps.normalMap)
        {
            var scale = mat.bumpScale;
            if (scale === undefined || scale >= 1)
                scale = 1;

            mat.normalScale = new THREE.Vector2(scale, scale);
        }
        else
        {
            if (mat.bumpScale === undefined && mat.textureMaps && (mat.textureMaps.map || mat.textureMaps.bumpMap))
                mat.bumpScale = 0.03; //seems like a good subtle default if not given
            else if (mat.bumpScale >= 1) //Protein generic mat sometimes comes with just 1.0 which can't be right...
                mat.bumpScale = 0.03;
        }

        //Blinn to Phong (for blurred environment map sampling)
        mat.shininess *= 0.25;

        if (_this.reflectionCube)
            mat.envMap = _this.reflectionCube;

        if (_this.irradianceMap)
            mat.irradianceMap = _this.irradianceMap;

        mat.exposureBias = Math.pow(2.0, this.viewer.renderer().getExposureBias());
        mat.tonemapOutput = this.viewer.renderer().getToneMapMethod();
        mat.envMapExposure = _envMapExposure;
        mat.envRotationSin = _envRotationSin;
        mat.envRotationCos = _envRotationCos;

        this.viewer.renderer().applyMRTFlags(mat);

        //if (mat.opacity < 1.0 || (mat.textureMaps && mat.textureMaps.opacityMap))
        //    mat.side = THREE.DoubleSide;

        if (mat.side == THREE.DoubleSide)
            this.viewer.renderer().toggleTwoSided(true);

        mat.cutplanes = _cutplanes;

        _materials[name] = mat;
    };

    this.addMaterialNonHDR = function(name, mat) {
        mat.cutplanes = _cutplanes;
        _materialsNonHDR[name] = mat;
    };

    this.togglePolygonOffset = function(state) {

        for (var p in _materials) {
            var mat = _materials[p];
            if (mat instanceof THREE.MeshPhongMaterial) {
                mat.polygonOffset = true;
                mat.polygonOffsetFactor = state ? 1 : 0;
                mat.polygonOffsetUnits = state ? 1 : 0;
                mat.needsUpdate = true;
            }
        }

    };

    //Certain material properties only become available
    //once we see a geometry that uses the material. Here,
    //we modify the material based on a given geometry that's using it.
    this.applyGeometryFlagsToMaterial = function(material, threegeom) {

        if (threegeom.attributes.color) {
            //TODO: Are we likely to get the same
            //material used both with and without vertex colors?
            //If yes, then we need two versions of the material.
            material.vertexColors = THREE.VertexColors;
            material.needsUpdate = true;
        }

        //If we detect a repeating texture in the geometry, we assume
        //it is some kind of material roughness pattern and reuse
        //the texture as a low-perturbation bump map as well.
        if (!material.proteinType && threegeom.attributes.uv && threegeom.attributes.uv.isPattern) {
            if (material.map && !material.bumpMap) {
                material.bumpMap = material.map;
                material.needsUpdate = true;
            }
            if (material.textureMaps && material.textureMaps.map && !material.textureMaps.bumpMap) {
                material.textureMaps.bumpMap = material.textureMaps.map;
                material.needsUpdate = true;
            }
        }

    };

    //Turns MRT rendering on/off in each material's shader
    this.toggleMRTSetting = function() {

        for (var p in _materials) {
            var m = _materials[p];
            if (!is2dMaterial(p))
                this.viewer.renderer().applyMRTFlags(m);
        }

    };

    this.updatePixelScale = function(pixelsPerUnit) {

        var mats = _materials;
        for (var p in mats) {
            if (is2dMaterial(p)) {
                var m = mats[p];
                m.uniforms["aaRange"].value = 0.5 / (pixelsPerUnit * m.modelScale);
                m.uniforms["pixelsPerUnit"].value = (pixelsPerUnit * m.modelScale);
            }
        }

    };

    this.updateViewportId = function(vpId) {

        var mats = _materials;
        for (var p in mats) {
            if (is2dMaterial(p)) {
                var m = mats[p];
                m.uniforms["viewportId"].value = vpId;
                m.needsUpdate = true;
            }
        }

        this.viewer.invalidate(true);
    };

    this.setCubeMapFromColors = function(ctop, cbot) {

        var texture = avp.CreateCubeMapFromColors(ctop, cbot);

        _this.reflectionCube = texture;
        _this.reflectionCube.isBgColor = true;

        for (var p in _materials) {
            var m = _materials[p];
            m.envMap = texture;
            m.needsUpdate = true;
        }

        this.viewer.invalidate(true);

        return _this.reflectionCube;
    };

    this.setCubeMap = function(path, exposure) {

        var self = this;

        var texLoadDone = function(map) {
            if (map) {
                map.mapping = THREE.CubeReflectionMapping;
                map.LogLuv = path.indexOf("logluv") != -1;
                map.RGBM = path.indexOf("rgbm") != -1;

                // TODO: Turn on use of half-float textures for envmaps. Disable due to blackness on Safari.
                avp.DecodeEnvMap(map, exposure, false /*isMobileDevice() ? false : this.viewer.glrenderer().supportsHalfFloatTextures()*/);
            }

            //Case where we use environment from the SVF model
            //Not currently supported all the way through
            //var svf = _this.model ? _this.model.getData() : null;
            //_this.reflectionCube = (map === undefined) && svf ? svf.envMap : map;
            self.reflectionCube = map;

            if (self.reflectionCube)
            {
                for (var p in _materials) {
                    var m = _materials[p];
                    m.envMap = _this.reflectionCube;
                    m.needsUpdate = true;
                }
            }
            else
            {
                self.setCubeMapFromColors(self.viewer.clearColorTop, self.viewer.clearColorBottom);
            }

            self.viewer.invalidate(true);
        };

        if (Array.isArray(path)) {
             this.reflectionCube = THREE.ImageUtils.loadTextureCube(path, THREE.CubeReflectionMapping, texLoadDone);
             this.reflectionCube.format = THREE.RGBFormat;
        }
        else if (typeof path == "string") {
            if (path.toLowerCase().indexOf(".dds") != -1) {
                this.reflectionCube = new THREE.DDSLoader().load(path, texLoadDone);
            }
            else {
                this.reflectionCube = THREE.ImageUtils.loadTexture(path, THREE.SphericalReflectionMapping, texLoadDone);
                this.reflectionCube.format = THREE.RGBFormat;
            }
        } else if (path) {
            //here we assume path is already a texture object
            texLoadDone(path);
        }
        else {
            texLoadDone(null);
        }

        return self.reflectionCube;
    };


    this.setIrradianceMap = function(path, exposure) {

        var self = this;
        var texLoadDone = function(map) {
			var p,m;
            if (map)
            {
                map.mapping = THREE.CubeReflectionMapping;
                map.LogLuv = path.indexOf("logluv") != -1;
                map.RGBM = path.indexOf("rgbm") != -1;

                // TODO: Turn on use of half-float textures for envmaps. Disable due to blackness on Safari.
                avp.DecodeEnvMap(map, exposure, false /*isMobileDevice() ? false : this.viewer.glrenderer().supportsHalfFloatTextures()*/);

                for (p in _materials) {
                    m = _materials[p];
                    m.irradianceMap = map;
                    m.needsUpdate = true;
                }

                self.irradianceMap = map;
            }
            else
            {
                if (self.irradianceMap)
                {
                    for (p in _materials) {
                        m = _materials[p];
                        m.irradianceMap = null;
                        m.needsUpdate = true;
                    }

                    self.irradianceMap = null;
                }
            }

            self.viewer.invalidate(true);
        };

        THREE.ImageUtils.crossOrigin = "";

        if (Array.isArray(path)) {
             _this.irradianceMap = THREE.ImageUtils.loadTextureCube(path, THREE.CubeReflectionMapping, texLoadDone);
             _this.irradianceMap.format = THREE.RGBFormat;
        }
        else if (typeof path == "string") {
            if (path.toLowerCase().indexOf(".dds") != -1) {
                _this.irradianceMap = new THREE.DDSLoader().load(path, texLoadDone);
            }
        } else if (path) {
            //here we assume path is already a texture object
            texLoadDone(path);
        }
        else {
            texLoadDone(null);
        }

        return self.irradianceMap;
    };


    this.setTonemapMethod = function(method) {

        for (var p in _materials) {
            var m = _materials[p];
            m.tonemapOutput = method;
            m.needsUpdate = true;
        }

    };

    /**
     * An additional multiplier of 2^envExposure will be applied
     * to the environment map intensities, in case RGBM environment map is used.
     */
    this.setEnvExposure = function(envExposure) {

        var scale = Math.pow(2.0, envExposure);
        _envMapExposure = scale;

        for (var p in _materials) {
            var m = _materials[p];
            m.envMapExposure = scale;
            m.needsUpdate = true;
        }

    };

    /*
     * Adjust orientation of the environment.
     * @param rotation Relative angle in radians (-Pi..Pi).
     */
    this.setEnvRotation = function(rotation) {
        _envRotationSin = Math.sin(rotation);
        _envRotationCos = Math.cos(rotation);
        for (var p in _materials) {
            var m = _materials[p];
            m.envRotationSin = _envRotationSin;
            m.envRotationCos = _envRotationCos;
            m.needsUpdate = true;
        }
    };

    /**
     * Exposure correction of 2^exposureBias applied to rendered output color before passing into
     * the tone mapper.
     */
    this.setTonemapExposureBias = function(exposureBias) {

        var bias = Math.pow(2.0, exposureBias);

        for (var p in _materials) {
            var m = _materials[p];
            m.exposureBias = bias;
            m.needsUpdate = true;
        }

    };


    //Creates a texture where each pixel corresponds to the visibility
    //of a 2D layer. The LineShader samples the texture to determine if
    //a geometry is visible based on its layer visibility.
    this.initLayersTexture = function(model) {

        //TODO: Once arbitrary layer texture size works
        //we can base the allocation size on the layerCount
        var count = model.getData().layerCount;
        var tw = 256;

        //TODO: Currently the shader math is limited to
        //a square 256x256 layers mask, since it just does a
        //scale of the two layer bytes by 1/255. We would need to
        //send the height of the layer texture to do something smarter,
        //or wait for texture size query in WebGL 2.
        //var th = 0 | Math.ceil((layersList.length) / 256.0);
        var th = 256;

        var layerMask = new Uint8Array(tw * th);
        for (var l= 0, lEnd = count; l<lEnd; l++) {
            layerMask[l] = 0xff;
        }

        var layerMaskTex = new THREE.DataTexture(layerMask, tw, th,
                                                 THREE.LuminanceFormat,
                                                 THREE.UnsignedByteType,
                                                 THREE.UVMapping,
                                                 THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
                                                 THREE.NearestFilter, THREE.NearestFilter, 0);
        layerMaskTex.generateMipmaps = false;
        layerMaskTex.flipY = false;
        layerMaskTex.needsUpdate = true;

        //TODO: These are per-model, so we will need
        //to remember multiple sets in case we support
        //multi-drawing views.
        this.layerMaskTex = layerMaskTex;
        this.layersMap = model.getData().layersMap;

    };


    this.initLineStyleTexture = function() {

        this.lineStyleTex = avp.CreateLinePatternTexture();

    };


    this.init2DSelectionMaterial = function(model) {

        var numObj = model.myData.maxObjectNumber || 1;
        var tw = 4096; //NOTE: This size is assumed in the shader, so update the shader if this changes!
        var th = 0 | Math.ceil(numObj / tw);
        var p2 = 1;
        while (p2 < th)
            p2 *= 2;
        th = p2;

        var selectionMask = new Uint8Array(tw*th);
        for (var i= 0; i<numObj; i++) {
            selectionMask[i] = 0;
        }

        //selectionMask[0] = 0xff;

        var selectionTex = new THREE.DataTexture(selectionMask, tw, th,
                                                 THREE.LuminanceFormat,
                                                 THREE.UnsignedByteType,
                                                 THREE.UVMapping,
                                                 THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
                                                 THREE.NearestFilter, THREE.NearestFilter, 0);
        selectionTex.generateMipmaps = false;
        selectionTex.flipY = false;
        selectionTex.needsUpdate = true;

        this.selectionTex = selectionTex;

        var hash = this.create2DMaterial(model.getData(), {}, false, true);
        var m = _materials[hash];

        m.uniforms["tSelectionTexture"].value = this.selectionTex;
        m.uniforms["vSelTexSize"].value.set(tw, th);
        m.needsUpdate = true;

        return m;
    };

    //Toggles 2D layer visibility by setting the corresponding
    //pixel in the layers texture.
    this.setLayerVisible = function(layerIndexes, visible){
        var layerMaskTex = this.layerMaskTex,
            layerMaskData = layerMaskTex.image.data,
            layersMap = this.layersMap,
            mask = visible ? 0xff : 0;

        for (var i = 0; i < layerIndexes.length; ++i) {
            var layerIndex = layerIndexes[i];
            layerMaskData[layersMap[layerIndex]] = mask;
        }

        layerMaskTex.needsUpdate = true;

        for (var p in _materials) {
            if (is2dMaterial(p))
                _materials[p].needsUpdate = true;
        }

        this.viewer.invalidate(true);
    };

    this.isLayerVisible = function (layerIndex) {
        return !!this.layerMaskTex.image.data[this.layersMap[layerIndex]];
    };

    //Meshes for 2d drawings contain many objects in a single mesh.
    //So we use a mask texture to pick out which object specifically
    //to highlight. The shader samples this texture to deside whether
    //to draw or not.
    this.highlightObject2D = function(dbId, state) {

        var data = this.selectionTex.image.data;

        data[dbId] = state ? 0xff : 0;

        //TODO: partial texture update using TexSubImage possible?
        this.selectionTex.needsUpdate = true;

        this.viewer.invalidate(false, false, true);

    };

    this.cloneMaterial = function (mat) {

        var material = mat.isPrismMaterial ? avp.clonePrismMaterial(mat) : mat.clone();

        // clone additional properties
        if (material instanceof THREE.MeshPhongMaterial || material.isPrismMaterial) {
            material.packedNormals = mat.packedNormals;
            material.exposureBias = mat.exposureBias;
            material.irradianceMap = mat.irradianceMap;
            material.envMapExposure = mat.envMapExposure;
            material.envRotationSin = mat.envRotationSin;
            material.envRotationCos = mat.envRotationCos;
            material.proteinType = mat.proteinType;
            material.proteinMat = mat.proteinMat;
            material.tonemapOutput = mat.tonemapOutput;
            material.cutplanes = mat.cutplanes;
        }

        this.viewer.renderer().applyMRTFlags(material);

        return material;
    };

    /**
     * Returns a copy of cut planes
     */
    this.getCutPlanes = function() {
        return _cutplanes.slice();
    };
    this.getCutPlanesRaw = function() {
        return _cutplanes;
    };


    /**
     * Sets cut planes for all materials
     * Clears any existing cutplanes and populates with the new ones
     * If empty array or undefined, cut planes will be turned off (cleared)
     */
    this.setCutPlanes = function(cutplanes) {
        // update mat shaders, if num of planes changed
        if ( _cutplanes.length !== (cutplanes ? cutplanes.length || 0 : 0) ) {
			var p;
            for (p in _materials) {
                _materials[p].needsUpdate = true;
                if (cutplanes && cutplanes.length > 0) _materials[p].side = THREE.DoubleSide;
            }
            for (p in _materialsNonHDR)
                _materialsNonHDR[p].needsUpdate = true;
        }

        // empty array (http://jsperf.com/empty-javascript-array)
        while(_cutplanes.length > 0) _cutplanes.pop();

        // copy cutplanes
        if (cutplanes) {
            for (var i=0; i<cutplanes.length; i++) {
                _cutplanes.push(cutplanes[i].clone());
            }
        }
    };

    /**
     * Deallocates any material related GL objects associated with the given model.
     */
    this.cleanup = function(svf) {

        //Dispose all textures that were loaded as part of the given SVF
        var newTex = {};

        for (var t in this.textures) {
            var tdef = this.textures[t];
            if (t.indexOf(svf.basePath) === -1)
                newTex[t] = tdef;
            else if (tdef.tex)
                tdef.tex.dispose();
        }
        this.textures = newTex;

        //Remove all materials that were used by the given SVF
        var newMats = {};
        var DISPOSE_EVENT = { type: 'dispose' };

        for (var m in _materials) {
            if (svf && m.indexOf(svf.basePath) === -1) {
                newMats[m] = _materials[m];
            } else {
                var mat = _materials[m];
                mat.dispatchEvent(DISPOSE_EVENT);
                mat.needsUpdate = true; //in case it gets used again
            }
        }

        _materials = this.materials = newMats;
    };


    this.addSimpleMaterial = function(id, simpleMaterial, svf) {
        var phongMat = avp.MaterialConverter.convertMaterial(simpleMaterial);
        var matName = getMaterialHash(svf, id);
        this.addMaterial(matName, phongMat);
        this.loadTexture(phongMat, svf);
    };

    //Register the default material
    this.addMaterial("__defaultMaterial__", this.defaultMaterial);


    //this.initLineStyleTexture();


}

Autodesk.Viewing.Private.MaterialManager = MaterialManager;

})();
;/**
 * @author nopjia / http://github.com/nopjia
 */
(function () {

'use strict';

var av = Autodesk.Viewing,
    avs = av.Shaders;


avs.init_GroundShader = function(THREE) {

if (typeof avs.GroundDepthShader !== "undefined")
    return;

avs.GroundDepthShader = {
    uniforms: {
        "cutplanes" : { type:"v4v", value: [] },
    },

    vertexShader: [
        "#ifdef USE_LOGDEPTHBUF",
        "    #ifdef USE_LOGDEPTHBUF_EXT",
        "        varying float vFragDepth;",
        "    #endif",
        "    uniform float logDepthBufFC;",
        "#endif",

        "#if NUM_CUTPLANES > 0",
            "varying vec3 vWorldPosition;",
        "#endif",

        "void main() {",
        "    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );;",

        "#if NUM_CUTPLANES > 0",
        "    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
        "    vWorldPosition = worldPosition.xyz;",
        "#endif",

        "#ifdef USE_LOGDEPTHBUF",
        "    gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;",
        "    #ifdef USE_LOGDEPTHBUF_EXT",
        "        vFragDepth = 1.0 + gl_Position.w;",
        "    #else",
        "        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;",
        "    #endif",
        "#endif",
        "}"
    ].join("\n"),

    fragmentShader: [
        "#ifdef USE_LOGDEPTHBUF",
        "    uniform float logDepthBufFC;",
        "    #ifdef USE_LOGDEPTHBUF_EXT",
        "        #extension GL_EXT_frag_depth : enable",
        "        varying float vFragDepth;",
        "    #endif",
        "#endif",

        avs.PackDepthShaderChunk,

        "#if NUM_CUTPLANES > 0",
            "varying vec3 vWorldPosition;",
        "#endif",
        avs.CutPlanesShaderChunk,

        "void main() {",
        "#if NUM_CUTPLANES > 0",
            "checkCutPlanes(vWorldPosition);",
        "#endif",

        "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)",
            "gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;",
        "#endif",

        "#ifdef USE_LOGDEPTHBUF_EXT",
            "float depth = gl_FragDepthEXT / gl_FragCoord.w;",
        "#else",
            "float depth = gl_FragCoord.z / gl_FragCoord.w;",
        "#endif",
            "depth = 1.0 - depth;",
            "gl_FragColor = packDepth(depth);",
        "}"
    ].join("\n")
};

avs.GroundShadowAOShader = {
    uniforms: {
        tDepth: { type: "t", value: null },
        worldSize: { type: "v3", value: new THREE.Vector3(1,1,1) }
    },

    defines : {

    },

    vertexShader: [
        "varying vec2 vUv;",

        "void main() {",
            "vUv = vec2(uv.x, uv.y);",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragmentShader: [

        "#define NUM_SAMPLES 29.0",
        "#define NUM_SPIRAL_TURNS 7.0",

        "uniform sampler2D tDepth;",
        "uniform vec3 worldSize;",

        "varying vec2 vUv;",

        //"#define PRESET_2",

        "#ifdef PRESET_2",
        "#define SAMPLE_RADIUS 0.3",
        "#define AO_GAMMA 1.0",
        "#define AO_INTENSITY 1.0",
        "#else",
        "#define SAMPLE_RADIUS 0.2",
        "#define AO_GAMMA 3.0",
        "#define AO_INTENSITY 0.8",
        "#endif",

        avs.PackDepthShaderChunk,

        "#define PI 3.14159265358979",

        "float rand(vec2 co) {",
            "return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);",
        "}",

        "float getRandomAngle(vec2 pos) {",
            "return rand(pos) * (2.0 * PI);",
        "}",

        /** Returns a unit vector and a screen-space radius for the tap on a unit disk (the caller should scale by the actual disk radius) */
        "vec2 tapLocation(float sampleNumber, float spinAngle, out float ssR){",
            // Radius relative to ssR
            "float alpha = float(sampleNumber + 0.5) * (1.0 / NUM_SAMPLES);",
            "float angle = alpha * (NUM_SPIRAL_TURNS * PI * 2.0) + spinAngle;",

            "ssR = alpha;",
            "return vec2(cos(angle), sin(angle));",
        "}",


        "vec2 sampleAO(vec2 unitDirection, float radius) {",
            "vec2 sampleOffset = unitDirection * radius;",
            "float idepth = unpackDepth(texture2D(tDepth, vUv + sampleOffset));",
            "float depth = 1.0 - idepth;", //in our texture storage 1.0 is near, 0.0 is far

            "if (depth < 1e-6) {",
                 "if (radius == 0.0)",
                    "return vec2(1.0, 1.0);",
                 "else",
                    "return vec2(0.0, 1.0);",
            "}",

            //This is (a rough proxy for) the world space distance to the sample
            "vec3 dir = vec3(sampleOffset.x, depth, sampleOffset.y) * worldSize;",
            "float distance2 = dot(dir,dir);",
            "float idistance = 1.0 / sqrt(distance2);",

            //Normalized direction vector pointing to the sample
            "vec3 ndir = dir * idistance;",

            //If ndir.y is bigger, sample is more important (dot(normal,sample dir) is closer to vertical)
            //If distance2 is bigger, sample is less important as it's too far
            "#ifdef PRESET_2",
            "float importance = ndir.y * idistance;",
            "#else",
            "float importance = ndir.y / distance2;",
            "#endif",

            "vec2 ret;",
            "ret.x = (idepth == 0.0) ? 0.0 : importance;", //accumulate darkness -- 0 if sample is not obscured
            "ret.y = importance;", //accumulate scale factor for normalization of the sum
            "return ret;",
        "}",

        "void main() {",
            "vec2 sum = vec2(0.0);",
            "float angle = getRandomAngle(vUv);",
            //Take NUM_SAMPLES random-ish samples on the hemispehere of
            //the current ground point, similar to how it's done by the SAO algorithm.
            "for (float i = 0.0; i<NUM_SAMPLES; i+= 1.0) {",
                "float ssR;",
                "vec2 uv = tapLocation(i, angle, ssR);",
                "sum += sampleAO(uv, ssR * SAMPLE_RADIUS);",
            "}",
            "float ao = sum.x / sum.y;", //normalize the sum
            "gl_FragColor = packDepth(AO_INTENSITY * clamp(pow(ao, AO_GAMMA), 0.0, 0.9999));",
        "}"
    ].join("\n")
};


avs.GroundShadowBlurShader = {
    uniforms: {
        tDepth: { type: "t", value: null }
    },

     defines: {
    //     KERNEL_SCALE:  1.0 / 64.0,
    //     KERNEL_RADIUS: 7.0
    //      BOX : 1
     },

    vertexShader: [
        "varying vec2 vUv;",

        "void main() {",
            "vUv = vec2(uv.x, uv.y);",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragmentShader: [
        "uniform sampler2D tDepth;",

        "varying vec2 vUv;",

        "#ifdef HORIZONTAL",
            "#define GET_UV(X) vec2(vUv.x + KERNEL_SCALE*(X), vUv.y)",
        "#else",
            "#define GET_UV(Y) vec2(vUv.x, vUv.y + KERNEL_SCALE*(Y))",
        "#endif",

        avs.PackDepthShaderChunk,

        "#define PI 3.14159265358979",
        "#define SIGMA ((2.0 * KERNEL_RADIUS+1.0) / 6.0)",
        "#define SIGMASQ2 (2.0 * SIGMA * SIGMA)",
        "#ifdef BOX",
            "#define KERNEL_VAL(X) 1.0",
        "#else",
            "#define KERNEL_VAL(X) ( (1.0 / sqrt(PI * SIGMASQ2)) * exp(-(X)*(X)/SIGMASQ2) )",
        "#endif",

        "void main() {",
            "float depthVal = 0.0;",
            "float sum = 0.0;",
            "for (float x=-KERNEL_RADIUS; x<=KERNEL_RADIUS; x+=1.0) {",
                "depthVal += unpackDepth(texture2D(tDepth, GET_UV(x))) * KERNEL_VAL(x);",
                "sum += KERNEL_VAL(x);",
            "}",
            "gl_FragColor = packDepth(depthVal/sum);",
        "}"
    ].join("\n")
};


avs.GroundShadowColorShader = {
    uniforms: {
        tDepth: { type: "t", value: null },
        uShadowColor: { type: "v4", value: new THREE.Vector4(0, 0, 0, 1) },
    },

    vertexShader: [
        "varying vec2 vUv;",

        "void main() {",
        "    vUv = vec2(uv.x, uv.y);",
        "    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragmentShader: [
        "uniform sampler2D tDepth;",
        "uniform vec4 uShadowColor;",
        "varying vec2 vUv;",

        avs.PackDepthShaderChunk,

        "void main() {",
            "float depthVal = unpackDepth(texture2D(tDepth, vUv));",
            //"depthVal *= depthVal;", //Nop's gamma correction
            "gl_FragColor = vec4(uShadowColor.rgb, uShadowColor.a * depthVal);",
        "}"
    ].join("\n")
};

};


var GroundShadow = function(renderer, params) {

    avs.init_GroundShader(THREE);

    var _renderer = renderer;
    var _camera;
    var _scene;
    var _planeMesh, _planeGeo;
    var _targetH, _targetV;
    var _matDepth, _matColor;
    var _blurPassH, _blurPassV, _aoPass;
    var _debugBox;

    var _bufferValid = false;

    var USE_AO_PASS = false;

    // param defaults
    var _params = {
        texSize: USE_AO_PASS ? 128.0 : 64.0,
        pixScale: 1.0,
        blurRadius: USE_AO_PASS ? 5.0 : 7.0,
        debug: false
    };

    // FUNCTIONS

    function createShaderMaterial(shader) {
        return new THREE.ShaderMaterial({
            uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            defines: THREE.UniformsUtils.clone( shader.defines )
        });
    }

    /**
     * Set transform of the ground shadow system
     * @param {Vector3} center  center of bounding box
     * @param {Vector3} size    size in look&up coordinates, look = y
     * @param {Vector3} lookDir look direction, where ground camera is facing
     * @param {Vector3} upDir   up direction for ground camera
     */
    this.setTransform = function(center, size, lookDir, upDir) {
        // ortho frustrum
        _camera.left   = -size.z / 2.0;
        _camera.right  =  size.z / 2.0;
        _camera.top    =  size.x / 2.0;
        _camera.bottom = -size.x / 2.0;
        _camera.near   =  1.0;
        _camera.far    =  size.y + _camera.near;

        // update projection
        _camera.updateProjectionMatrix();

        // camera transform
        _camera.position.addVectors(center, lookDir.clone().multiplyScalar(-size.y/2.0 - _camera.near));
        if(upDir) _camera.up.set(upDir.x, upDir.y, upDir.z);
        _camera.lookAt(center);

        // plane transform
        _planeMesh.position.set(center.x, center.y /*+ size.y * 0.05*/, center.z);
        _planeMesh.rotation.set(_camera.rotation.x, _camera.rotation.y, _camera.rotation.z);
        _planeMesh.scale.set(size.z, size.x, size.y);

        // debug box
        if (_params.debug) {
            _debugBox.position.set(center.x, center.y, center.z);
            _debugBox.rotation.set(_camera.rotation.x, _camera.rotation.y, _camera.rotation.z);
            _debugBox.scale.set(size.z, size.x, size.y);
        }

        _aoPass.uniforms['worldSize'].value.copy(size);
    };

    this.renderIntoShadow = function(scene) {
        //Skip ghosted objects
        if (scene.overrideMaterial && scene.overrideMaterial.transparent)
            return;

        var oldMat = scene.overrideMaterial;
        scene.overrideMaterial = _matDepth;
        _renderer.render(scene, _camera, _targetH, false);
        scene.overrideMaterial = oldMat;

        // console.log("GS render in");
    };

    this.renderShadow = function(camera, target) {
        if (!_bufferValid)
            return;

        if (target)
            _renderer.render(_scene, camera, target, false);
        else
            _renderer.render(_scene, camera);

        // console.log("GS render out");
    };

    this.postprocess = function() {
        if (USE_AO_PASS) {
            _aoPass.render(_renderer, _targetV, _targetH);
            _blurPassV.render(_renderer, _targetH, _targetV);
            _blurPassH.render(_renderer, _targetV, _targetH);
        } else {
            _blurPassV.render(_renderer, _targetV, _targetH);
            _blurPassH.render(_renderer, _targetH, _targetV);
        }

        _bufferValid = true;

        // console.log("GS postprocess");
    };

    this.clear = function() {
        var oldClearColor = _renderer.getClearColor().getHex();
        var oldClearAlpha = _renderer.getClearAlpha();
        _renderer.setClearColor(0, 0);
        _renderer.clearTarget(_targetH, true, true, false);
        _renderer.setClearColor(oldClearColor, oldClearAlpha);
        _bufferValid = false;

        // console.log("GS clear");
    };

    this.setColor = function(color) {
        _matColor.uniforms.uShadowColor.value.x = color.r;
        _matColor.uniforms.uShadowColor.value.y = color.g;
        _matColor.uniforms.uShadowColor.value.z = color.b;
    };

    this.getColor = function() {
        return new THREE.Color(
            _matColor.uniforms.uShadowColor.value.x,
            _matColor.uniforms.uShadowColor.value.y,
            _matColor.uniforms.uShadowColor.value.z
        );
    };

    this.setAlpha = function(alpha) {
        _matColor.uniforms.uShadowColor.value.w = alpha;
    };

    this.getAlpha = function() {
        return _matColor.uniforms.uShadowColor.value.w;
    };

    this.isValid = function() {
        return _bufferValid;
    };

    // TODO_NOP: hack exposing groundshadow material
    this.getDepthMaterial = function() {
        return _matDepth;
    };

    // INITIALIZATION

    if (params) {
        for (var i in _params) {
            _params[i] = params[i] || _params[i];
        }
    }

    // init scene
    _scene = new THREE.Scene();

    // init camera
    _camera = new THREE.OrthographicCamera();

    // init targets

    _targetH = new THREE.WebGLRenderTarget(_params.texSize, _params.texSize, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: false,
    });
    _targetH.generateMipmaps = false;

    _targetV = new THREE.WebGLRenderTarget(_params.texSize, _params.texSize, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: false
    });
    _targetV.generateMipmaps = false;


    // init materials

    _matDepth = createShaderMaterial(avs.GroundDepthShader);
    _matDepth.side = THREE.DoubleSide;
    _matDepth.blending = THREE.NoBlending;

    _blurPassH = new avs.LmvShaderPass(avs.GroundShadowBlurShader, "tDepth");
    _blurPassV = new avs.LmvShaderPass(avs.GroundShadowBlurShader, "tDepth");
    _aoPass = new avs.LmvShaderPass(avs.GroundShadowAOShader, "tDepth");

    // write defines
    _blurPassH.material.defines["KERNEL_SCALE"] = _blurPassV.material.defines["KERNEL_SCALE"] = (_params.pixScale/_params.texSize).toFixed(4);
    _blurPassH.material.defines["KERNEL_RADIUS"] = _blurPassV.material.defines["KERNEL_RADIUS"] = _params.blurRadius.toFixed(2);

    //Some standard GL setup for the blur passes.
    _aoPass.material.blending =   _blurPassH.material.blending =   _blurPassV.material.blending = THREE.NoBlending;
    _aoPass.material.depthWrite = _blurPassH.material.depthWrite = _blurPassV.material.depthWrite = false;
    _aoPass.material.depthTest =  _blurPassH.material.depthTest =  _blurPassV.material.depthTest = false;
    _blurPassH.material.defines["HORIZONTAL"] = 1;

    _matColor = createShaderMaterial(avs.GroundShadowColorShader);
    _matColor.uniforms.tDepth.value = USE_AO_PASS ? _targetV : _targetH;
    _matColor.depthWrite = false;
    _matColor.transparent = true;

    // init plane

    _planeGeo = new THREE.BufferGeometry();
    _planeGeo.addAttribute("position", new THREE.BufferAttribute(( new Float32Array([
        -0.5, -0.5,  0.5,
        -0.5,  0.5,  0.5,
         0.5,  0.5,  0.5,
         0.5, -0.5,  0.5
    ]) ), 3));
    _planeGeo.addAttribute("uv", new THREE.BufferAttribute(( new Float32Array([
        0.0, 0.0,
        0.0, 1.0,
        1.0, 1.0,
        1.0, 0.0
    ]) ), 2));
    _planeGeo.addAttribute("index", new THREE.BufferAttribute(( new Uint16Array([
        0, 1, 2,
        2, 3, 0
    ]) ), 1));
    _planeMesh = new THREE.Mesh(_planeGeo, _matColor);
    _scene.add(_planeMesh);

    // init debug box
    if (_params.debug) {
        _debugBox = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } )
        );
        _scene.add(_debugBox);
    }

    // init with default bounds and up
    this.setTransform(
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(1, 1, 1),
        new THREE.Vector3(0, 1, 0)
    );
};

GroundShadow.prototype.constructor = GroundShadow;

avs.GroundShadow = GroundShadow;

})();;/**
 * @author nopjia / http://github.com/nopjia
 */

function init_GroundReflectionShader() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var avs = Autodesk.Viewing.Shaders;


if (typeof avs.GroundReflectionCompShader !== "undefined")
    return;

avs.GroundReflectionCompShader = {
    uniforms: {
        tDiffuse: { type: "t", value: null },
        tBackground: { type: "t", value: null },
        uColor: { type: "v4", value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) }
    },

    vertexShader: [
        "varying vec2 vUv;",
        "void main() {",
            "vUv = uv;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}"
    ].join("\n"),

    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform sampler2D tBackground;",
        "uniform vec4 uColor;",
        "varying vec2 vUv;",
        "void main() {",
            "vec4 bgCol = texture2D( tBackground, vUv );",
            "vec4 diffCol = uColor * texture2D( tDiffuse, vUv );",
            "gl_FragColor = mix(bgCol, diffCol, diffCol.a);",
        "}"
    ].join("\n")
};

avs.GroundReflectionDrawShader = {
    uniforms: {
        tDiffuse: { type: "t", value: null },
    },

    vertexShader: [
        "varying vec2 vUv;",
        "void main() {",
            "vUv = uv;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}"
    ].join("\n"),

    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "varying vec2 vUv;",
        "void main() {",
            "vec4 texel = texture2D( tDiffuse, vUv );",
            "gl_FragColor = texel;",
        "}"
    ].join("\n")
};
}


(function() {

"use strict";


var avs = Autodesk.Viewing.Shaders;

var GroundReflection = function(renderer, width, height, params) {

    init_GroundReflectionShader();

    var _renderer = renderer;
    var _gl = _renderer.getContext();
    var _width = width || 512;
    var _height = height || 512;
    var _gaussianPass, _drawPass;
    var _groundPlane, _groundCenter;
    var _reflCamera;
    var _isGroundCulled = false;
    var _clearColor = new THREE.Color(0,0,0);
    var _clearPass, _useClearPass = false;
    var _envMapBg = false;

    this.inTarget = undefined;
    this.outTarget = undefined;

    // param defaults
    var _params = {
        color: new THREE.Color(1.0, 1.0, 1.0),
        alpha: 0.3,
        texScale: 0.5,
        blurRadius: 2,
        blurTexScale: 0.5,
        fadeAngle: Math.PI/18
    };

    // PRIVATE FUNCTIONS

    var getReflectionMatrix = function(plane) {
        var N = plane.normal;
        var C = plane.constant;
        return (new THREE.Matrix4()).set(
            1 - 2 * N.x * N.x,   - 2 * N.y * N.x,   - 2 * N.x * N.z, - 2 * C * N.x,
              - 2 * N.x * N.y, 1 - 2 * N.y * N.y,   - 2 * N.y * N.z, - 2 * C * N.y,
              - 2 * N.x * N.z,   - 2 * N.y * N.z, 1 - 2 * N.z * N.z, - 2 * C * N.z,
                            0,                 0,                 0,             1
        );
    };

    // PUBLIC FUNCTIONS
    // note: currently scale is not used
    this.setTransform = function(center, upDir, scale) {
        _groundCenter = center;
        _groundPlane.normal = upDir;
        _groundPlane.constant = -center.dot(upDir);
    };

    this.cleanup = function() {
        if (_gaussianPass)  _gaussianPass.cleanup();
        if (this.inTarget)  this.inTarget.dispose();
        if (this.outTarget) this.outTarget.dispose();
    };

    this.setSize = function(width, height) {
        _width = width;
        _height = height;

        this.cleanup();

        // init targets

        this.inTarget = new THREE.WebGLRenderTarget(
            _width * _params.texScale,
            _height * _params.texScale,
            {
                magFilter: THREE.LinearFilter,
                minFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: false
            }
        );
        this.inTarget.generateMipmaps = false;

        this.outTarget = new THREE.WebGLRenderTarget(
            _width * _params.texScale,
            _height * _params.texScale,
            {
                magFilter: THREE.LinearFilter,
                minFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: false
            }
        );
        this.outTarget.generateMipmaps = false;

        // init gaussian pass

        if (!_gaussianPass)
            _gaussianPass = new avs.GaussianPass(
                _width * _params.texScale * _params.blurTexScale,
                _height * _params.texScale * _params.blurTexScale,
                _params.blurRadius,
                1.0, {
                    hasAlpha: true,
                    blending: true,
                    flipUV: true
                });
        else
            _gaussianPass.setSize(
                _width * _params.texScale * _params.blurTexScale,
                _height * _params.texScale * _params.blurTexScale);
    };

    this.updateCamera = function(camera) {
        // do not render if camera angle below zero
        var camDir = camera.position.clone().sub(_groundCenter).normalize();
        var camAngle = Math.PI/2 - camDir.angleTo(_groundPlane.normal);
        _isGroundCulled = camAngle < 0;

        if (_isGroundCulled) return;

        // fade out
        if (_params.fadeAngle > 0) {
            var fadeAmount = Math.min(_params.fadeAngle, camAngle) / _params.fadeAngle;
            _gaussianPass.setAlpha(fadeAmount * _params.alpha);
        }

        // construct reflected camera
        var reflMatrix = getReflectionMatrix(_groundPlane);
        _reflCamera = camera.clone();
        _reflCamera.applyMatrix(reflMatrix);
        // MAGIC: scale negative Y and flip UV gives us correct result without messing with face winding
        _reflCamera.projectionMatrix.elements[5] *= -1;
        _reflCamera.matrixWorldNeedsUpdate = true;

        // copy worldUpTransform
        if (camera.worldUpTransform)
            _reflCamera.worldUpTransform = camera.worldUpTransform.clone();
        else
            _reflCamera.worldUpTransform = new THREE.Matrix4();
    };

    this.renderIntoReflection = function(scene) {
        if (_isGroundCulled) return;
        _renderer.render(scene, _reflCamera, this.inTarget);

        // console.log("GR render in");
    };

    this.renderReflection = function(camera, target) {
        if (_isGroundCulled) return;

        _gl.depthRange(0.999999, 1);
        _drawPass.render(_renderer, target, this.outTarget);
        _gl.depthRange(0, 1);

        // console.log("GR render out");
    };

    this.toggleEnvMapBackground = function (value) {

        _envMapBg = value;
        _clearPass.uniforms.envMapBackground.value = value;
    };

    this.postprocess = function(camera) {
        if (_isGroundCulled) return;

        // clear outTarget with bg color
        if (_useClearPass || _envMapBg) {

            _clearPass.uniforms['uCamDir'].value = camera.getWorldDirection();
            _clearPass.uniforms['uCamUp'].value = camera.up;
            _clearPass.uniforms['uResolution'].value.set(_width, _height);
            _clearPass.uniforms['uHalfFovTan'].value = Math.tan(THREE.Math.degToRad(camera.fov * 0.5));

            _clearPass.render(_renderer, this.outTarget);
            _renderer.clearTarget(this.outTarget, false, true, false);
        }
        else {
            _renderer.setClearColor(_clearColor, 1.0);
            _renderer.clearTarget(this.outTarget, true, true, false);
        }

        // blur inTarget with alpha blending over bg in outTarget
        _gaussianPass.render(_renderer, this.outTarget, this.inTarget);

        // console.log("GR postprocess");
    };

    this.clear = function() {
        // clear with bgColor otherwise there'll be outline problem
        // using the cheaper flat clear color in this case
        _renderer.setClearColor(_clearColor, 0);
        _renderer.clearTarget(this.inTarget, true, true, false);

        // console.log("GR clear");
    };

    // params are normalized clamped THREE.Vector3
    this.setClearColors = function(colorTop, colorBot) {
        if (!colorBot) {
            _clearColor.copy(colorTop);
            _useClearPass = false;
        }
        else {
            _clearColor.setRGB(
                0.5 * (colorTop.x + colorBot.x),
                0.5 * (colorTop.y + colorBot.y),
                0.5 * (colorTop.z + colorBot.z));

            // same logic as RenderContext.setClearColors
            _useClearPass =
                !colorTop.equals(colorBot) &&
                !av.isAndroidDevice() &&
                !av.isIOSDevice();
        }

        if (_useClearPass) {
            _clearPass.uniforms.color1.value.copy(colorTop);
            _clearPass.uniforms.color2.value.copy(colorBot);
        }
    };

    this.setEnvRotation = function(rotation) {
        _clearPass.material.envRotationSin = Math.sin(rotation);
        _clearPass.material.envRotationCos = Math.cos(rotation);
    };

    this.isGroundCulled = function() {
        return _isGroundCulled;
    };

    this.setColor = function(color) {
        _gaussianPass.setColor(_params.color);
        _params.color.set(color);
    };

    this.setAlpha = function(alpha) {
        _gaussianPass.setAlpha(_params.alpha);
        _params.alpha = alpha;
    };

    // INITIALIZATION

    if (params) {
        for (var i in _params) {
            _params[i] = (params[i] !== undefined) ? params[i] : _params[i];
        }
    }

    // init passes

    _drawPass = new avs.LmvShaderPass(avs.GroundReflectionDrawShader);
    _drawPass.material.blending = THREE.NoBlending;
    _drawPass.material.depthTest = true;
    _drawPass.material.depthWrite = false;

    _clearPass = new avs.LmvShaderPass(avs.BackgroundShader);
    _clearPass.material.blending = THREE.NoBlending;
    _clearPass.material.depthWrite = false;
    _clearPass.material.depthTest = false;

    // init targets
    this.setSize(_width, _height);

    _gaussianPass.setAlpha(_params.color);
    _gaussianPass.setAlpha(_params.alpha);

    // init plane

    _groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
    _groundCenter = new THREE.Vector3(0, 0, 0);

};

GroundReflection.prototype.constructor = GroundReflection;

avs.GroundReflection = GroundReflection;

})();;/**
 * @author nopjia / http://github.com/nopjia
 */
 
function init_GaussianShader() {
    'use strict';

var avs = Autodesk.Viewing.Shaders;

if (typeof avs.GaussianShader !== "undefined")
    return; 

avs.GaussianShader = {
    uniforms: {
        tDiffuse: { type: "t", value: null },
        uColor: { type: "v4", value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) }
    },

    // defines: {
    //     KERNEL_SCALE_H:  1.0 / 64.0,
    //     KERNEL_SCALE_V:  1.0 / 64.0,
    //     KERNEL_RADIUS: 7.0
    // },

    vertexShader: [
        "varying vec2 vUv;",

        "void main() {",
        "#if defined(HORIZONTAL) && defined(FLIP_UV)",
        "    vUv = vec2(uv.x, 1.0-uv.y);",
        "#else",
        "    vUv = vec2(uv.x, uv.y);",
        "#endif",
        "    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
        "}",
    ].join("\n"),

    fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform vec4 uColor;",
        "varying vec2 vUv;",
        "#ifdef HORIZONTAL",
        "    #define GET_UV(X) vec2(vUv.x + KERNEL_SCALE_H*(X), vUv.y)",
        "#else",
        "    #define GET_UV(Y) vec2(vUv.x, vUv.y + KERNEL_SCALE_V*(Y))",
        "#endif",
        "#define PI 3.14159265358979",
        "#define SIGMA ((KERNEL_RADIUS+KERNEL_RADIUS+1.0) / 6.0)",
        "#define SIGMASQ2 (2.0 * SIGMA * SIGMA)",
        "#define GAUSSIAN(X) ( (1.0 / sqrt(PI * SIGMASQ2)) * exp(-(X)*(X)/SIGMASQ2) )",
        "void main() {",
        "    vec4 texColSum = vec4(0.0);",
        "    float gaussSum = 0.0;",
        "    for (float x=-KERNEL_RADIUS; x<=KERNEL_RADIUS; x+=1.0) {",
        "        float gauss = GAUSSIAN(x);",
        "        vec4 texCol = texture2D(tDiffuse, GET_UV(x));",
        "        #ifdef HAS_ALPHA",
        "            texCol.rgb *= texCol.a;",
        "        #endif",
        "        texColSum += texCol * gauss;",
        "        gaussSum += gauss;",
        "    }",
        "    #ifdef HAS_ALPHA",
        "        texColSum.rgb /= texColSum.a;",
        "    #endif",
        "#ifdef HORIZONTAL",
        "    gl_FragColor = texColSum/gaussSum;",
        "#else",
        "    gl_FragColor = texColSum/gaussSum * uColor;",
        "#endif",
        "}",
    ].join("\n")
};
}

(function() {

var avs = Autodesk.Viewing.Shaders;

var GaussianPass = function(width, height, radius, scale, params) {
    
    init_GaussianShader();

    var _width = width;
    var _height = height;
    var _blurRadius = radius || 3.0;
    var _pixelScale = scale || 1.0;
    var _blurPassH, _blurPassV;
    var _tmptarget;

    var _params = {
        hasAlpha: params.hasAlpha || false,
        blending: params.blending || false,
        flipUV:   params.flipUV || false
    };

    // PUBLIC FUNCTIONS

    this.render = function(renderer, writeBuffer, readBuffer) {
        _blurPassH.render(renderer, _tmptarget, readBuffer);     // from readBuffer to intermediary tmp
        _blurPassV.render(renderer, writeBuffer, _tmptarget);    // tmp out to write
    };

    this.setSize = function(width, height) {
        this.cleanup();

        _width = width;
        _height = height;

        _tmptarget = new THREE.WebGLRenderTarget(width, height, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: false
        });
        _tmptarget.generateMipmaps = false;

        _blurPassH.material.defines.KERNEL_SCALE_H = _blurPassV.material.defines.KERNEL_SCALE_H = (_pixelScale/_width).toFixed(4);
        _blurPassH.material.defines.KERNEL_SCALE_V = _blurPassV.material.defines.KERNEL_SCALE_V = (_pixelScale/_height).toFixed(4);
        _blurPassH.material.needsUpdate = _blurPassV.material.needsUpdate = true;
    };

    this.cleanup = function() {
        if (_tmptarget)
            _tmptarget.dispose();
    };

    this.setColor = function(color) {
        _blurPassV.material.uniforms.uColor.value.x = color.r;
        _blurPassV.material.uniforms.uColor.value.y = color.g;
        _blurPassV.material.uniforms.uColor.value.z = color.b;
    };

    this.setAlpha = function(alpha) {
        _blurPassV.material.uniforms.uColor.value.w = alpha;
    };

    // INITIALIZATION

    // init shader passes
    _blurPassH = new avs.LmvShaderPass(avs.GaussianShader);
    _blurPassV = new avs.LmvShaderPass(avs.GaussianShader);

    // init target
    this.setSize(width, height);

    _blurPassH.material.blending   = _blurPassV.material.blending   = THREE.NoBlending;
    _blurPassH.material.depthWrite = _blurPassV.material.depthWrite = false;
    _blurPassH.material.depthTest  = _blurPassV.material.depthTest  = false;
    _blurPassH.material.defines.HORIZONTAL = 1;

    _blurPassH.material.defines.KERNEL_RADIUS = _blurPassV.material.defines.KERNEL_RADIUS = _blurRadius.toFixed(1);

    if (_params.blending) {
        _blurPassV.material.transparent = true;
        _blurPassV.material.blending = THREE.NormalBlending;
    }

    if (_params.hasAlpha)
        _blurPassH.material.defines.HAS_ALPHA = _blurPassV.material.defines.HAS_ALPHA = "";

    if (_params.flipUV)
        _blurPassH.material.defines.FLIP_UV = "";

};

avs.GaussianPass = GaussianPass;

})();;
(function() {

"use strict";

var avp = Autodesk.Viewing.Private;

var INTERPOLATION_TYPE = {
    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2
};

var AnimationHandler = function() {
    this.animations = [];
};

AnimationHandler.prototype.init = function(data) {
    // return same data if initialized
    if (data.initialized === true) return data;

    // loop through all keys
    for (var h = 0; h < data.hierarchy.length; h++) {
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            // remove minus times
            if (data.hierarchy[h].keys[k].time < 0 ) {
                 data.hierarchy[h].keys[k].time = 0;
            }

            // create quaternions
            if (data.hierarchy[h].keys[k].rot !== undefined &&
              ! (data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
                var quat = data.hierarchy[h].keys[k].rot;
                if (!Array.isArray(quat)) {
                    quat = [quat._x, quat._y, quat._z, quat._w];
                }
                data.hierarchy[h].keys[k].rot = new THREE.Quaternion().fromArray(quat);
            }
        }

        // remove all keys with same time
        for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
            if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
                data.hierarchy[h].keys.splice(k, 1);
                k--;
            }
        }

        // set index
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            data.hierarchy[h].keys[k].index = k;
        }
    }
    data.initialized = true;
    return data;
};

AnimationHandler.prototype.parse = function(root) {
    function parseRecurseHierarchy(root, hierarchy) {
        hierarchy.push(root);

        // check Object3D.children if not defined
        // do not animate camera's light node
        if (root.children && !(root instanceof THREE.Camera)) {
            for(var c = 0; c < root.children.length; c++)
                parseRecurseHierarchy(root.children[c], hierarchy);
        }
    }
    var hierarchy = [];
    parseRecurseHierarchy(root, hierarchy);
    return hierarchy;
};

AnimationHandler.prototype.play = function(animation) {
    if (this.animations.indexOf(animation) === -1) {
        this.animations.push(animation);
    }
};

AnimationHandler.prototype.stop = function(animation) {
    var index = this.animations.indexOf(animation);
    if (index !== -1) {
        this.animations.splice(index, 1);
    }
};

AnimationHandler.prototype.update = function(deltaTimeMS) {
    for (var i = 0; i < this.animations.length; i++) {
        this.animations[i].update(deltaTimeMS);
    }
};

var Animation = function(root, data, animator) {
    this.root = root;
    this.handler = animator.animationHandler;
    this.data = this.handler.init(data);
    this.hierarchy = this.handler.parse(root);
    this.viewer = animator.viewer;
    this.animator = animator;

    this.currentTime = 0;
    this.timeScale = 1;

    this.isPlaying = false;
    this.isPaused = true;
    this.loop = false;
    this.delta = 0.5;

    this.interpolationType = INTERPOLATION_TYPE.LINEAR;

    this.setStartAndEndKeyTime();
};

Animation.prototype.setStartAndEndKeyTime = function() {
    if (this.data.hierarchy.length > 0) {
        // root of hierarchy should have key time covering animation
        var keys = this.data.hierarchy[0].keys;
        this.startKeyTime = keys[0].time;
        this.endKeyTime = keys[keys.length-1].time;
    } else {
        this.startKeyTime = this.endKeyTime = 0;
    }
};

Animation.prototype.keyTypes = [];
Animation.prototype.defaultKey = {};

Animation.prototype.play = function(startTime) {
    this.currentTime = startTime !== undefined ? startTime : 0;
    this.isPlaying = true;
    this.isPaused = false;
    this.reset();
    this.handler.play(this);
};

Animation.prototype.pause = function() {
    if (this.isPaused === true) {
        this.handler.play(this);
    } else {
        this.handler.stop(this);
    }
    this.isPaused = !this.isPaused;
};

Animation.prototype.stop = function() {
    this.isPlaying = false;
    this.isPaused  = false;
    this.handler.stop(this);
};

Animation.prototype.goto = function(time) {
    if (!this.isPlaying) this.play();
    if (!this.isPaused) this.pause();
    var delta = time - this.currentTime;
    this.update(delta);
};

Animation.prototype.reset = function() {
    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
        var object = this.hierarchy[h];

        if (object.animationCache === undefined) {
            object.animationCache = {};
        }

        if (object.animationCache[this.data.name] === undefined) {
            object.animationCache[this.data.name] = {
                prevKey: this.defaultKey,
                nextKey: this.defaultKey,
                originalMatrix: object.matrix
            };
        }

        // get keys to match our current time
        var animationCache = object.animationCache[this.data.name];
        for (var t = 0; t < this.keyTypes.length; t++) {
            var type = this.keyTypes[t];
            var prevKey = this.data.hierarchy[h].keys[0];
            var nextKey = this.getNextKeyWith(type, h, 1);
            while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                prevKey = nextKey;
                nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
            }
            animationCache.prevKey[type] = prevKey;
            animationCache.nextKey[type] = nextKey;
        }
    }

    this.setStartAndEndKeyTime();
};

Animation.prototype.getNextKeyWith = function (type, h, key) {
    var keys = this.data.hierarchy[h].keys;
    if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
        this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
        key = key < keys.length - 1 ? key : keys.length - 1;
    } else {
        key = key % keys.length;
    }

    for (; key < keys.length; key++) {
        if (keys[key][type] !== undefined) {
            return keys[key];
        }
    }
    return this.data.hierarchy[h].keys[0];
};

Animation.prototype.getPrevKeyWith = function (type, h, key) {
    var keys = this.data.hierarchy[h].keys;
    if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
        this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
        key = key > 0 ? key : 0;
    } else {
        key = key >= 0 ? key : key + keys.length;
    }

    for (; key >= 0; key--) {
        if (keys[key][type] !== undefined) {
            return keys[key];
        }
    }
    return this.data.hierarchy[h].keys[keys.length - 1];
};

Animation.prototype.isPlayingOutOfRange = function() {
    return (this.isPaused === false && (this.currentTime < this.startKeyTime - this.delta ||
            this.currentTime > this.endKeyTime + this.delta))
};

Animation.prototype.resetIfLooped = function() {
    if (this.loop === true && this.currentTime > this.endKeyTime) {
        this.currentTime %= this.endKeyTime;
        this.reset();
    }
};

var MeshAnimation = function(root, data, animator) {
    Animation.call(this, root, data, animator);
    //this.originalMatrix = root.matrix.clone();
    this.localMatrix = new THREE.Matrix4();
    
    this.root.getAnimTransform();
    this.relativeTransform = (data.custom && data.custom.transform && data.custom.transform === "abs")? false: true;

    /*
    if (this.relativeTransform) {
        //this.root.updateMatrixWorld();
    } else {
        
    }
    */
};

MeshAnimation.prototype = Object.create(Animation.prototype);
MeshAnimation.prototype.constructor = MeshAnimation;
MeshAnimation.prototype.keyTypes = ["pos", "rot", "scl"];
MeshAnimation.prototype.defaultKey = {pos: 0, rot: 0, scl: 0};

MeshAnimation.prototype.update = (function() {
    var points = [];
    var target;
    var newVector;
    var newQuat;
    
    function init_three() {
        if (target)
            return;
    
        target = new THREE.Vector3();
        newVector = new THREE.Vector3();
        newQuat = new THREE.Quaternion();
    }

    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        init_three();

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                // interpolate
                if (type === "pos") {
                    if (this.interpolationType === INTERPOLATION_TYPE.LINEAR) {
                        newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                        newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                        newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                        object.position.copy(newVector);
                    } else /*if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
                        this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD)*/ {
                        points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                        points[1] = prevXYZ;
                        points[2] = nextXYZ;
                        points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];

                        scale = scale * 0.33 + 0.33;

                        var currentPoint = interpolateCatmullRom(points, scale);
                        newVector.x = currentPoint[0];
                        newVector.y = currentPoint[1];
                        newVector.z = currentPoint[2];
                        object.position.copy(newVector);

                        if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                            var forwardPoint = interpolateCatmullRom(points, scale * 1.01);

                            target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                            target.sub(vector);
                            target.y = 0;
                            target.normalize();

                            var angle = Math.atan2(target.x, target.z);
                            object.rotation.set(0, angle, 0);
                        }
                    }
                } else if (type === "rot") {
                    THREE.Quaternion.slerp(prevXYZ, nextXYZ, newQuat, scale);
                    object.quaternion.copy(newQuat);
                } else if (type === "scl") {
                    newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                    newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                    newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                    object.scale.copy(newVector);
                }
            }

            if (this.relativeTransform) {
                // compose local transform and multiply to original transform
                object.updateAnimTransform();
            } else {
                //object.matrixAutoUpdate = true;
                //object.matrixWorldNeedsUpdate = true;
            }

            // update world matrix so scene bounds can be set correctly
            //object.updateMatrixWorld();
        }
    };
})();

var CameraAnimation = function(root, data, animator) {
    Animation.call(this, root, data, animator);
};

CameraAnimation.prototype = Object.create(Animation.prototype);
CameraAnimation.prototype.constructor = CameraAnimation;
CameraAnimation.prototype.keyTypes = ["pos", "up", "target", "fov", "perspective"];
CameraAnimation.prototype.defaultKey = {pos: 0, up: 0, target: 0, fov: 0, perspective:0};

CameraAnimation.prototype.update = (function() {
    var points = [];
    
    var target;
    var newVector;
    function init_three() {
        if (target)
            return;
        target = new THREE.Vector3();
        newVector = new THREE.Vector3();
    }

    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;
        
        init_three();

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime  || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                // interpolate
                var vector;
                if (type === "pos") {
                    vector = object.position;
                } else if (type === "up") {
                    vector = object.up;
                } else if (type === "target") {
                    vector = object.target;
                } else if (type === "fov") {
                    object.setFov(prevXYZ + (nextXYZ - prevXYZ) * scale);
                    continue;
                } else if (type === "perspective") {
                    var mode = scale > 0.5 ? nextXYZ : prevXYZ;
                    if (mode)
                        object.toPerspective();
                    else
                        object.toOrthographic();
                    continue;
                }

                if (this.interpolationType === INTERPOLATION_TYPE.LINEAR) {
                    newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                    newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                    newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                    vector.copy(newVector);
                } else /*if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
                    this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD)*/ {
                    points[0] = this.getPrevKeyWith(type, h, prevKey.index - 1)[type];
                    points[1] = prevXYZ;
                    points[2] = nextXYZ;
                    points[3] = this.getNextKeyWith(type, h, nextKey.index + 1)[type];

                    scale = scale * 0.33 + 0.33;

                    var currentPoint = interpolateCatmullRom(points, scale);
                    newVector.x = currentPoint[0];
                    newVector.y = currentPoint[1];
                    newVector.z = currentPoint[2];
                    vector.copy(newVector);

                    if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                        var forwardPoint = interpolateCatmullRom(points, scale * 1.01);

                        target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                        target.sub(vector);
                        target.y = 0;
                        target.normalize();

                        var angle = Math.atan2(target.x, target.z);
                        object.rotation.set(0, angle, 0);
                    }
                }
            }
            object.matrixAutoUpdate = true;
            object.matrixWorldNeedsUpdate = true;
        }
        object.lookAt(object.target);
        this.animator.updateFlag |= this.animator.UPDATE_CAMERA;
    };
})();

var VisibilityAnimation = function(root, data, nodeId, animator) {
    Animation.call(this, root, data, animator);
    this.nodeId = nodeId;
    this.epsilon = 0.1;

    //Need to clone the material as it can be shared between many objects
    //and we need to modify it for this object specifically
    this.root.setMaterial(this.viewer.matman().cloneMaterial(root.getMaterial()));
};

VisibilityAnimation.prototype = Object.create(Animation.prototype);
VisibilityAnimation.prototype.constructor = VisibilityAnimation;
VisibilityAnimation.prototype.keyTypes = ["vis", "opa"];
VisibilityAnimation.prototype.defaultKey = {viz: 1, opa: 1};

VisibilityAnimation.prototype.update = (function() {
    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevVis = prevKey[type];
                var nextVis = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevVis === undefined || nextVis === undefined) continue;

                var material = object.getMaterial();

                if (type === "vis") {
                    var isNextKey = Math.abs(this.currentTime - nextKey.time) < this.epsilon;
                    var key = isNextKey ? nextKey : prevKey;
                    var vis = isNextKey ? nextVis : prevVis;
                    // set to opaque if vis is 1 and opa is not specified
                    if (vis === 1 && key["opa"] === undefined) {
                        material.transparent = true;
                        material.opacity = 1;
                    }
                    this.viewer.visibilityManager.setNodeOff(this.nodeId, !vis);
                } else if (type === "opa") {
                    var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                    if (scale < 0) scale = 0;
                    if (scale > 1) scale = 1;
                    var opacity = prevVis + (nextVis - prevVis) * scale;
                    
                    material.transparent = (opacity !== 1);
                    material.opacity = opacity;
                    if (opacity > 0) 
                        this.viewer.visibilityManager.setNodeOff(this.nodeId, false);
                }
            }
        }
    };
})();

var AnnotationAnimation = function(root, data, animator) {
    function createAnnotation(data, viewer, state) {
        var container = that.container = document.createElement('div');
        var name = data.name;
        container.id = name;
        container.style.cursor = "pointer";
        container.style.visibility = state;

        var text = document.createElement('div');
        text.id = name + '-txt';
        text.style.cssText = 'display: none;position: absolute;z-index: 1;';
        container.appendChild(text);

        var icon = document.createElement('img');
        var isAttached = data.custom && data.custom.att && data.custom.att === 1;
        icon.src = isAttached? "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAABv1BMVEUAAAAAAAAAAAAAAAABAwEAAAAAAAAjSRkAAAAFDASJqnZhg1IqTyAjSRkpTx8hRxggRRcAAAAhRRcKFwgAAACau4R9mnFmiFUhSBgbOhMZNhIAAAAECQMgQxcAAAAAAAAAAAAHDwXB2q2jw4yfvoivyJ6fuI6mv5eSr4KAoWu2trZpiV3Nzc0wVSUhRxhNT01vb28AAAAgRBcAAAAAAAAAAAAhRxgeQBYAAAAAAAAAAAAfQRbP5MC0zqCqyJKpyJJBYje3z6WxyKOFpXF9nmkrTiG+wb5xkGVcf0xYfEg1WSpNTU0hRhgfQhYfQhZVVVVAQEAXMREcOhQcHBwSJw0AAAAAAAAWLxAVLQ8AAAAAAAAfQhYIEgYAAACbvn+DsGCGsmSUunaItGXc6dStypelxY2ZvX2Ntm2JtGnS48fB17G40aWNuWucxH6ny4mUvnPF27aPuHCEsGHV5czI3Lq52KGvzJqz1JmqyJOqzY6ew4OYwHiGs2OEsWHb29vL4LvM5bnD3q2+3KWkyoaLtWuKtmfOzs7IyMi21pyawXqPuG/g4ODX68fI4rTG4LCu0ZKszJKlx4qZwHuBnXR2iXENcZskAAAAXnRSTlMAEAIBCAsF6BUn+vPu7erjsZyBEwP99/TRk3JgRUQ1IxwO/v79/Pv6+fn09PPq08q7sqWDe2xrY01AMBj+/v7+/v37+fn59fXz8u/c1cbFxLWonZiIcm1lYVdSQT8de/EoFwAAAgVJREFUOMutklVz21AQRiNFlswYs+M6DTdN0kCDZWZmuAKDZFtgiO2YYm6TlOEHV53ptGs5j93Xc+a7e3d36P/W9prdZ/PZ17aPxphz3mR0x91G07wTG8TDo5R3HLGH3S6fGPdSo8Na/to6W2HZBEqwPCNULlu1BkFdQSyKx4qxOMoyDDJSRB/HnTcqWbSbTmVS6V3E57hvXicOBZd1gmfj6Z1kPrmTjrMMfRizumDA+k3UTcRSyWg0mkzFEgLNlU3rIIJcns0KqJjJq0I+U0SqUJlZJv8JugU3J/QnHEwu6MCMqPN1pq+H3sFxCgOC7RyT48Ev6qLUL/gmeJrJ/p0DzSnyxTtAGLMbv9dohv8zSbomSqUpOxB0AdNXsUbnGEEQmJzKq3JrLgCaJAzms5LI1enfVefEamc/YzYQYFB6/1xBUsQex3E9UZHkUvO6X48PwQjLTKEjVRVFqUqd8v6naQsMUCNcL8xTrVJZluXyl1K7OW1+7sL71x15cvVH43O7UGi3mmc8lkCE0ByMbvXazwueycbHxiXPrUdv3hLDGiF8au/d4sO7Novtnj9k0BO45uRGTp98f2JlK/RqYzN8TK8bGTjZLTXgfvDp6rMNA0ZADAOWHI6VTYwE4WAZjz/s3V5yvIxADosIPlh0BNXHSdA8LFIfDgE8WDg5hmmx9h/40fgXth2SDk3yjP4AAAAASUVORK5CYII=" :
        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAABvFBMVEUAAAAAAAADAAAAAAAAAAACAAAAAAAAAAC5PznHVE8BAAAAAADbc27NXVeUDQaZDQaRBwAAAAAAAACHBgDuhoHVa2W9RD2QCAKYCAGPBgB0BQAAAAAAAACMBgAAAAADAAD2jonWb2n2jYjYbWfmeXPNzc3RYFqzODKfFA1RUVGKBgCVBwBvb2+WBwCBBgCFBgCWBwCLBgAAAAAAAACMBgCTBwByBQCTBwBbBACEBgAAAAAAAAAoAgBSBADgeHOoOzXmfnnofnjieHPGvr63t7e0tLTidW/ebmnba2XWZWDAT0qRHBfBSkRNTU2aFxGOBgBYTEsAAACNBgBAQEAAAABbBQAcHBxyBQBKBAAAAABfBAAAAAAAAAAsAgAkAgCJBgDZRT3MOTHQPDTVQjrlUkrjUEjRPjbOOjP/bGTvXFTqV0/fTETNOjL5Zl7eS0PzYFjxXlbiT0fUQTn0e3T7aGDWXFXbSEDTRj/PQTrOPjbb29vgamTxY1zoVE3STETTQjvSPzfOzs7IyMj5g3zzaWLXY13XYVrsXlbbU0zg4OD8lZD4gXq0eHXqd3HscWv2b2jrZmDQZWDdWVLkV1C5y9+5AAAAYHRSTlMAAgUBDggMEeDsIBj+8NHJxpxAEP754tDDtIFsYDkvI/78+/j08/DfycfHxbuvr5mTjYN0bWxkWVZTTDUjEfz8+/n59fT08vHw8PDw5NzV0Mq5uLWrm5iLfX1hV0g/ODZEwKduAAACAklEQVQ4y62SVXPbQBzEa1mWZYaY49ihBhtmKjMzw92JLLBsyxxT2mCZvnCVmU59VpO37Ms97G929nb+p05WXUvTE5GJ6aWuY+yFEdoVdAZd9MjCEYi5J0L3FZutSqVZdIYiPWaj/85j2yszAACGVyq7Lo+RIMZtxRaQOZaTwZZSLbrGLR2+aX54twVykpgVpRzgYbVGz5twYMPTV2ZkKZMupDOSzAiwfNazgQesDO9VASemU6lUWuQAgnyNXsEiiBlbEwE2W9CBQpbVAfRraIZoA5ZosII6EpB6MYrVpLxOQejowKsBL9UGSK+zCnnsF4omB7wkBkQHylDZ+rcDROD3hYcYQE0NHQhQ4f8uCQVG/XF9isJKLtI1TYBQQAgdPlqJzYcWMYBYd58/YJACD6UgpsTVA+51AhvKGgt9zQGN1xN4Dajs/vbtmBXf2mIP3/jGqiW9Q0nlGtn8tXBSnwGPWHYP5PcbLMs2JHFn+6p7WQ/ARTie3/rZm9+pZ+rfP/fawi8dhOFgqLlLX87dHOz/1D9ou/vsrcNiNgBrZzbf338yOXZvbDL2xm4ljCdn6j794cpswr/62p+wWy2m/042oQeMxudedK8mSdzGAy4/9vlm/STRtjGRTz9u3nnge2U3+O2h4o9GfXG7lcLKGWZY8ycduG3sQJCk0Tb+w3S0/Qemc4+eJchuZgAAAABJRU5ErkJggg==";
        icon.id = name + '-img';
        icon.style.cssText = 'display: block;position: absolute;z-index: 1;';
        container.appendChild(icon);

        viewer.api.container.appendChild(container);

        container.addEventListener('click', function () {
            text.style.display = text.style.display === 'none'? 'block' : 'none';
        });

        var color = 0x007F00;
        var opacity = 0.6;
        var geometry = new THREE.SphereGeometry(0.01);
        var material = new THREE.MeshPhongMaterial({color:color, ambient:color, opacity:opacity, transparent:true});
        var mesh = new THREE.Mesh(geometry, material);
        mesh.visible = false;

        if (viewer.overlayScenes["annotation"] === undefined) {
        // add annotation to an overlay scene
            viewer.createOverlayScene("annotation");
        }
        viewer.addOverlay("annotation", mesh);

        return mesh;
    }

    var that = this;
    if (root === null) {
        root = createAnnotation(data, animator.viewer, 'hidden');
    }
    Animation.call(this, root, data, animator);
    this.id = data.name;
    this.text = "";
    this.state = 'hidden';
    this.epsilon = 0.1;

    this.viewer.api.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, function(evt) {
        that.updateText(root.position, that.text);
    });
};

AnnotationAnimation.prototype = Object.create(Animation.prototype);
AnnotationAnimation.prototype.constructor = AnnotationAnimation;
AnnotationAnimation.prototype.keyTypes = ["pos", "text", "vis"];
AnnotationAnimation.prototype.defaultKey = {pos: 0, text: "", vis: 1};

AnnotationAnimation.prototype.stop = function() {
    Animation.prototype.stop.call(this);
    this.container.parentNode.removeChild(this.container);
    this.viewer.removeOverlay("annotation", this.root);
    this.root = null;
};

AnnotationAnimation.prototype.updateText = function(position, text) {
    function projectToScreen(position, camera, canvas) {
        var pos = position.clone();
        var projScreenMat = new THREE.Matrix4();
        camera.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        projScreenMat.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        pos.applyProjection(projScreenMat);

        return {x: (pos.x + 1) * canvas.width / 2 + canvas.offsetLeft,
                y: (-pos.y + 1) * canvas.height / 2 + canvas.offsetTop};
    }
    var coord = projectToScreen(position, this.viewer.camera, this.viewer.canvas);
    var element = document.getElementById(this.id + '-txt');
    if (element) {
        element.innerHTML = text;
        element.style.left = coord.x + 'px';
        element.style.top = coord.y + 'px';
        this.text = text;
    }
    element = document.getElementById(this.id + '-img');
    if (element) {
        element.style.left = coord.x + 'px';
        element.style.top = coord.y - 24 + 'px'; // adjust based on image height
    }
};

AnnotationAnimation.prototype.update = (function() {
    var points = [];

    var target;
    var newVector;
    function init_three() {
        if (target)
            return;
        target = new THREE.Vector3();
        newVector = new THREE.Vector3();
    }


    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        init_three();

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        // restore and return if paused before start key
        if (this.isPaused && this.currentTime < this.startKeyTime) {
            var element = document.getElementById(this.id);
            if (element) element.style.visibility = this.state;
            return;
        }

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                // interpolate
                if (type === "pos") {
                    if (this.interpolationType === INTERPOLATION_TYPE.LINEAR) {
                        newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                        newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                        newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                        object.position.copy(newVector);
                    } else if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
                        this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                        points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                        points[1] = prevXYZ;
                        points[2] = nextXYZ;
                        points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];

                        scale = scale * 0.33 + 0.33;

                        var currentPoint = interpolateCatmullRom(points, scale);
                        newVector.x = currentPoint[0];
                        newVector.y = currentPoint[1];
                        newVector.z = currentPoint[2];
                        object.position.copy(newVector);

                        if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                            var forwardPoint = interpolateCatmullRom(points, scale * 1.01);

                            target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                            target.sub(vector);
                            target.y = 0;
                            target.normalize();

                            var angle = Math.atan2(target.x, target.z);
                            object.rotation.set(0, angle, 0);
                        }
                    }

                } else if (type === "text") {
                    var text = Math.abs(this.currentTime - nextKey.time) < this.epsilon ? nextXYZ : prevXYZ;
                    this.updateText(object.position, text);
                } else if (type === "vis") {
                    var element = document.getElementById(this.id);
                    if (element) {
                        var visible = Math.abs(this.currentTime - nextKey.time) < this.epsilon ? nextXYZ : prevXYZ;
                        element.style.visibility = visible? 'visible' : 'hidden';
                    }
                }
            }
            object.matrixAutoUpdate = true;
            object.matrixWorldNeedsUpdate = true;
        }
    };
})();

var PolylineAnimation = function(root, data, animator) {
    this.viewer = animator.viewer;
    if (root === null) {
        root = this.createPolyline([]);
    }
    Animation.call(this, root, data, animator);
    this.epsilon = 0.1;
};

PolylineAnimation.prototype = Object.create(Animation.prototype);
PolylineAnimation.prototype.constructor = PolylineAnimation;
PolylineAnimation.prototype.keyTypes = ["points", "vis"];
PolylineAnimation.prototype.defaultKey = {points: [], vis: 1};

PolylineAnimation.prototype.stop = function() {
    Animation.prototype.stop.call(this);
    this.viewer.removeOverlay("polyline", this.root);
    this.root = null;
};

PolylineAnimation.prototype.update = (function() {
    function removePolyline(anim) {
        if (anim.root) {
            anim.viewer.removeOverlay("polyline", anim.root);
            anim.root = null;
        }
    }

    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        // restore and return if paused before start key
        if (this.isPaused && this.currentTime < this.startKeyTime) {
            removePolyline(this);
            return;
        }

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop thru keys
            for (var t = 0; t < this.keyTypes.length; t++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevPoints = prevKey[type];
                var nextPoints = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevPoints === undefined || nextPoints === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                if (type === "points") {
                    // interpolate start and end points
                    var points = scale < 0.5? prevPoints : nextPoints;
                    this.viewer.removeOverlay("polyline", this.root);
                    this.root = null;
                    var vertices = [];
                    for (var i = 0; i < points.length; i++) {
                        var pt = points[i].slice();
                        if (i === 0) {
                            pt[0] = prevPoints[i][0] + (nextPoints[i][0] - prevPoints[i][0]) * scale;
                            pt[1] = prevPoints[i][1] + (nextPoints[i][1] - prevPoints[i][1]) * scale;
                            pt[2] = prevPoints[i][2] + (nextPoints[i][2] - prevPoints[i][2]) * scale;
                        }
                        else if (i === points.length-1) {
                            var p = prevPoints.length - 1;
                            var n = nextPoints.length - 1;
                            pt[0] = prevPoints[p][0] + (nextPoints[n][0] - prevPoints[p][0]) * scale;
                            pt[1] = prevPoints[p][1] + (nextPoints[n][1] - prevPoints[p][1]) * scale;
                            pt[2] = prevPoints[p][2] + (nextPoints[n][2] - prevPoints[p][2]) * scale;
                        }
                        var newpt = new THREE.Vector3(pt[0], pt[1], pt[2]);
                        vertices.push(newpt);
                    }
                    this.root = this.createPolyline(vertices);
                } else if (type === "vis") {
                    var vis = Math.abs(this.currentTime - nextKey.time) < this.epsilon ? nextPoints : prevPoints;
                    this.root.visible = vis;
                    if (!vis) removePolyline(this);
                }
            }
        }
    };
})();

PolylineAnimation.prototype.createPolyline = function(points) {
    var geometry = new THREE.Geometry();
    for (var i = 0; i < points.length; i++) {
        geometry.vertices.push(points[i]);
    }
    geometry.computeLineDistances();

    var material = new THREE.LineDashedMaterial({color: 0x0, dashSize:1, gapSize:0.5, linewidth:1});
    var line = new THREE.Line(geometry, material, THREE.LineStrip);

    // add polyline to an overlay scene
    if (this.viewer.overlayScenes["polyline"] === undefined) {
        this.viewer.createOverlayScene("polyline");
    }
    this.viewer.addOverlay("polyline", line);

    return line;
};

// Catmull-Rom spline
function interpolateCatmullRom(points, scale) {
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5,
            v1 = (p3 - p1) * 0.5;

        return (2 * (p1 - p2) + v0 + v1) * t3 + (- 3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }

    var c = [], v3 = [],
    point, intPoint, weight, w2, w3,
    pa, pb, pc, pd;

    point = (points.length - 1) * scale;
    intPoint = Math.floor(point);
    weight = point - intPoint;

    c[0] = intPoint === 0 ? intPoint : intPoint - 1;
    c[1] = intPoint;
    c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
    c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

    pa = points[c[0]];
    pb = points[c[1]];
    pc = points[c[2]];
    pd = points[c[3]];

    w2 = weight * weight;
    w3 = weight * w2;

    v3[0] = interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
    v3[1] = interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
    v3[2] = interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);

    return v3;
}


avp.Animation = Animation;
avp.AnimationHandler = AnimationHandler;
avp.MeshAnimation = MeshAnimation;
avp.CameraAnimation = CameraAnimation;
avp.PolylineAnimation = PolylineAnimation;
avp.VisibilityAnimation = VisibilityAnimation;
avp.AnnotationAnimation = AnnotationAnimation;


})();;
(function() {

"use strict";

var avp = Autodesk.Viewing.Private;

/**
 *  This is the keyframe animator class that performs keyframe animation
 *
 *  @constructor
 *  @alias Autodesk.Viewing.Private.KeyFrameAnimator
 *  @param {Viewer3DImpl} viewer The viewer
 *  @param {number} duration The duration of the animation in seconds
 */
var KeyFrameAnimator = function(viewer, duration) {
    this.animations = [];
    this.viewer = viewer;
    this.keys = [];
    this.isPlaying = false;
    this.isPaused = true;
    this.updateFlag = 0;
    this.duration = duration;
    this.currentTime = 0;
    this.onPlayCallback = null;
    this.animationHandler = new Autodesk.Viewing.Private.AnimationHandler();
    this.areCameraAnimationsPaused = false;
    this.UPDATE_SCENE = 1;
    this.UPDATE_CAMERA = 2;
};

/**
 * Destructor. Releasing references to other objects.
 */
KeyFrameAnimator.prototype.destroy = function() {
    this.stop();
    this.viewer = null;
    this.keys = null;
    this.animations = null;
    this.isPlaying = false;
    this.isPaused = false;
    this.animationHandler = null;
};

/**
 * Add an animation to the keyframe animator
 *
 * @param {object} animation The animation object to add
 */
KeyFrameAnimator.prototype.add = function(animation) {
    // return if animation has no hierarchy data or less than two keys
    if (!animation.hierarchy || animation.hierarchy.length < 1 || !animation.hierarchy[0].keys ||
        animation.hierarchy[0].keys.length < 2)
        return;

    var anim = null;
    var that = this;
    if (animation.type === "camera") {
        anim = new avp.CameraAnimation(that.viewer.camera, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "annotation") {
        anim = new avp.AnnotationAnimation(null, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "polyline") {
        anim = new avp.PolylineAnimation(null, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "mesh" || animation.type === "visibility") {
    
        that.viewer.model.getData().instanceTree.enumNodeFragments(animation.id, function(fragId) {

            var mesh = that.viewer.getFragmentProxy(that.viewer.model, fragId);
            if (mesh) {
                // meshes of the node will share same data
                if (animation.type === "mesh")
                    anim = new avp.MeshAnimation(mesh, animation, that);
                else
                    anim = new avp.VisibilityAnimation(mesh, animation, animation.id, that);
                    
                that.animations.push(anim);
            }
        
        }, true);
    
    }


    // sort and remove duplicates
    function sortAndRemoveDuplicateKeys(keys) {
        function removeDuplicates(a,b,c) {
            b=a.length;while(c=--b)while(c--)a[b]!==a[c]||a.splice(c,1);
        }

        // sort keys
        keys.sort(function(a, b) {return a-b});

        // remove duplicates
        removeDuplicates(keys);
    }

    if (anim) {
        // add keys
        for (var h = 0, hl = animation.hierarchy.length; h < hl; h ++) {
            var keys = animation.hierarchy[h].keys;
            for (var i = 0; i < keys.length; i++) {
                // add user defined (non extra) keys
                if (keys[i].xk === undefined)
                    that.keys.push(keys[i].time);
            }
        }
        sortAndRemoveDuplicateKeys(that.keys);
    }

    this.updateFlag |= this.UPDATE_SCENE;
};

/**
 * Update all animations in the keyframe animator
 *
 * @param {number} time The time in second to advance
 * @return {number} 0 for no update, 1 for scene, 2 for camera, 3 for both
 */
KeyFrameAnimator.prototype.update = function(time) {
    this.animationHandler.update(time);
    var update = this.updateFlag;
    if (this.isPlaying && !this.isPaused) {
        this.currentTime += time;
        this.currentTime = Math.min(this.currentTime, this.duration);
        if (this.onPlayCallback) {
            // send playback percentage
            this.onPlayCallback(this.duration > 0? this.currentTime / this.duration * 100 : 0);    
        }
        if (this.currentTime >= this.duration) {
            this.pause();
        }
        update |= this.UPDATE_SCENE;
    }
    this.updateFlag = 0;
    return update;
};

/**
 * Play all animations
 *
 * @param {number} startTime The time in second to start
 */
KeyFrameAnimator.prototype.play = function(startTime, onPlayCallback) {
    this.onPlayCallback = onPlayCallback;

    // auto-rewind and play if reached the end
    if (this.currentTime >= this.duration) {
        this.goto(0);
    }

    if (this.isPlaying) {
        this.pause();
        return;
    }

    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.play(startTime);
    }

    this.isPlaying = true;
    this.isPaused = false;
};

/**
 * Pause all animations
 *
 */
KeyFrameAnimator.prototype.pause = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        // pause sync with same state
        if (animation.isPaused === this.isPaused) {
            animation.pause();
        }
    }

    this.isPaused = !this.isPaused;
    this.areCameraAnimationsPaused = this.isPaused;
};

/**
 * Pause camera animations
 *
 */
KeyFrameAnimator.prototype.pauseCameraAnimations = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        if (animation instanceof Autodesk.Viewing.Private.CameraAnimation) {
            animation.pause();
        }
    }

    this.areCameraAnimationsPaused = !this.areCameraAnimationsPaused;
};

/**
 * Stop all animations
 *
 */
KeyFrameAnimator.prototype.stop = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.stop();
    }

    this.isPlaying = false;
    this.isPaused  = false;
};

/**
 * Goto specific time in the animation
 *
 * @param {number} time The specific time in second
 */
KeyFrameAnimator.prototype.goto = function(time) {
    if (time === undefined) return;
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.goto(time);
    }

    this.isPlaying = true;
    this.isPaused  = true;
    this.currentTime = time;
    this.updateFlag |= this.UPDATE_SCENE;
};

/**
 * Step forward to next key
 *
 */
KeyFrameAnimator.prototype.next = function() {
    // find next key time
    function findNextKey(time, keys) {
        var key = -1;
        for (var t = 0; t < keys.length; t++) {
            if (keys[t] > time) {
                key = keys[t];
                break;
            }
        }
        return (key < 0? keys[keys.length-1] : key);
    }
    var time = findNextKey(this.currentTime, this.keys);
    this.goto(time);
};

/**
 * Step backward to previous key
 *
 */
KeyFrameAnimator.prototype.prev = function() {
    // find previous key time
    function findPrevKey(time, keys) {
        var key = -1;
        for (var t = keys.length-1; t > -1; t--) {
            if (keys[t] < time) {
                key = keys[t];
                break;
            }
        }
        return (key < 0? keys[0] : key);
    }
    var time = findPrevKey(this.currentTime, this.keys);
    this.goto(time);
};

avp.KeyFrameAnimator = KeyFrameAnimator;


})();;
if (ENABLE_DEBUG === undefined)
    var ENABLE_DEBUG = true;

if (ENABLE_TRACE === undefined)
    var ENABLE_TRACE = true;

(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

avp.RENDER_NORMAL      = 0;//=== RenderQueue.NORMAL !!!
avp.RENDER_HIGHLIGHTED = 1;//=== RenderQueue.HIGHLIGHTED !!!
avp.RENDER_HIDDEN      = 2;//=== RenderQueue.HIDDEN !!!
avp.RENDER_FINISHED    = 3;

//default parameters for WebGL initialization
av.InitParametersSetting = {
    canvas: null,
    antialias: false,
    alpha: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    stencil: false,
    depth: false,
    devicePixelRatio: null
};



/** @constructor */
function Viewer3DImpl(thecanvas, theapi)
{
    var _this = this;

    //Frame time cutoffs in milliseconds. We target the middle value,
    //but adjust the CPU-side work in the give min/max range
    //once we measure actual frame times (including async GPU work, system load, etc).
    //NOTE: These are doubled for mobile devices at construction time (end of this file).
    var MAX_FRAME_TIME = 1000 / 15,
        TARGET_FRAME_TIME = 1000 / 30,
        MIN_FRAME_TIME = 1000 / 120; //We aren't hoping for 120 fps -- this is just how often tick() gets called
                                     //not counting GPU latency, etc.

    var _phase = avp.RENDER_NORMAL;

    var _currentLightPreset = -1;
    var _oldLightPreset = -1;

    var _lastTickMoved = false;

    var _worldUp = new THREE.Vector3(0,1,0);
    var _worldUpName = "y";

    var _reqid, _needsResize, _newWidth, _newHeight, _materials;
    var _webglrender, _renderer;

    var _needsClear = false,
        _needsRender = false,
        _overlayDirty = false;

    var _sceneDirty = false;

    var _cameraUpdated;

    var _explodeScale = 0;

    var _lastBeginFrameTimeStamp = 0, _beginFrameAvg = 0;

    var _lastHighResTimeStamp = 0;

    var _frameTimeAvg = 1000.0 / 60.0;

    var _isLoading = true;  // turned off in onLoadComplete()

    var _groundShadow, _groundReflection;

    var _envMapBackground = false;

    var _modelQueue = new avp.RenderScene();

    /*
    if (thecanvas) {
        setInterval(function() {
            if (_isLoading) {
                return;
            }
            _this.log({ name: 'fps', value: _this.fps(), aggregate: 'last' });

        }, 30000);
    }
    */

    function createRenderer(canvas) {

        if (!av.isBrowser)
            return null;

        //TODO: improve the pixel scale heuristics below
        var dpr = window.devicePixelRatio;
        if (!dpr) dpr = 1;

        //High density display -- turn off antialiasing since
        //it's not worth the slowdown in that case.
        //if (dpr >= 2.0)
        //    _settings.antialias = false;

        //Expose the pramaters to outside so that we could set these params on HTML.
        var params = av.InitParametersSetting;
        params.canvas=canvas;
        params.devicePixelRatio=dpr;
        
        var renderer = new FireflyWebGLRenderer(params);

        renderer.autoClear = false;

        //Turn off scene sorting by THREE -- this is ok if we
        //do progressive draw in an order that makes sense
        //transparency-wise. If we start drawing using a frustum culling
        //r-tree or there are problems with transparency we'd have to turn on sorting.
        renderer.sortObjects = false;

        return renderer;
    }


    //Bridge between the render queue and render context
    //For passing pieces of model to the renderer during
    //timed progressive rendering, while also taking into account
    //the current rendering mode of the viewer
    function renderSomeCallback(scene) {

        //Ideally, here we only want the piece of the
        //render function that specifically renders geometries,
        //and none of the camera update stuff that we already do
        //once in beginProgressive() -- but this requires
        //some refactoring of THREE.WebGLRenderer.
        var phase = _phase;
        var wantColor = true;
        var wantSAO = phase == avp.RENDER_NORMAL;
        var wantID = _renderer.settings.idbuffer && phase != avp.RENDER_HIDDEN;

        if (phase == avp.RENDER_HIDDEN)
            scene.overrideMaterial = _this.fadeMaterial;
        else if (phase == avp.RENDER_HIGHLIGHTED)
            scene.overrideMaterial = _this.highlightMaterial;

        _renderer.renderScenePart(scene, wantColor, wantSAO, wantID);

        scene.overrideMaterial = null;

    }

    function updateFPS(highResTimeStamp) {
        if (_lastHighResTimeStamp > 0)
        {
            _frameTimeAvg = _frameTimeAvg * 0.8 + (highResTimeStamp - _lastHighResTimeStamp) * 0.2;
        }

        if (_this.fpsCallback)
            _this.fpsCallback(_this.fps());
    }

    function updateAnimations(highResTimeStamp) {
        if (_this.keyFrameAnimator) {
            var delta = _lastHighResTimeStamp > 0 ? (highResTimeStamp - _lastHighResTimeStamp) / 1000 : 0;
            var updateFlags = _this.keyFrameAnimator.update(delta);
            if (updateFlags) {
                _this.sceneUpdated(true);
                if (updateFlags & _this.keyFrameAnimator.UPDATE_CAMERA)
                    return true;
            }
        }
        return false;
    }

    function updateCanvasSize() {
        if (_needsResize) {
            _this.camera.aspect = _newWidth/_newHeight;
            _this.camera.clientWidth = _newWidth;
            _this.camera.clientHeight = _newHeight;
            _renderer.setSize(_newWidth,_newHeight);
            _this.controls.handleResize();
            if (_groundReflection)
                _groundReflection.setSize(_newWidth, _newHeight);
            _this.invalidate(true, true, true);
            _needsResize = false;
            _this.api.fireEvent({
                type: av.VIEWER_RESIZE_EVENT,
                width: _newWidth,
                height: _newHeight
            });
        }
    }

    var updateGroundShadow = (function() {
        var MAX_PROCESS_FRAMES = 10;    // max number of frames over which shadows take to process
        var MIN_SCENES_PER_FRAME = 10;  // minimum number of scenes to process each frame

        var qScenes;
        var qSceneCount = 0;
        var qSceneIdx = 0;
        var maxScenesPerFrame = 0;

        return function updateGroundShadow(colorClear) {

            if (!_groundShadow.enabled ||
                _this.is2d ||
                _modelQueue.isEmpty() ||
                _isLoading)
                return false;

            // color buffer was cleared, need to draw shadow
            if (colorClear)
                _groundShadow.rendered = false;

            //this will happen once the linear render list is replaced
            //by the BVH.
            if (qScenes != _modelQueue.getGeomScenes())
                _groundShadow.needClear = true;

            // reset
            if (_groundShadow.needClear) {
                _groundShadow.clear();
                _groundShadow.needClear = false;

                qScenes = _modelQueue.getGeomScenes();
                qSceneCount = qScenes.length;
                qSceneIdx = 0;
                maxScenesPerFrame = Math.max( Math.ceil(qSceneCount / MAX_PROCESS_FRAMES), MIN_SCENES_PER_FRAME );
            }

            // ready to render
            if (_groundShadow.isValid()) {
                if (!_groundShadow.rendered &&
                    !_groundReflection) {
                    _groundShadow.renderShadow(_this.camera, _renderer.getColorTarget());
                    _groundShadow.rendered = true;
                }
            }

            // progressive draw into shadow
            else {
                var i = 0;
                while (i < maxScenesPerFrame && qSceneIdx < qSceneCount) {
                    var qScene = qScenes[qSceneIdx];

                    if (qScene) {
                        // passing forceVisible to FireflyWebGLRenderer.projectObject()
                        qScene.forceVisible = true;
                        _groundShadow.renderIntoShadow(qScene);
                        qScene.forceVisible = false;
                        i++;
                    }

                    qSceneIdx++;
                }

                // finish
                if (qSceneIdx >= qSceneCount) {
                    _groundShadow.postprocess();

                    if (!_groundShadow.rendered &&
                        !_groundReflection) {
                        _groundShadow.renderShadow(_this.camera, _renderer.getColorTarget());
                        _groundShadow.rendered = true;
                    }

                    return true;
                }
            }

            return false;
        };
    })();

    var updateGroundReflection = (function() {
        var MAX_PROCESS_FRAMES = 20;
        var MIN_SCENES_PER_FRAME = 1;

        var qScenes;
        var qSceneCount = 0;
        var qSceneIdx = 0;
        var maxScenesPerFrame = 0;

        return function updateGroundReflection(needClear) {

            if (!_groundReflection ||
                (_groundReflection.finished && !needClear) ||
                _this.is2d ||
                _modelQueue.isEmpty() ||
                _isLoading)
                return;

            // reset
            if (needClear) {
                _groundReflection.clear();
                _groundReflection.updateCamera(_this.camera);
                _groundReflection.rendered = false;
                _groundReflection.finished = false;

                if (_groundReflection.isGroundCulled())
                    return;

                qScenes = _modelQueue.getGeomScenes();
                qSceneCount = qScenes.length;
                qSceneIdx = 0;
                maxScenesPerFrame = Math.max( Math.ceil(qSceneCount / MAX_PROCESS_FRAMES), MIN_SCENES_PER_FRAME );
            }

            if (_groundReflection.isGroundCulled())
                return;

            // progressive draw into reflection
            var i = 0;
			// if progressive rendering is off, or it's on and i < maxScenesPerFrame, then render
			// the ground reflection; also check that the scene index is less than the scene count
			// for the loop itself.
            while ( (!_this.progressiveRender || (i < maxScenesPerFrame)) &&
				(qSceneIdx < qSceneCount) ) {
                var qScene = qScenes[qSceneIdx];

                if (qScene) {
                    // passing forceVisible to FireflyWebGLRenderer.projectObject()
                    qScene.forceVisible = true;
                    _groundReflection.renderIntoReflection(qScene);
                    qScene.forceVisible = false;
                    i++;
                }

                qSceneIdx++;
            }

            // reflection was dirtied (rendered into)
            if (qSceneIdx < qSceneCount)
                _groundReflection.rendered = false;
            else
                _groundReflection.finished = true;

            // draw out reflection
            //
            // if not rendered
            // if not below ground
            //   if finished or
            //   if progressive reflections, color pass has to be processing
            //   i.e., if color pass done then only draw the finished reflections
            if (!_groundReflection.rendered &&
                !_groundReflection.isGroundCulled() && (
                    _groundReflection.finished ||
                    !_modelQueue.isDone()
                )) {

                _groundReflection.postprocess(_this.camera, _materials);

                if (_groundShadow.enabled && _groundShadow.isValid()) {
                    _groundShadow.renderShadow(_this.camera, _groundReflection.outTarget);
                    _groundShadow.rendered = true;
                }

                _groundReflection.renderReflection(_this.camera, _renderer.getColorTarget());
                _groundReflection.rendered = true;

                // if color pass already finished, non-progressive case
                if (_modelQueue.isDone()) {
                    // if ghosting, draw after refls are done
                    if (_this.showGhosting && !_modelQueue.areAllVisible()) {
                        _phase = avp.RENDER_HIDDEN;
                        _modelQueue.reset(_this.camera, _phase);
                    }
                    // else, just draw result
                    else {
                        _renderer.presentBuffer();
                    }
                }
            }

        };
    })();

    function updateGroundTransform() {
        if (!_groundShadow.enabled && !_groundReflection || _this.is2d)
            return;

        var groundBox;
        if (_this.model && !_this.model.isLoadDone()) {
            groundBox = _this.model.getData().bbox;
        }
        else {
            groundBox = _this.getVisibleBounds(true, false);
        }
        if (!groundBox)
            return;

        _groundShadow.needClear = true;

        var camera = _this.camera;
        var bbox = groundBox.clone();

        var rightAxis = new THREE.Vector3(1, 0, 0);
        var bcenter = bbox.center();
        var bsize = bbox.size();
        if (camera.worldUpTransform) {
            rightAxis.applyMatrix4(camera.worldUpTransform);
            bbox.applyMatrix4(camera.worldUpTransform);
            //bcenter.applyMatrix4(camera.worldUpTransform);
            bsize = bbox.size();
        }
        bsize.multiply(new THREE.Vector3(1.25, 1.01, 1.25));
        bsize.x = bsize.z = Math.max(bsize.x, bsize.z); // maintain square texture
        _groundShadow.setTransform(
            bcenter,
            bsize,
            camera.worldup,
            rightAxis
        );

        if (_groundReflection) {
            var groundPos = (new THREE.Vector3()).subVectors(bcenter, camera.worldup.clone().multiplyScalar(bsize.y/2));
            _groundReflection.setTransform(groundPos, camera.worldup, bsize);
        }
    }

    function updateScene(highResTimeStamp) {
        if (_sceneDirty) {
            updateGroundTransform();
            _sceneDirty = false;
        }
    }

    function updateOverlays(highResTimeStamp) {

        //Update the selection set cloned meshes
        for (var id in _this.selectionMeshes) {

            var m = _this.selectionMeshes[id];
            m.model.getFragmentList().getWorldMatrix(m.fragId, m.matrix);

        }

    }


    //Main animation loop -- update camera,
    //advance animations, render if needed.
    function tick(highResTimeStamp)
    {
        //Did the window resize since last tick?
        if (_needsResize) updateCanvasSize();

        //Texture uploads of newly received textures
        _materials.updateMaterials();

        //Do animations -- this has to be done
        //before the scene update below
        var animationMoved = updateAnimations(highResTimeStamp);

        var controlsMoved = _this.controls.update(highResTimeStamp);

        var moved = controlsMoved || animationMoved || _cameraUpdated;

        _needsClear = _needsClear || moved;
        _overlayDirty = _overlayDirty || moved;

        if (_overlayDirty)
            updateOverlays(highResTimeStamp);

        _overlayDirty = _overlayDirty || _renderer.overlayUpdate(highResTimeStamp);

        // ??? By adding on demand loading geometry, the progress of rendering now
        // ??? will proceed back and forth a few times.
        var signalProgressByRendering = _this.model && (_this.model.isLoadDone() ||
            (_this.model.myData.partPacksLoadDone == true));

        var frameBudget = _this.progressiveRender ? _this.targetFrameTime : 1e10;
        var frameRemaining = frameBudget;
        var q = _modelQueue;

        //Has the geometry changed since the last frame.
        //Note this is not the same as just the camera moving, it indicates
        //that meshes have changed position, e.g. like during explode.
        if (_sceneDirty) updateScene(highResTimeStamp);

        //Whether we will reset the render queue -- we could
        //do that without a screen clear in case we are just
        //loading new data without motion.
        if (_needsClear || _needsRender) {

            if (signalProgressByRendering)
                _this.signalProgress(0, null); //zero out the progress bar for when rendering begins

            //Measure actual frame time between two consecutive initial frames.
            //This is used to correct measured per-scene times to what they actually take
            //once the async processing of the graphics thread is taken into account.
            if (_lastBeginFrameTimeStamp > 0) {
                var delta = highResTimeStamp - _lastBeginFrameTimeStamp;
                _beginFrameAvg = 0.75 * _beginFrameAvg + 0.25 * delta;
            }
            _lastBeginFrameTimeStamp = highResTimeStamp;

            //Adjust frame time allowance based on actual frame rate,
            //but stay within the given boundaries.
            if (_beginFrameAvg < TARGET_FRAME_TIME && frameBudget < MAX_FRAME_TIME)
                _this.targetFrameTime += 1;
            else if (_beginFrameAvg > TARGET_FRAME_TIME && frameBudget > MIN_FRAME_TIME)
                _this.targetFrameTime -= 1;

            _this.updateCameraMatrices();

            _renderer.beginScene(_this.scene, _this.camera, _this.lights, _needsClear);

            if (moved) {
                _this.api.fireEvent(_this.cameraChangedEvent);
            }

            if (q) {
                if (q.hasHighlighted()) {
                    //If we have objects in the render queue that are set
                    //to draw as "highlighted", render them first
                    _phase = avp.RENDER_HIGHLIGHTED;
                    q.reset(_this.camera, _phase, moved | _needsClear);
                } else {
                    // If nothing is highlighted just skip the highlighted phase
                    _phase = avp.RENDER_NORMAL;
                    q.reset(_this.camera, _phase, moved | _needsClear);
                }
            }
        } else {
            _lastBeginFrameTimeStamp = -1;
        }

        // process shadows before color pass draw but after color clear
        // so that if it finishes it can immediately render to the current frame
        var shadowDone = updateGroundShadow(_needsClear);
        _overlayDirty = _overlayDirty || shadowDone;

        // process reflections after shadows, if it finishes it can render on top of reflections
        updateGroundReflection(_needsClear);

        //Render some meshes until we run out of time
        if (!q.isEmpty() && !q.isDone()) {

            frameRemaining = q.renderSome(renderSomeCallback, frameRemaining);

            if (q.isDone() && _phase === avp.RENDER_HIGHLIGHTED) {
                _phase = avp.RENDER_NORMAL;
                q.reset(_this.camera, _phase);

                // Allow the use of the remaining frame time to draw normal objects.
                frameRemaining = q.renderSome(renderSomeCallback, frameRemaining);
            }

            //if needed apply post-process to copy render target to screen
            if (!moved && !_overlayDirty) {
                updateFPS(highResTimeStamp);

                 _renderer.composeFinalFrame();
            }

            if (q.isDone()) {
                if (_phase === avp.RENDER_NORMAL &&
                    !q.areAllVisible() &&
                    _this.showGhosting)
                {
                    // delay render hidden until reflections are done
                    if (!_groundReflection || _groundReflection.finished) {
                        _phase = avp.RENDER_HIDDEN;
                        q.reset(_this.camera, _phase);
                    }
                }
                else
                {
                    _phase = avp.RENDER_FINISHED;
                    _renderer.renderScenePart(_this.sceneAfter, true, true, true);
                    _renderer.composeFinalFrame(moved && _this.skipAOWhenMoving, true);
                }

                if (signalProgressByRendering)
                    _this.signalProgress(100.0, null);
            }
            else {
                if (signalProgressByRendering)
                    _this.signalProgress(100.0 * q.getRenderProgress(), null);
            }
        }
        //Render selection highlight / pivot / HUD overlays and post-processing stuff
        if (_overlayDirty) {

            _renderer.renderScenePart(_this.sceneAfter, true, true, true);

            if ((!q.isEmpty() && q.isDone()) || _this.showOverlaysWhileMoving) {
                _this.renderOverlays();

                //During progressive rendering, we want to
                //continue rendering overlays until the queue is done
                //because adding more to the scene will affect the z buffer
                //which would change which parts of the overlays is visible.
                if (!q.isEmpty() && !q.isDone())
                    _overlayDirty = true;
            } else {
                _renderer.clearAllOverlays();
            }

            _renderer.composeFinalFrame((moved || q.isEmpty() || !q.isDone()) && _this.skipAOWhenMoving, q && q.isDone());

            updateFPS(highResTimeStamp);
        }

        //Finally, draw the AO pass, in case we skip AO pass when moving or progressive repaint.
        if (_lastTickMoved && !moved && _this.skipAOWhenMoving)
            _renderer.composeFinalFrame();
        _lastTickMoved = moved;

        _lastHighResTimeStamp = highResTimeStamp;

        // At the end of this tick, lets see whether need a re-render,
        // if page out started but failed, we need a re-run.
        if (q && q.needsRender()) {
            _needsRender = true;
            q.resetNeedsRender();
        }
        else {
            _needsRender = false;
        }

        _needsClear = false;
        _cameraUpdated = false;
    }


    this.run = function() {
        //Begin the render loop
        _reqid = 0;
        (function animloop(highResTimeStamp) {
            _reqid = window.requestAnimationFrame(animloop);
            tick(highResTimeStamp);
        })();
    };

    this.toggleProgressive = function(value) {
        this.progressiveRender = value;
        _needsClear = true;
    };


    this.toggleGhosting = function(value) {
        this.showGhosting = value;
        _needsClear = true;
    };

    this.toggleOverlaysWhileMoving = function(value) {
        this.showOverlaysWhileMoving = value;
    };

    this.togglePostProcess = function(useSAO, useFXAA) {
        _renderer.initPostPipeline(useSAO, useFXAA);
        this.fireRenderOptionChanged();
        _needsClear = true;
    };

    this.toggleCelShading = function(value) {
        _renderer.toggleCelShading(value);
        this.fireRenderOptionChanged();
        _needsClear = true;
    };

    this.toggleGroundShadow = function(value) {
        if (_groundShadow.enabled === value)
            return;

        _groundShadow.enabled = value;
        _groundShadow.needClear = true;
        updateGroundTransform();
        this.fireRenderOptionChanged();
        this.invalidate(true, false, false);
    };

    this.setGroundShadowColor = function(color) {
        if (!_groundShadow.enabled) return;

        _groundShadow.setColor(color);
        this.invalidate(true, false, false);
    };

    this.setGroundShadowAlpha = function(alpha) {
        if (!_groundShadow.enabled) return;

        _groundShadow.setAlpha(alpha);
        this.invalidate(true, false, false);
    };

    this.toggleGroundReflection = function(enable) {
        if ((enable && !!_groundReflection) ||
            (!enable && !_groundReflection))
            return;

        if (enable) {
            _groundReflection = new av.Shaders.GroundReflection(_webglrender, this.canvas.clientWidth, this.canvas.clientHeight);
            _groundReflection.setClearColors(this.clearColorTop, this.clearColorBottom);
            _groundReflection.toggleEnvMapBackground(_envMapBackground);
            _groundReflection.setEnvRotation(_renderer.getEnvRotation());
            updateGroundTransform();
        }
        else {
            _groundReflection.cleanup();
            _groundReflection = undefined;
        }

        this.fireRenderOptionChanged();
        this.invalidate(true, false, false);
    };

    this.setGroundReflectionColor = function(color) {
        if (!_groundReflection) return;

        _groundReflection.setColor(color);
        this.invalidate(true, false, false);
    };

    this.setGroundReflectionAlpha = function(alpha) {
        if (!_groundReflection) return;

        _groundReflection.setAlpha(alpha);
        this.invalidate(true, false, false);
    };

    this.toggleEnvMapBackground = function(value) {
        _envMapBackground = value;
        _renderer.toggleEnvMapBackground(value);

        if (_groundReflection) {
            _groundReflection.toggleEnvMapBackground(value);
        }
        this.invalidate(true, true, false);
    };

    this.isEnvMapBackground = function() {
        return _envMapBackground;
    };

    this.toggleRenderPrism = function (value) {
        _materials.setRenderPrism(value);

        //TODO: support switching at run-time.
    };

    this.setOptimizeNavigation = function(value) {
        this.skipAOWhenMoving = value;
    };

    this.renderOverlays = function() {

        //The overlays (selection, pivot, etc) get lighted using
        //the default lights, even if IBL is on
        var lightsOn = this.lightsOn;
        if (!lightsOn)
            this.toggleLights(true, true);

        var oldIntensity;
        if (this.dir_light1) {
            oldIntensity = this.dir_light1.intensity;
            this.dir_light1.intensity = 1;
        }

        _renderer.renderOverlays(this.overlayScenes, this.lights);

        if (!lightsOn)
            this.toggleLights(false, true);

        if (this.dir_light1)
            this.dir_light1.intensity = oldIntensity;

        _overlayDirty = false;
    };

    this.setLayerVisible = function (layerIndexes, visible) {
        this.matman().setLayerVisible(layerIndexes, visible);
    };

    this.isLayerVisible = function (layerIndex) {
        return this.matman().isLayerVisible(layerIndex);
    };

    this.updateCameraMatrices = (function() {

        var tmpCameraMatrix = new THREE.Matrix4();
        var tmpViewMatrix = new THREE.Matrix4();
        var tmpBox = new THREE.Box3();

        return function() {
        var camera = this.camera;

        //NOTE: This is not computing the same matrix as what we use for rendering,
        //in cases where we are in ORTHO mode and the camera is inside the model,
        //which would result in negative near plane. For the purposes of computing
        //the near/far planes, we have to skip the logic that adjusts the view matrix
        //based on the near/far planes. See UnifiedCamera.updateMatrix for the related
        //adjustment to the view matrix.
        tmpCameraMatrix.compose( camera.position, camera.quaternion, camera.scale );
        tmpViewMatrix.getInverse( tmpCameraMatrix );

        //TODO: Would be nice if this got called by the world up tool instead,
        //so that we don't have to update it every frame.
        if (camera.worldup)
            this.setWorldUp(camera.worldup);

        //Fix near and far to fit the current view
        if (this.model) {
            var worldBox = this.getVisibleBounds(true, _overlayDirty);
            tmpBox.copy(worldBox);
			
			//If reflection is on, then we need to double the worldBox size in the Y
			//direction, the reflection direction, otherwise the reflected view can be
			//clipped.
			if ( _groundReflection ) {
				// Increase bounding box to include ground reflection geometry. The idea
				// here is to extend the bounding box in the direction of reflection, based
				// on the "up" vector.
				var tmpVecReflect = new THREE.Vector3;
				tmpVecReflect.multiplyVectors( tmpBox.max, camera.worldup );
				var tmpVecMin = new THREE.Vector3;
				tmpVecMin.multiplyVectors( tmpBox.min, camera.worldup );
				tmpVecReflect.sub( tmpVecMin );
				// tmpVecReflect holds how much to increase the bounding box.
				// Negative values means the "up" vector is upside down along that axis,
				// so we increase the maximum bounds of the bounding box in this case.
				if ( tmpVecReflect.x >= 0.0 ) {
					tmpBox.min.x -= tmpVecReflect.x;
				} else {
					tmpBox.max.x -= tmpVecReflect.x;
				}
				if ( tmpVecReflect.y >= 0.0 ) {
					tmpBox.min.y -= tmpVecReflect.y;
				} else {
					tmpBox.max.y -= tmpVecReflect.y;
				}
				if ( tmpVecReflect.z >= 0.0 ) {
					tmpBox.min.z -= tmpVecReflect.z;
				} else {
					tmpBox.max.z -= tmpVecReflect.z;
				}
			}

            //Transform the world bounds to camera space
            //to estimate the near/far planes we need for this frame
            tmpBox.applyMatrix4(tmpViewMatrix);

            //Expand the range by a small amount to avoid clipping when
            //the object is perfectly aligned with the axes and has faces at its boundaries.
            var sz = 1e-5 * (tmpBox.max.z - tmpBox.min.z);

            //TODO: expand for ground shadow. This just matches what the
            //ground shadow needs, but we need a better way to take into account
            //the ground shadow scene's bounds
            var expand = (tmpBox.max.y - tmpBox.min.y) * 0.5;

            var dMin = -(tmpBox.max.z+sz)-expand;
            var dMax = -(tmpBox.min.z-sz)+expand;

            //Camera is inside the model?
            if (camera.isPerspective)
                dMin = Math.max(dMin, Math.min(1, Math.abs(dMax - dMin) * 1e-4));
            else {
                //TODO:
                //Do nothing in case of ortho. While this "fixes" near plane clipping too early,
                //it effectively disallows moving through walls to go inside the object.
                //So we may need some heuristic based on how big we want the object to be
                //on screen before we let it clip out.
                //dMin = Math.max(dMin, 0);
            }

            //The whole thing is behind us -- nothing will display anyway?
            dMax = Math.max(dMax, dMin);

            camera.near = dMin;
            camera.far = dMax;
            camera.updateProjectionMatrix();

            //stderr("near " + dMin + " far " + dMax + " top " + camera.top);

            //Update the line width scale with the
            //new pixels per unit scale
            if (this.model.is2d())
            {
                //Here we base pixel scale on the point at the center of the view.
                //However, this might not always be the most appropriate point,
                //e.g. at oblique angles or when the drawing is off to one side.
                //It might make more sense to base the scale on the distance of the
                //camera to the nearest part of the world bounding box, which requires
                //a more generic ray-aabb test.
                var groundPt = this.intersectGroundViewport(new THREE.Vector3(0,0,1));

                var distance;
                if (groundPt)
                    distance = camera.position.distanceTo(groundPt);
                else
                    distance = camera.position.distanceTo(worldBox.center()); //degenerate case: camera direction is parallel to the ground plane

                //NOTE: In case of ortho projection, we set FOV such that tan(fov/2) = 0.5,
                //so here we don't need separate code path for ortho.
                var pixelsPerUnit = _renderer.settings.deviceHeight / (2 * distance * Math.tan(THREE.Math.degToRad(camera.fov * 0.5)));

                //If we want to take into account devicePixelRatio for line weights (so that lines are not too thin)
                //we can do this here, but it's less esthetically pleasing:
                //pixelsPerUnit /= _webglrenderer.getPixelRatio();

                _materials.updatePixelScale(pixelsPerUnit);
            } else {

                //If there is a cutting plane, get a point on that plane
                //for by the pixel scale computation.
                var cp = _materials.getCutPlanesRaw();

                var pt;
                if (cp && cp.length) {
                    var p = cp[0];

                    var dir = camera.target.clone().sub(camera.position).normalize();
                    var denominator = dir.dot(p);

                    if (denominator === 0)
                        pt = worldBox.center();
                    else {
                        var t = - ( camera.position.clone().dot( p ) + p.w ) / denominator;
                        pt = worldBox.clampPoint(dir.multiplyScalar(t).add(camera.position));
                    }
                } else {
                    pt = worldBox.center();
                }

                var distance = camera.position.distanceTo(pt);

                //NOTE: In case of ortho projection, we set FOV such that tan(fov/2) = 0.5,
                //so here we don't need separate code path for ortho.
                var pixelsPerUnit = _renderer.settings.deviceHeight / (2 * distance * Math.tan(THREE.Math.degToRad(camera.fov * 0.5)));

                _materials.updatePixelScale(pixelsPerUnit);
            }

        }
    }
    })();


    this.initLights = function(dist)
    {
        var lightIntensity = avp.LightPresets[_currentLightPreset].lightMultiplier;

        this.lightNode = new THREE.Object3D();

        this.dir_light1 = new THREE.DirectionalLight( new THREE.Color().setRGB(
            1.0, 1.0, 1.0),//Note this color will be overridden by various light presets
            lightIntensity );

        this.dir_light1.position.set( -1, 0, 1 );
        //for whatever reason we need to move the light far out to make it draw correctly,
        //even though it's a directional light
        this.dir_light1.position.multiplyScalar(dist * 1000);
        this.lightNode.add( this.dir_light1 );

        //Note this color will be overridden by various light presets
        this.amb_light = new THREE.AmbientLight( new THREE.Color().setRGB(1, 1, 1 ));

        //We do not add the lights to any scene, because we need to use them
        //in multiple scenes during progressive render.
        //this.scene.add(this.amb_light);

        //Attach the light to the camera so the light moves with the camera
        this.camera.add(this.lightNode);

        this.toggleLights(lightIntensity !== 0);
    };

    this.toggleLights = function(state, isForOverlay) {

        //This can happen during initial construction
        if (!this.amb_light || !this.lightNode)
            return;

        //Light on or off? Add/remove from the scene accordingly.
        if (state && !this.lightsOn)
        {
            this.lights = [this.dir_light1, this.amb_light];
            this.lightsOn = true;
        }
        else if (!state && this.lightsOn)
        {
            this.lightsOn = false;
            this.lights = [];
        }

        //Update the light colors based on the current preset
        var preset = avp.LightPresets[_currentLightPreset];
        var ac = preset.ambientLightColor;
        var dc = preset.directLightColor;

        if (this.lightsOn) {
            if (isForOverlay && this.amb_light)
                this.amb_light.color.setRGB(dc[0]*0.5,dc[1]*0.5,dc[2]*0.5);
            else if (ac && this.amb_light)
                this.amb_light.color.setRGB(ac[0],ac[1],ac[2]);
            if (dc && this.dir_light1)
                this.dir_light1.color.setRGB(dc[0],dc[1],dc[2]);
        }
        else
        {
            //Restores the ambient for the main scene after drawing overlays
            if (ac && this.amb_light && isForOverlay)
                this.amb_light.color.setRGB(ac[0],ac[1],ac[2]);
        }
    };

    //Forces the view controller to update when the camera
    //changes programmatically (instead of via mouse events).
    this.syncCamera = function(syncWorldUp)
    {
        this.camera.updateProjectionMatrix();

        if( syncWorldUp )
            this.setWorldUp( this.api.navigation.getWorldUpVector() );

        _cameraUpdated = true;
    };


    this.setViewFromFile = function(model, skipTransition) {

        var camera;

        var defaultCamera = model.getDefaultCamera();

        if (defaultCamera) {

            camera = defaultCamera;

        } else {

            //Model has no default view. Make one up based on the bounding box.

            camera = {};

            var bbox = model.getBoundingBox();
            var size = bbox.size();
            camera.target = bbox.center();

            if (!model.is2d())
            {
                camera.isPerspective = true;
                camera.fov = this.camera.fov;
                camera.up = this.camera.up.clone();

                camera.position = camera.target.clone();
                camera.position.z += 1.5 * Math.max(size.x, size.y, size.z);
            }
            else {
                camera.isPerspective = false;

                var pageAspect = size.x / size.y;
                var screenAspect = this.camera.aspect;

                //Fit the page to the screen
                if (screenAspect > pageAspect)
                    camera.orthoScale = size.y;
                else
                    camera.orthoScale = size.x / screenAspect;

                //2D case -- ground plane / up vector is Z
                camera.up = new THREE.Vector3(0,0,1);

                camera.position = camera.target.clone();
                camera.position.z += camera.orthoScale;

                //This is to avoid freaking out the camera / controller with co-linear up and direction
                camera.target.y += 1e-6 * size.y;

            }

        }

        this.setViewFromCamera(camera, skipTransition);
    };

    //Camera is expected to have the properties of a THREE.Camera.
    this.adjustOrthoCamera = function(camera) {

        //Sometimes (Revit) the camera target is unspecified/infinite
        //for ortho. So we pick target and distance such that
        //initial view and orbit is about right
        if (!camera.isPerspective && this.model) {
            var bbox = this.model.getBoundingBox();
            var size = bbox.size();

            var at = camera.target.clone().sub(camera.position);
            if (at.length() > 1000 * size.length()) {
                //We will try to set a target point that is a similar
                //distance away as camera->bbox center, but is in the
                //direction of the at vector (which is not necessarily looking at the center)
                var dist = camera.position.distanceTo(bbox.center());
                camera.target.copy(camera.position).add(at.normalize().multiplyScalar(dist));
            }
            else {
                //TODO: UnifiedCamera does not actually look at the orthoScale property. It bases
                //the ortho projection on value derived from the position-target distance and an
                //assumed field of view. Here we apply the inverse so that the initial view is
                //right, without affecting the initial orbit target.
                camera.position.copy(camera.target).add(at.normalize().multiplyScalar(-camera.orthoScale));
            }
        }
    };

    //Camera is expected to have the properties of a THREE.Camera.
    this.setViewFromCamera = function(camera, skipTransition)
    {
        this.adjustOrthoCamera(camera);

        //If up vector is given explicitly (in world space)
        //then use that instead
        //TODO: Is that desired now that we allow heads-down situations?
        //or should we accept the camera exactly as given.
        var upVectorArray = this.model ? this.model.getUpVector() : null;

        //HACK for local testing copy of SaRang
        if (this.model && this.model.getData().basePath.indexOf("SaRang") != -1)
            upVectorArray = [0,0,1];

        var up;
        if (upVectorArray)
            up = new THREE.Vector3().fromArray(upVectorArray);
        else
            up = av.Navigation.snapToAxis(camera.up.clone());

        camera.up = up;


        var navapi = this.api.navigation;
        if ( navapi) {
            if (!skipTransition) {
                this.camera.isPerspective = camera.isPerspective;
                up = navapi.computeOrthogonalUp(camera.position, camera.target);
                navapi.setRequestTransitionWithUp(true, camera.position, camera.target, camera.fov, up, camera.up);
            }
            else {

                //This code path used during initial load -- it sets the view directly
                //without doing a transition. Transitions require that the camera is set explicitly

                var tc = this.camera;
                tc.up.copy(camera.up);
                tc.position.copy(camera.position);
                tc.target.copy(camera.target);
                if( camera.isPerspective ) {
                    tc.fov = camera.fov;
                }
                else {
                    tc.saveFov = camera.fov;    // Stash original fov
                    tc.fov = av.UnifiedCamera.ORTHO_FOV;
                }
                tc.isPerspective = camera.isPerspective;
                tc.orthoScale = camera.orthoScale;
                tc.dirty = true;

                navapi.setWorldUpVector(tc.up);
                navapi.setView(tc.position, tc.target);
                navapi.setPivotPoint(tc.target);

                this.syncCamera(true);
            }
        }
        _cameraUpdated = true;
    };

    this.setViewFromViewBox = function(model, viewbox, name, skipTransition)
    {
        if (!model.is2d()) {
            return;
        }


        var camera = {};

        var bbox = model.getBoundingBox();

        var box = {
            width: viewbox[2] - viewbox[0],
            height: viewbox[3] - viewbox[1]
        };
        box.aspect = box.width / box.height;
        box.centerX = viewbox[0] + box.width / 2;
        box.centerY = viewbox[1] + box.height / 2;

        var screenAspect = this.camera.aspect;

        //Fit the viewbox to the screen
        if (screenAspect > box.aspect)
            camera.orthoScale = box.height;
        else
            camera.orthoScale = box.width / screenAspect;

        camera.isPerspective = false;
        camera.position = new THREE.Vector3(box.centerX, box.centerY, bbox.center().z + camera.orthoScale);
        camera.target = new THREE.Vector3(box.centerX, box.centerY, bbox.center().z);
        camera.target.y += 1e-6 * box.height;

        camera.up = new THREE.Vector3(0,0,1);

        this.setViewFromCamera(camera, skipTransition);
    };

    this.setWorldUp = function(upVector) {

        if (_worldUp.equals(upVector))
            return;

        _worldUp.copy(upVector);

        // get the (max) up axis and sign
        var maxVal = Math.abs(upVector.x);
        _worldUpName = "x";
        if (Math.abs(upVector.y) > maxVal) {
            _worldUpName = "y";
            maxVal = Math.abs(upVector.y);
        }
        if (Math.abs(upVector.z) > maxVal) {
            _worldUpName = "z";
        }

        var getRotation = function(vFrom, vTo) {
            var rotAxis = (new THREE.Vector3()).crossVectors(vTo, vFrom).normalize();  // not sure why this is backwards
            var rotAngle = Math.acos(vFrom.dot(vTo));
            return (new THREE.Matrix4()).makeRotationAxis(rotAxis, rotAngle);
        };

        var identityUp = new THREE.Vector3(0,1,0);
        _this.camera.worldUpTransform = getRotation(identityUp, upVector);

        this.sceneUpdated(false);
    };


    this.addModel = function(model)
    {
        if (!model)
            return;

        //Is it the first model being loaded into the scene?
        var isOverlay = !!this.model;
        var is2d = model.is2d();

        if (!this.model) {
            this.model = model;

            //stderr("Unit scale " + m.getUnitScale());
            _renderer.setUnitScale(model.getUnitScale());
        }

        //Create a render list for progressive rendering of the
        //scene fragments
        _modelQueue.addModel(model);
        this.selector.addModel(model);
        this.visibilityManager.addModel(model);

        if (is2d)
        {
            //In case of a 2D drawing
            //initialize the common line shader
            //and the layers texture

            _materials.initLayersTexture(model);

            var idMatName = _materials.create2DMaterial(model.getData(), {}, true);
            var idMaterial = _materials.findMaterial(model.getData(), idMatName);

            _renderer.enter2DMode(idMaterial);

            if (!isOverlay) {
                this.is2d = true;

                //Rememeber the light preset so we can restore is
                //when we unload the 2d sheet -- the light preset for 2d
                //is not persisted.
                _oldLightPreset = _currentLightPreset;
                this.setLightPreset(avp.DefaultLightPreset2d);

                var svf = model.getData();
                if (svf.hidePaper) {
                    var bg = svf.bgColor;
                    var r = (bg>>16)&0xff;
                    var g = (bg >>8)&0xff;
                    var b = bg&0xff;
                    this.setClearColors(r,g,b,r,g,b );
                }
            }
        }

        if (this.api.navigation) {
            this.api.navigation.setIs2D(is2d && !isOverlay);
            this.api.setActiveNavigationTool(); // use default nav tool
        }


        if (!isOverlay) {
            this.setViewFromFile(model, true);
            this.controls.recordHomeView();

            //Currently the lights need to know
            //the overall size of the scene
            //since they are point lights
            var bbox = model.getBoundingBox();
            var radius = 0.5 * bbox.size().length();
            this.initLights(radius);
        }

        // grab the environment preset data from the file.
        if (!is2d && !this.setLightPresetFromFile(model)) {
            this.setLightPreset(_currentLightPreset, true);
        }

        this.fireRenderOptionChanged();
        this.invalidate(true);
    };

    this.getSvfMaterialId = function (fragId) {
        return this.model.getFragmentList().getSvfMaterialId(fragId);
    };

    this.getMaterials = function() { return _materials; };


    //Creates a THREE.Mesh representation of a fragment. Currently this is only
    //used as vehicle for activating a fragment instance for rendering once its geometry is received
    //or changing the fragment data (matrix, material). So, it's mostly vestigial.
    this.setupMesh = function(model, threegeom, materialId, matrix) {
    
        var svf = model.getData();

        var m = {
            geometry: threegeom,
            matrix: matrix,
            isLine: threegeom.isLines,
            is2d: threegeom.is2d
        };

        // Check if this geometry is to be rendered with a line mesh
        if ( threegeom.isLines ) {
            // Check to see if there are vertex colors
            var vertexColors = !!threegeom.attributes.color;
            // Create a new LineBasicMaterial with vertexColors true/false depending on above
            //TODO: this material also needs to be added to the materials set, but first
            //make sure this will not cause line display side effects.
            var material = new THREE.LineBasicMaterial({ vertexColors: vertexColors });

            // If there are no vertex colors, default to the material color
            if(!vertexColors){
                var svfmat = _materials.findMaterial(svf, materialId);
                material.color = svfmat.color;
            }
            
            //Register it with material manager so that cutplanes get updated
            _materials.addMaterialNonHDR(svf.basePath + materialId + "_line_" + material.id, material);
            
            // Use line mesh
            m.material = material;

            svf.hasLines = true;
        } else {
            var material = _materials.findMaterial(svf, materialId);

            if (material) // Save in material so we can map back from material to SVF id.
                material.svfMatId = materialId;

            _materials.applyGeometryFlagsToMaterial(material, threegeom);

            m.material = material;
        }

        return m;
    };


    // Gets called by the active Loader
    this.onLoadComplete = function (model)
    {
        _isLoading = false;

        this.signalProgress(100, "");

        this.sceneUpdated(false);

        //In the case of 2d drawing, initialize the dbIds texture
        //to be used for selection highlighting. Initially,
        //nothing is highlighted
        if (this.is2d) {
            this.selectionMaterial2d = _materials.init2DSelectionMaterial(model);
            this.createOverlayScene("selection2d", this.selectionMaterial2d);
        }

        var svf = model.getData();

        _modelQueue.getGeometryList().printStats();

        //If the model has line geometries
        //set polygon offset on the solid materials
        //so that we avoid z-fighting between solids and
        //their outlines.
        if (svf.hasLines) {
            _materials.togglePolygonOffset(true);
        }

        // Init animations
        var that = this;
        function initAnimations() {
            if (svf.animations) {
                that.keyFrameAnimator = new avp.KeyFrameAnimator(that, svf.animations.duration);
                for (var a in svf.animations.animations) {
                    that.keyFrameAnimator.add(svf.animations.animations[a]);
                }
                that.keyFrameAnimator.goto(0);
                that.api.fireEvent({ type: av.ANIMATION_READY_EVENT });
            }
            that.api.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, initAnimations);
        }
        // init animations after object tree created and geometry loaded
        if (model.isObjectTreeCreated()) {
            initAnimations();
        } else {
            this.api.addEventListener(av.OBJECT_TREE_CREATED_EVENT, initAnimations);
        }


        // Fire the event so we know the geometry is done loading.
        this.api.fireEvent({
            type: av.GEOMETRY_LOADED_EVENT,
            model: model
        });
    };

    this.signalProgress = function(percent, message)
    {
        this.api.fireEvent({type:av.PROGRESS_UPDATE_EVENT, percent:percent, message:message});
    };

    this.resize = function(w, h) {
        _needsResize = true;
        _newWidth = w;
        _newHeight = h;
    };


    this.unloadModel = function(model) {

        if (!_modelQueue.removeModel(model))
            return; //model was not found

        if (this.keyFrameAnimator) {
            this.keyFrameAnimator.destroy();
            this.keyFrameAnimator = null;
        }

        model.dtor(this.glrenderer());

        _materials.cleanup(model.getData());

        if (model.isLoadDone())
            model.getData().propWorker.dtor();
        if (model.loader)
            model.loader.dtor();

        this.selector.removeModel(model);
        this.visibilityManager.removeModel(model);

        if (model === this.model) {
            this.model = null;

            if (!_modelQueue.isEmpty())
                this.model = _modelQueue.getModels()[0];
        }

        this.api.fireEvent({type: av.MODEL_UNLOADED_EVENT, model: model});

        this.invalidate(true);
    };

    this.unloadCurrentModel = function() {
        //Before loading a new model, restore states back to what they
        //need to be when loading a new model. This means restoring transient
        //changes to the render state made when entering 2d mode,
        //like light preset, antialias and SAO settings,
        //and freeing GL objects specific to the old model.
        if (this.is2d) {
            this.is2d = undefined;
            this.selectionMaterial2d = null;
            this.removeOverlay("selection2d");
            _renderer.exit2DMode();
        }

        _renderer.beginScene(this.scene, this.camera, this.lights, true);
        _renderer.composeFinalFrame();

        this.model = null;

        var models = _modelQueue.getModels();
        for (var i=models.length-1; i>=0; i--)
            this.unloadModel(models[i]);

        if (_oldLightPreset >= 0)
            _currentLightPreset = _oldLightPreset;
    };

    var createSelectionScene = function(name, materialPre, materialPost) {
        materialPre.depthWrite = false;
        materialPre.depthTest = true;
        materialPre.side = THREE.DoubleSide;

        materialPost.depthWrite = false;
        materialPost.depthTest = true;
        materialPost.side = THREE.DoubleSide;

        _this.createOverlayScene(name, materialPre, materialPost);
    };

    this.createOverlayScene = function(name, materialPre, materialPost, camera) {
        if (materialPre) {
            _materials.addMaterialNonHDR(name+"_pre", materialPre);
        }
        if (materialPost) {
            _materials.addMaterialNonHDR(name+"_post", materialPost);
        }

        var s = new THREE.Scene();
        s.__lights = this.scene.__lights;
        this.overlayScenes[name] = {
            scene : s,
            camera: camera,
            materialPre : materialPre,
            materialPost : materialPost
        };
    };

    this.removeOverlayScene = function (name) {

        var overlay = this.overlayScenes[name];
        if (overlay) {
            delete this.overlayScenes[name];
            this.invalidate(false, false, true);
        }
    };

    this.addOverlay = function(overlayName, mesh) {
        this.overlayScenes[overlayName].scene.add(mesh);
        this.invalidate(false, false, true);
    };

    this.addMultipleOverlays = function(overlayName, meshes) {
        for (var i in meshes) {
            if (!meshes.hasOwnProperty(i)) continue;
            this.addOverlay(overlayName, meshes[i]);
        }
    };

    this.removeOverlay = function(overlayName, mesh) {
        this.overlayScenes[overlayName].scene.remove(mesh);
        this.invalidate(false, false, true);
    };

    this.removeMultipleOverlays = function(overlayName, meshes) {
        for (var i in meshes) {
            if (!meshes.hasOwnProperty(i)) continue;
            this.removeOverlay(overlayName, meshes[i]);
        }
    };

    this.clearOverlay = function(overlayName) {

        if (!this.overlayScenes[overlayName])
            return;

        var scene = this.overlayScenes[overlayName].scene;
        var obj, i;
        for (i = scene.children.length - 1; i >= 0; --i) {
            obj = scene.children[ i ];
            if (obj) {
                scene.remove(obj);
            }
        }

        this.invalidate(false, false, true);
    };

    this.setClearColors = function(r,g,b, r2, g2, b2) {
        this.clearColorTop = new THREE.Vector3(r/255.0,g/255.0,b/255.0);
        this.clearColorBottom = new THREE.Vector3(r2/255.0,g2/255.0,b2/255.0);

        //If we are using the background color as environment also,
        //create an environment map texture from the new colors
        if (!_materials.reflectionCube || _materials.reflectionCube.isBgColor) {
            var cubeMap = _materials.setCubeMapFromColors(this.clearColorTop, this.clearColorBottom);
            _renderer.setCubeMap(cubeMap);
        }

        _renderer.setClearColors(this.clearColorTop, this.clearColorBottom);
        if (_groundReflection) _groundReflection.setClearColors(this.clearColorTop, this.clearColorBottom);
        _needsClear = true;
        this.fireRenderOptionChanged();
    };

    //Similar to THREE.Box3.setFromObject, but uses the precomputed bboxes of the
    //objects instead of doing it per vertex.
    var _box3 = new THREE.Box3();
    function computeObjectBounds(dst, object) {

        object.updateMatrixWorld( true );

        object.traverse( function ( node ) {

            var geometry = node.geometry;

            if (geometry !== undefined && geometry.visible) {

                if (!geometry.boundingBox)
                    geometry.computeBoundingBox();

                _box3.copy(geometry.boundingBox);
                _box3.applyMatrix4(node.matrixWorld);
                dst.union(_box3);
            }

        } );
    }

    function getOverlayBounds() {
        var bounds = new THREE.Box3();
        var overlays = _this.overlayScenes;

        for (var key in overlays) {
            if (!overlays.hasOwnProperty(key))
                continue;

            computeObjectBounds(bounds, overlays[key].scene);
        }

        //Also add the root scene -- people add overlays there too
        computeObjectBounds(bounds, _this.scene);

        return bounds;
    }

    this.getVisibleBounds = function(includeGhosted, includeOverlays) {
        var result = new THREE.Box3();
        if (!_modelQueue.isEmpty()) {
            computeObjectBounds(result, this.scene);
            result = _modelQueue.getVisibleBounds(includeGhosted).union(result);

            if (includeOverlays) {
                result = getOverlayBounds().union(result);
            }
        }
        return result;
    };

    this.getFitBounds = function( ignoreSelection )
    {
        var bounds;

        // If there is a valid selection, use its bounds
        // unless this is a 2d file
        //
        if (this.is2d) {
            ignoreSelection = true;
        }
        if( !ignoreSelection && this.selector !== null) {
            bounds = this.selector.getSelectionBounds();
        }

        // Otherwise, if there is a valid isolation, use its bounds
        if(!bounds || bounds.empty()) {
            bounds = this.getVisibleBounds();
        }

        return bounds;
    };

    this.getRenderProxy = function(model, fragId) {
        //currently there is a single model so the mapping
        //of fragId to render mesh is 1:1.
        return model.getFragmentList().getVizmesh(fragId);
    };

    this.getFragmentProxy = function(model, fragId) {
        return new avp.FragmentPointer(model.getFragmentList(), fragId);
    };

    this.getRenderProxyCount = function(model) {
        return model.getFragmentList().getCount();
    };

    this.getRenderProxyDbIds = function(model, fragId) {
        return model.getFragmentList().getDbIds(fragId);
    };

    this.isWholeModelVisible = function(model) {
        return _modelQueue ? _modelQueue.areAllVisible() : true;
    };

    this.highlightObjectNode = function(model, dbId, value, simpleHighlight) {

        if (model.is2d()) {
            _materials.highlightObject2D(dbId, value); //update the 2d object id texture
        }

        var scope = this;
        var it = model.getData().instanceTree;

        //TODO: There can be instance tree in the case of 2D drawing, but
        //we do not currently populate the node tree with the virtual fragment ids
        //that map 2d objects to 2d consolidated meshes, hence the use of dbId2fragId in the else condition
        if (it && !model.is2d()) {

            it.enumNodeFragments(dbId, function(fragId) {
                scope.highlightFragment(model, fragId, value, simpleHighlight);
            }, false);

        } else {
            var fragId = dbId;

            if (model.is2d())
                fragId = model.getData().fragments.dbId2fragId[dbId];

            if (Array.isArray(fragId))
                for (var i=0; i<fragId.length; i++)
                    scope.highlightFragment(model, fragId[i], value, simpleHighlight);
            else
                scope.highlightFragment(model, fragId, value, simpleHighlight);

        }

    };

    this.highlightFragment = function(model, fragId, value, simpleHighlight) {

        var mesh = this.getRenderProxy(model, fragId);

        if (!mesh)
            return;

        //And also add a mesh to the overlays in case we need that.
        //For 2D that is always the case, while for 3D it's done
        //for "fancy" single-selection where we draw an outline for the object
        //as post-processing step.
        var useOverlay = !simpleHighlight || mesh.is2d;

        var highlightId = model.id + ":" + fragId;

        if (useOverlay) {
            var overlayName = model.is2d() ? "selection2d" : "selection";

            if (value)
            {
                var selectionProxy = new THREE.Mesh(mesh.geometry, mesh.material);
                selectionProxy.matrix.copy(mesh.matrixWorld);
                selectionProxy.matrixAutoUpdate = false;
                selectionProxy.matrixWorldNeedsUpdate = true;

                selectionProxy.frustumCulled = false;
                selectionProxy.model = model;
                selectionProxy.fragId = fragId;

                this.addOverlay(overlayName, selectionProxy);

                this.selectionMeshes[highlightId] = selectionProxy;
            }
            else
            {
                if (this.selectionMeshes[highlightId]) {
                    this.removeOverlay(overlayName, this.selectionMeshes[highlightId]);
                    delete this.selectionMeshes[highlightId];
                }
            }
        }

        if (!useOverlay || !value) {
            //Case where highlighting was done directly in the primary render queue
            //and we need to repaint to clear it. This happens when multiple
            //nodes are highlighted using e.g. right click in the tree view
            if (model.setHighlighted(fragId, value)) //or update the vizflags in the render queue for 3D objects
                this.invalidate(true);
        }
    };

    this.explode = function(scale) {

        if(scale == _explodeScale)
            return;

        _explodeScale = scale;

        _modelQueue.explode(scale);

        //force a repaint and a clear
        this.sceneUpdated(true);

        this.api.fireEvent({type:av.EXPLODE_CHANGE_EVENT});
    };

    /**
     * Gets the last applied explode scale
     */
    this.getExplodeScale = function()
    {
        return _explodeScale;
    };


    /* simple function to set the brightness of the ghosting.
     * Simply sets another colour that is better for brighter environments
     */
    this.setGhostingBrightness = function(darkerFade)
    {
        if (darkerFade) {
            this.fadeMaterial.color = new THREE.Color(0x101010);
        }
        else {
            this.fadeMaterial.color =  new THREE.Color(0xffffff);
        }
        this.fadeMaterial.needsUpdate = true;
    };


    this.setLightPreset = function(index, force)
    {
        if (_currentLightPreset == index && !force)
            return;

        // Reset index in cases the index out of range.
        // This could happen, if we update the light preset list and user
        // has a local web storage which stores the last accessed preset index which is potentially
        // out of range with respect to the new preset list.
        if (index < 0 || avp.LightPresets.length <= index) {
            index = avp.DefaultLightPreset;
        }

        _currentLightPreset = index;
        var preset = avp.LightPresets[index];
        if (preset && preset.path) {
            var pathPrefix = "res/environments/" + preset.path;
            var reflPath = avp.getResourceUrl(pathPrefix + "_mipdrop." + (preset.type || "") + ".dds");
            var irrPath =  avp.getResourceUrl(pathPrefix + "_irr." + (preset.type || "") + ".dds");

            _materials.setIrradianceMap(irrPath, preset.E_bias);
            var cubeMap = _materials.setCubeMap(reflPath, preset.E_bias);
            _renderer.setCubeMap(cubeMap);

            //Set exposure that the environment was baked with.
            //This has to be known at baking time and is applied
            //by the shader.
            _materials.setEnvExposure(-preset.E_bias);

            this.setTonemapExposureBias(preset.E_bias);
            this.setTonemapMethod(preset.tonemap);

            this.setGhostingBrightness(preset.darkerFade);
        }
        else {
            _materials.setIrradianceMap(null);
            var cubeMap = _materials.setCubeMap(null);
            _renderer.setCubeMap(cubeMap);
            _materials.setEnvExposure(0);

            this.setTonemapExposureBias(0);
            this.setTonemapMethod(0);

            this.setGhostingBrightness(false);
        }


        //To begin with, get the SAO defaults from the shader uniforms definition
        //Note the scaling we apply to inverse scaling done by the setAOOptions API internally.
        //This is not pretty....
        var saoRadius = av.Shaders.SAOShader.uniforms.radius.value;
        var saoIntensity = av.Shaders.SAOShader.uniforms.intensity.value;

        //Check if the preset overrides the SAO settings
        if (preset.hasOwnProperty("saoRadius"))
            saoRadius = preset.saoRadius;
        if (preset.hasOwnProperty("saoIntensity"))
            saoIntensity = preset.saoIntensity;
        _renderer.setAOOptions(saoRadius, saoIntensity);

        //if the light preset has a specific background color, set that
        var c = preset.bgColorGradient;
        if (!c)
            c = avp.BackgroundPresets["Custom"];
        this.setClearColors(c[0], c[1], c[2], c[3], c[4], c[5]);

        var lightIntensity = 1;
        if (preset.lightMultiplier !== null && preset.lightMultiplier !== undefined) {
            lightIntensity = preset.lightMultiplier;
        }

        if (this.dir_light1) {
            this.toggleLights(lightIntensity !== 0);
            this.dir_light1.intensity = lightIntensity;

            if (preset.lightDirection) {

                this.dir_light1.position.set( -preset.lightDirection[0], -preset.lightDirection[1], -preset.lightDirection[2] );
                //for whatever reason we need to move the light far out to make it draw correctly,
                //even though it's a directional light
                this.dir_light1.position.multiplyScalar(this.model.getData().bbox.size().length() * 1000);

            }

        }

        _materials.setEnvRotation(preset.rotation || 0.0);
        _renderer.setEnvRotation(preset.rotation || 0.0);

        if (_groundReflection) _groundReflection.setEnvRotation(preset.rotation || 0.0);

        this.invalidate(true, false, true);

        this.fireRenderOptionChanged();
    };

    this.setLightPresetFromFile = function(model)
    {

        var style = model.getMetadata('renderEnvironmentStyle', 'value', null);

        if ((style === null) || (style ===""))
            return false;

        // TODO add more control for environments
        // the user cannot set anything expect the style from current UI
        // currently only the style can be selected.
        // TODO We cannot control these values so comment out for now
        //var grndReflection = this.getMetadata('renderEnvironmentGroundReflection', 'value', null);
        // default value = false
        //var grndShadow = this.getMetadata('renderEnvironmentGroundShadow', 'value', null);
        // default value = false

        var exposureBias = model.getMetadata('renderEnvironmentExposureBias', 'value', null);
        var exposureBase = model.getMetadata('renderEnvironmentExposureBase', 'value', null);

        var found = false;
        for (var i=0; i<avp.LightPresets.length; i++) {
            if (style === avp.LightPresets[i].name) {
                if (exposureBias !== null && exposureBase !== null ) {
                    //TODO: This is overwriting the setting in our main Environment definitions array.
                    //In fact, the setting should probably be transient for the viewable only we
                    //we should not be writing it back the definition.
                    avp.LightPresets[i].E_bias = exposureBias + exposureBase;
                }
                this.setLightPreset(i);
                found = true;
                break;
            }
        }

        var bgColor = model.getMetadata('renderEnvironmentBackgroundColor', 'value', null);
        if (bgColor) {
            this.setClearColors(
                255.0 * bgColor[0], 255.0 * bgColor[1], 255.0 * bgColor[2],
                255.0 * bgColor[0], 255.0 * bgColor[1], 255.0 * bgColor[2]);
        }

        var bgEnvironment = model.getMetadata('renderEnvironmentBackgroundFromEnvironment', 'value', null);
        if (bgEnvironment !== null) {
            this.toggleEnvMapBackground(bgEnvironment);
        }

        // Environment rotation, assumed to be in radians
        var envRotation = model.getMetadata('renderEnvironmentRotation', 'value', null);
        if (envRotation) {
            _materials.setEnvRotation(envRotation);
            _renderer.setEnvRotation(envRotation);

            if (_groundReflection) _groundReflection.setEnvRotation(envRotation);
        }

        return found;
    };


    this.setTonemapMethod = function (index) {

        if (index == _renderer.getToneMapMethod())
            return;

        _renderer.setTonemapMethod(index);
        _materials.setTonemapMethod(index);

        this.fireRenderOptionChanged();
        this.invalidate(true);
    };

    this.setTonemapExposureBias = function (bias) {

        if (bias == _renderer.getExposureBias())
            return;

        _renderer.setTonemapExposureBias(bias);
        _materials.setTonemapExposureBias(bias);

        this.fireRenderOptionChanged();
        this.invalidate(true);
    };


    /**
     * Unloads model, frees memory, as much as possible.
     */
    this.dtor = function() {
        window.cancelAnimationFrame(_reqid);

        this.unloadCurrentModel();

        // this.controls is uninitialized by Viewer3D, since it was initialized there
        this.controls = null;
        this.canvas = null;

        this.loader = null;

        this.selector.dtor();
        this.selector = null;

        this.model = null;
        this.visibilityManager = null;

        _modelQueue = null;
        _renderer = null;
        _materials.dtor();
        _materials = null;
    };

    this.hideLines = function(hide){
        if (_modelQueue && !_modelQueue.isEmpty()) {
            _modelQueue.hideLines(hide);
            this.sceneUpdated(true);
            return true;
        }
        return false;
    };

    this.getCutPlanes = function() {
        return _materials.getCutPlanes();
    };

    this.setCutPlanes = function(planes) {
        _materials.setCutPlanes(planes);
        this.sceneUpdated();
        this.api.fireEvent({type:av.CUTPLANES_CHANGE_EVENT});
    };

    this.fireRenderOptionChanged = function() {

        //If SAO is changing and we are using multiple
        //render targets in the main material pass, we have
        //to update the materials accordingly.
        _materials.toggleMRTSetting();

        this.api.fireEvent({type:av.RENDER_OPTION_CHANGED_EVENT});
    };

    this.viewportToRay = function(vpVec, ray) {
        var camera = this.camera;

        // set two vectors with opposing z values
        vpVec.z = -1.0;
        var end = new THREE.Vector3( vpVec.x, vpVec.y, 1.0 );
		vpVec = vpVec.unproject(camera);
        end = end.unproject( camera );

        // find direction from vector to end
        end.sub( vpVec ).normalize();

        if (!ray)
            ray = new THREE.Ray();

        ray.set(!camera.isPerspective ? vpVec : camera.position, end);

        return ray;
    };

    // Add "meshes" parameter, after we get meshes of the object using id buffer,
    // then we just need to ray intersect this object instead of all objects of the model.
    this.rayIntersect = function(ray, ignoreTransparent, dbIds) {
        var result = _modelQueue.rayIntersect(ray.origin, ray.direction, ignoreTransparent, dbIds);

        if (this.sceneAfter.children.length) {
            var raycaster = new THREE.Raycaster(ray.origin, ray.direction, this.camera.near, this.camera.far);
            var intersects = [];
            VBIntersector.intersectObject(this.sceneAfter, raycaster, intersects, true);

            if (intersects.length) {
                if (!result || intersects[0].distance < result.distance) {
                    result = intersects[0];
                }
            }
        }

        if (!result)
            return null;

        var fragId = result.fragId,
            intersectPoint = result.point,
            face = result.face,
            model = result.model;

        var dbId = result.dbId;
        if (dbId === undefined && fragId !== undefined /* 0 is a valid fragId */) {

            dbId = model.getFragmentList().getDbIds(fragId);
            var instanceTree = model.getData().instanceTree;

            if (!instanceTree) {
                //Case where there is no object tree hierarchy. Create a 'virtual' node
                //with node Id = fragment Id, so that selection works like
                //each scene fragment is a scene node by itself.
                dbId = fragId;
            }
        }

        return { dbId: dbId, fragId: fragId, "intersectPoint":intersectPoint, "face":face, "model":model };
    };

    this.castRayViewport = function() {

        var _ray = new THREE.Ray();

        // Add "meshes" parameter, after we get meshes of the object using id buffer,
        // then we just need to ray intersect this object instead of all objects of the model.
        return function (vpVec, ignoreTransparent, dbIds) {
            if (!_modelQueue) {
                return {};
            }

            this.viewportToRay(vpVec, _ray);

            return this.rayIntersect(_ray, ignoreTransparent, dbIds);
        };

    }();

    this.clientToViewport = function (clientX, clientY)
    {
        var rect = _this.canvas.getBoundingClientRect();
        return new THREE.Vector3(
            ((clientX + 0.5) / rect.width) * 2 - 1,
           -((clientY + 0.5) / rect.height) * 2 + 1, 1 );
    };

    this.viewportToClient = function (viewportX, viewportY)
    {
        var rect = _this.canvas.getBoundingClientRect();
        return new THREE.Vector3(
            (viewportX + 1) * 0.5 * rect.width  - 0.5,
            (viewportY - 1) *-0.5 * rect.height - 0.5, 0 );
    };

    this.castRay = function (clientX, clientY, ignoreTransparent) {
        // Use the offsets based on the client rectangle, which is relative to the browser's client
        // rectangle, unlike offsetLeft and offsetTop, which are relative to a parent element.
        //
        return this.castRayViewport(this.clientToViewport(clientX, clientY),ignoreTransparent);
    };


    this.intersectGroundViewport = function(vpVec) {

        var camera = this.camera;

        var worldUp = "z";

        //In 2D mode, the roll tool can be used to change the orientation
        //of the sheet, which will also set the world up vector to the new orientation.
        //However, this is not what we want in case of a 2d sheet -- its ground plane is always Z.
        //TODO: It's not clear if checking here or in setWorldUp is better. Also I don't see
        //a way to generalize the math in a way to make it work without such check (e.g. by using camera up only).
        if (!this.is2d) {
            worldUp = _worldUpName;
        }

        var vector = vpVec;

        // set two vectors with opposing z values
        vector.z = -1.0;
        var end = new THREE.Vector3( vector.x, vector.y, 1.0 );
        vector = vector.unproject( camera );
        end = end.unproject( camera );

        // find direction from vector to end
        end.sub( vector ).normalize();

        var dir = end;

        //Is the direction parallel to the ground plane?
        //Then we fail.
        if (Math.abs(dir[worldUp]) < 1e-6)
            return null;

        var rayOrigin;
        if (camera.isPerspective) {
            rayOrigin = camera.position;
        }
        else {
            rayOrigin = vector;
        }

        var baseElev = this.model ? this.model.getBoundingBox().min[worldUp] : 0;

        var distance = (baseElev - rayOrigin[worldUp]) / dir[worldUp];

        //2D drawing, intersect the plane
        dir.multiplyScalar(distance);
        dir.add(rayOrigin);

        return dir;
    };

    this.intersectGround = function(clientX, clientY) {
        return this.intersectGroundViewport(this.clientToViewport(clientX, clientY));
    };


    this.hitTestViewport = function(vpVec, ignoreTransparent) {

        var result;

        if (_this.is2d) {

            // Set the detection area to 5*5 pixel search rectangle
            var dbId = _renderer.idAtPixels(vpVec.x, vpVec.y, 5);

            if (dbId <= 0)
                return null;

            //Note this function will destructively modify vpVec,
            //so it's unusable after that.
            var point = this.intersectGroundViewport(vpVec);

            //var node = dbId ? { dbId : dbId, fragIds : _this.model.getData().fragments.dbId2fragId[dbId] } : null;
            result = {
                intersectPoint : point,
                dbId : dbId,
                fragId : _this.model.getData().fragments.dbId2fragId[dbId],
                model: _this.model
            };
        }
        else {

            result = this.castRayViewport(vpVec, ignoreTransparent);

        }

        return result;
    };


    this.hitTest = function(clientX, clientY, ignoreTransparent) {

        return _this.hitTestViewport(this.clientToViewport(clientX, clientY), ignoreTransparent);

    };

    this.snappingHitTestViewport = function(vpVec, ignoreTransparent) {

        var result;

        if (_this.is2d) {

            //Notice: The amount of pixels per line should correspond to pixelSize in setDetectRadius of Snapper.js,
            //the shape of detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.
            var dbId = _renderer.idAtPixels(vpVec.x, vpVec.y, 17);

            // Need to do hitTest in snapping when dbId = 0
            if (dbId < 0)
                return null;

            //Note this function will destructively modify vpVec,
            //so it's unusable after that.
            var point = this.intersectGroundViewport(vpVec);

            //var node = dbId ? { dbId : dbId, fragIds : _this.model.getData().fragments.dbId2fragId[dbId] } : null;
            result = { intersectPoint : point, dbId : dbId, fragId : _this.model.getData().fragments.dbId2fragId[dbId] };

            if (dbId) {
                //stderr("dbId " + dbId);
                //result.node = ... get the node for the dbId here
            }

        }
        else {

            var dbId = _renderer.idAtPixel(vpVec.x, vpVec.y);

            result = this.castRayViewport(vpVec, ignoreTransparent, dbId > 0 ? [dbId] : null);

        }

        return result;
    };

    // Used for snapping
    // firstly, find the intersect object using pre-computed ID buffer
    // secondly, find the intersect point and face using intersection test
    this.snappingHitTest = function(clientX, clientY, ignoreTransparent) {

        return this.snappingHitTestViewport(this.clientToViewport(clientX, clientY), ignoreTransparent);
    };

    //Used for rollover highlighting using pre-computed ID buffer
    //Currently only the 2D code path can do this.
    this.rolloverObjectViewport = function(vpVec) {

        //Not supported for 3d.
        //if (!this.is2d)
        //    return;

        if (_renderer.rolloverObjectViewport(vpVec.x, vpVec.y))
            this.invalidate(false, false, true);
    };

    this.rolloverObject = function(clientX, clientY) {

        if (!this.rolloverDisabled)
            this.rolloverObjectViewport(this.clientToViewport(clientX, clientY));
    };

    this.disableRollover = function(disable) {

        this.rolloverDisabled = disable;
    };

    this.rolloverObjectNode = function(dbId) {

        var dbIds = [];
        var it = _this.model.getData().instanceTree;

        if (it) {

            it.enumNodeChildren(dbId, function(childId) {
                dbIds.push(childId);
            }, true);

            // Sort the array to get the dbIds range, it should exclude the first node which
            // is local root, since its dbId may not be serial number like its descendants.
            if (dbIds.length > 1) {
                var temp = dbIds.shift();
                dbIds.sort(function(a,b) {return a-b;});
                dbIds.unshift(temp);
            }

        }
        else {
            dbIds.push(dbId);
        }

        if (_renderer.rolloverObjectViewport(null, null, dbIds))
            this.invalidate(false, false, true);
    };

    // https://github.com/ebidel/filer.js/blob/master/src/filer.js
    function dataURLToBlob(dataURL) {
        var BASE64_MARKER = ';base64,';
        if (dataURL.indexOf(BASE64_MARKER) == -1) {
            var parts = dataURL.split(',');
            var contentType = parts[0].split(':')[1];
            var raw = decodeURIComponent(parts[1]);

            return new Blob([raw], {type: contentType});
        }

        var parts = dataURL.split(BASE64_MARKER);
        var contentType = parts[0].split(':')[1];
        var raw = window.atob(parts[1]);
        var rawLength = raw.length;

        var uInt8Array = new Uint8Array(rawLength);

        for (var i = 0; i < rawLength; ++i) {
            uInt8Array[i] = raw.charCodeAt(i);
        }

        return new Blob([uInt8Array], {type: contentType});
    }

    //this function get a blob object
    this.getScreenShotBuffer = function (w, h, cb) {
        _renderer.presentBuffer();
        var blobobj = _this.canvas.toDataURL("image/png");

        if (!w || !h)
            return blobobj;

        // calc resize and center
        var nw, nh, nx = 0, ny = 0;
        if (w > h || (_newWidth / _newHeight < w / h)) {
            nw = w;
            nh = _newHeight / _newWidth * w;
            ny = h / 2 - nh / 2;
        }
        else {
            nh = h;
            nw = _newWidth / _newHeight * h;
            nx = w / 2 - nw / 2;
        }

        var blobURL = window.URL.createObjectURL(dataURLToBlob(_this.canvas.toDataURL("image/png")));
        // new image from blobURL
        var img = new Image();
        img.src = blobURL;

        // create working canvas
        var tmpCanvas = document.createElement("canvas");
        var ctx = tmpCanvas.getContext("2d");
        tmpCanvas.width = w;
        tmpCanvas.height = h;

        // draw image on canvas
        img.onload = function () {
            ctx.drawImage(img, nx, ny, nw, nh);
            var newobj = tmpCanvas.toDataURL("image/png");
            var newBlobURL = window.URL.createObjectURL(dataURLToBlob(tmpCanvas.toDataURL("image/png")));
            if (cb)
                cb(newobj);
            else
                window.open(newBlobURL);
        };
    };

    // we use Blob URL, Chrome crashes when opening dataURL that is too large
    // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
    this.getScreenShot = function(w, h, cb) {
        _renderer.presentBuffer();
        var blobURL = window.URL.createObjectURL(dataURLToBlob(_this.canvas.toDataURL("image/png")));

        if (!w || !h)
            return blobURL;

        // calc resize and center
        var nw, nh, nx = 0, ny = 0;
        if (w > h || (_newWidth/_newHeight < w/h)) {
            nw = w;
            nh = _newHeight/_newWidth * w;
            ny = h/2 - nh/2;
        }
        else {
            nh = h;
            nw = _newWidth/_newHeight * h;
            nx = w/2 - nw/2;
        }

        // new image from blobURL
        var img = new Image();
        img.src = blobURL;

        // create working canvas
        var tmpCanvas = document.createElement("canvas");
        var ctx = tmpCanvas.getContext("2d");
        tmpCanvas.width = w;
        tmpCanvas.height = h;

        // draw image on canvas
        img.onload = function() {
            ctx.drawImage(img, nx, ny, nw, nh);
            var newBlobURL = window.URL.createObjectURL(dataURLToBlob(tmpCanvas.toDataURL("image/png")));
            if (cb)
                cb(newBlobURL);
            else
                window.open(newBlobURL);
        };
    };

    //This accessor is only used for debugging purposes a.t.m.
    this.modelQueue = function() { return _modelQueue; };

    this.glrenderer = function() { return _webglrender; };

    this.renderer = function() { return _renderer; };

    this.worldUp = function() { return _worldUp; };
    this.worldUpName = function() { return _worldUpName; };

    this.setUserRenderContext = function(ctx) {

        //restore our own render context
        if (!ctx) {
            _renderer = new RenderContext();
        }
        else {
            _renderer = ctx;
        }

        _renderer.init(_webglrender, this.canvas.clientWidth, this.canvas.clientHeight);
        _renderer.setClearColors(this.clearColorTop, this.clearColorBottom);
        this.invalidate(true);
        this.sceneUpdated(false); //to reset world boxes needed by new RenderContext for shadows, etc
    };

    this.invalidate = function(needsClear, needsRender, overlayDirty) {
        _needsClear = _needsClear || needsClear;
        _needsRender = _needsRender || needsRender;
        _overlayDirty = _overlayDirty || overlayDirty;
    };

    this.sceneUpdated = function(objectsMoved) {

        this.invalidate(true, false, true);

        // Mark the scene bounds for update
        if (_modelQueue && objectsMoved)
            _modelQueue.invalidateVisibleBounds();

        _sceneDirty = true;

    };

    this.currentLightPreset = function() { return _currentLightPreset; };

    this.matman = function() { return _materials; };

    this.fps = function() { return 1000.0 / _frameTimeAvg; };

    this.setFPSTargets = function(min, target, max) {
        MAX_FRAME_TIME = 1000 / max;
        MIN_FRAME_TIME = 1000 / min;
        TARGET_FRAME_TIME = 1000 / target;
        this.targetFrameTime = TARGET_FRAME_TIME;
    };

    //========================================================================

    this.api = theapi;
    this.canvas = thecanvas;
    
    this.loader = null;

    //TODO: node webgl renderer
    _webglrender = createRenderer(thecanvas);
    _renderer = new avp.RenderContext();
    _renderer.init(_webglrender, thecanvas ? thecanvas.clientWidth : 0, thecanvas ? thecanvas.clientHeight : 0);

    _materials = new avp.MaterialManager(this);

    //stderr("dpr: " + window.devicePixelRatio);

    //this.camera = new THREE.CombinedCamera( w, h, VIEW_ANGLE, NEAR, FAR, NEAR, FAR);
    // this.camera = new THREE.PerspectiveCamera( VIEW_ANGLE, thecanvas.clientWidth/thecanvas.clientHeight, NEAR, FAR);
    // this.cameraChangedEvent = {type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: this.camera};
    //this.camera = new THREE.CombinedCamera( w, h, VIEW_ANGLE, NEAR, FAR, NEAR, FAR);
    avp.init_UnifiedCamera(THREE);
    this.camera = new av.UnifiedCamera(thecanvas ? thecanvas.clientWidth : 512, thecanvas ? thecanvas.clientHeight : 512);
    this.lights = [];

    // this.camera = this.unicam.getOrthographicCamera();
    this.cameraChangedEvent = this.camera.getCameraChangedEvent();

    //This scene will just hold the camera and lights, while
    //we keep groups of progressively rendered geometry in
    //separate geometry scenes.
    this.scene = new THREE.Scene();
    this.sceneAfter = new THREE.Scene();
    this.sceneAfter.sortObjects = false;

    this.overlayScenes = {};

    this.selectionMaterial2d = null;

    this.selectionMaterialBase = new THREE.MeshPhongMaterial({color:0x6699ff, specular:0x080808, emissive:0x334c77, ambient:0, opacity:1.0, transparent:false});
    this.selectionMaterialTop = new THREE.MeshPhongMaterial({color:0x6699ff, specular:0x080808, emissive:0x334c77, ambient:0, opacity:0.15, transparent:true});
    this.selectionMaterialTop.packedNormals = true;
    this.selectionMaterialBase.packedNormals = true;
    createSelectionScene("selection", this.selectionMaterialBase, this.selectionMaterialTop);
    this.selectionMeshes = {};

    this.fadeMaterial = new THREE.MeshPhongMaterial({color:0xffffff, opacity:0.1, reflectivity: 0, transparent:true, depthWrite:false});
    this.fadeMaterial.packedNormals = true;
    _materials.addMaterial("__fadeMaterial__", this.fadeMaterial, true);

    this.highlightMaterial = new THREE.MeshPhongMaterial({color:0x6699ff, specular:0x080808, emissive:0x334c77, ambient:0, opacity:1.0, transparent:false});
    this.highlightMaterial.packedNormals = true;
    _materials.addMaterial("__highlightMaterial__", this.highlightMaterial, true);

    //Settings exposed to GUI:
    this.progressiveRender = true;

    if (av.isMobileDevice()) {
        MAX_FRAME_TIME *= 2;
        MIN_FRAME_TIME *= 2;
        TARGET_FRAME_TIME *= 2;
    }
    this.targetFrameTime = TARGET_FRAME_TIME;

    this.controls = {
        update: function(timeStamp) {
            this.camera.lookAt( this.camera.target );
            this.camera.updateProjectionMatrix();
            this.camera.dirty = false;
        },
        handleResize: function() {},
        recordHomeView: function() {},
        uninitialize: function() {}
    };

    this.selector = new avp.MultiModelSelector(this);

    this.visibilityManager = new avp.MultiModelVisibilityManager(this);

    this.showGhosting = true;
    this.showOverlaysWhileMoving = true;
    this.skipAOWhenMoving = false;

    this.keyFrameAnimator = null;

    var cc = avp.LightPresets[avp.DefaultLightPreset].bgColorGradient;
    this.setClearColors(cc[0], cc[1], cc[2], cc[3], cc[4], cc[5]);

    _groundShadow = new av.Shaders.GroundShadow(_webglrender);
    _groundShadow.enabled = true;

    // TODO_NOP: hack register materials for cutplanes
    _materials.addMaterialNonHDR("groundShadowDepthMaterial", _groundShadow.getDepthMaterial());
    _materials.addMaterialNonHDR("normalsMaterial", _renderer.getDepthMaterial());

    // Finally

    //just meant to do an initial clear to the background color we want.
    _renderer.beginScene(this.scene, this.camera, this.lights, true);
    _renderer.composeFinalFrame();

    // Record fragments transformation in explode mode for RaaS rendering
    //this.fragTransformConfig = [];

    this.log = function(event) {
        if (avp.logger) {
            avp.logger.log(event);
        }
    };

    this.worldToClient = function(point) {
        var p = new THREE.Vector4(point.x, point.y, point.z, 1);
        p.applyMatrix4(this.camera.matrixWorldInverse);
        p.applyMatrix4(this.camera.projectionMatrix);

        // Don't want to mirror values with negative z (behind camera)
        if (p.w > 0)
        {
            p.x /= p.w;
            p.y /= p.w;
            p.z /= p.w;
        }

        return this.viewportToClient(p.x, p.y);
    };

    this.clientToWorld = function(clientX, clientY, ignoreTransparent) {

        var result = null;
        var model = this.model;
        var modelData = model.getData();

        if (model.is2d()) {

            var collision = this.intersectGround(clientX, clientY);
            if (collision) {
                collision.z = 0;
                var bbox = modelData.bbox;
                if (modelData.hidePaper || bbox.containsPoint(collision)) {
                    result = {
                        point: collision,
                        model: model
                    };
                }
            }
        } else {

            // hitTest handles multiple scenes
            result = this.hitTest(clientX, clientY, ignoreTransparent);
            if (result) {
                result.point = result.intersectPoint; // API expects attribute point to have the return value too.
            }
        }

        return result;
    };

    /**
     *
     * @param {THREE.Color} color
     */
    this.setSelectionColor = function(color) {
        this.selectionMaterialBase.color.set(color);
        this.selectionMaterialTop.color.set(color);
        this.invalidate(false, false, true);
    };

    // Update the viewport Id for the first selection in 2d measure
    this.updateViewportId = function(vpId) {

        _materials.updateViewportId(vpId);
    };
}

Viewer3DImpl.prototype.constructor = Viewer3DImpl;

avp.Viewer3DImpl = Viewer3DImpl;

})();
;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * Responsible for creating and restoring viewer states.
 *
 * Main interactions come from methods
 * - getState()
 * - restoreState()
 *
 * Consumer classes can check if a given
 *
 * @tutorial viewer_state
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance used to operate on.
 * @constructor
 */
Autodesk.Viewing.Private.ViewerState = function( viewer )
{
    /**
     * All-inclusive filter constant used when no filter is provided.
     * @type {boolean}
     * @private
     */
    var FILTER_ALL = true;


    /**
     * Returns a unique identifier.
     *
     * @returns {string}
     * @deprecated
     * @private
     */
    function makeRandom() {
        // TODO: think a better way to get random numbers (Math.random is not a good random function).
        var random = Math.round(Math.random() * 0xffffffff);
        var timestamp = Date.now();

        return random.toString(16) + timestamp.toString(16);
    }


    /**
     * Returns a viewer state Object for the current viewer instance.
     *
     * For details and sample usage, please check {@tutorial viewer_state}
     *
     * @param {Object} [filter] - Object with a structure similar to the output where
     *                          values are replaced with Booleans true/false indicating
     *                          whether they should be stored or not.
     * @returns {Object} - Plain object describing the state of the viewer.
     * @tutorial viewer_state
     */
    this.getState = function( filter ) {

        var nav = viewer.navigation;
        var avp = Autodesk.Viewing.Private;
        var viewerState = {};

        // Adding level-0 properties
        viewerState["guid"] = makeRandom();
        viewerState["seedURN"] = this.getSeedUrn();
        viewerState["overrides"] = this.getTransformsOverrides();


        // Object set, contains selection, isolation and explode value.
        var objectSet = viewerState["objectSet"];
        if (!Array.isArray(objectSet)) {
            viewerState["objectSet"] = objectSet = [];
        }
        // Spec call for these elements to grouped in an Object at an Array's index 0.
        // 3d models attributes
        if(viewer.model && !viewer.model.is2d()) {
            objectSet[0] = {
                id: this.getSelectedNodes(),
                isolated: viewer.getIsolatedNodes(),
                hidden: viewer.getHiddenNodes(),
                explodeScale: viewer.getExplodeScale(),
                idType: 'lmv'
            };
        }
        // 2d models attributes
        if(viewer.model && viewer.model.is2d()) {
            objectSet[0] = {
                id: this.getSelectedNodes(), // Works for 2d and 3d
                isolated: this.getVisibleLayers2d(),
                hidden: [], // There's no hide feature for 2d.
                idType: 'lmv'
            };
        }

        // Viewport
        var viewport = viewerState["viewport"];
        if (!viewport) {
            viewport = viewerState["viewport"] = {};
        }
        
        var bPerspectiveCam = nav.getCamera().isPerspective;
        viewport["name"] = ""; // TODO: Populate accordingly; Requested by the mobile team.
        viewport["eye"] = nav.getPosition().toArray();
        viewport["target"] = nav.getTarget().toArray();
        viewport["up"] = nav.getCamera().up.toArray();
        viewport["worldUpVector"] = nav.getWorldUpVector().toArray();
        viewport["pivotPoint"] = nav.getPivotPoint().toArray();
        viewport["distanceToOrbit"] = nav.getPivotPlaneDistance();
        viewport["aspectRatio"] = this.getAspectRatio();
        viewport["projection"] = bPerspectiveCam ? "perspective" : "orthographic";
        viewport["isOrthographic"] = !bPerspectiveCam;
        if (bPerspectiveCam) {
            viewport["fieldOfView"] = nav.getVerticalFov();
        } else {
            viewport["orthographicHeight"] = this.getOrthographicHeight();
        }


        // Render Options
        var renderOptions = viewerState["renderOptions"];
        if (!renderOptions) {
            renderOptions = viewerState["renderOptions"] = {};
        }
        renderOptions["environment"] = avp.LightPresets[viewer.impl.currentLightPreset()].name;
        renderOptions["ambientOcclusion"] = {
            enabled: viewer.impl.renderer().settings.sao,
            radius: viewer.impl.renderer().getAORadius(),
            intensity: viewer.impl.renderer().getAOIntensity()
        };
        renderOptions["toneMap"] = {
            method: viewer.impl.renderer().getToneMapMethod(),
            exposure: viewer.impl.renderer().getExposureBias(),
            lightMultiplier: this.getToneMapIntensity()
        };
        renderOptions["appearance"] = {
            ghostHidden: viewer.impl.showGhosting,
            ambientShadow: viewer.prefs.ambientShadows,
            antiAliasing: viewer.impl.renderer().settings.antialias,
            progressiveDisplay: viewer.prefs.progressiveRendering,
            displayLines: viewer.prefs.lineRendering
        };

        // Cutplanes (aka: Sectioning) are a 3d-only feature.
        if (viewer.model && !viewer.model.is2d()) {
            var cutplanes = viewerState["cutplanes"] = [];
            var planes = viewer.getCutPlanes();
            for (var i=0; i<planes.length; i++) {
                cutplanes.push(planes[i].toArray());
            }
        }

        // Allow extensions to inject their state data
        for (var extensionName in viewer.loadedExtensions) {
            viewer.loadedExtensions[extensionName].getState(viewerState);
        }

        // Filter out values the user doesn't want to consume before returning.
        if (filter && filter !== FILTER_ALL) {
            this.applyFilter(viewerState, filter);
        }
        return viewerState;
    };


    /**
     * Restores the associated viewer instance with the provided viewerState object.
     *
     * For details and sample usage, please check {@tutorial viewer_state}
     *
     * @param {Object} viewerState
     * @param {Object} [filter] - Similar in structure to viewerState used to filter out values
     *                            that should not be restored.
     * @param {boolean} [immediate] - Whether the state should be apply with (false)
     *                                or without (true) a smooth transition
     *
     * @returns {boolean} true, if the operation was successful.
     * @tutorial viewer_state
     */
    this.restoreState = function( viewerState, filter, immediate ) {

        if (!viewerState) {
            stderr("restoreState has no viewer state to restore from.");
            return false;
        }

        if (!viewer || !viewer.model) {
            stderr("restoreState has no viewer or model to restore.");
            return false;
        }

        if (filter && filter !== FILTER_ALL) {
            // To avoid modifying viewerState passed in, we create a clone of it
            viewerState = JSON.parse(JSON.stringify(viewerState));
            this.applyFilter(viewerState, filter);
        }

        // Abort if we are still animating
        var nav = viewer.navigation;
        if( nav.getTransitionActive() ) {
            stderr("Abort restoreState, animation in progress...");
            return false;
        }

        var isModel2d = viewer.model.is2d();
        var isModel3d = !isModel2d;

        // Objectset
        if (viewer.model && Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];

            // Selection (2d and 3d)
            var selectionIds = objectSet.id;
            if (selectionIds) {
                selectionIds = this.toIntArray(selectionIds);
                viewer.select(selectionIds);
            }

            // Isolation / Hidden depends on whether it is 2d or 3d
            if (isModel2d) {

                // 2d Isolation is Layer visibility
                var visibleLayers = objectSet.isolated;
                if (Array.isArray(visibleLayers) && visibleLayers.length > 0) {
                    // Only certain layers are visible
                    viewer.setLayerVisible(null, false); // start by hiding all
                    viewer.impl.setLayerVisible(visibleLayers, true);
                } else {
                    // All layers are visible
                    viewer.setLayerVisible(null, true);
                }
            } else {
                // 3d Isolation
                var isolatedIds = objectSet.isolated || [];
                isolatedIds = this.toIntArray(isolatedIds);
                viewer.isolate(isolatedIds);

                // 3d Hidden nodes (only when there's no isolation) (3d only)
                if (isolatedIds.length === 0 ) {
                    var hiddenIds = objectSet.hidden || null;
                    if (hiddenIds && hiddenIds.length > 0) {
                        hiddenIds = this.toIntArray(hiddenIds);
                        viewer.hide(hiddenIds);
                    }
                }
            }

            // Explode scale (3d)
            if ("explodeScale" in objectSet) {
                var explodeScale = parseFloat(objectSet.explodeScale);
                if(viewer.explode) {
                    viewer.explode(explodeScale);
                }
            }
        }

        var viewport = viewerState.viewport;
        if (viewport) {

            var eye = this.getVector3FromArray(viewport.eye, nav.getPosition());
            var up = this.getVector3FromArray(viewport.up, nav.getCamera().up);
            var target = this.getVector3FromArray(viewport.target, nav.getTarget());
            var fov = ("fieldOfView" in viewport) ? parseFloat(viewport.fieldOfView) : nav.getVerticalFov();
            var worldUp = this.getVector3FromArray(viewport.worldUpVector, null);
            if (!worldUp) {
                var upVectorArray = viewer.model ? viewer.model.getUpVector() : null;
                if (upVectorArray) {
                    worldUp = new THREE.Vector3().fromArray(upVectorArray);
                } else {
                    worldUp = new THREE.Vector3(0,1,0); // TODO: Can we do better? Is it worth it?
                }
            }

            // Retain current values if not available in restore object
            var isPerspective = nav.getCamera().isPerspective;
            if ('isOrthographic' in viewport) {
                isPerspective = !viewport.isOrthographic;
            }
            var orthoScale = this.getOrthographicHeight();
            if ('orthographicHeight' in viewport) {
                orthoScale = Number(viewport.orthographicHeight);
            }

            // Pivot is currently not taken into account. Target is set as the new pivot.
            var camera = {
                position: eye,
                target: target,
                up: up,
                worldup: worldUp,
                aspect: viewer.impl.camera.aspect,
                fov: fov,
                orthoScale: orthoScale,
                isPerspective: isPerspective
            };

            this.restoreCameraState(camera, immediate);
        }


        // Render option state
        var renderOptions = viewerState.renderOptions;
        if (renderOptions) {

            // current values
            var saoEnabled = viewer.prefs.ambientShadows;
            var antiAliasing = viewer.prefs.antialiasing;

            var sao = renderOptions.ambientOcclusion;
            if (sao) {
                if ("enabled" in sao) {
                    saoEnabled = sao.enabled;
                }
                var saoRadius = ("radius" in sao) ? sao.radius : null;
                var saoIntensity = ("intensity" in sao) ? sao.intensity : null;
                if (saoRadius !== null && saoIntensity !== null) {
                    viewer.impl.renderer().setAOOptions(saoRadius, saoIntensity);
                    viewer.impl.renderer().composeFinalFrame(false);
                }
            }

            if ("environment" in renderOptions) {
                var lightPresetIndex = this.getLightPresetIndex(renderOptions.environment);
                if (lightPresetIndex !== -1 && isModel3d) {
                    viewer.setLightPreset(lightPresetIndex);
                }
            }

            // ToneMap values are overrides to the environment settings.
            var toneMap = renderOptions.toneMap;
            if (toneMap) {
                var lightMultiplier = "lightMultiplier" in toneMap ?  toneMap.lightMultiplier : null;
                var exposure = "exposure" in toneMap ? toneMap.exposure : null;
                if (lightMultiplier !== null && exposure !== null) {
                    if (viewer.impl.dir_light1) {
                        viewer.impl.dir_light1.intensity = Math.pow(2.0, lightMultiplier);
                    }
                    viewer.impl.renderer().setTonemapExposureBias(exposure, lightMultiplier);
                    viewer.impl.invalidate(true);
                }
            }

            var appearance = renderOptions.appearance;
            if (appearance) {
                if ("antiAliasing" in appearance) {
                    antiAliasing = appearance.antiAliasing;
                }
                if ("progressiveDisplay" in appearance) {
                    viewer.setProgressiveRendering(appearance.progressiveDisplay);
                }
                if (("ghostHidden" in appearance) && isModel3d) {
                    viewer.setGhosting(appearance.ghostHidden);
                }
                if ("displayLines" in appearance) {
                    viewer.hideLines(!appearance.displayLines);
                }
            }

            // SAO and AA at the end.
            if (isModel3d) {
                viewer.setQualityLevel(saoEnabled, antiAliasing);
            }
        }

        // Restore cutplanes (aka: Sectioning) data only for 3d models.
        if (Array.isArray(viewerState.cutplanes) && viewer.model && isModel3d) {
            var cutplanes = [];
            for (var i=0; i<viewerState.cutplanes.length; i++) {
                var plane = viewerState.cutplanes[i];
                if (Array.isArray(plane) && plane.length >= 4) {
                    cutplanes.push(new THREE.Vector4(plane[0], plane[1], plane[2], plane[3]));
                }
            }
            viewer.setCutPlanes(cutplanes);
        }

        // Allow extensions to restore their data
        for (var extensionName in viewer.loadedExtensions) {
            viewer.loadedExtensions[extensionName].restoreState(viewerState, immediate);
        }

        return true;
    };

    /**
     * Restores camera states values back into the viewer.
     * We avoid using methods such as setViewFromCamera() because those make some
     * assumptions about the current state of the viewer. We need no such things.
     *
     * Note: Implementation based on Viewer3DImpl.setViewFromCamera()
     *
     * @param {Object} camera
     * @param {Boolean} immediate
     * @private
     */
    this.restoreCameraState = function(camera, immediate) {

        viewer.impl.adjustOrthoCamera(camera);
        var navapi = viewer.navigation;

        if (!immediate) {
            // With animation
            viewer.impl.camera.isPerspective = camera.isPerspective;
            navapi.setRequestTransitionWithUp(true, camera.position, camera.target, camera.fov, camera.up, camera.worldup);
        } else {
            // Instantaneous, no animation
            if (camera.isPerspective) {
                navapi.toPerspective();
            } else {
                navapi.toOrthographic();
            }
            navapi.setCameraUpVector(camera.up);
            navapi.setWorldUpVector(camera.worldup);
            navapi.setView(camera.position, camera.target);
            navapi.setPivotPoint(camera.target);
            navapi.setVerticalFov(camera.fov, false);

            viewer.impl.syncCamera(true);
        }
    };

    /**
     * Helper method with the intent to change the type of an array with ids from String to ints.
     * We need this method because we need to make sure that ids that get fed into the ViewerState
     * are in the correct type.
     *
     * @param {Array} array - example: ["45", "33", "1"]
     * @returns {Array} - example: [45, 33, 1]
     * @private
     */
    this.toIntArray = function( array ) {
        var ret = [];
        if (Array.isArray(array)) {
            for (var i= 0, len=array.length; i<len; ++i) {
                ret.push( parseInt(array[i]) );
            }
        }
        return ret;
    };

    /**
     * Helper function that given a viewer state, extracts the selected nodes.
     *
     * @param {Object} viewerState - for example, the result of this.getState().
     * @return {Array} Array containing Number-typed ids of the selected nodes. Empty array when no 'selected'
     *                 objectSet value is defined.
     * @private
     * @deprecated
     */
    this.extractSelectedNodeIds = function( viewerState ) {

        if (viewerState && Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];
            return this.toIntArray(objectSet.id);
        }
        return [];
    };

    /**
     * Helper function that given a viewer state, extracts the isolated nodes.
     *
     * @param {Object} viewerState - for example, the result of this.getState().
     * @return {Array} Array containing Number-typed ids of the isolated nodes. Empty array when no 'isolated'
     *                 objectSet value is defined.
     * @private
     * @deprecated
     */
    this.extractIsolatedNodeIds = function( viewerState ) {

        if (viewerState && Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];
            return this.toIntArray(objectSet.isolated);
        }
        return [];
    };

    /**
     * Helper method that constructs a Vector3 from a given Array.
     * If Array is not well-formed, then the failValue is return instead.
     *
     * @param {Array} array - An array with 3 values
     * @param {THREE.Vector3} failValue - If array param is invalid, failValue will be returned instead.
     *
     * @returns {THREE.Vector3} either a new Vector with values coming from 'array' or failValue.
     * @private
     */
    this.getVector3FromArray = function(array, failValue) {

        if (array instanceof Array && array.length > 2) {

            // Some array values are exported as string-of-numbers. Fix that here.
            array[0] = parseFloat(array[0]);
            array[1] = parseFloat(array[1]);
            array[2] = parseFloat(array[2]);
            return new THREE.Vector3().fromArray(array);
        }
        return failValue;
    };

    /**
     * Helper function that returns selected node ids in an array.
     * @returns {Array}
     * @private
     */
    this.getSelectedNodes = function() {

        return viewer.impl && viewer.impl.selector ? viewer.impl.selector.getSelection() : [];

    };

    /**
     * Helper function that returns the index values of the isolated (visible) layers
     * Applies only to 2d models/blueprints
     * @private
     */
    this.getVisibleLayers2d = function() {
        var ret = [];
        var materialManager = viewer.impl.matman();
        var layersMap = materialManager.layersMap;
        for (var layerIndex in layersMap) {
            if (layersMap.hasOwnProperty(layerIndex)) {
                if (materialManager.isLayerVisible(layerIndex)){
                    ret.push(layerIndex);
                }
            }
        }
        return ret;
    };

    /**
     * Gets the aspect ratio.
     *
     * @returns {number} aspect ratio
     * @private
     */
    this.getAspectRatio = function() {
        var viewport = viewer.navigation.getScreenViewport();
        var aspect = viewport.width / viewport.height;
        return aspect;
    };

    /**
     * Returns world height when in orthographic camera mode.
     * @returns {number}
     * @private
     */
    this.getOrthographicHeight = function() {
        var cam = viewer.navigation.getCamera();
        if (cam.isPerspective) return 0;
        return Math.abs(2 * cam.orthographicCamera.top);
    };

    /**
     * Returns the URN of the document model.
     * @returns {String}
     */
    this.getSeedUrn = function() {
        if (viewer.model && viewer.model.loader) {
            return viewer.model.loader.svfUrn || "";
        }
        return "";
    };

    /**
     * TODO: Add proper comment
     * @returns {{}}
     * @private
     */
    this.getTransformsOverrides = function() {

        // TODO: Add proper implementation.
        return  { transformations: [] };
    };

    /**
     * Returns the slider value for the viewer's current light intensity
     * @returns {number}
     * @private
     */
    this.getToneMapIntensity = function () {

        // Original code from RenderOptionsPanel.js
        // Should probably live elsewhere in the api.
        var intensity = 0.0;
        if (viewer.impl.dir_light1) {
            if (viewer.impl.dir_light1.intensity != 0)
                intensity = Math.log(viewer.impl.dir_light1.intensity)/Math.log(2.0);
            else
                intensity = -1e-20;
        }
        return intensity;
    };

    /**
     * Returns the index of the LightPreset with a matching name value.
     * @param environmentName
     * @returns {number} index of LightPreset, or -1 if not found.
     * @private
     */
    this.getLightPresetIndex = function ( environmentName ) {

        var avp = Autodesk.Viewing.Private;
        for (var i=0; i<avp.LightPresets.length; i++) {
            if (avp.LightPresets[i].name === environmentName) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Filters out key/value pairs from the viewerState.
     *
     * @note To get all of the values available use FILTER_ALL. If no filter is provided FILTER_ALL will be used.
     *       It is encourage for consumers to define their specialized filters.
     *
     * @param {Object} viewerState - Object to be filtered.
     * @param {Object} filter - Object with a similar structure to viewerState, where values are Booleans signaling which
     *                          elements should be included (true) and which ones should not (false).
     *                          If a viewerState key is not found in the filter, we assume that it is non-wanted.
     *
     * @private
     */
    this.applyFilter = function( viewerState, filter ) {

        // Check the 'ALL' filter
        if (filter === true) return;

        // Filtering only 1 level depth keys
        // Additional levels are checked recursively.
        for (var key in viewerState) {

            if (!viewerState.hasOwnProperty(key)) {
                continue;
            }

            // Try to find the key in the filter object
            var filterValue = filter[key];

            if (filterValue === undefined) {

                // key not enabled in filter, remove key/value pair from viewerState.
                delete viewerState[key];
                stderr("[applyFilter] C - skipping key [" + key + "] from viewerState; unspecified in filter.");
            }
            else if (typeof(filterValue) === 'boolean') {

                if (filterValue === false) {
                    // key explicitly flagged for removal, remove key/value pair from viewerState.
                    delete viewerState[key];
                    stderr("[applyFilter] D - skipping key [" + key + "] from viewerState; explicit filtering.");
                }
            }
            else if (filterValue instanceof Object) {

                if (viewerState[key] instanceof Object) {
                    // Both are Objects, recursive call on them.
                    this.applyFilter(viewerState[key], filter[key]);
                } else {
                    // This case signals a miss-match between filter and value.
                    // Since it's an undefined case, we'll be inclusive for the time being.
                    // *** Keep the value in viewerState ***
                    stderr("[applyFilter] A - Invalid filter Object for key [" + key + "]");
                }
            }
            else {

                // Note: Every other value for filter is invalid.
                // For now, we'll keep the key/value in viewerState.
                stderr("[applyFilter] B - Invalid filter value for key [" + key + "]");
            }

        }
    };

};

Autodesk.Viewing.Private.ViewerState.prototype.constructor = Autodesk.Viewing.Private.ViewerState;
;// i18next, v1.7.3
// Copyright (c)2014 Jan Mühlemann (jamuhl).
// Distributed under MIT license
// http://i18next.com

AutodeskNamespace('Autodesk.Viewing.i18n');

(function() {

    var debugLocString = null;

    // Set a specific string that will be used for key values when translating
    function setDebugLocString() {
        debugLocString = 'aaaa';
        localize();
    }

    // Nullify debugLocString and run localization
    function clearDebugLocString() {
        debugLocString = null;
        localize();
    }

    // add indexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }
    
    // add lastIndexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.lastIndexOf) {
        Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = len;
            if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n != n) {
                    n = 0;
                } else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);
            for (; k >= 0; k--) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        };
    }
    
    // Add string trim for IE8.
    if (typeof String.prototype.trim !== 'function') {
        String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, ''); 
        }
    }

    var root = this
      , $ = root.jQuery || root.Zepto
      , i18n = {}
      , resStore = {}
      , currentLng
      , replacementCounter = 0
      , languages = []
      , initialized = false;

    // Export the i18next object for **CommonJS**. 
    // If we're not in CommonJS, add `i18n` to the
    // global object or to jquery.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = i18n;
    } else {
        if ($) {
            $.i18n = $.i18n || i18n;
        }
        root.i18n = root.i18n || i18n;
    }
    // defaults
    var o = {
        lng: undefined,
        load: 'current',
        preload: [],
        lowerCaseLng: false,
        returnObjectTrees: false,
        fallbackLng: ['dev'],
        fallbackNS: [],
        detectLngQS: 'setLng',
        ns: 'translation',
        fallbackOnNull: true,
        fallbackOnEmpty: false,
        fallbackToDefaultNS: false,
        nsseparator: ':',
        keyseparator: '.',
        selectorAttr: 'data-i18n',
        debug: false,
        
        resGetPath: 'res/locales/__lng__/__ns__.json',
        resPostPath: 'res/locales/add/__lng__/__ns__',
    
        getAsync: true,
        postAsync: true,
    
        resStore: undefined,
        useLocalStorage: false,
        localStorageExpirationTime: 7*24*60*60*1000,
    
        dynamicLoad: false,
        sendMissing: false,
        sendMissingTo: 'fallback', // current | all
        sendType: 'POST',
    
        interpolationPrefix: '__',
        interpolationSuffix: '__',
        reusePrefix: '$t(',
        reuseSuffix: ')',
        pluralSuffix: '_plural',
        pluralNotFound: ['plural_not_found', Math.random()].join(''),
        contextNotFound: ['context_not_found', Math.random()].join(''),
        escapeInterpolation: false,

        defaultValueFromContent: true,
        useDataAttrOptions: false,
        cookieExpirationTime: undefined,
        useCookie: true,
        cookieName: 'i18next',
        cookieDomain: undefined,
    
        objectTreeKeyHandler: undefined,
        postProcess: undefined,
        parseMissingKey: undefined,
    
        shortcutFunction: 'sprintf' // or: defaultValue
    };

    function _extend(target, source) {
        if (!source || typeof source === 'function') {
            return target;
        }
    
        for (var attr in source) { target[attr] = source[attr]; }
        return target;
    }
    
    function _each(object, callback, args) {
        var name, i = 0,
            length = object.length,
            isObj = length === undefined || Object.prototype.toString.apply(object) !== '[object Array]' || typeof object === "function";
    
        if (args) {
            if (isObj) {
                for (name in object) {
                    if (callback.apply(object[name], args) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.apply(object[i++], args) === false) {
                        break;
                    }
                }
            }
    
        // A special, fast, case for the most common use of each
        } else {
            if (isObj) {
                for (name in object) {
                    if (callback.call(object[name], name, object[name]) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.call(object[i], i, object[i++]) === false) {
                        break;
                    }
                }
            }
        }
    
        return object;
    }
    
    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;',
        "/": '&#x2F;'
    };
    
    function _escape(data) {
        if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
            });
        }else{
            return data;
        }
    }


    // This is taken from https://github.com/sindresorhus/strip-json-comments
    //
    var stripJsonComments = function( str ) {

        var currentChar;
        var nextChar;
        var insideString = false;
        var insideComment = false;
        var ret = '';

        for (var i = 0; i < str.length; i++) {
            currentChar = str[i];
            nextChar = str[i + 1];

            if (!insideComment && str[i - 1] !== '\\' && currentChar === '"') {
                insideString = !insideString;
            }

            if (insideString) {
                ret += currentChar;
                continue;
            }

            if (!insideComment && currentChar + nextChar === '//') {
                insideComment = 'single';
                i++;
            } else if (insideComment === 'single' && currentChar + nextChar === '\r\n') {
                insideComment = false;
                i++;
            } else if (insideComment === 'single' && currentChar === '\n') {
                insideComment = false;
            } else if (!insideComment && currentChar + nextChar === '/*') {
                insideComment = 'multi';
                i++;
                continue;
            } else if (insideComment === 'multi' && currentChar + nextChar === '*/') {
                insideComment = false;
                i++;
                continue;
            }

            if (insideComment) {
                continue;
            }

            ret += currentChar;
        }
        return ret;
    };

    function _ajax(options) {
    
        // v0.5.0 of https://github.com/goloroden/http.js
        var getXhr = function (callback) {
            // Use the native XHR object if the browser supports it.
            if (window.XMLHttpRequest) {
                return callback(null, new XMLHttpRequest());
            } else if (window.ActiveXObject) {
                // In Internet Explorer check for ActiveX versions of the XHR object.
                try {
                    return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                } catch (e) {
                    return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                }
            }
    
            // If no XHR support was found, throw an error.
            return callback(new Error());
        };
    
        var encodeUsingUrlEncoding = function (data) {
            if(typeof data === 'string') {
                return data;
            }
    
            var result = [];
            for(var dataItem in data) {
                if(data.hasOwnProperty(dataItem)) {
                    result.push(encodeURIComponent(dataItem) + '=' + encodeURIComponent(data[dataItem]));
                }
            }
    
            return result.join('&');
        };
    
        var utf8 = function (text) {
            text = text.replace(/\r\n/g, '\n');
            var result = '';
    
            for(var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
    
                if(c < 128) {
                        result += String.fromCharCode(c);
                } else if((c > 127) && (c < 2048)) {
                        result += String.fromCharCode((c >> 6) | 192);
                        result += String.fromCharCode((c & 63) | 128);
                } else {
                        result += String.fromCharCode((c >> 12) | 224);
                        result += String.fromCharCode(((c >> 6) & 63) | 128);
                        result += String.fromCharCode((c & 63) | 128);
                }
            }
    
            return result;
        };
    
        var base64 = function (text) {
            var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    
            text = utf8(text);
            var result = '',
                    chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    i = 0;
    
            do {
                chr1 = text.charCodeAt(i++);
                chr2 = text.charCodeAt(i++);
                chr3 = text.charCodeAt(i++);
    
                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;
    
                if(isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if(isNaN(chr3)) {
                    enc4 = 64;
                }
    
                result +=
                    keyStr.charAt(enc1) +
                    keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) +
                    keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while(i < text.length);
    
            return result;
        };
    
        var mergeHeaders = function () {
            // Use the first header object as base.
            var result = arguments[0];
    
            // Iterate through the remaining header objects and add them.
            for(var i = 1; i < arguments.length; i++) {
                var currentHeaders = arguments[i];
                for(var header in currentHeaders) {
                    if(currentHeaders.hasOwnProperty(header)) {
                        result[header] = currentHeaders[header];
                    }
                }
            }
    
            // Return the merged headers.
            return result;
        };

        //
        var ajax = function (method, url, options, callback) {
            // Adjust parameters.
            if(typeof options === 'function') {
                callback = options;
                options = {};
            }
    
            // Set default parameter values.
            options.doNotCache = options.doNotCache || false;
            options.data = options.data || {};
            options.headers = options.headers || {};
            options.jsonp = options.jsonp || false;
            options.async = options.async === undefined ? true : options.async;

            // Merge the various header objects.
            var headers = mergeHeaders({
                'accept': '*/*',
                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
            }, ajax.headers, options.headers);
    
            // Encode the data according to the content-type.
            var payload;
            if (headers['content-type'] === 'application/json') {
                payload = JSON.stringify(options.data);
            } else {
                payload = encodeUsingUrlEncoding(options.data);
            }
    
            // Specially prepare GET requests: Setup the query string, handle caching and make a JSONP call
            // if neccessary.
            if(method === 'GET') {
                // Setup the query string.
                var queryString = [];
                if(payload) {
                    queryString.push(payload);
                    payload = null;
                }
    
                // Handle caching.
                if(options.doNotCache) {
                    queryString.push('_=' + (new Date()).getTime());
                }
    
                // If neccessary prepare the query string for a JSONP call.
                if(options.jsonp) {
                    queryString.push('callback=' + options.jsonp);
                    queryString.push('jsonp=' + options.jsonp);
                }
    
                // Merge the query string and attach it to the url.
                queryString = queryString.join('&');
                if (queryString.length > 1) {
                    if (url.indexOf('?') > -1) {
                        url += '&' + queryString;
                    } else {
                        url += '?' + queryString;
                    }
                }
    
                // Make a JSONP call if neccessary.
                if(options.jsonp) {
                    var head = document.getElementsByTagName('head')[0];
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = url;
                    head.appendChild(script);
                    return;
                }
            }
    
            // Since we got here, it is no JSONP request, so make a normal XHR request.
            getXhr(function (err, xhr) {
                if(err) return callback(err);
    
                // Open the request.
                xhr.open(method, url, options.async);
    
                // Set the request headers.
                for(var header in headers) {
                    if(headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header, headers[header]);
                    }
                }
    
                // Handle the request events.
                xhr.onreadystatechange = function () {
                    if(xhr.readyState === 4) {
                        var data = xhr.responseText || '';

                        // If no callback is given, return.
                        if(!callback) {
                            return;
                        }
    
                        // Return an object that provides access to the data as text and JSON.
                        callback(xhr.status, data );

                    }
                };
    
                // Actually send the XHR request.
                xhr.send(payload);
            });
        };
    
        // Define the external interface.
        var http = {
            authBasic: function (username, password) {
                ajax.headers['Authorization'] = 'Basic ' + base64(username + ':' + password);
            },
    
            connect: function (url, options, callback) {
                return ajax('CONNECT', url, options, callback);
            },
    
            del: function (url, options, callback) {
                return ajax('DELETE', url, options, callback);
            },
    
            get: function (url, options, callback) {
                return ajax('GET', url, options, callback);
            },
    
            head: function (url, options, callback) {
                return ajax('HEAD', url, options, callback);
            },
    
            headers: function (headers) {
                ajax.headers = headers || {};
            },
    
            isAllowed: function (url, verb, callback) {
                this.options(url, function (status, data) {
                    callback(data.text().indexOf(verb) !== -1);
                });
            },
    
            options: function (url, options, callback) {
                return ajax('OPTIONS', url, options, callback);
            },
    
            patch: function (url, options, callback) {
                return ajax('PATCH', url, options, callback);
            },
    
            post: function (url, options, callback) {
                return ajax('POST', url, options, callback);
            },
    
            put: function (url, options, callback) {
                return ajax('PUT', url, options, callback);
            },
    
            trace: function (url, options, callback) {
                return ajax('TRACE', url, options, callback);
            }
        };
    
    
        var methode = options.type ? options.type.toLowerCase() : 'get';
    
        http[methode](options.url, options, function (status, data) {
            if (status === 200) {
                options.success(data, status, null);
            } else {
                options.error(data, status, null);
            }
        });
    }
    
    var _cookie = {
        create: function(name,value,minutes,domain) {
            var expires;
            if (minutes) {
                var date = new Date();
                date.setTime(date.getTime()+(minutes*60*1000));
                expires = "; expires="+date.toGMTString();
            }
            else expires = "";
            domain = (domain)? "domain="+domain+";" : "";
            document.cookie = name+"="+value+expires+";"+domain+"path=/";
        },
    
        read: function(name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for(var i=0;i < ca.length;i++) {
                var c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        },
    
        remove: function(name) {
            this.create(name,"",-1);
        }
    };
    
    var cookie_noop = {
        create: function(name,value,minutes,domain) {},
        read: function(name) { return null; },
        remove: function(name) {}
    };
    
    
    
    // move dependent functions to a container so that
    // they can be overriden easier in no jquery environment (node.js)
    var f = {
        extend: $ ? $.extend : _extend,
        each: $ ? $.each : _each,
        ajax: $ ? $.ajax : (typeof document !== 'undefined' ? _ajax : function() {}),
        cookie: typeof document !== 'undefined' ? _cookie : cookie_noop,
        detectLanguage: detectLanguage,
        escape: _escape,
        log: function(str) {
            if (o.debug && typeof console !== "undefined") console.log(str);
        },
        toLanguages: function(lng) {
            var languages = [];
            if (typeof lng === 'string' && lng.indexOf('-') > -1) {
                var parts = lng.split('-');
    
                lng = o.lowerCaseLng ?
                    parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                    parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
    
                if (o.load !== 'unspecific') languages.push(lng);
                if (o.load !== 'current') languages.push(parts[0]);
            } else {
                languages.push(lng);
            }
    
            for (var i = 0; i < o.fallbackLng.length; i++) {
                if (languages.indexOf(o.fallbackLng[i]) === -1 && o.fallbackLng[i]) languages.push(o.fallbackLng[i]);
            }
    
            return languages;
        },
        regexEscape: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        }
    };

    function init(options, cb) {
        
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        options = options || {};
        
        // override defaults with passed in options
        f.extend(o, options);
        delete o.fixLng; /* passed in each time */
    
        // create namespace object if namespace is passed in as string
        if (typeof o.ns == 'string') {
            o.ns = { namespaces: [o.ns], defaultNs: o.ns};
        }
    
        // fallback namespaces
        if (typeof o.fallbackNS == 'string') {
            o.fallbackNS = [o.fallbackNS];
        }
    
        // fallback languages
        if (typeof o.fallbackLng == 'string' || typeof o.fallbackLng == 'boolean') {
            o.fallbackLng = [o.fallbackLng];
        }
    
        // escape prefix/suffix
        o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix);
        o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix);
    
        if (!o.lng) o.lng = f.detectLanguage(); 
        if (o.lng) {
            // set cookie with lng set (as detectLanguage will set cookie on need)
            if (o.useCookie) f.cookie.create(o.cookieName, o.lng, o.cookieExpirationTime, o.cookieDomain);
        } else {
            o.lng =  o.fallbackLng[0];
            if (o.useCookie) f.cookie.remove(o.cookieName);
        }
    
        languages = f.toLanguages(o.lng);
        currentLng = languages[0];
        f.log('currentLng set to: ' + currentLng);
    
        var lngTranslate = translate;
        if (options.fixLng) {
            lngTranslate = function(key, options) {
                options = options || {};
                options.lng = options.lng || lngTranslate.lng;
                return translate(key, options);
            };
            lngTranslate.lng = currentLng;
        }
    
        pluralExtensions.setCurrentLng(currentLng);

        // return immidiatly if res are passed in
        if (o.resStore) {
            resStore = o.resStore;
            initialized = true;
            if (cb) cb(lngTranslate);
            return;
        }
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // else load them
        Autodesk.Viewing.i18n.sync.load(lngsToLoad, o, function(err, store) {
            resStore = store;
            initialized = true;
    
            if (cb) cb(lngTranslate);
        });
    }

    function preload(lngs, cb) {
        if (typeof lngs === 'string') lngs = [lngs];
        for (var i = 0, l = lngs.length; i < l; i++) {
            if (o.preload.indexOf(lngs[i]) < 0) {
                o.preload.push(lngs[i]);
            }
        }
        return init(cb);
    }
    
    function addResourceBundle(lng, ns, resources) {
        if (typeof ns !== 'string') {
            resources = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};
    
        f.extend(resStore[lng][ns], resources);
    }
    
    function removeResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = {};
    }
    
    function setDefaultNamespace(ns) {
        o.ns.defaultNs = ns;
    }
    
    function loadNamespace(namespace, cb) {
        loadNamespaces([namespace], cb);
    }
    
    function loadNamespaces(namespaces, cb) {
        var opts = {
            dynamicLoad: o.dynamicLoad,
            resGetPath: o.resGetPath,
            getAsync: o.getAsync,
            customLoad: o.customLoad,
            ns: { namespaces: namespaces, defaultNs: ''} /* new namespaces to load */
        };
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // check if we have to load
        var lngNeedLoad = [];
        for (var a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
            var needLoad = false;
            var resSet = resStore[lngsToLoad[a]];
            if (resSet) {
                for (var b = 0, lenB = namespaces.length; b < lenB; b++) {
                    if (!resSet[namespaces[b]]) needLoad = true;
                }
            } else {
                needLoad = true;
            }
    
            if (needLoad) lngNeedLoad.push(lngsToLoad[a]);
        }
    
        if (lngNeedLoad.length) {
            i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
                var todo = namespaces.length * lngNeedLoad.length;
    
                // load each file individual
                f.each(namespaces, function(nsIndex, nsValue) {
    
                    // append namespace to namespace array
                    if (o.ns.namespaces.indexOf(nsValue) < 0) {
                        o.ns.namespaces.push(nsValue);
                    }
    
                    f.each(lngNeedLoad, function(lngIndex, lngValue) {
                        resStore[lngValue] = resStore[lngValue] || {};
                        resStore[lngValue][nsValue] = store[lngValue][nsValue];
    
                        todo--; // wait for all done befor callback
                        if (todo === 0 && cb) {
                            if (o.useLocalStorage) i18n.sync._storeLocal(resStore);
                            cb();
                        }
                    });
                });
            });
        } else {
            if (cb) cb();
        }
    }
    
    function setLng(lng, options, cb) {
        if (typeof options === 'function') {
            cb = options;
            options = {};
        } else if (!options) {
            options = {};
        }
    
        options.lng = lng;
        return init(options, cb);
    }
    
    function lng() {
        return currentLng;
    }

    function applyReplacement(str, replacementHash, nestedKey, options) {
        if (!str) return str;
    
        options = options || replacementHash; // first call uses replacement hash combined with options
        if (str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;
    
        var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped
          , suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped
          , unEscapingSuffix = 'HTML'+suffix;
    
        f.each(replacementHash, function(key, value) {
            var nextKey = nestedKey ? nestedKey + o.keyseparator + key : key;
            if (typeof value === 'object' && value !== null) {
                str = applyReplacement(str, value, nextKey, options);
            } else {
                if (options.escapeInterpolation || o.escapeInterpolation) {
                    str = str.replace(new RegExp([prefix, nextKey, unEscapingSuffix].join(''), 'g'), value);
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.escape(value));
                } else {
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), value);
                }
                // str = options.escapeInterpolation;
            }
        });
        return str;
    }
    
    // append it to functions
    f.applyReplacement = applyReplacement;
    
    function applyReuse(translated, options) {
        var comma = ',';
        var options_open = '{';
        var options_close = '}';
    
        var opts = f.extend({}, options);
        delete opts.postProcess;
    
        while (translated.indexOf(o.reusePrefix) != -1) {
            replacementCounter++;
            if (replacementCounter > o.maxRecursion) { break; } // safety net for too much recursion
            var index_of_opening = translated.lastIndexOf(o.reusePrefix);
            var index_of_end_of_closing = translated.indexOf(o.reuseSuffix, index_of_opening) + o.reuseSuffix.length;
            var token = translated.substring(index_of_opening, index_of_end_of_closing);
            var token_without_symbols = token.replace(o.reusePrefix, '').replace(o.reuseSuffix, '');
    
    
            if (token_without_symbols.indexOf(comma) != -1) {
                var index_of_token_end_of_closing = token_without_symbols.indexOf(comma);
                if (token_without_symbols.indexOf(options_open, index_of_token_end_of_closing) != -1 && token_without_symbols.indexOf(options_close, index_of_token_end_of_closing) != -1) {
                    var index_of_opts_opening = token_without_symbols.indexOf(options_open, index_of_token_end_of_closing);
                    var index_of_opts_end_of_closing = token_without_symbols.indexOf(options_close, index_of_opts_opening) + options_close.length;
                    try {
                        opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing)));
                        token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                    } catch (e) {
                    }
                }
            }
    
            var translated_token = _translate(token_without_symbols, opts);
            translated = translated.replace(token, translated_token);
        }
        return translated;
    }
    
    function hasContext(options) {
        return (options.context && (typeof options.context == 'string' || typeof options.context == 'number'));
    }
    
    function needsPlural(options) {
        return (options.count !== undefined && typeof options.count != 'string' && options.count !== 1);
    }
    
    function exists(key, options) {
        options = options || {};
    
        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options);
    
        return found !== undefined || found === notFound;
    }
    
    function translate(key, options) {
        options = options || {};
    
        if (!initialized) {
            f.log('i18next not finished initialization. you might have called t function before loading resources finished.');
            var colon = key.indexOf(":");
            if (colon < 0)
                colon = 0;
            else
                colon++;

            var stringToReturn = options.defaultValue || key.substr(colon);
            if (stringToReturn)
                stringToReturn = applyReplacement( stringToReturn, options );
            return stringToReturn;
        }
        replacementCounter = 0;
        return _translate.apply(null, arguments);
    }
    
    function _getDefaultValue(key, options) {
        return (options.defaultValue !== undefined) ? options.defaultValue : key;
    }
    
    function _injectSprintfProcessor() {
    
        var values = [];
    
        // mh: build array from second argument onwards
        for (var i = 1; i < arguments.length; i++) {
            values.push(arguments[i]);
        }
    
        return {
            postProcess: 'sprintf',
            sprintf:     values
        };
    }
    
    function _translate(potentialKeys, options) {
        if (options && typeof options !== 'object') {
            if (o.shortcutFunction === 'sprintf') {
                // mh: gettext like sprintf syntax found, automatically create sprintf processor
                options = _injectSprintfProcessor.apply(null, arguments);
            } else if (o.shortcutFunction === 'defaultValue') {
                options = {
                    defaultValue: options
                }
            }
        } else {
            options = options || {};
        }
    
        if (potentialKeys === undefined || potentialKeys === null) return '';
    
        if (typeof potentialKeys == 'string') {
            potentialKeys = [potentialKeys];
        }
    
        var key = potentialKeys[0];
    
        if (potentialKeys.length > 1) {
            for (var i = 0; i < potentialKeys.length; i++) {
                key = potentialKeys[i];
                if (exists(key, options)) {
                    break;
                }
            }
        }
    
        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options)
            , lngs = options.lng ? f.toLanguages(options.lng) : languages
            , ns = options.ns || o.ns.defaultNs
            , parts;

        // split ns and key
        if (key.indexOf(o.nsseparator) > -1) {
            parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }

        if (found === undefined && o.sendMissing) {
            if (options.lng) {
                sync.postMissing(lngs[0], ns, key, notFound, lngs);
            } else {
                sync.postMissing(o.lng, ns, key, notFound, lngs);
            }
        }
    
        var postProcessor = options.postProcess || o.postProcess;
        if (found !== undefined && postProcessor) {
            if (postProcessors[postProcessor]) {
                found = postProcessors[postProcessor](found, key, options);
            }
        }

        // return localization test string, if a key is found and debugLocString is enabled
        if (debugLocString && found !== undefined) return debugLocString;
    
        // process notFound if function exists
        var splitNotFound = notFound;
        if (notFound.indexOf(o.nsseparator) > -1) {
            parts = notFound.split(o.nsseparator);
            splitNotFound = parts[1];
        }
        if (splitNotFound === key && o.parseMissingKey) {
            notFound = o.parseMissingKey(notFound);
        }
    
        if (found === undefined) {
            notFound = applyReplacement(notFound, options);
            notFound = applyReuse(notFound, options);
    
            if (postProcessor && postProcessors[postProcessor]) {
                var val = _getDefaultValue(key, options);
                found = postProcessors[postProcessor](val, key, options);
            }
        }
        return (found !== undefined) ? found : notFound;
    }
    
    function _find(key, options) {
        options = options || {};
    
        var optionWithoutCount, translated
            , notFound = _getDefaultValue(key, options)
            , lngs = languages;
    
        if (!resStore) { return notFound; } // no resStore to translate from
    
        // CI mode
        if (lngs[0].toLowerCase() === 'cimode') return notFound;
    
        // passed in lng
        if (options.lng) {
            lngs = f.toLanguages(options.lng);
    
            if (!resStore[lngs[0]]) {
                var oldAsync = o.getAsync;
                o.getAsync = false;
    
                Autodesk.Viewing.i18n.sync.load(lngs, o, function(err, store) {
                    f.extend(resStore, store);
                    o.getAsync = oldAsync;
                });
            }
        }
    
        var ns = options.ns || o.ns.defaultNs;
        if (key.indexOf(o.nsseparator) > -1) {
            var parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }
    
        if (hasContext(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.context;
            optionWithoutCount.defaultValue = o.contextNotFound;
    
            var contextKey = ns + o.nsseparator + key + '_' + options.context;
    
            translated = translate(contextKey, optionWithoutCount);
            if (translated != o.contextNotFound) {
                return applyReplacement(translated, { context: options.context }); // apply replacement for context only
            } // else continue translation with original/nonContext key
        }
    
        if (needsPlural(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.count;
            optionWithoutCount.defaultValue = o.pluralNotFound;
    
            var pluralKey = ns + o.nsseparator + key + o.pluralSuffix;
            var pluralExtension = pluralExtensions.get(lngs[0], options.count);
            if (pluralExtension >= 0) {
                pluralKey = pluralKey + '_' + pluralExtension;
            } else if (pluralExtension === 1) {
                pluralKey = ns + o.nsseparator + key; // singular
            }
    
            translated = translate(pluralKey, optionWithoutCount);
            if (translated != o.pluralNotFound) {
                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                }); // apply replacement for count only
            } // else continue translation with original/singular key
        }
    
        var found;
        var keys = key.split(o.keyseparator);
        for (var i = 0, len = lngs.length; i < len; i++ ) {
            if (found !== undefined) break;
    
            var l = lngs[i];
    
            var x = 0;
            var value = resStore[l] && resStore[l][ns];
            while (keys[x]) {
                value = value && value[keys[x]];
                x++;
            }
            if (value !== undefined) {
                var valueType = Object.prototype.toString.apply(value);
                if (typeof value === 'string') {
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (valueType === '[object Array]' && !o.returnObjectTrees && !options.returnObjectTrees) {
                    value = value.join('\n');
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (value === null && o.fallbackOnNull === true) {
                    value = undefined;
                } else if (value !== null) {
                    if (!o.returnObjectTrees && !options.returnObjectTrees) {
                        if (o.objectTreeKeyHandler && typeof o.objectTreeKeyHandler == 'function') {
                            value = o.objectTreeKeyHandler(key, value, l, ns, options);
                        } else {
                            value = 'key \'' + ns + ':' + key + ' (' + l + ')\' ' +
                                'returned an object instead of string.';
                            f.log(value);
                        }
                    } else if (valueType !== '[object Number]' && valueType !== '[object Function]' && valueType !== '[object RegExp]') {
                        var copy = (valueType === '[object Array]') ? [] : {}; // apply child translation on a copy
                        f.each(value, function(m) {
                            copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
                        });
                        value = copy;
                    }
                }
    
                if (typeof value === 'string' && value.trim() === '' && o.fallbackOnEmpty === true)
                    value = undefined;
    
                found = value;
            }
        }
    
        if (found === undefined && !options.isFallbackLookup && (o.fallbackToDefaultNS === true || (o.fallbackNS && o.fallbackNS.length > 0))) {
            // set flag for fallback lookup - avoid recursion
            options.isFallbackLookup = true;
    
            if (o.fallbackNS.length) {
    
                for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                    found = _find(o.fallbackNS[y] + o.nsseparator + key, options);
    
                    if (found) {
                        /* compare value without namespace */
                        var foundValue = found.indexOf(o.nsseparator) > -1 ? found.split(o.nsseparator)[1] : found
                          , notFoundValue = notFound.indexOf(o.nsseparator) > -1 ? notFound.split(o.nsseparator)[1] : notFound;
    
                        if (foundValue !== notFoundValue) break;
                    }
                }
            } else {
                found = _find(key, options); // fallback to default NS
            }
        }
    
        return found;
    }
    function detectLanguage() {
        var detectedLng;
    
        // get from qs
        var qsParm = [];
        if (typeof window !== 'undefined') {
            (function() {
                var query = window.location.search.substring(1);
                var parms = query.split('&');
                for (var i=0; i<parms.length; i++) {
                    var pos = parms[i].indexOf('=');
                    if (pos > 0) {
                        var key = parms[i].substring(0,pos);
                        var val = parms[i].substring(pos+1);
                        qsParm[key] = val;
                    }
                }
            })();
            if (qsParm[o.detectLngQS]) {
                detectedLng = qsParm[o.detectLngQS];
            }
        }
    
        // get from cookie
        if (!detectedLng && typeof document !== 'undefined' && o.useCookie ) {
            var c = f.cookie.read(o.cookieName);
            if (c) detectedLng = c;
        }
    
        // get from navigator
        if (!detectedLng && typeof navigator !== 'undefined') {
            detectedLng =  (navigator.language) ? navigator.language : navigator.userLanguage;
        }
        
        return detectedLng;
    }
    var sync = {
    
        load: function(lngs, options, cb) {
            if (options.useLocalStorage) {
                sync._loadLocal(lngs, options, function(err, store) {
                    var missingLngs = [];
                    for (var i = 0, len = lngs.length; i < len; i++) {
                        if (!store[lngs[i]]) missingLngs.push(lngs[i]);
                    }
    
                    if (missingLngs.length > 0) {
                        sync._fetch(missingLngs, options, function(err, fetched) {
                            f.extend(store, fetched);
                            sync._storeLocal(fetched);
    
                            cb(null, store);
                        });
                    } else {
                        cb(null, store);
                    }
                });
            } else {
                sync._fetch(lngs, options, function(err, store){
                    cb(null, store);
                });
            }
        },
    
        _loadLocal: function(lngs, options, cb) {
            var store = {}
              , nowMS = new Date().getTime();
    
            if(window.localStorage) {
    
                var todo = lngs.length;
    
                f.each(lngs, function(key, lng) {
                    var local = window.localStorage.getItem('res_' + lng);
    
                    if (local) {
                        local = JSON.parse(local);
    
                        if (local.i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS) {
                            store[lng] = local;
                        }
                    }
    
                    todo--; // wait for all done befor callback
                    if (todo === 0) cb(null, store);
                });
            }
        },
    
        _storeLocal: function(store) {
            if(window.localStorage) {
                for (var m in store) {
                    store[m].i18nStamp = new Date().getTime();
                    window.localStorage.setItem('res_' + m, JSON.stringify(store[m]));
                }
            }
            return;
        },
    
        _fetch: function(lngs, options, cb) {
            var ns = options.ns
              , store = {};
            
            if (!options.dynamicLoad) {
                var todo = ns.namespaces.length * lngs.length
                  , errors;


                // Load each file individually.
                f.each(ns.namespaces, function(nsIndex, nsValue) {
                    f.each(lngs, function(lngIndex, lngValue) {
                        
                        // Call this once our translation has returned.
                        var loadComplete = function(err, data) {
                            if (err) {
                                errors = errors || [];
                                errors.push(err);
                            }
                            store[lngValue] = store[lngValue] || {};
                            store[lngValue][nsValue] = data;
    
                            todo--; // wait for all done befor callback
                            if (todo === 0) cb(errors, store);
                        };
                        
                        if(typeof options.customLoad == 'function'){
                            // Use the specified custom callback.
                            options.customLoad(lngValue, nsValue, options, loadComplete);
                        } else {
                            //~ // Use our inbuilt sync.
                            sync._fetchOne(lngValue, nsValue, options, loadComplete);
                        }
                    });
                });

            } else {
                // Call this once our translation has returned.
                var loadComplete = function(err, data) {
                    cb(null, data);
                };
    
                if(typeof options.customLoad == 'function'){
                    // Use the specified custom callback.
                    options.customLoad(lngs, ns.namespaces, options, loadComplete);
                } else {
                    var url = applyReplacement(options.resGetPath, { lng: lngs.join('+'), ns: ns.namespaces.join('+') });
                    // load all needed stuff once
                    url = Autodesk.Viewing.Private.getResourceUrl(url);

                    f.ajax({
                        url: url,
                        success: function(data, status, xhr) {
                            f.log('loaded: ' + url);
                            loadComplete(null, data.json());
                        },
                        error : function(xhr, status, error) {
                            f.log('failed loading: ' + url);
                            loadComplete('failed loading resource.json error: ' + error);
                        },
                        dataType: "text",
                        async : options.getAsync
                    });
                }    
            }
        },
    
        _fetchOne: function(lng, ns, options, done) {

            var url = applyReplacement(options.resGetPath, { lng: lng, ns: ns });
            url = Autodesk.Viewing.Private.getResourceUrl(url);

            f.ajax({
                url: url,
                success: function(data, status, xhr) {
                    f.log('loaded: ' + url);
                    var jsonData = stripJsonComments( data );
                    done(null, JSON.parse( jsonData ));
                },
                error : function(xhr, status, error) {
                    if ((status && status == 200) || (xhr && xhr.status && xhr.status == 200)) {
                        // file loaded but invalid json, stop waste time !
                        f.log('There is a typo in: ' + url);
                    } else if ((status && status == 404) || (xhr && xhr.status && xhr.status == 404)) {
                        f.log('Does not exist: ' + url);
                    } else {
                        var theStatus = status ? status : ((xhr && xhr.status) ? xhr.status : null);
                        f.log(theStatus + ' when loading ' + url);
                    }
                    
                    done(error, {});
                },
                dataType: "text",
                async : options.getAsync
            });
        },
    
        postMissing: function(lng, ns, key, defaultValue, lngs) {
            var payload = {};
            payload[key] = defaultValue;
    
            var urls = [];
    
            if (o.sendMissingTo === 'fallback' && o.fallbackLng[0] !== false) {
                for (var i = 0; i < o.fallbackLng.length; i++) {
                    urls.push({lng: o.fallbackLng[i], url: applyReplacement(o.resPostPath, { lng: o.fallbackLng[i], ns: ns })});
                }
            } else if (o.sendMissingTo === 'current' || (o.sendMissingTo === 'fallback' && o.fallbackLng[0] === false) ) {
                urls.push({lng: lng, url: applyReplacement(o.resPostPath, { lng: lng, ns: ns })});
            } else if (o.sendMissingTo === 'all') {
                for (var i = 0, l = lngs.length; i < l; i++) {
                    urls.push({lng: lngs[i], url: applyReplacement(o.resPostPath, { lng: lngs[i], ns: ns })});
                }
            }
    
            for (var y = 0, len = urls.length; y < len; y++) {
                var item = urls[y];
                f.ajax({
                    url: item.url,
                    type: o.sendType,
                    data: payload,
                    success: function(data, status, xhr) {
                        f.log('posted missing key \'' + key + '\' to: ' + item.url);
    
                        // add key to resStore
                        var keys = key.split('.');
                        var x = 0;
                        var value = resStore[item.lng][ns];
                        while (keys[x]) {
                            if (x === keys.length - 1) {
                                value = value[keys[x]] = defaultValue;
                            } else {
                                value = value[keys[x]] = value[keys[x]] || {};
                            }
                            x++;
                        }
                    },
                    error : function(xhr, status, error) {
                        f.log('failed posting missing key \'' + key + '\' to: ' + item.url);
                    },
                    dataType: "json",
                    async : o.postAsync
                });
            }
        }
    };

    // definition http://translate.sourceforge.net/wiki/l10n/pluralforms
    var pluralExtensions = {
    
        rules: {
            "ach": {
                "name": "Acholi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "af": {
                "name": "Afrikaans", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ak": {
                "name": "Akan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "am": {
                "name": "Amharic", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "an": {
                "name": "Aragonese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ar": {
                "name": "Arabic", 
                "numbers": [
                    0, 
                    1, 
                    2, 
                    3, 
                    11, 
                    100
                ], 
                "plurals": function(n) { return Number(n===0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5); }
            }, 
            "arn": {
                "name": "Mapudungun", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "ast": {
                "name": "Asturian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ay": {
                "name": "Aymar\u00e1", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "az": {
                "name": "Azerbaijani", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "be": {
                "name": "Belarusian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "bg": {
                "name": "Bulgarian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "bn": {
                "name": "Bengali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "bo": {
                "name": "Tibetan", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "br": {
                "name": "Breton", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "bs": {
                "name": "Bosnian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "ca": {
                "name": "Catalan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "cgg": {
                "name": "Chiga", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "cs": {
                "name": "Czech", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2); }
            }, 
            "csb": {
                "name": "Kashubian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "cy": {
                "name": "Welsh", 
                "numbers": [
                    1, 
                    2, 
                    3, 
                    8
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3); }
            }, 
            "da": {
                "name": "Danish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "de": {
                "name": "German", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "dz": {
                "name": "Dzongkha", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "el": {
                "name": "Greek", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "en": {
                "name": "English", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "eo": {
                "name": "Esperanto", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "es": {
                "name": "Spanish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "es_ar": {
                "name": "Argentinean Spanish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "et": {
                "name": "Estonian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "eu": {
                "name": "Basque", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fa": {
                "name": "Persian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "fi": {
                "name": "Finnish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fil": {
                "name": "Filipino", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "fo": {
                "name": "Faroese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fr": {
                "name": "French", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "fur": {
                "name": "Friulian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fy": {
                "name": "Frisian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ga": {
                "name": "Irish", 
                "numbers": [
                    1, 
                    2,
                    3,
                    7, 
                    11
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4) ;}
            }, 
            "gd": {
                "name": "Scottish Gaelic", 
                "numbers": [
                    1, 
                    2, 
                    3,
                    20
                ], 
                "plurals": function(n) { return Number((n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3); }
            }, 
            "gl": {
                "name": "Galician", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "gu": {
                "name": "Gujarati", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "gun": {
                "name": "Gun", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "ha": {
                "name": "Hausa", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "he": {
                "name": "Hebrew", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hi": {
                "name": "Hindi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hr": {
                "name": "Croatian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "hu": {
                "name": "Hungarian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hy": {
                "name": "Armenian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ia": {
                "name": "Interlingua", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "id": {
                "name": "Indonesian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "is": {
                "name": "Icelandic", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n%10!=1 || n%100==11); }
            }, 
            "it": {
                "name": "Italian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ja": {
                "name": "Japanese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "jbo": {
                "name": "Lojban", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "jv": {
                "name": "Javanese", 
                "numbers": [
                    0, 
                    1
                ], 
                "plurals": function(n) { return Number(n !== 0); }
            }, 
            "ka": {
                "name": "Georgian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "kk": {
                "name": "Kazakh", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "km": {
                "name": "Khmer", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "kn": {
                "name": "Kannada", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ko": {
                "name": "Korean", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ku": {
                "name": "Kurdish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "kw": {
                "name": "Cornish", 
                "numbers": [
                    1, 
                    2, 
                    3,
                    4
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3); }
            }, 
            "ky": {
                "name": "Kyrgyz", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "lb": {
                "name": "Letzeburgesch", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ln": {
                "name": "Lingala", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "lo": {
                "name": "Lao", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "lt": {
                "name": "Lithuanian", 
                "numbers": [
                    1, 
                    2,
                    10
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "lv": {
                "name": "Latvian", 
                "numbers": [
                    1, 
                    2, 
                    0
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n !== 0 ? 1 : 2); }
            }, 
            "mai": {
                "name": "Maithili", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mfe": {
                "name": "Mauritian Creole", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mg": {
                "name": "Malagasy", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mi": {
                "name": "Maori", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mk": {
                "name": "Macedonian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n==1 || n%10==1 ? 0 : 1); }
            }, 
            "ml": {
                "name": "Malayalam", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mn": {
                "name": "Mongolian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mnk": {
                "name": "Mandinka", 
                "numbers": [
                    0, 
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(0 ? 0 : n==1 ? 1 : 2); }
            }, 
            "mr": {
                "name": "Marathi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ms": {
                "name": "Malay", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "mt": {
                "name": "Maltese", 
                "numbers": [
                    1, 
                    2, 
                    11, 
                    20
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n===0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3); }
            }, 
            "nah": {
                "name": "Nahuatl", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nap": {
                "name": "Neapolitan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nb": {
                "name": "Norwegian Bokmal", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ne": {
                "name": "Nepali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nl": {
                "name": "Dutch", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nn": {
                "name": "Norwegian Nynorsk", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "no": {
                "name": "Norwegian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nso": {
                "name": "Northern Sotho", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "oc": {
                "name": "Occitan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "or": {
                "name": "Oriya", 
                "numbers": [
                    2, 
                    1
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pa": {
                "name": "Punjabi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pap": {
                "name": "Papiamento", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pl": {
                "name": "Polish", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "pms": {
                "name": "Piemontese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ps": {
                "name": "Pashto", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pt": {
                "name": "Portuguese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pt_br": {
                "name": "Brazilian Portuguese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "rm": {
                "name": "Romansh", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ro": {
                "name": "Romanian", 
                "numbers": [
                    1, 
                    2,
                    20
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : (n===0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2); }
            }, 
            "ru": {
                "name": "Russian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "sah": {
                "name": "Yakut", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "sco": {
                "name": "Scots", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "se": {
                "name": "Northern Sami", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "si": {
                "name": "Sinhala", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sk": {
                "name": "Slovak", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2); }
            }, 
            "sl": {
                "name": "Slovenian", 
                "numbers": [
                    5, 
                    1, 
                    2, 
                    3
                ], 
                "plurals": function(n) { return Number(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0); }
            }, 
            "so": {
                "name": "Somali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "son": {
                "name": "Songhay", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sq": {
                "name": "Albanian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sr": {
                "name": "Serbian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "su": {
                "name": "Sundanese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "sv": {
                "name": "Swedish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sw": {
                "name": "Swahili", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ta": {
                "name": "Tamil", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "te": {
                "name": "Telugu", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "tg": {
                "name": "Tajik", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "th": {
                "name": "Thai", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ti": {
                "name": "Tigrinya", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "tk": {
                "name": "Turkmen", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "tr": {
                "name": "Turkish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "tt": {
                "name": "Tatar", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ug": {
                "name": "Uyghur", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "uk": {
                "name": "Ukrainian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "ur": {
                "name": "Urdu", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "uz": {
                "name": "Uzbek", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "vi": {
                "name": "Vietnamese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "wa": {
                "name": "Walloon", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "wo": {
                "name": "Wolof", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "yo": {
                "name": "Yoruba", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "zh": {
                "name": "Chinese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }
        },
    
        // for demonstration only sl and ar is added but you can add your own pluralExtensions
        addRule: function(lng, obj) {
            pluralExtensions.rules[lng] = obj;    
        },
    
        setCurrentLng: function(lng) {
            if (!pluralExtensions.currentRule || pluralExtensions.currentRule.lng !== lng) {
                var parts = lng.split('-');
    
                pluralExtensions.currentRule = {
                    lng: lng,
                    rule: pluralExtensions.rules[parts[0]]
                };
            }
        },
    
        get: function(lng, count) {
            var parts = lng.split('-');
    
            function getResult(l, c) {
                var ext;
                if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                    ext = pluralExtensions.currentRule.rule; 
                } else {
                    ext = pluralExtensions.rules[l];
                }
                if (ext) {
                    var i = ext.plurals(c);
                    var number = ext.numbers[i];
                    if (ext.numbers.length === 2 && ext.numbers[0] === 1) {
                        if (number === 2) { 
                            number = -1; // regular plural
                        } else if (number === 1) {
                            number = 1; // singular
                        }
                    }//console.log(count + '-' + number);
                    return number;
                } else {
                    return c === 1 ? '1' : '-1';
                }
            }
                        
            return getResult(parts[0], count);
        }
    
    };
    var postProcessors = {};
    var addPostProcessor = function(name, fc) {
        postProcessors[name] = fc;
    };

    // sprintf support
    var sprintf = (function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        function str_repeat(input, multiplier) {
            for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
            return output.join('');
        }
    
        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };
    
        str_format.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                    output.push(parse_tree[i]);
                }
                else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    }
                    else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    }
                    else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }
    
                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                        throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                        case 'b': arg = arg.toString(2); break;
                        case 'c': arg = String.fromCharCode(arg); break;
                        case 'd': arg = parseInt(arg, 10); break;
                        case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                        case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                        case 'o': arg = arg.toString(8); break;
                        case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                        case 'u': arg = Math.abs(arg); break;
                        case 'x': arg = arg.toString(16); break;
                        case 'X': arg = arg.toString(16).toUpperCase(); break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join('');
        };
    
        str_format.cache = {};
    
        str_format.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                }
                else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                }
                else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else {
                                    throw('[sprintf] huh?');
                                }
                            }
                        }
                        else {
                            throw('[sprintf] huh?');
                        }
                        match[2] = field_list;
                    }
                    else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                }
                else {
                    throw('[sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };
    
        return str_format;
    })();
    
    var vsprintf = function(fmt, argv) {
        argv.unshift(fmt);
        return sprintf.apply(null, argv);
    };
    
    addPostProcessor("sprintf", function(val, key, opts) {
        if (!opts.sprintf) return val;
    
        if (Object.prototype.toString.apply(opts.sprintf) === '[object Array]') {
            return vsprintf(val, opts.sprintf);
        } else if (typeof opts.sprintf === 'object') {
            return sprintf(val, opts.sprintf);
        }
    
        return val;
    });

    var localize = function() {
        // Parse data
        function parse( data ) {
            var attribute, value;

            var dataSplit = data.split(/\[|\]/);
            if (dataSplit.length === 1) {
                attribute = null;
                value = dataSplit[0];
            }
            else if (dataSplit.length===3) {
                attribute = dataSplit[1];
                value = dataSplit[2];
            }
            return [attribute, value];
        };

        Array.prototype.forEach.call (document.querySelectorAll ('[data-i18n]'), function (element){
            var dataToTranslate = element.getAttribute('data-i18n');
            var parsed  = parse( dataToTranslate );
            var attributeName  = parsed[0];
            var stringToTrans  = parsed[1];

            var translatedString = Autodesk.Viewing.i18n.translate(stringToTrans);
            if (translatedString)
            {
                if (attributeName) {
                    element.setAttribute( attributeName, translatedString );
                }
                else {
                    element.textContent = translatedString;
                }
            }
            else
            {
                if (attributeName) {
                    element.setAttribute( attributeName, stringToTrans );
                }
                else {
                    element.textContent = stringToTrans;
                }
            }
        });
    };

    // public api interface
    Autodesk.Viewing.i18n.init = init;
    Autodesk.Viewing.i18n.setLng = setLng;
    Autodesk.Viewing.i18n.preload = preload;
    Autodesk.Viewing.i18n.addResourceBundle = addResourceBundle;
    Autodesk.Viewing.i18n.removeResourceBundle = removeResourceBundle;
    Autodesk.Viewing.i18n.loadNamespace = loadNamespace;
    Autodesk.Viewing.i18n.loadNamespaces = loadNamespaces;
    Autodesk.Viewing.i18n.localize = localize;
    Autodesk.Viewing.i18n.setDefaultNamespace = setDefaultNamespace;
    Autodesk.Viewing.i18n.t = translate;
    Autodesk.Viewing.i18n.translate = translate;
    Autodesk.Viewing.i18n.exists = exists;
    Autodesk.Viewing.i18n.detectLanguage = f.detectLanguage;
    Autodesk.Viewing.i18n.pluralExtensions = pluralExtensions;
    Autodesk.Viewing.i18n.sync = sync;
    Autodesk.Viewing.i18n.functions = f;
    Autodesk.Viewing.i18n.lng = lng;
    Autodesk.Viewing.i18n.addPostProcessor = addPostProcessor;
    Autodesk.Viewing.i18n.options = o;
    Autodesk.Viewing.i18n.setDebugLocString = setDebugLocString;
    Autodesk.Viewing.i18n.clearDebugLocString = clearDebugLocString;

})();;/** @license Copyright (c) 2014 Autodesk Inc. */
/** Version : @buildnum@ */

(function() {

"use strict";

var avu = Autodesk.Viewing.UI;

/**
 *  DockingPanel represents a UI panel that is movable and resizeable within
 *  the bounds of its parent container.
 *  @constructor
 *
 *  @alias Autodesk.Viewing.UI.DockingPanel
 *
 *  @param {HTMLElement} parentContainer - The container for this panel.
 *  @param {string} id - The id to assign this panel.
 *  @param {string} title - The title of this panel.
 *  @param {Object=} [options] - An optional dictionary of options.
 *  @param {boolean} [options.localizeTitle=true] - When true, localization is attempted for the given title.
 * 
 * @example <caption>From DocumentExample.html</caption>
        // Example of a simple DockingPanel that displays the given content.
        // The titlebar and move behavior are overridden in initialize(), which also
        // creates a custom close button.
        //
        SimplePanel = function(parentContainer, id, title, content, x, y)
        {
            this.content = content;
            Autodesk.Viewing.UI.DockingPanel.call(this, parentContainer, id, '');

            // Auto-fit to the content and don't allow resize.  Position at the coordinates given.
            //
            this.container.style.height = "auto";
            this.container.style.width = "auto";
            this.container.style.resize = "none";
            this.container.style.left = x + "px";
            this.container.style.top = y + "px";
        };

        SimplePanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
        SimplePanel.prototype.constructor = SimplePanel;

        SimplePanel.prototype.initialize = function()
        {
            // Override DockingPanel initialize() to:
            // - create a standard title bar
            // - click anywhere on the panel to move
            // - create a close element at the bottom right
            //
            this.title = this.createTitleBar(this.titleLabel || this.container.id);
            this.container.appendChild(this.title);

            this.container.appendChild(this.content);
            this.initializeMoveHandlers(this.container);

            this.closer = document.createElement("div");
            this.closer.className = "simplePanelClose";
            this.closer.textContent = "Close";
            this.initializeCloseHandler(this.closer);
            this.container.appendChild(this.closer);
        };
 */
var DockingPanel = function (parentContainer, id, title, options) {

    // Constants
    this.kMinWdth   = 100;
    this.kMinHeight = 100;

    this.visibilityCallbacks = [];
    this.movedSinceLastClick = false;

    this.parentContainer = parentContainer;

    this.container = document.createElement("div");
    this.container.id = id;
    this.container.lastWidth = "";
    this.container.dockRight = false;
    this.container.dockBottom = false;
    this.titleLabel = title;

    // By default, localize the title.
    //
    options = options || {};
    if (!options.hasOwnProperty('localizeTitle')) {
        options.localizeTitle = true;
    }
    this.options = options;

    this.container.classList.add('dockingPanel');

    parentContainer.appendChild(this.container);
    this.listeners = [];

    this.initialize();

    // The panel is not visible initially.  The child class may still be constructing
    // the elements, so let it decide when to show.
    //
    this.setVisible(false);
};

/**
 *  Creates the sub-elements of this DockingPanel.  Override this in derived classes.
 *  The default implementation is to create a title bar with the title or id provided
 *  in the constructor.  The title bar also acts as the move handler for the DockingPanel.
 *  Finally, a close button is added to the top right corner.
 */
DockingPanel.prototype.initialize = function () {
    this.title = this.createTitleBar(this.titleLabel || this.container.id);
    this.container.appendChild(this.title);
    this.initializeMoveHandlers(this.title);
    this.setTitle(this.titleLabel || this.container.id, this.options);

    this.closer = this.createCloseButton();
    this.container.appendChild(this.closer);
};

/**
 *  Performs any clean up necessary.  This can include disconnecting UI elements,
 *  unregistering event callbacks, etc.
 *
 */
DockingPanel.prototype.uninitialize = function () {
    // Remove all of the listeners we're aware of.
    //
    for (var i = 0; i < this.listeners.length; ++i) {
        var listener = this.listeners[i];
        listener.target.removeEventListener(listener.eventId, listener.callback);
    }
    this.listeners = [];
    this.visibilityCallbacks = [];

    // Disconnect our DOM tree from our parent.
    //
    this.parentContainer.removeChild(this.container);
    this.parentContainer = null;
    this.container = null;
    this.title = null;
    this.closer = null;
};

/**
 *  Adds a callback to call when this DockingPanel changes visibility.
 *
 *  @param {function} callback - A function that takes in a single boolean parameter
 *                               indicating the current visibility state.
 */
DockingPanel.prototype.addVisibilityListener = function (callback) {
    this.visibilityCallbacks.push(callback);
};

/**
 *  Sets the new visibility state of this DockingPanel.
 *
 *  @param {boolean} show - The desired visibility state.
 */
DockingPanel.prototype.setVisible = function (show) {

    if (show) {
        var parentBox = this.getContainerBoundingRect();

        if (this.container.dockRight) {
            var screenw = parentBox.width;
            var wi2 = 300;

            var wi = this.container.lastWidth || this.container.style.width;
            if (!wi)
                wi = this.container.getBoundingClientRect().width;
            if (wi)
                wi2 = parseInt(wi);

            this.container.style.left = (screenw - wi2) + "px";
        }
        if (this.container.dockBottom) {
            var screenh = parentBox.height;
            var hi2 = 300;

            var hi = this.container.lastHeight || this.container.style.height;
            if (!hi)
                hi = this.container.getBoundingClientRect().height;
            if (hi)
                hi2 = parseInt(hi);

            this.container.style.top = (screenh - hi2) + "px";
        }

        this.container.style.maxHeight = parentBox.height + "px";
        this.container.style.maxWidth  = parentBox.width + "px";
            this.container.style.display = "block";

    }
    else {
        this.container.lastWidth = this.container.style.width;
        this.container.lastHeight = this.container.style.height;
        this.container.style.display = "none";
    }

    for (var i = 0; i < this.visibilityCallbacks.length; i++) {
        this.visibilityCallbacks[i](show);
    }
};

/**
 *  Gets the new visibility state of this DockingPanel.
 *
 *  return {boolean} - Whether or not the panel is visible
 */
DockingPanel.prototype.isVisible = function () {
    return (this.container.style.display === "block");
};

/**
 *  Notification that visibility has been changed by external sources.
 */
DockingPanel.prototype.visibilityChanged = function () {
};

/**
 *  Initializes the given HTMLDomElement as the move handle for this DockingPanel.
 *  When this element is clicked and dragged, this DockingPanel is moved.
 *
 *  @param {HTMLElement} mover - the DOM element that will act as the move handle.
 */
DockingPanel.prototype.initializeMoveHandlers = function (mover) {
    var x, y;
    var lastX, lastY;
    var startX, startY;
    var deltaX, deltaY;
    var container = this.container;
    var self = this;

    // This gets scoped under window during the handleMove event handler
    function handleMove(e) {
        var minWidth  = container.style.minWidth ? parseInt(container.style.minWidth) : self.kMinWdth,
            minHeight = container.style.minHeight ? parseInt(container.style.minHeight) : self.kMinHeight,
            parentRect = self.getContainerBoundingRect();

        if (container.style.maxWidth && parseInt(container.style.width) > parseInt(container.style.maxWidth)) {
            container.style.width = container.style.maxWidth;
        }
        if (container.style.maxHeight && parseInt(container.style.height) > parseInt(container.style.maxHeight)) {
            container.style.height = container.style.maxHeight;
        }

        if (parseInt(container.style.width) < minWidth) {
            container.style.width = minWidth + "px";
        }
        if (parseInt(container.style.height) < minHeight) {
            container.style.height = minHeight + "px";
        }
        if (e.type === "touchmove") {
            e.screenX = e.touches[0].screenX;
            e.screenY = e.touches[0].screenY;
        }

        deltaX += e.screenX - lastX;
        deltaY += e.screenY - lastY;

        x = startX + deltaX;
        y = startY + deltaY;

        var wi = parseInt(container.style.width);
        var hi = parseInt(container.style.height);

        if (isNaN(wi)) {
            wi = self.container.getBoundingClientRect().width;
        }
        if (isNaN(hi)) {
            hi = self.container.getBoundingClientRect().height;
        }

        // check left, top
        if (x < 5)
            x = 0;

        if (y < 5)
            y = 0;

        container.dockRight = false;
        container.dockBottom = false;

        // check bottom, right
        if (parentRect.width - 5 < x + wi) {
            x = parentRect.width - wi;
            container.dockRight = true;
        }

        if (parentRect.height - 5 < y + hi) {
            y = parentRect.height - hi;
            container.dockBottom = true;
        }
/*
        if (self.scrollContainer) {
            if (x == 0) {
                self.scrollContainer.classList.remove("right");
                self.scrollContainer.classList.add("left");
            }
            else {
                self.scrollContainer.classList.remove("left");
                self.scrollContainer.classList.add("right");
            }
        }
*/
        container.style.left = x + "px";
        container.style.top = y + "px";
        container.style.maxWidth  = (parentRect.width - x) + "px";
        container.style.maxHeight = (parentRect.height - y) + "px";

        //TODO: check for right side
        //TODO: handle docking and bounds check against the canvas element

        lastX = e.screenX;
        lastY = e.screenY;

        self.onMove(e, x, y);
    }

    function handleUp(e) {
        window.removeEventListener('mousemove', handleMove);
        window.removeEventListener('mouseup', handleUp);
        window.removeEventListener('touchmove', handleMove);
        window.removeEventListener('touchend', handleUp);
        self.onEndMove(e, x, y);
    }

    function handleDown(e) {
        if (e.type === "touchstart") {
            e.screenX = e.touches[0].screenX;
            e.screenY = e.touches[0].screenY;
        }
        lastX = e.screenX;
        lastY = e.screenY;

        deltaX = 0;
        deltaY = 0;

        // Save the current panel position relative to its parent container.
        //
        startX = self.container.offsetLeft;
        startY = self.container.offsetTop;

        window.addEventListener('mousemove', handleMove, false);
        window.addEventListener('mouseup', handleUp, false);
        window.addEventListener('touchmove', handleMove, false);
        window.addEventListener('touchend', handleUp, false);

        e.preventDefault();

        self.onStartMove(e, startX, startY);
    }

    // We'll keep track of the mousedown event listener as this one is always active.
    // The mousemove and mouseup listeners above are temporary so we don't need to track them.
    //
    self.addEventListener(mover, 'mousedown', handleDown);
    self.addEventListener(mover, 'touchstart', handleDown);
};

/**
 *  Initializes the given HTMLDomElement as the close handle for this DockingPanel.
 *  When this element is clicked, this DockingPanel is hidden.
 *
 *  @param {HTMLElement} closer - the DOM element that will act as the close handle.
 */
DockingPanel.prototype.initializeCloseHandler = function (closer) {
    var self = this;
    self.addEventListener(closer, 'click', function (e) {
        self.setVisible(false);
    }, false);
};

/**
 *  Creates a scroll container element to add to this DockingPanel.  Call this method during
 *  initialize() if a scroll container is needed. The function will create the scroll container
 *  and make it available via the "scrollContainer" property of the DockingPanel.
 *
 *  @param {Object=} [options] - An optional dictionary of options.
 *  @param {boolean} [options.left=false] - When true, the scrollbar appears on the left.
 *  @param {int} [options.heightAdjustment=0] - The scroll container height is 100% of the panel
 *                                              minus the height adjustment.  Provide a value
 *                                              to account for other elements in the panel like a title bar.
 *  @param {int} [options.marginTop=0] - The marginTop setting for the scroll container's CSS style, in pixels.
 */
DockingPanel.prototype.createScrollContainer = function (options) {
    var scrollContainer = document.createElement("div"),
        classList = scrollContainer.classList;
    classList.add('dockingPanelScroll');
    classList.add((options && options.left) ? 'left' : 'right');

    if (options && options.heightAdjustment) {
        scrollContainer.style.height = "calc(100% - " + options.heightAdjustment + "px)";
    }

    if (options.marginTop) {
        scrollContainer.style.marginTop = options.marginTop + "px";
    }

    scrollContainer.id = this.container.id + '-scroll-container';

    this.container.appendChild(scrollContainer);
    this.scrollContainer = scrollContainer;

    return scrollContainer; //for backwards compatibility we still return that, though it's no longer documented that way.
};



/**
 *  Creates a title bar element to add to this DockingPanel.  Call this method during
 *  initialize() if a standard title bar is desired, and then add it to an existing container.
 *
 *  @param {string} title - The text to use in the title bar.
 *
 *  @returns {HTMLElement} The created title bar.
 */
DockingPanel.prototype.createTitleBar = function (title) {
    var titleBar = document.createElement("div");
    titleBar.className = "dockingPanelTitle";
    titleBar.textContent = title;

    var that = this;
    that.addEventListener(titleBar, 'click', function (event) {
        if (!that.movedSinceLastClick) {
            that.onTitleClick(event);
        }
        that.movedSinceLastClick = false;
    });

    that.addEventListener(titleBar, 'dblclick', function (event) {
        that.onTitleDoubleClick(event);
    });

    return titleBar;
};

/**
 * Sets the title for this panel.
 *
 * @param {string} text - The title for this panel.
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {boolean} [options.localizeTitle=false] - When true, localization is attempted for the given text.
 */
DockingPanel.prototype.setTitle = function (text, options) {
    if (options && options.localizeTitle) {
        this.title.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    } else {
        this.title.removeAttribute('data-i18n');
    }
    this.title.textContent = text;
};

/**
 *  Creates a close button to add to this DockingPanel.  When clicked, this DockingPanel
 *  is hidden.  Call this method during initialize() if a standard close button is desired,
 *  and then add it to an existing container.
 *
 *  @returns {HTMLElement} The created close button.
 */
DockingPanel.prototype.createCloseButton = function () {
    var closeButton = document.createElement("div");
    closeButton.className = "dockingPanelClose";
    closeButton.innerHTML = "&times;";
    this.initializeCloseHandler(closeButton);
    return closeButton;
};

/**
 * Override this event to be notified when this panel begins a move operation.
 *
 * @param {MouseEvent} event - The mousedown event.
 * @param {int} startX - The starting x position of the panel in pixels.
 * @param {int} startY - The starting y position of the panel in pixels.
 */
DockingPanel.prototype.onStartMove = function (event, startX, startY) {
};

/**
 * Override this event to be notified when this panel ends a move operation.
 *
 * @param {MouseEvent} event - The mouseup event.
 * @param {int} endX - The ending x position of the panel in pixels.
 * @param {int} endY - The ending y position of the panel in pixels.
 */
DockingPanel.prototype.onEndMove = function (event, endX, endY) {
};

/**
 * Override this to be notified when this panel is moved.  Note, do not forget to call
 * this base class method in the overriding method.
 *
 * @param {MouseEvent} event - The mousemove event
 * @param {int} currentX - The current x position of the panel in pixels
 * @param {int} currentY - The current y position of the panel in pixels
 */
DockingPanel.prototype.onMove = function (event, currentX, currentY) {
    this.movedSinceLastClick = true;
};

/**
 * Override this method to be notified when the user clicks on the title.
 * @param {Event} event
 */
DockingPanel.prototype.onTitleClick = function (event) {
};

/**
 * Override this method to be notified when the user double-clicks on the title.
 * @param {Event} event
 */
DockingPanel.prototype.onTitleDoubleClick = function (event) {
};

/**
 * Adds an event listener to a given target that has an addEventListener(event, callback) API.
 * These event listeners are tracked by the DockingPanel and are automatically removed on uninitialize.
 *
 * @param {Object} target - The target that will fire the event.
 * @param {string} eventId - The event to be listened to.
 * @param {function} callback - The callback to execute when the event is fired.
 */
DockingPanel.prototype.addEventListener = function (target, eventId, callback) {
    target.addEventListener(eventId, callback);
    this.listeners.push({target: target, eventId: eventId, callback: callback});
};

/**
 * Removes an existing event listener added using DockingPanel.addEventListener.
 *
 * @param {Object} target - The target with the event listener.
 * @param {string} eventId - The id of the event being listened to.
 * @param {function} callback - The callback executed when the event is fired.
 *
 * @returns {boolean} - true if the listener was removed successfully; false otherwise.
 */
DockingPanel.prototype.removeEventListener = function (target, eventId, callback) {
    for (var i = 0; i < this.listeners.length; ++i) {
        var listener = this.listeners[i];
        if (listener.target === target && listener.eventId === eventId && listener.callback === callback) {
            target.removeEventListener(eventId, callback);
            this.listeners.splice(i, 1);
            return true;
        }
    }
    return false;
};

/**
 * Override this method to return the width and height to use when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
DockingPanel.prototype.getContentSize = function () {
    return {height: this.container.clientHeight, width: this.container.clientWidth};
};

/**
 * Resizes the panel to the current content.  Currently this only works on height.
 *
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {int} [options.maxHeight] - The maximum height to resize this panel.
 */
DockingPanel.prototype.resizeToContent = function (options) {

    if (!this.isVisible())
        return;

    var dimensions = this.getContentSize(),
        newHeight  = dimensions.height,
        panelRect  = this.container.getBoundingClientRect(),
        parentRect = this.getContainerBoundingRect();

    var toolbarHeight = 75; //hardcoded clearance for the toolbar at the bottom

    var maxHeight = options && options.maxHeight ? options.maxHeight - panelRect.top: parentRect.height - panelRect.top;
    maxHeight -= toolbarHeight;

    if (newHeight > maxHeight) {
        newHeight = maxHeight;
    }

    // TODO: Once toolbar can be positioned anywhere, we will also need to
    // do the same for the width.
    this.container.style.height = newHeight.toString() + 'px';
};

/**
 * Returns the parent's container bounding rectangle.
 *
 * @returns {ClientRect} - bounding rectangle of the parent.
 */
DockingPanel.prototype.getContainerBoundingRect = function () {
    return this.parentContainer.getBoundingClientRect();
};

Autodesk.Viewing.UI.DockingPanel = DockingPanel;

})();;/** @license Copyright (c) 2014 Autodesk Inc. */
/** Version : @buildnum@ */

(function() {

"use strict";

var avu = Autodesk.Viewing.UI;

/**
 * ModelStructurePanel
 * Sets the model structure panel for displaying the loaded model.
 * @class
 * @augments Autodesk.Viewing.UI.DockingPanel
 *
 * @param {HTMLElement} parentContainer - The container for this panel.
 * @param {string} id - The id for this panel.
 * @param {string} title - The initial title for this panel.
 * @param {Object} [options] - An optional dictionary of options.
 * @param {boolean} [options.startCollapsed=true] - When true, collapses all of the nodes under the root.
 * @constructor
 */
var ModelStructurePanel = function(parentContainer, id, title, options)
{
    avu.DockingPanel.call(this, parentContainer, id, title, options);
    this.container.classList.add('modelStructurePanel');
    
    options = options || {};
    if (!options.heightAdjustment)
        options.heightAdjustment = 40;
    if (!options.marginTop)
        options.marginTop = 0;
    options.left = true;
    
    this.createScrollContainer(options);

    this.options = options;
    this.instanceTree = null;
    this.tree = null;
    this.selectedNodes = [];

    this.uiCreated = false;

    var that = this;
    this.addVisibilityListener(function (show) {
        if (show) {
            if (!that.uiCreated) {
                that.createUI();                
            }
            
            that.resizeToContent();
        }
    });
    
    
};

ModelStructurePanel.prototype = Object.create(avu.DockingPanel.prototype);
ModelStructurePanel.prototype.constructor = ModelStructurePanel;

/**
 * Sets the model for this panel to display.
 *
 * @param {InstanceTree} instanceTree - The object tree returned by Autodesk.Viewing.Model.getObjectTree( function(instanceTree) );
 * @param {string=} [modelTitle] - An optional title to display for this model.
 */
ModelStructurePanel.prototype.setModel = function(instanceTree, modelTitle)
{
    this.instanceTree = instanceTree;
    this.modelTitle = modelTitle;

    if (this.isVisible())
        this.createUI();
    else    
        this.uiCreated = false;
};

/**
 * Used for delayed initialization of the HTML DOM tree
 * @private
 */
ModelStructurePanel.prototype.createUI = function()
{
    var that = this;
    var instanceTree = that.instanceTree;
    
    if (!instanceTree)
        return;

    var createDelegate = function()
    {
        var delegate = new avu.TreeDelegate();
     
        delegate.getTreeNodeId = function(node)
        {
            if (typeof node == "object") {
                stderr("Object used instead of dbId. Fix it.");
                return node.dbId;
            } else
                return node;
        };

        delegate.getTreeNodeLabel = function(node)
        {
            var dbId = this.getTreeNodeId(node);

            var res = that.instanceTree.getNodeName(dbId);

            return res || ('Object ' + dbId);
        };

        delegate.getTreeNodeClass = function(node)
        {
            return that.getNodeClass(node);
        };

        delegate.isTreeNodeGroup = function(node)
        {
            return that.isGroupNode(node);
        };

        delegate.shouldCreateTreeNode = function(node)
        {
            return that.shouldInclude(node);
        };

        delegate.onTreeNodeClick = function(tree, node, event)
        {
            that.onClick(node, event);
        };

        delegate.onTreeNodeRightClick = function(tree, node, event)
        {
            that.onRightClick(node, event);
        };

        delegate.onTreeNodeDoubleClick = function(tree, node, event)
        {
            that.onDoubleClick(node, event);
        };

        delegate.onTreeNodeIconClick = function(tree, node, event)
        {
            that.onIconClick(node, event);
        };

        delegate.forEachChild = function(node, callback) {

            var dbId = this.getTreeNodeId(node);

            that.instanceTree.enumNodeChildren(dbId, callback);
        };

        delegate.onTreeNodeHover = function(tree, node, event)
        {
            that.onHover(node, event);
        };

        return delegate;
    };

    that.selectedNodes = [];

    var title = that.modelTitle;

    if(!title) {
        if (that.options && that.options.defaultTitle) {
            title = that.options.defaultTitle;
        }
    }

    var options = {};
    if(!title) {
        title = "Browser";  // localized by DockingPanel.prototype.setTitle
        options.localizeTitle = true;
    }
    that.setTitle(title, options);

    // Remove the previous tree from the scroll container and any listeners on the title bar.
    //
    if(that.tree) {
        while(that.scrollContainer.hasChildNodes()){
            that.scrollContainer.removeChild(that.scrollContainer.lastChild);
        }
        that.title.removeEventListener("click", that.onTitleClick);
        that.title.removeEventListener("dblclick", that.onTitleDoubleClick);
    }

    var rootId = this.rootId = instanceTree.getRootId();
    var rootName = instanceTree.getNodeName(rootId);
    var childName;
    var childId = 0;
    var childCount = 0;
    instanceTree.enumNodeChildren(rootId, function(child) {
        if (!childCount) {
            childName = instanceTree.getNodeName(child);
            childId = child;
        }
        childCount++;
    });

    var delegate = createDelegate();
    this.myDelegate = delegate;

    //Detect Fusion models which have a root inside a root (which was probably an arms race
    //against us putting the root in the title bar)
    var skipRoot = (childCount === 1 && rootName === childName);

    var treeOptions = {
        excludeRoot: skipRoot,
        localize: true
    };
    that.tree = new avu.Tree(delegate, rootId, that.scrollContainer, treeOptions);

    if(!that.options || !that.options.hasOwnProperty('startCollapsed') || that.options.startCollapsed) {
        that.tree.setAllCollapsed(true);
        
        that.tree.setCollapsed(rootId, false);
        if (skipRoot)
            that.tree.setCollapsed(childId, false);
    }

    this.uiCreated = true;
};

/**
 * Override this method to specify the label for a node.
 * By default, this is the node's name, or 'Object ' + object id if the name
 * is blank.
 *
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @returns {string} Label of the tree node
 */
ModelStructurePanel.prototype.getNodeLabel = function(node)
{
    return this.myDelegate.getNodeLabel(node);
};

/**
 * Override this to specify the CSS classes of a node. This way, in CSS, the designer
 * can specify custom styling per type.
 * By default, an empty string is returned.
 *
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @returns {string} CSS classes for the node
 */
ModelStructurePanel.prototype.getNodeClass = function(node)
{
    return '';
};

/**
 * Override this method to specify whether or not a node is a group node.
 * By default, a node is considered a group if it has a 'children' property containing
 * an array with at least one element.
 *
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @returns {boolean} true if this node is a group node, false otherwise
 */
ModelStructurePanel.prototype.isGroupNode = function(node)
{
    var dbId = this.myDelegate.getTreeNodeId(node);
    return this.instanceTree.getChildCount(dbId);
};

/**
 * Override this method to specify if a tree node should be created for this node.
 * By default, every node will be displayed.
 *
 * @param {Object} node - A node in an {@link Autodesk.Viewing.Model}
 * @returns {boolean} true if a node should be created, false otherwise
 */
ModelStructurePanel.prototype.shouldInclude = function(node)
{
    return true;
};

/**
 * Override this method to do something when the user clicks on a tree node
 * @param {Object} node - A node in an {@link Autodesk.Viewing.Model}
 * @param {Event} event
 */
ModelStructurePanel.prototype.onClick = function(node, event)
{
    this.setSelection([node]);
};

/**
 * Override this to do something when the user double-clicks on a tree node
 *
 * @param {Object} node - A node in an {@link Autodesk.Viewing.Model}
 * @param {Event} event
 */
ModelStructurePanel.prototype.onDoubleClick = function(node, event)
{
};

/**
 * Override this to do something when the user clicks on a tree node's icon.
 * By default, groups will be expanded/collapsed.
 *
 * @param {Object} node - A node in an {@link Autodesk.Viewing.Model}
 * @param {Event} event
 */
ModelStructurePanel.prototype.onIconClick = function(node, event)
{
    this.setGroupCollapsed(node, !this.isGroupCollapsed(node));
};

/**
 * Collapse/expand a group node.
 *
 * @param {Object} node - A node to collapse/expand in the tree.
 * @param {Boolean} collapsed - True to collapse the group, false to expand it.
 */
ModelStructurePanel.prototype.setGroupCollapsed = function(node, collapsed)
{
    var delegate = this.tree.delegate();
    if (delegate.isTreeNodeGroup(node)) {
        this.tree.setCollapsed(node, collapsed);

        this.resizeToContent();
    }
};

/**
 * Returns true if the group is collapsed.
 *
 * @param {Object} node - The node in the tree.
 * @returns {Boolean} - True if the group is collapsed, false otherwise.
 */
ModelStructurePanel.prototype.isGroupCollapsed = function(node)
{
    var delegate = this.tree.delegate();
    if (delegate.isTreeNodeGroup(node)) {
        return this.tree.isCollapsed(node);
    }
    return false
};

/**
 * Override this to do something when the user right-clicks on a tree node
 * 
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @param {Event} event
 */
ModelStructurePanel.prototype.onRightClick = function(node, event)
{
};

/**
 * Override this method to be notified when the user clicks on the title.
 * @override
 * @param {Event} event
 */
ModelStructurePanel.prototype.onTitleClick = function(event) {
};

/**
 * Override this method to be notified when the user double-clicks on the title.
 * @override
 * @param {Event} event
 */
ModelStructurePanel.prototype.onTitleDoubleClick = function(event) {
};

/**
 * Override this to do something when the user hovers on a tree node
 *
 * @param {Object} node - A node in an {@link Autodesk.Viewing.Model}
 * @param {Event} event
*/
ModelStructurePanel.prototype.onHover = function(node, event) {
};

/**
 * Displays the given nodes as selected in this panel.
 *
 * @param {Array} nodes - An array of Autodesk.Viewing.Model nodes to display as selected
 */
ModelStructurePanel.prototype.setSelection = function(nodes)
{
    // Bail if no model structure.
    //
    if (!this.tree) {
        return;
    }

    var i, parent;

    // Un-mark the ancestors.
    //
    for(i=0; i<this.selectedNodes.length; ++i) {
        parent = this.instanceTree.getNodeParentId(this.selectedNodes[i]);
        while(parent) {
            this.tree.removeClass(parent, 'ancestor-selected');
            parent = this.instanceTree.getNodeParentId(parent);
        }
    }

    // Mark the ancestors of the newly selected nodes.
    //
    var selectedNodesHierarchy = [];
    for(i=0; i<nodes.length; ++i) {
        selectedNodesHierarchy.push(nodes[i]);
        parent = this.instanceTree.getNodeParentId(nodes[i]);
        while(parent) {
            this.tree.addClass(parent, 'ancestor-selected');
            parent = this.instanceTree.getNodeParentId(parent);
        }
    }

    // Mark the newly selected nodes.
    //
    this.selectedNodes = nodes;
    this.tree.setSelection(selectedNodesHierarchy);
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
ModelStructurePanel.prototype.getContentSize = function () {
    var tree = this.tree;
    if (tree) {
        var treeContainer = tree.getRootContainer();
        if (treeContainer) {
            return {height: treeContainer.clientHeight + this.options.heightAdjustment + 35, width: treeContainer.clientWidth};
        }
    }
    return {height: 0, width: 0};
};

/**
 * Given a node's id, adds the given CSS class to this node.
 * 
 * @param {string} id - The id of a node in an Autodesk.Viewing.Model
 * @param {string} className - The CSS class to add
 * @returns {boolean} - true if the class was added, false otherwise
 */
ModelStructurePanel.prototype.addClass = function(id, className)
{
    return (this.tree !== null) && this.tree.addClass(id, className);
};

/**
 * Given a node's id, removes the given CSS class from this node.
 *
 * @param {string} id - The id of a node in an Autodesk.Viewing.Model
 * @param {string} className - The CSS class to remove
 * @returns {boolean} - true if the class was removed, false otherwise
 */
ModelStructurePanel.prototype.removeClass = function(id, className)
{
    return (this.tree !== null) && this.tree.removeClass(id, className);
};


Autodesk.Viewing.UI.ModelStructurePanel = ModelStructurePanel;

})();;(function() {

"use strict";

var avu = Autodesk.Viewing.UI;

/**
 * PropertyPanel
 * A panel for displaying a set of properties that are optionally categorized.
 * @class
 * @augments Autodesk.Viewing.UI.DockingPanel
 *
 * @param {HTMLElement} parentContainer - The container for this panel.
 * @param {string} id - The id for this panel.
 * @param {string} title - The initial title for this panel.
 * @param {Object} [options] - An optional dictionary of options.  Currently unused.
 * @constructor
 */
var PropertyPanel = function (parentContainer, id, title, options) {
    avu.DockingPanel.call(this, parentContainer, id, title, options);

    this.container.classList.add('propertyPanel');
    this.container.dockRight = true;

    this.createScrollContainer({left: false, heightAdjustment: 45, marginTop:0});

    this.highlightableElements = {};

    var that = this;

    function createDelegate() {
        var delegate = new avu.TreeDelegate();

        function isCategory(object) {
            return object.type === 'category';
        }

        delegate.getTreeNodeId = function (node) {
            return node.name + (node.hasOwnProperty('value') ? node.value : '') + (node.hasOwnProperty('category') ? node.category : '');
        };

        delegate.getTreeNodeClass = function (node) {
            return isCategory(node) ? that.getCategoryClass(node) : that.getPropertyClass(node);
        };

        delegate.isTreeNodeGroup = function (node) {
            return isCategory(node);
        };

        delegate.onTreeNodeClick = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryClick(node, event);
            } else {
                that.onPropertyClick(node, event);
            }
        };

        delegate.onTreeNodeRightClick = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryRightClick(node, event);
            } else {
                that.onPropertyRightClick(node, event);
            }
        };

        delegate.onTreeNodeDoubleClick = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryDoubleClick(node, event);
            } else {
                that.onPropertyDoubleClick(node, event);
            }
        };

        delegate.onTreeNodeIconClick = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryIconClick(node, event);
            } else {
                that.onPropertyIconClick(node, event);
            }
        };

        delegate.createTreeNode = function (node, parent, options) {
            var highlightableElements = null;
            if (isCategory(node)) {
                highlightableElements = that.displayCategory(node, parent, options);
            } else {
                highlightableElements = that.displayProperty(node, parent, options);
            }

            if (highlightableElements) {
                that.highlightableElements[this.getTreeNodeId(node)] = highlightableElements;
            }
        };

        return delegate;
    }

    var delegate = createDelegate();
    this.tree = new avu.Tree(delegate, null, this.scrollContainer, {});

};

PropertyPanel.prototype = Object.create(avu.DockingPanel.prototype);
PropertyPanel.prototype.constructor = PropertyPanel;

/**
 * Adds the given properties to the display panel.
 * @param {Array} properties - An array of properties, each property represented as {displayName: name, displayValue: value}.
 * @param {Object=} [options] - An optional dictionary of options.  Currently unused.
 */
PropertyPanel.prototype.setProperties = function (properties, options) {
    this.removeAllProperties();

    // Check if any categories need to be displayed.
    //
    var withCategories = [];
    var withoutCategories = [];

    for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (!property.hidden) {
            var category = properties[i].displayCategory;
            if (category && typeof category === 'string' && category !== '') {
                withCategories.push(property);
            } else {
                withoutCategories.push(property);
            }
        }
    }

    if ((withCategories.length + withoutCategories.length) === 0) {
        this.showNoProperties();
        return;
    }

    for (var i = 0; i < withCategories.length; i++) {
        var property = withCategories[i];
        var value = Autodesk.Viewing.Private.formatValueWithUnits(property.displayValue, property.units, property.type);
        this.addProperty(property.displayName, value, property.displayCategory);
    }

    var hasCategories = (withCategories.length > 0);
    for (var i = 0; i < withoutCategories.length; i++) {
        var property = withoutCategories[i];
        var value = Autodesk.Viewing.Private.formatValueWithUnits(property.displayValue, property.units, property.type);
        this.addProperty(property.displayName, value, hasCategories ? 'Other' : '', hasCategories ? {localizeCategory: true} : {});
    }
};

/**
 * Displays only the "No properties" item.
 */
PropertyPanel.prototype.showNoProperties = function () {
    this.removeAllProperties();
    var rootContainer = this.tree.myRootContainer;

    var message = document.createElement('div');
    message.className = 'noProperties';

    var text = 'No properties to display';  // string localized below
    message.setAttribute('data-i18n', text);
    message.textContent = Autodesk.Viewing.i18n.translate(text);

    rootContainer.appendChild(message);
};

/**
 * Override this to display the default properties.  The current default is to display no properties.
 */
PropertyPanel.prototype.showDefaultProperties = function () {
    this.showNoProperties();

    this.resizeToContent();
};

/**
 * Override this to return true if the default properties are being displayed.
 */
PropertyPanel.prototype.areDefaultPropertiesShown = function () {
    return !this.hasProperties();
};

/**
 * Adds a property to this panel.  The property is defined by its name, value, and category.  The
 * add will fail if a property with the same name, value, and category already exists.
 *
 * @param {string} name - The name of the property to add.
 * @param {string} value - The value of the property to add.
 * @param {string} category - The category of the property to add.
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {boolean} [options.localizeCategory=false] - When true, localization is attempted for the given category
 * @param {boolean} [options.localizeProperty=false] - When true, localization is attempted for the given property
 * @returns {boolean} - true if the property was added, false otherwise.
 */
PropertyPanel.prototype.addProperty = function (name, value, category, options) {
    var element = this.tree.getElementForNode({name: name, value: value, category: category});
    if (element) {
        return false;
    }

    var parent = null;
    var property = {name: name, value: value, type: 'property'};

    if (category) {
        parent = this.tree.getElementForNode({name: category});
        if (!parent) {
            parent = this.tree.createElement_({name: category, type: 'category'}, this.tree.myRootContainer, options && options.localizeCategory ? {localize: true} : null);
        }
        property.category = category;
    } else {
        parent = this.tree.myRootContainer;
    }

    this.tree.createElement_(property, parent, options && options.localizeProperty ? {localize: true} : null);

    return true;
};

/**
 * Returns whether this property panel currently has properties.
 *
 * @returns {boolean} - true if there are properties to display, false otherwise.
 */
PropertyPanel.prototype.hasProperties = function () {
    for (var property in this.highlightableElements) {
        return true;
    }
    return false;
};

/**
 * Removes a property from this panel.  The property is defined by its name, value, and category.
 *
 * @param {string} name - The name of the property to remove.
 * @param {string} value - The value of the property to remove.
 * @param {string} category - The category of the property to remove.
 * @param {Object=} [options] - An optional dictionary of options.  Currently unused.
 * @returns {boolean} - true if the property was removed, false otherwise.
 */
PropertyPanel.prototype.removeProperty = function (name, value, category, options) {
    var property = {name: name, value: value, category: category};
    var element = this.tree.getElementForNode(property);
    if (element) {
        delete this.highlightableElements[this.tree.delegate().getTreeNodeId(property)];
        element.parentNode.removeChild(element);
        return true;
    }
    return false;
};

/**
 * Removes all properties from the panel.
 */
PropertyPanel.prototype.removeAllProperties = function () {
    this.highlightableElements = {};
    this.tree.clear();
};

/**
 * Sets the collapse state of the given category.
 *
 * @param {Object} category - A category object.
 * @param {boolean} collapsed - The new collapse state.
 */
PropertyPanel.prototype.setCategoryCollapsed = function (category, collapsed) {
    var id = this.tree.delegate().getTreeNodeId(category);
    this.tree.setCollapsed(id, collapsed);
};

/**
 * Returns whether the given category is currently collapsed.
 *
 * @param {Object} category - A category object.
 * @returns {boolean} - true if the category is collapsed, false otherwise.
 */
PropertyPanel.prototype.isCategoryCollapsed = function (category) {
    var id = this.tree.delegate().getTreeNodeId(category);
    return this.tree.isCollapsed(id);
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
PropertyPanel.prototype.getContentSize = function () {
    // For the PropertyPanel, it's the size of the tree + some padding value for the height.
    //
    var treeContainer = this.tree.myRootContainer;
    return {height: treeContainer.clientHeight + 55, width: treeContainer.clientWidth};
};

/**
 * Highlights the given text if found in the property name or value.
 *
 * @param {string} text - The text to highlight.
 * @param {Object=} [options] - An optional dictionary of options.  Currently unused.
 */
PropertyPanel.prototype.highlight = function (text, options) {
    function highlightElement(element) {
        var current = element.innerHTML;
        var unhighlighted = current.replace(/(<highlight>|<\/highlight>)/igm, "");
        if (current !== unhighlighted) {
            element.innerHTML = unhighlighted;
        }

        if (text && text !== "") {
            var query = new RegExp("(\\b" + text + "\\b)", "gim");
            var highlighted = unhighlighted.replace(query, "<highlight>$1</highlight>");
            element.innerHTML = highlighted;
        }
    }

    for (var property in this.highlightableElements) {
        var elements = this.highlightableElements[property];
        for (var i = 0; i < elements.length; ++i) {
            highlightElement(elements[i]);
        }
    }
};

/**
 * Creates and adds the HTML elements to display the given category.
 *
 * @param {Object} category - A category object.
 * @param {HTMLElement} parent - The parent to attach the new HTML elements.
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {boolean} [options.localize=false] - When true, localization is attempted for the given category name.
 *
 * @returns {Array} elementList - the list of HTML elements to include when highlighting.
 *                                Warning:  ensure no event listeners are attached to these elements
 *                                as they will be lost during highlighting.
 */
PropertyPanel.prototype.displayCategory = function (category, parent, options) {
    var name = document.createElement('div');

    var text = category.name;
    if (options && options.localize) {
        name.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    }

    name.textContent = text;
    name.title = text;
    name.className = 'categoryName';
    parent.appendChild(name);

    // Make the category name highlightable.
    //
    return [name];
};

function replaceUrls(s) {
    s = String(s); // Make sure we only get Strings here!
    var t = ' target="blank" class="propertyLink" ';
    var patternMap = [{
      pattern: /\b(?:https?|ftp):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*[a-z0-9-+&@#\/%=~_|]/gim,
      value: '<a' + t + 'href="$&">$&</a>'
    }, {
      pattern: /(^|[^\/])(www\.[\S]+(\b|$))/gim,
      value: '$1<a' + t + 'href="http://$2">$2</a>'
    }];
    return patternMap.reduce(function(a, b){
      return a.replace(b.pattern, b.value);
    }, s);
}

/**
 * Creates and adds the HTML elements to display the given property.
 *
 * @param {Object} property - A property object.
 * @param {HTMLElement} parent - The parent to attach the new HTML elements.
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {boolean} [options.localize=false] - When true, localization is attempted for the given property name.
 *
 * @returns {Array} elementList - the list of HTML elements to include when highlighting.
 *                                Warning:  ensure no event listeners are attached to these elements
 *                                as they will be lost during highlighting.
 */
PropertyPanel.prototype.displayProperty = function (property, parent, options) {
    var name = document.createElement('div');

    var text = property.name;
    if (options && options.localize) {
        name.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    }

    name.textContent = text;
    name.title = text;
    name.className = 'propertyName';

    var separator = document.createElement('div');
    separator.className = 'separator';

    var value = document.createElement('div');
    value.textContent = property.value;

    var s = property.value;
    value.title = s;
    s = replaceUrls(s);
    value.innerHTML = s;

    value.className = 'propertyValue';

    parent.appendChild(name);
    parent.appendChild(separator);
    parent.appendChild(value);

    // Make the property name and value highlightable.
    //
    return [name, value];
};

/**
 * Override this to specify the CSS classes of a category. This way, in CSS, the designer
 * can specify custom styling for specific category types.
 *
 * @param {Object} category
 * @returns {string} - CSS classes for the category.
 */
PropertyPanel.prototype.getCategoryClass = function (category) {
    return 'category';
};

/**
 * Override this to specify the CSS classes of a property. This way, in CSS, the designer
 * can specify custom styling for specific property types.
 *
 * @param {Object} property
 * @returns {string} - CSS classes for the property.
 */
PropertyPanel.prototype.getPropertyClass = function (property) {
    return 'property';
};

/**
 * Override this method to do something when the user clicks on a category.  The default
 * implementation is to toggle the collapse state of the category.
 *
 * @param {Object} category
 * @param {Event} event
 */
PropertyPanel.prototype.onCategoryClick = function (category, event) {
    this.setCategoryCollapsed(category, !this.isCategoryCollapsed(category));
};

/**
 * Override this method to do something when the user clicks on a property.
 *
 * @param {Object} property
 * @param {Event} event
 */
PropertyPanel.prototype.onPropertyClick = function (property, event) {
};

/**
 * Override this method to do something when the user clicks on a category's icon.  The default
 * implementation is to toggle the collapse state of the category.
 *
 * @param {Object} category
 * @param {Event} event
 */
PropertyPanel.prototype.onCategoryIconClick = function (category, event) {
    this.setCategoryCollapsed(category, !this.isCategoryCollapsed(category));
};

/**
 * Override this method to do something when the user clicks on a property's icon.
 *
 * @param {Object} property
 * @param {Event} event
 */
PropertyPanel.prototype.onPropertyIconClick = function (property, event) {
};

/**
 * Override this method to do something when the user double clicks on a category.
 *
 * @param {Object} category
 * @param {Event} event
 */
PropertyPanel.prototype.onCategoryDoubleClick = function (category, event) {
};

/**
 * Override this method to do something when the user double clicks on a property.
 *
 * @param {Object} property
 * @param {Event} event
 */
PropertyPanel.prototype.onPropertyDoubleClick = function (property, event) {
};

/**
 * Override this method to do something when the user right clicks on a category.
 *
 * @param {Object} category
 * @param {Event} event
 */
PropertyPanel.prototype.onCategoryRightClick = function (category, event) {
};

/**
 * Override this method to do something when the user right clicks on a property.
 *
 * @param {Object} property
 * @param {Event} event
 */
PropertyPanel.prototype.onPropertyRightClick = function (property, event) {
};


Autodesk.Viewing.UI.PropertyPanel = PropertyPanel;

})();
;(function() {

/** @constructor */
var ContextMenu = function(viewer) {
    this.viewer = viewer;
    this.menus = [];
    this.open = false;
};

ContextMenu.prototype.constructor = ContextMenu;

ContextMenu.prototype.show = function(event, menu) {
    var viewport = this.viewer.container.getBoundingClientRect();

    // Normalize Hammer events
    if (Array.isArray(event.changedPointers) && event.changedPointers.length > 0) {
        event.clientX = event.changedPointers[0].clientX;
        event.clientY = event.changedPointers[0].clientY;
    }

    var x = event.clientX - viewport.left;
    var y = event.clientY - viewport.top;

    if (!this.open) {

        var self = this;

        this.showMenu(menu, x, y);
        this.open = true;
        this.hideEventListener = function(event) {
            if (event.target.className !== "menuItem") {
                self.hide(event);
            }
        };
        this.isTouch = (event.type === "press");
        document.body.addEventListener(this.isTouch ? "touchstart" : "mousedown", this.hideEventListener, true);
    }
};

ContextMenu.prototype.showMenu = function (menu, x, y) {
    var container = document.createElement('div'),
        menuItem,
        submenus = [];

    container.className = 'menu';
    this.viewer.container.appendChild(container);
    this.menus.push(container);

    for (var i = 0; i < menu.length; ++i) {
        var defn = menu[i],
            title = defn.title,
            target = defn.target;

        menuItem = this.createMenuItem(container, title);

        if (typeof target === 'function') {
            this.addCallbackToMenuItem(menuItem, target);

        } else if (Array.isArray(target)) {
            submenus.push({menuItem: menuItem, target: target});

        } else {
            console.warn("Invalid context menu option:", title, target);
        }
    }

    var rect = container.getBoundingClientRect(),
        containerWidth = rect.width,
        containerHeight = rect.height,
        viewerRect = this.viewer.container.getBoundingClientRect(),
        viewerWidth = viewerRect.width,
        viewerHeight = viewerRect.height,
        shiftLeft = isTouchDevice() && !this.viewer.navigation.getUseLeftHandedInput();

    if (shiftLeft) {
        x -= containerWidth;
    }

    if (x < 0) {
        x = 0;
    }
    if (viewerWidth < x + containerWidth) {
        x = viewerWidth - containerWidth;
        if (x < 0) {
            x = 0;
        }
    }

    if (y < 0) {
        y = 0;
    }
    if (viewerHeight < y + containerHeight) {
        y = viewerHeight - containerHeight;
        if (y < 0) {
            y = 0;
        }
    }

    container.style.top = Math.round(y) + "px";
    container.style.left = Math.round(x) + "px";

    for (i = 0; i < submenus.length; ++i) {
        var submenu = submenus[i];

        menuItem = submenu.menuItem;
        rect = menuItem.getBoundingClientRect();
        x = Math.round((shiftLeft ? rect.left : rect.right) - viewerRect.left);
        y = Math.round(rect.top - viewerRect.top);

        this.addSubmenuCallbackToMenuItem(menuItem, submenu.target, x, y);
    }
};

ContextMenu.prototype.createMenuItem = function(parentItem, text) {
    var menuItem = document.createElement("div");
    menuItem.className = "menuItem";
    menuItem.setAttribute("data-i18n", text);
    menuItem.textContent = Autodesk.Viewing.i18n.translate( text );
    parentItem.appendChild(menuItem);
    return menuItem;
};

ContextMenu.prototype.addCallbackToMenuItem = function (menuItem, target) {
    var that = this;

    menuItem.addEventListener('click', function (event) {
        that.hide();
        target();
        event.preventDefault();
        return false;
    }, false);
};

ContextMenu.prototype.addSubmenuCallbackToMenuItem = function (menuItem, menu, x, y) {
    var that = this;

    menuItem.addEventListener('click', function () {
        that.showMenu(menu, x, y);
    }, false);
};

ContextMenu.prototype.hide = function() {
    if (this.open) {
        for (var index=0; index<this.menus.length; ++index) {
            if(this.menus[index]) {
                this.menus[index].parentNode.removeChild(this.menus[index]);
            }
        }
        this.menus = [];
        this.open = false;
        document.body.removeEventListener(this.isTouch ? "touchstart" : "mousedown", this.hideEventListener);
        this.isTouch = false;
        return true;
    }
    return false;
};

Autodesk.Viewing.Private.ContextMenu = ContextMenu;

})();;
(function() {

"use strict";

var avu = Autodesk.Viewing.UI,
    avp = Autodesk.Viewing.Private;


/**
 * Constructs an ObjectContextMenu object.
 * This is the base class for object context menus.
 * @alias Autodesk.Viewing.UI.ObjectContextMenu
 * @param {Viewer} viewer
 * @constructor
 */
var ObjectContextMenu = function (viewer) {
    this.viewer = viewer;
    this.contextMenu = new avp.ContextMenu(viewer);
};

ObjectContextMenu.prototype.constructor = ObjectContextMenu;

/**
 * Shows the context menu.
 * @param {Event} event - Browser event that requested the context menu
 */
ObjectContextMenu.prototype.show = function (event) {
    var numSelected = this.viewer.getSelectionCount(),
        visibility = this.viewer.getSelectionVisibility(),
        status = {
            numSelected: numSelected,
            hasSelected: (0 < numSelected),
            hasVisible: visibility.hasVisible,
            hasHidden: visibility.hasHidden
        },
        menu = this.buildMenu(event, status);

    this.viewer.runContextMenuCallbacks(menu, status);

    if (menu && 0 < menu.length) {
        this.contextMenu.show(event, menu);
    }
};

/**
 * Hides the context menu.
 * @returns {boolean} true if the context menu was open, false otherwise.
 */
ObjectContextMenu.prototype.hide = function () {
    return this.contextMenu.hide();
};

/**
 * Builds the context menu to be displayed.
 * Override this method to change the context menu.
 * @param {Event} event - Browser event that requested the context menu
 * @param {Object} status - Information about nodes.
 * @param {Number} status.numSelected - The number of selected objects.
 * @param {Boolean} status.hasSelected - True if there is at least one selected object.
 * @param {Boolean} status.hasVisible - True if at least one selected object is visible.
 * @param {Boolean} status.hasHidden - True if at least one selected object is hidden.
 * @returns {?Array} An array of menu items.
 *
 * Sample menu item:
 * {title: 'This is a menu item', target: function () {alert('Menu item clicked');}}
 * A submenu can be specified by providing an array of submenu items as the target.
 */
ObjectContextMenu.prototype.buildMenu = function (event, status) {
    return null;
};

Autodesk.Viewing.UI.ObjectContextMenu = ObjectContextMenu;

})();;
/**
 * Application preferences. Optionally uses web storage.
 * @constructor
 * @param {Viewer} viewer - Viewer instance
 * @param {string} prefix - A string to prefix preference names in web storage
 */
Autodesk.Viewing.Private.Preferences = function (viewer, prefix) {
    if (!prefix) {
        prefix = 'Autodesk.Viewing.Preferences.';
    }

    // from stackoverflow:
    // http://stackoverflow.com/questions/14555347/html5-localstorage-error-with-safari-quota-exceeded-err-dom-exception-22-an
    //
    function isLocalStorageSupported() {
        var testKey = prefix + 'test';
        try {
            var storage = window.localStorage; // This may assert if browsers disallow sites from setting data.
            storage.setItem(testKey, '1');
            storage.removeItem(testKey);
            return true;

        } catch (error) {
            return false;
        }
    }

    var defaults = {}, // Default values
        callbacks = {}, // Changed and Reset listeners
        tags = {},
        PREF_CHANGED_EVENT = 'PrefChanged',
        PREF_RESET_EVENT = 'PrefReset',
        useLocalStorage = isLocalStorageSupported(),
        that = this;

    // TODO: callbacks should be array, not single
    // Would need to deal with issue of registering same callback twice
    //
    viewer.addEventListener(PREF_CHANGED_EVENT, function (event) {
        var callbacksForName = callbacks[event.name];
        if (callbacksForName) {
            var callback = callbacksForName.changed;
            if (callback) {
                callback(event.value);
            }
        }
    });

    viewer.addEventListener(PREF_RESET_EVENT, function (event) {
        for (var name in callbacks) {
            if (callbacks.hasOwnProperty(name)) {
                var callback = callbacks[name].reset;
                if (callback) {
                    callback(that[name]);
                }
            }
        }
    });

    /**
     * Get/set preference value in web storage.
     * @param {string} name - Preference name
     * @param {*=} [value] - Preference value
     * @returns {*} Preference value or undefined if not available
     * @private
     */
    function webStorage(name, value) {
        if (useLocalStorage) {

            // Prefix our names, so we don't pollute the localStorage of the embedding application
            name = prefix + name;

            if (typeof(value) !== "undefined") {
                // If value is specified, we set this value at localStorage[name]
                localStorage[name] = value;

            } else {
                // If no value is specified we return the value at localStorage[name]
                value = localStorage[name];
            }
            return value;
        }
        return undefined;
    }

    /**
     * Adds a preference name + default value, tries to load value from web storage.
     * @param {string} name
     * @param defaultValue
     * @private
     */
    function addPref(name, defaultValue) {
        if (typeof name !== 'string' || typeof that[name] === 'function') {
            stderr('Preferences: invalid name=' + name);
            return;
        }

        // Use default if nothing in web storage.
        //
        var value = webStorage(name);
            ok = false;

        if (value !== undefined) {
            try {
                value = JSON.parse(value);
                ok = true;
            } catch (e) {
            }
        }
        that[name] = ok ? value : defaultValue;
        tags[name] = {};
    }

    /**
     * Load preference values from web storage/defaults.
     * @param {Object} defaultValues - Preference names and their default values
     */
    this.load = function (defaultValues) {
        defaults = defaultValues;
        for (var name in defaults) {
            if (defaults.hasOwnProperty(name)) {
                addPref(name, defaults[name]);
            }
        }
    };

    /**
     * Adds a tag to the specified preferences.
     * These are used by reset().
     * @param {string} tag
     * @param {Array.<string>|string} [names] - Preference names, default all preferences
     */
    this.tag = function (tag, names) {
        if (tag) {
            if (!names) {
                names = Object.keys(defaults);
            } else if (!Array.isArray(names)) {
                names = [names];
            }
            for (var i = 0; i < names.length; ++i) {
                tags[names[i]][tag] = true;
            }
        }
    };

    /**
     * Removes a tag from the specified preferences.
     * These are used by reset().
     * @param {string} tag
     * @param {Array.<string>|string} [names] - Preference names, default all preferences
     */
    this.untag = function (tag, names) {
        if (tag) {
            if (!names) {
                names = Object.keys(defaults);
            } else if (!Array.isArray(names)) {
                names = [names];
            }
            for (var i = 0; i < names.length; ++i) {
                tags[names[i]][tag] = false;
            }
        }
    };

    /**
     * Adds a new preference name + default value.
     * This preference was not previously loaded via load().
     * @param {string} name - Preference name
     * @param defaultValue - Preference default value
     * @param {Array.<string>|string} [tags] - Optional tags
     * @returns {boolean} true if the preference was added
     */
    this.add = function (name, defaultValue, tags) {
        if (defaults.hasOwnProperty(name)) {
            stderr("Preferences: " + name + " already exists");

        } else {
            defaults[name] = defaultValue;
            addPref(name, defaultValue);

            if (tags) {
                if (!Array.isArray(tags)) {
                    tags = [tags];
                }
                for (var i = 0; i < tags.length; ++i) {
                    this.tag(tags[i], name);
                }
            }
            return true;
        }
        return false;
    };

    /**
     * Removes an existing preference.
     * @param {string} name - Preference name
     * @param {boolean} [removeFromWebStorage=false] - true to clear the web storage entry for this preference
     * @returns {boolean} true if the preference was removed
     */
    this.remove = function (name, removeFromWebStorage) {
        if (defaults.hasOwnProperty(name)) {
            delete defaults[name];
            delete tags[name];
            delete this[name];

            if (removeFromWebStorage && useLocalStorage) {
                name = prefix + name;
                delete localStorage[name];
            }

            return true;
        }
        return false;
    };

    /**
     * Reset preferences to default values.
     * If a tag is specified, then only certain preferences are reset.
     * @param {string=} [tag] Optional tag
     * @param {boolean=} [include=true] true to reset only preferences with matching tags
     */
    this.reset = function (tag, include) {
        if (tag && include === undefined) {
            include = true;
        }

        for (var name in defaults) {
            if (defaults.hasOwnProperty(name)) {
                if (tag) {
                    var tagged = !!tags[name][tag];
                    if ((include && !tagged) || (!include && tagged)) {
                        continue;
                    }
                }

                if (this.set(name, defaults[name], false)) {
                    viewer.fireEvent({
                        type: PREF_RESET_EVENT,
                        name: name,
                        value: this[name]
                    });
                }
            }
        }
    };

    /**
     * Get named preference value.
     * Shortcut: prefs[name]
     * @returns {*} Preference value
     */
    this.get = function (name) {
        return this[name];
    };

    /**
     * Set named preference value.
     * Do not use shortcut prefs[name] = value
     * @param {string} name - Preference name
     * @param {*} value - Preference value
     * @param {boolean=} [notify=true] - If true then PREF_CHANGED_EVENT is fired.
     * @returns {boolean} true if the value changed, false otherwise
     */
    this.set = function (name, value, notify) {
        // Updates the cached value as well as the value in the web storage
        if (this[name] !== value) {
            this[name] = value;
            webStorage(name, value);

            if (notify === undefined || notify) {
                viewer.fireEvent({
                    type: PREF_CHANGED_EVENT,
                    name: name,
                    value: value
                });
            }
            
            var logger = Autodesk.Viewing.Private.logger;
            if (logger) {
                logger.log({category: "pref_changed", name:name, value:value});
            }

            return true;
        }
        return false;
    };

    /**
     * Listen for preference changed and reset events.
     * @param {string} name - Preferences name
     * @param {function(*)} onChangedCallback - Function called when preferences are changed
     * @param {function(*)} onResetCallback - Function called when preferences are reset
     */
    this.addListeners = function (name, onChangedCallback, onResetCallback) {
        callbacks[name] = {changed: onChangedCallback, reset: onResetCallback};
    };
    
    /**
     * Remove listeners for preference changed and reset events.
     * @param {string} name - Preferences name
     */
    this.removeListeners = function(name) {
        if(callbacks[name] !== undefined) {
            delete callbacks[name];
        }
    };
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * Formats a value with units
 * @param {number} value
 * @param {string} units - GNU units format
 * @param {number} type - For example: 1=boolean, 2=integer, 3=double, 20=string
 * @param {number} precision - required precision.
 * see https://git.autodesk.com/A360/platform-translation-propertydb/blob/master/propertydb/PropertyDatabase.h
 * @returns {string} formatted value
 */
Autodesk.Viewing.Private.formatValueWithUnits = function (value, units, type, precision) {

    function modf(x) {
        var intPart = (0 <= x) ? Math.floor(x) : Math.ceil(x),
            fracPart = x - intPart;
        return {intPart: intPart, fracPart: fracPart};
    }

    function formatNumber(x, precision, needMinusSign) {
        var result = '';

//        // Change -0.0 to 0.0
//        if (x === 0.0) {
//            x = 0.0;
//        }

        if (needMinusSign && x === 0) {
            result += '-';
        }

        //According to Shawn's request, do not truncate trailing .0's
        //if (modf(x).fracPart === 0) {
        //
        //    // No fractional part.
        //    //
        //    result += x;
        //
        //} else if (0 < precision) {
        if (0 < precision) {

            // Truncate any trailing .0's.
            //
            //var s = x.toFixed(precision);
            //var re = /^\-?([0-9]+)\.0+$/;
            //var m = re.exec(s);
            //if (m !== null) {
            //    result += m[1];
            //} else {
            //    result += s;
            //}
            result += x.toFixed(precision);

        } else {
            result += x.toFixed(0);
        }

        return result;
    }

    function formatFeet(value, precision, inchesOnly) {

        // Borrowed from AdCoreUnits PrimeDoublePrimeSymbol2::Format

        var result = '',
            radix = 12.0,
            denominator = 1.0,
            isNegative = (value < 0);

        for (var i = 0; i < precision; ++i) {
            denominator *= 2.0;
        }

        // round to the nearest 1/denominator
        if (value > 0) {
            value += 0.5/denominator;
        } else {
            value -= 0.5/denominator;
        }

        var primeValue, doublePrimeValue;

        if (!inchesOnly) {
            primeValue = modf(value/radix).intPart;
            result += formatNumber(primeValue, 0, isNegative) + '\' ';
            doublePrimeValue = value - (primeValue * radix);
            if (doublePrimeValue < 0) {
                doublePrimeValue = -doublePrimeValue;
            }

        } else {
            doublePrimeValue = value;
        }

        var intPart = modf(doublePrimeValue).intPart;
        var numerator = modf((doublePrimeValue - intPart) * denominator).intPart;

        if (numerator === 0 || intPart !== 0) {
            result += formatNumber(intPart, 0);
        }

        if (numerator !== 0) {
            if (intPart < 0 && numerator < 0) {
                numerator = -numerator;
            }
            while (numerator % 2 === 0) {
                numerator /= 2;
                denominator /= 2;
            }
            if (intPart !== 0) {
                result += '-';
            }
            result += formatNumber(numerator, 0) + '/' + formatNumber(denominator, 0);
        }

        result += '\"';
        return result;
    }

    function formatMeterAndCentimeter(value, precision) {
        var sign = '';
        if (value < 0) {
            sign = '-';
            value = Math.abs(value);
        }
        var modfValue = modf(value),
            mValue = modfValue.intPart,
            cmValue = modfValue.fracPart * 100.0;

        return sign + formatNumber(mValue, 0) + ' m ' + formatNumber(cmValue, precision) + ' cm';
    }

    function formatFeetAndDecimalInches(value, precision) {
        var sign = '';
        if (value < 0) {
            sign = '-';
            value = Math.abs(value);
        }
        var modfValue = modf(value),
            ftValue = modfValue.intPart,
            inValue = modfValue.fracPart * 12.0;

        return sign + formatNumber(ftValue, 0) + '\' ' + formatNumber(inValue, precision) + '\"';
    }

    var result;

    if (precision === undefined) {
        precision = 3;
    }

    if (type === 1) { // Boolean
        result = Autodesk.Viewing.i18n.translate(value ? 'Yes' : 'No');

    } else if ((type === 2 || type === 3) && isNaN(value)) {
        result = 'NaN';

    } else if (units === 'ft-and-fractional-in') {
        result = formatFeet(value * 12.0, precision);

    } else if (units === 'ft-and-fractional-in^2') {
        result = formatFeet(value * 12.0, precision) + ' ' + String.fromCharCode(0xb2);

    } else if (units === 'ft-and-decimal-in') {
        result = formatFeetAndDecimalInches(value, precision);

    } else if (units === 'ft-and-decimal-in^2') {
        result = formatFeetAndDecimalInches(value, precision) + ' ' + String.fromCharCode(0xb2);

    } else if (units === 'decimal-in' || units === 'in' || units === 'inch') {
        result = formatNumber(value, precision) + '\"';

    } else if (units === 'decimal-in^2' || units === 'in^2' || units === 'inch^2') {
        result = formatNumber(value, precision) + '\"' + ' ' + String.fromCharCode(0xb2);

    } else if (units === 'decimal-ft' || units === 'ft' || units === 'feet' || units === 'foot') {
        result = formatNumber(value, precision) + '\'';

    } else if (units === 'decimal-ft^2' || units === 'ft^2' || units === 'feet^2' || units === 'foot^2') {
        result = formatNumber(value, precision) + '\'' + ' ' + String.fromCharCode(0xb2);

    } else if (units === 'fractional-in') {
        result = formatFeet(value, precision, /*inchesOnly=*/true);

    } else if (units === 'fractional-in^2') {
        result = formatFeet(value, precision, /*inchesOnly=*/true) + ' ' + String.fromCharCode(0xb2);

    } else if (units === 'm-and-cm') {
        result = formatMeterAndCentimeter(value, precision);

    } else if (units === 'm-and-cm^2') {
        result = formatMeterAndCentimeter(value, precision) + ' ' + String.fromCharCode(0xb2);

    } else if (type === 3 && units) { // Double, with units
        units = units.replace("^2", String.fromCharCode(0xb2));
        units = units.replace("^3", String.fromCharCode(0xb3));
        result = formatNumber(value, precision) + ' ' + units;

    } else if (units) {
        result = value + ' ' + units;

    } else if (type === 3) { // Double, no units
        result = formatNumber(value, precision);

    } else {
        result = value;
    }

    return result;
};

/**
 * Convert distance from unit to unit.
 * @param {string} fromUnits - GNU units format - units to convert from
 * @param {string} toUnits - GNU units format - units to convert to
 * @param {number} d - distance to convert
 * @param {string} type - default for distance, "square" for area
 * @returns {number} - distance after conversion.
 */
Autodesk.Viewing.Private.convertUnits = function (fromUnits, toUnits, d, type) {

    if (fromUnits === toUnits)
        return d;

    var toFactor = 1;
    switch (toUnits) {
        case "mm": toFactor = 1000; break;
        case "cm": toFactor = 100; break;
        case "m" : toFactor = 1; break;
        case "in": toFactor = 39.37007874; break;
        case "ft": toFactor = 3.280839895; break;
        case "ft-and-fractional-in": toFactor = 3.280839895; break;
        case "ft-and-decimal-in": toFactor = 3.280839895; break;
        case "decimal-in": toFactor = 39.37007874; break;
        case "decimal-ft": toFactor = 3.280839895; break;
        case "fractional-in": toFactor = 39.37007874; break;
        case "m-and-cm": toFactor = 1; break;
    }

    var fromFactor = 1;
    switch (fromUnits) {
        case "mm": fromFactor = 0.001; break;
        case "cm": fromFactor = 0.01; break;
        case "m" : fromFactor = 1; break;
        case "in": fromFactor = 0.0254; break;
        case "ft": fromFactor = 0.3048; break;
        case "ft-and-fractional-in": fromFactor = 0.3048; break;
        case "ft-and-decimal-in": fromFactor = 0.3048; break;
        case "decimal-in": fromFactor = 0.0254; break;
        case "decimal-ft": fromFactor = 0.3048; break;
        case "fractional-in": fromFactor = 0.0254; break;
        case "m-and-cm": fromFactor = 1; break;
    }

    if (type === "square") {

        return (d * Math.pow(toFactor * fromFactor, 2));
    }
    return (d * toFactor * fromFactor);
};
;AutodeskNamespace('Autodesk.Viewing.Private');

(function() {

    var av = Autodesk.Viewing,
        avp = Autodesk.Viewing.Private;

    /** @constructor */
    avp.OptionSlider = function (caption, min, max, parentTbody, options) {
        var self = this;
        this.tbody = parentTbody;

        var atIndex = options && options.insertAtIndex ? options.insertAtIndex : -1;
        this.sliderRow = this.tbody.insertRow(atIndex);

        var cell = this.sliderRow.insertCell(0);
        this.caption = document.createElement("div");
        this.caption.setAttribute("data-i18n", caption);
        this.caption.textContent = av.i18n.translate(caption);

        this.sliderElement = document.createElement("input");
        this.sliderElement.type = "range";
        this.sliderElement.id = caption + "_slider";
        this.sliderElement.min = min;
        this.sliderElement.max = max;
        //this.sliderElement.style.width = "95%";
        cell.appendChild(this.caption);
        cell.appendChild(this.sliderElement);

        cell = this.sliderRow.insertCell(1);
        this.stepperElement = document.createElement("input");
        this.stepperElement.type = "number";
        this.stepperElement.id = caption + "_stepper";
        this.stepperElement.min = min;
        this.stepperElement.max = max;
        this.stepperElement.step = 1;
        //this.stepperElement.style.resize = "none";
        this.stepperElement.style.width = "64px";
        cell.appendChild(this.stepperElement);

        this.blockEvent = false;

        this.stepperElement.addEventListener("change",
            function (e) {
                if (e.target != self.sliderElement)
                    self.sliderElement.value = self.stepperElement.value;
                self.fireChangeEvent();
            }, false);

        function changeHandler(e) {
            if (e.target != self.stepperElement)
                self.stepperElement.value = self.sliderElement.value;
            self.fireChangeEvent();
        }

        this.sliderElement.addEventListener("change", changeHandler, false);
        this.sliderElement.addEventListener("input", changeHandler, false);
    };

    avp.OptionSlider.prototype.constructor = avp.OptionSlider;
    av.EventDispatcher.prototype.apply(avp.OptionSlider.prototype);

    avp.OptionSlider.prototype.fireChangeEvent = function () {
        if (!this.blockEvent) {
            this.value = this.sliderElement.value;
            var e = new CustomEvent("change", {
                detail: {
                    target: this,
                    value: this.sliderElement.value
                }
            });
            this.dispatchEvent(e);
        }
    };

    avp.OptionSlider.prototype.setValue = function (v) {
        this.blockEvent = true;
        this.value = v;
        this.sliderElement.value = v;
        this.stepperElement.value = v;
        this.blockEvent = false;
    };

    avp.OptionSlider.prototype.setDisabled = function (v) {
        this.sliderElement.disabled = v;
        this.stepperElement.disabled = v;
        this.caption.disabled = v;
    };

//==========================================================================================================
//==========================================================================================================
//==========================================================================================================

    /** @constructor */
    avp.OptionCheckbox = function (caption, parentTbody, initialState, options) {
        var self = this;
        this.tbody = parentTbody;

        var atIndex = options && options.insertAtIndex ? options.insertAtIndex : -1;
        this.sliderRow = this.tbody.insertRow(atIndex);

        var cell = this.sliderRow.insertCell(0);
        this.caption = document.createElement("div");
        this.caption.setAttribute("data-i18n", caption);
        this.caption.textContent = av.i18n.translate(caption);

        cell.appendChild(this.caption);

        cell = this.sliderRow.insertCell(1);
        this.checkElement = document.createElement("input");
        this.checkElement.type = "checkbox";
        this.checkElement.id = caption + "_check";
        this.checkElement.checked = initialState;
        cell.appendChild(this.checkElement);
        //cell.style.width = "26px";

        this.blockEvent = false;
        this.checked = initialState;

        this.checkElement.addEventListener("change",
            function (e) {
                self.fireChangeEvent();
            }, false);

        if (isTouchDevice()) {
            // Tap on a checkbox is handled by the browser so we don't hav to do anything for it.

            this.sliderRowHammer = new Hammer.Manager(this.sliderRow, {
                recognizers: [[Hammer.Tap]],
                inputClass: Hammer.TouchInput
            });
            this.sliderRowHammer.on("tap", function (e) {
                e.preventDefault();
                //e.stopPropagation(); // Doesn't exist for tap events.
                e.target.click();
            });
        }

        this.checkElement.addEventListener("click", function (event) {
            event.stopPropagation();
        }, false);

        // Make the slider row clickable as well so that when
        // clicking on the row, the checkbox is toggled.
        this.sliderRow.addEventListener("click",
            function (e) {
                if (!self.checkElement.disabled) {
                    self.checkElement.checked = !self.checkElement.checked;
                    self.fireChangeEvent();
                }
            }, false);
    };

    avp.OptionCheckbox.prototype.constructor = avp.OptionCheckbox;
    av.EventDispatcher.prototype.apply(avp.OptionCheckbox.prototype);

    avp.OptionCheckbox.prototype.fireChangeEvent = function () {
        if (!this.blockEvent) {
            this.checked = this.checkElement.checked;
            var e = new CustomEvent("change", {
                detail: {
                    target: this,
                    value: this.checkElement.checked
                }
            });
            this.dispatchEvent(e);
        }
    };

    avp.OptionCheckbox.prototype.setValue = function (v) {
        this.blockEvent = true;
        this.checked = v;
        this.checkElement.checked = v;
        this.blockEvent = false;
    };

    avp.OptionCheckbox.prototype.setDisabled = function (v) {
        this.checkElement.disabled = v;
        this.caption.disabled = v;
    };

    avp.OptionCheckbox.prototype.setVisibility = function (isVisible) {
        if (isVisible)
            this.sliderRow.style.display = "table-row";
        else
            this.sliderRow.style.display = "none";
    };

//==========================================================================================================
//==========================================================================================================
//==========================================================================================================

    avp.OptionDropDown = function (caption, parentTbody, items, initialItemIndex, options) {

        var self = this;
        this.tbody = parentTbody;

        var atIndex = options && options.insertAtIndex ? options.insertAtIndex : -1;
        this.sliderRow = this.tbody.insertRow(atIndex);

        var cell = this.sliderRow.insertCell(0);
        this.caption = document.createElement("div");
        this.caption.setAttribute("data-i18n", caption);
        this.caption.textContent = av.i18n.translate(caption);

        cell.appendChild(this.caption);

        cell = this.sliderRow.insertCell(1);
        this.dropdownElement = document.createElement("select");
        this.dropdownElement.id = caption + "_dropdown";
        this.dropdownElement.className = "optionDropDown";

        for (var i = 0; i < items.length; i++) {
            var item = document.createElement("option");
            item.value = i;
            item.setAttribute("data-i18n", items[i]);
            item.textContent = av.i18n.translate(items[i]);
            this.dropdownElement.add(item);
        }

        this.selectedIndex = this.dropdownElement.selectedIndex = initialItemIndex;

        cell.appendChild(this.dropdownElement);
        cell.style.paddingLeft = "5px";
        cell.style.paddingRight = "5px";

        this.blockEvent = false;

        this.dropdownElement.addEventListener("change",
            function (e) {
                self.fireChangeEvent();
            }, false);

    };

    avp.OptionDropDown.prototype.constructor = avp.OptionDropDown;
    av.EventDispatcher.prototype.apply(avp.OptionDropDown.prototype);


    avp.OptionDropDown.prototype.setSelectedIndex = function (index) {
        this.blockEvent = true;
        this.selectedIndex = this.dropdownElement.selectedIndex = index;
        this.blockEvent = false;
    };

    avp.OptionDropDown.prototype.setSelectedValue = function (value) {
        this.blockEvent = true;
        this.dropdownElement.selectedValue = value;
        this.selectedIndex = this.dropdownElement.selectedIndex;
        this.blockEvent = false;
    };

    avp.OptionDropDown.prototype.fireChangeEvent = function () {
        if (!this.blockEvent) {
            this.selectedIndex = this.dropdownElement.selectedIndex;
            var e = new CustomEvent("change", {
                detail: {
                    target: this,
                    value: this.selectedIndex
                }
            });
            this.dispatchEvent(e);
        }
    };

    avp.OptionDropDown.prototype.setDisabled = function (v) {
        this.dropdownElement.disabled = v;
        this.caption.disabled = v;
    };

})();;
(function() {

"use strict";

var ProgressBar = function (container) {

    this.bg = document.createElement('div');
    this.bg.className = 'progressbg';

    this.fg = document.createElement('div');
    this.fg.className = 'progressfg';
    this.bg.appendChild(this.fg);
    this.lastValue = -1;

    container.appendChild(this.bg);

    this.widthScale = this.fg.clientWidth;
};

ProgressBar.prototype.setPercent = function(pct) {

    if (pct == this.lastValue)
        return;

    this.lastValue = pct;

    if (pct >= 99)
        this.bg.style.visibility = "hidden";
    else {
        this.bg.style.visibility = "visible";
        this.fg.style.width = (this.widthScale * pct * 0.01) + "px";
    }
};


Autodesk.Viewing.Private.ProgressBar = ProgressBar;

})();
;AutodeskNamespace('Autodesk.Viewing.Private');

/** @constructor */
Autodesk.Viewing.Private.RenderOptionsPanel = function (viewer) {
    var self = this;
    var avp = Autodesk.Viewing.Private;
    this.viewer = viewer;
    Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, 'RenderOptionsPanel', 'Rendering Options');

    this.table = document.createElement("table");
    this.table.className = "tftable";

    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);

    // Create the scroll container.  Adjust the height so the scroll container does not overlap
    // the resize handle.  50px accounts for the titlebar and resize handle.
    //
    this.createScrollContainer({heightAdjustment:70, marginTop:20});

    this.scrollContainer.appendChild(this.table);

    this.container.style.width  = "320px";
    this.container.style.top    = "260px";
    this.container.style.left   = "220px"; // just needs an initial value dock overrides value
    this.container.style.height = "460px";
    this.container.dockRight = true;

    var color_list = [];
    for (var p in viewer.impl.BackgroundPresets) {
        color_list.push(p);
    }

    this.bgSelect = new avp.OptionDropDown("Background Color", this.tbody, color_list, -1);
    this.updateBgColorIndex();

    this.addEventListener(this.bgSelect, "change", function(e) {

        var chosen = self.bgSelect.value;

        var c = viewer.BackgroundPresets[chosen];

        viewer.prefs.set("backgroundColorPreset", JSON.stringify(c));
        viewer.impl.setClearColors(c[0],c[1],c[2],c[3],c[4],c[5]);
    });
    
    this.celToggle = new avp.OptionCheckbox("Cel Shaded", this.tbody, true);
    this.addEventListener(this.celToggle, "change", function(e) {
        var enable = self.celToggle.checked;
        viewer.prefs.set("celShaded", enable);
        viewer.impl.toggleCelShading(enable);
    });

    this.saoToggle = new avp.OptionCheckbox("AO Enabled", this.tbody, true);
    this.addEventListener(this.saoToggle, "change", function(e) {
        var enable = self.saoToggle.checked;
        viewer.prefs.set("ambientShadows", enable);
        viewer.setQualityLevel(enable, viewer.impl.renderer().settings.antialias);
    });

    this.saoRadius = new avp.OptionSlider("AO Radius", 0, 100, this.tbody);
    this.saoRadius.setValue(10);
    this.saoRadius.sliderElement.step = this.saoRadius.stepperElement.step = 1;
    this.addEventListener(this.saoRadius, "change", function(e) {
        viewer.impl.renderer().setAOOptions(parseInt(self.saoRadius.value), parseFloat(self.saoIntensity.value));
        viewer.impl.renderer().composeFinalFrame(false);
    });

    this.saoIntensity = new avp.OptionSlider("AO Intensity", 0, 3, this.tbody);
    this.saoIntensity.setValue(0.75);
    this.saoIntensity.sliderElement.step = this.saoIntensity.stepperElement.step = 0.1;
    this.addEventListener(this.saoIntensity, "change", function(e) {
        viewer.impl.renderer().setAOOptions(parseInt(self.saoRadius.value), parseFloat(self.saoIntensity.value));
        viewer.impl.renderer().composeFinalFrame(false);
    });

    this.groundShadowAlpha = new avp.OptionSlider("Shadow Alpha", 0, 2, this.tbody);
    this.groundShadowAlpha.setValue(1.0);
    this.groundShadowAlpha.sliderElement.step = this.groundShadowAlpha.stepperElement.step = 0.1;
    this.addEventListener(this.groundShadowAlpha, "change", function(e) {
        viewer.setGroundShadowAlpha(parseFloat(self.groundShadowAlpha.value));
    });

    this.groundShadowColor = new avp.OptionCheckbox("Shadow Color", this.tbody);
    if (!_isIE11)
        this.groundShadowColor.checkElement.type = "color"; // hack
    this.addEventListener(this.groundShadowColor, "change", function(e) {
        var colStr = self.groundShadowColor.checkElement.value;
        viewer.setGroundShadowColor(
            new THREE.Color(parseInt(colStr.substr(1,7), 16))
        );
    });

    this.groundReflectionAlpha = new avp.OptionSlider("Reflection Alpha", 0, 2, this.tbody);
    this.groundReflectionAlpha.setValue(1.0);
    this.groundReflectionAlpha.sliderElement.step = this.groundReflectionAlpha.stepperElement.step = 0.1;
    this.addEventListener(this.groundReflectionAlpha, "change", function(e) {
        viewer.setGroundReflectionAlpha(parseFloat(self.groundReflectionAlpha.value));
    });

    this.groundReflectionColor = new avp.OptionCheckbox("Reflection Color", this.tbody);
    if (!_isIE11)
        this.groundReflectionColor.checkElement.type = "color"; // hack
    this.addEventListener(this.groundReflectionColor, "change", function(e) {
        var colStr = self.groundReflectionColor.checkElement.value;
        viewer.setGroundReflectionColor(
            new THREE.Color(parseInt(colStr.substr(1,7), 16))
        );
    });

    var env_list = [];
    for (var i=0; i<avp.LightPresets.length; i++) {
        env_list.push(avp.LightPresets[i].name);
    }

    this.envSelect = new avp.OptionDropDown("Environment", this.tbody, env_list, viewer.impl.currentLightPreset());

    this.addEventListener(this.envSelect, "change", function(e) {
        var chosen = self.envSelect.selectedIndex;
        viewer.setLightPreset(chosen);
    });


    var initialTonemapMethod = viewer.impl.renderer().getToneMapMethod();

    this.toneMapMethod = new avp.OptionDropDown("Tonemap Method", this.tbody,
        ["None",
         "Canon-Lum",
         "Canon-RGB"
         ],
        initialTonemapMethod);

    this.addEventListener(this.toneMapMethod, "change", function() {
        // NOTE: Changing between Canon-Lum and Canon-RGB will yield no results
        // TODO: Add mechanism to make a change in those values effective in the material.
        // Best way to test this (for now) is to add an Environment with the desired toneMap value
        var method = self.toneMapMethod.selectedIndex;
        viewer.impl.setTonemapMethod(method);
    });

    this.exposureBias = new avp.OptionSlider("Exposure Bias", -30.0, 30.0, this.tbody);
    this.exposureBias.setValue(viewer.impl.renderer().getExposureBias());
    this.exposureBias.sliderElement.step = this.exposureBias.stepperElement.step = 0.1;
    this.addEventListener(this.exposureBias, "change", function(e) {
        viewer.impl.setTonemapExposureBias(self.exposureBias.value, self.whiteScale.value);
    });
    this.exposureBias.setDisabled(initialTonemapMethod == 0);

    this.whiteScale = new avp.OptionSlider("Light Intensity", -5.0, 20.0, this.tbody);
    var intensity = 0.0;
    if (viewer.impl.dir_light1) {
        if (viewer.impl.dir_light1.intensity != 0)
            intensity = Math.log(viewer.impl.dir_light1.intensity)/Math.log(2.0);
        else
            intensity = -1e-20;
    }
    this.whiteScale.setValue(intensity);
    this.whiteScale.sliderElement.step = this.whiteScale.stepperElement.step = 0.1;
    this.addEventListener(this.whiteScale, "change", function(e) {
        viewer.impl.dir_light1.intensity = Math.pow(2.0,self.whiteScale.value);
        viewer.impl.setTonemapExposureBias(self.exposureBias.value, self.whiteScale.value);
    });

    // 10-200mm lens range:
    this.fovAngle = new avp.OptionSlider("FOV-degrees", 6.88, 100, this.tbody);
    this.fovAngle.setValue(viewer.getFOV());
    this.addEventListener(this.fovAngle, "change", function(e) {
        viewer.setFOV(parseFloat(self.fovAngle.value));
    });

    this.addEventListener(this.viewer, Autodesk.Viewing.CAMERA_CHANGE_EVENT, function(evt) {
        var myFov = parseFloat(self.fovAngle.value);
        var camFov = viewer.getFOV();

        if (myFov != camFov)
            self.fovAngle.setValue(camFov);
    });

    this.addEventListener(this.viewer, Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT, function(e) {
        self.syncUI();
    });

    this.addVisibilityListener(function () {
        self.resizeToContent();
    });
};

Autodesk.Viewing.Private.RenderOptionsPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Private.RenderOptionsPanel.prototype.constructor = Autodesk.Viewing.Private.RenderOptionsPanel;

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
Autodesk.Viewing.Private.RenderOptionsPanel.prototype.getContentSize = function () {
    return {height: this.table.clientHeight + 75, width: this.table.clientWidth};
};

Autodesk.Viewing.Private.RenderOptionsPanel.prototype.updateBgColorIndex = function() {

    var viewer = this.viewer.impl;
    var ctop = viewer.clearColorTop;
    var cbot = viewer.clearColorBottom;
    var current_color = [(ctop.x * 255)|0, (ctop.y * 255)|0, (ctop.z * 255)|0,
                         (cbot.x * 255)|0, (cbot.y * 255)|0, (cbot.z * 255)|0];

    //Check if the current setting of the viewer matches any of the presets.
    var color_name;
    for (var p in Autodesk.Viewing.Private.BackgroundPresets)
    {
        var c = Autodesk.Viewing.Private.BackgroundPresets[p];
        var j;
        for (j = 0; j<6; j++)
        {
            if (c[j] != current_color[j])
                break;
        }
        if (j == 6)
        {
            color_name = p;
            break;
        }
    }

    //If it does not match, add it as extra entry in the combo box
    if (!color_name)
    {
        color_name = "Custom";
        var custom_color_arr = Autodesk.Viewing.Private.BackgroundPresets[color_name];
        for (var i=0; i<6; i++) {
            custom_color_arr[i] = current_color[i];
        }
    }

    this.bgSelect.setSelectedValue(color_name);
};

Autodesk.Viewing.Private.RenderOptionsPanel.prototype.syncUI = function() {
    var impl = this.viewer.impl;

    var intensity = 0.0;
    if (impl.dir_light1) {
        if (impl.dir_light1.intensity != 0)
            intensity = Math.log(impl.dir_light1.intensity)/Math.log(2.0);
        else
            intensity = -1e-20;
    }
    this.whiteScale.setValue(intensity);

    this.exposureBias.setValue(impl.renderer().getExposureBias());

    this.updateBgColorIndex();

    var method = impl.renderer().getToneMapMethod();
    this.toneMapMethod.setSelectedIndex(method);
    this.envSelect.setSelectedIndex(impl.currentLightPreset());

    this.exposureBias.setDisabled(method == 0);
    this.saoToggle.setValue(impl.renderer().settings.sao);
    this.saoRadius.setDisabled(!impl.renderer().settings.sao);
    this.saoIntensity.setDisabled(!impl.renderer().settings.sao);

    this.saoRadius.setValue(impl.renderer().getAORadius());
    this.saoIntensity.setValue(impl.renderer().getAOIntensity());

    // NOTE_NOP: no sync value because no get methods, not necessary to implement
    this.groundShadowAlpha.setDisabled(!this.viewer.prefs.get("groundShadow"));
    this.groundShadowColor.setDisabled(!this.viewer.prefs.get("groundShadow"));
    this.groundReflectionAlpha.setDisabled(!this.viewer.prefs.get("groundReflection"));
    this.groundReflectionColor.setDisabled(!this.viewer.prefs.get("groundReflection"));

    this.fovAngle.setValue(this.viewer.getFOV());
    
    this.celToggle.setValue(impl.renderer().settings.toonShaded);
};

Autodesk.Viewing.Private.RenderOptionsPanel.prototype.uninitialize = function () {
    Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);
    this.table = null;
    this.tbody = null;
    this.bgSelect = null;
    this.saoToggle = null;
    this.saoRadius = null;
    this.saoIntensity = null;
    this.groundShadowAlpha = null;
    this.envSelect = null;
    this.toneMapMethod = null;
    this.exposureBias = null;
    this.whiteScale = null;
    this.fovAngle = null;
    this.viewer = null;
};
;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avu = Autodesk.Viewing.UI;

/**
 * LayersPanel
 * This is a panel for displaying the layers in a file.
 * @class
 * @augments Autodesk.Viewing.UI.DockingPanel
 * @alias Autodesk.Viewing.UI.LayersPanel
 * @param {Viewer} viewer - The parent viewer.
 * @param {HTMLElement} parentContainer - The container for this panel.
 * @param {string} id - The id for this panel.
 * @constructor
 * @private
 */
var LayersPanel = function (viewer, parentContainer, id) {
    this.viewer = viewer;
    this.tree = null;
    this.layersRoot = null;
    this.visibilityImages = {};
    this.isMac = (navigator.userAgent.search("Mac OS") !== -1);

    var title = "Layer Manager"; // Gets translated by DockingPanel's constructor
    var viewableName = viewer.config.viewableName;
    var localizeTitle = true;

    if (viewableName && viewableName !== 'W2D') { // See SPK-1304
        title = av.i18n.translate(title) + ": " + viewableName;
        localizeTitle = false;
    }

    this.filterImageId = id + "-layerFilterImageId";

    avu.DockingPanel.call(this, viewer.container, id, title, {localizeTitle: localizeTitle});
    this.container.classList.add('layersPanel');
    this.filterContainer = document.createElement("div");
    this.filterContainer.className = "filterBox";
    this.filterContainer.id = this.container.id + '-search-container';
    this.container.appendChild( this.filterContainer );

    this.createScrollContainer({heightAdjustment: 105, marginTop : 5});

    var that = this;
    if (viewer.model) {
        that.build();
    } else {
        that.addEventListener(viewer, av.GEOMETRY_LOADED_EVENT, function () {
            that.build();
        });
    }

    this.addVisibilityListener(function () {
        that.resizeToContent();
    });
};

LayersPanel.prototype = Object.create(avu.DockingPanel.prototype);
LayersPanel.prototype.constructor = LayersPanel;

/**
 * Clean up when the layers panel is about to be removed.
 * @override
 */
LayersPanel.prototype.uninitialize = function () {
    avu.DockingPanel.prototype.uninitialize.call(this);

    this.viewer = null;
    this.tree = null;
    this.layersRoot = null;
    this.visibilityImages = null;
    this.scrollContainer = null;
    this.filterContainer = null;
};

/**
 * Builds the layers panel.
 */
LayersPanel.prototype.build = function () {
    var that = this;

    function createDelegate() {
        var delegate = new avu.TreeDelegate();

        delegate.getTreeNodeId = function (node) {
            return node.id;
        };

        delegate.getTreeNodeLabel = function (node) {
            return that.getNodeLabel(node);
        };

        delegate.getTreeNodeClass = function (node) {
            return that.getNodeClass(node);
        };

        delegate.isTreeNodeGroup = function (node) {
            return that.isGroupNode(node);
        };

        delegate.shouldCreateTreeNode = function (node) {
            return that.shouldInclude(node);
        };

        delegate.onTreeNodeClick = function (tree, node, event) {
            that.onClick(node, event);
        };

        delegate.onTreeNodeRightClick = function (tree, node, event) {
            that.onRightClick(node, event);
        };

        delegate.onTreeNodeDoubleClick = function (tree, node, event) {
            that.onDoubleClick(node, event);
        };

        delegate.onTreeNodeIconClick = function(tree, node, event)
        {
            that.onIconClick(node, event);
        };

        delegate.createTreeNode = function (node, parent) {
            that.createNode(node, parent);
        };

        return delegate;
    }

    // Search field
    var searchDiv = document.createElement("div");
    searchDiv.className = "filterSearch";
    that.filterContainer.appendChild(searchDiv);

    var image = document.createElement('div');
    image.className = "filterImage";
    image.id  = that.filterImageId;
    image.title = av.i18n.translate("Show/hide all layers");
    searchDiv.appendChild( image );
    that.visibilityImages[that.filterImageId] = image;

    that.addEventListener(image, 'click', function (event) {
        that.onImageClick(null, event);
        event.stopPropagation();
    });

    var filterField = this.filterField = document.createElement("input");
    filterField.className = "filterInput";
    filterField.placeholder = av.i18n.translate("Enter filter term");
    filterField.setAttribute("data-i18n", "[placeholder]Enter filter term");
    filterField.type = 'search';
    filterField.incremental = "incremental";

    searchDiv.appendChild(filterField);

    var searchTimer = null,
        viewer = that.viewer;

    function doIncrementalSearch() {
        if (searchTimer) {
            clearTimeout(searchTimer);
        }
        searchTimer = setTimeout(doSearch, 500);
    }

    function doSearch() {

        function getMatches(node) {
            var matches = [];
            if (node.name.toLowerCase().indexOf(searchText) !== -1) {
                matches.push(node);
            } else if (!node.isLayer) {
                var children = node.children;
                for (var i = 0; i < children.length; ++i) {
                    matches = matches.concat(getMatches(children[i]));
                }
            }
            return matches;
        }

        if (filterField.value) {
            var searchText = filterField.value.toLowerCase();

            if (layersRoot && 0 < layersRoot.childCount) {
                viewer.setLayerVisible(getMatches(layersRoot), true, true);
            }

        } else {
            // Make all the layers visible.
            viewer.setLayerVisible(null, true);
        }
        searchTimer = null;
    }

    filterField.addEventListener('keyup', function (e) {
        doIncrementalSearch();
    });

    // This is to detect when the user clicks on the 'x' to clear.
    filterField.addEventListener('click', function (e) {
        if (filterField.value === '') {
            viewer.setLayerVisible(null, true);
            return;
        }

        // When this event is fired after clicking on the clear button
        // the value is not cleared yet. We have to wait for it.
        setTimeout(function () {
            if (filterField.value === '') {
                viewer.setLayerVisible(null, true);
                e.preventDefault();
            }
        }, 1);
    });

    var delegate = createDelegate(),
        layersRoot = that.layersRoot = that.viewer.model.getLayersRoot();

    if (layersRoot) {
        that.tree = new avu.Tree(delegate, layersRoot, that.scrollContainer, {excludeRoot:true});
        that.resizeToContent();
        that.update();

        that.addEventListener(that.viewer, av.LAYER_VISIBILITY_CHANGED_EVENT, function () {
            that.update();
        });
    }
};

/**
 * Updates the visibility states for the layers in the panel.
 */
LayersPanel.prototype.update = function () {
    var that = this;

    function updateImage(image, state) {
        var cls;
        if (state === 1) {
            cls = 'layerVisible';
        } else if (state === 0) {
            cls = 'layerHidden';
        } else { // -1
            cls = 'layerMixed';
        }

        image.classList.remove('layerVisible', 'layerHidden', 'layerMixed');
        image.classList.add(cls);
    }

    function updateLook(node, state) {
        if (state === 0) {
            that.tree.addClass(node.id, 'dim');
        } else { // state === 1 || state === -1
            that.tree.removeClass(node.id, "dim");
        }
    }

    function getItemState(items) {
        var state;

        if (0 < items.length) {
            for (var i = 0; i < items.length; ++i) {
                var item = items[i];

                if (state === undefined) {
                    state = item;
                } else if (item === 0 && state === 1) {
                    state = -1;
                } else if (item === 1 && state === 0) {
                    state = -1;
                }

                if (state === -1) {
                    break;
                }
            }
        } else {
            state = 0;
        }
        return state;
    }

    function traverse(parent) {
        var id = parent.id,
            image = that.visibilityImages[id];

        if (!parent.isLayer) {
            var children = parent.children,
                visibility = [];

            for (var i = 0; i < children.length; ++i) {
                visibility = visibility.concat(traverse(children[i]));
            }

            var state = getItemState(visibility);
            updateImage(image, state);
            updateLook(parent, state);
            return visibility;
        }

        var visible = that.viewer.isLayerVisible(parent) ? 1 : 0;
        updateImage(image, visible);
        updateLook(parent, visible);

        return [visible];
    }

    var allVisible = (this.layersRoot && 0 < this.layersRoot.childCount) ? traverse(that.layersRoot) : [];

    // Update the filter image.
    var filterImage = that.visibilityImages[that.filterImageId];
    updateImage(filterImage, getItemState(allVisible));
};

/**
 * Toggle or isolate the visibility state for a layer node.
 * @param {?Object} node
 * @param {boolean=} [isolate=false] true to isolate, false to toggle
 */
LayersPanel.prototype.setLayerVisible = function (node, isolate) {
    var id = node ? node.id : this.filterImageId,
        cls = this.visibilityImages[id].className,
        visible = (cls !== 'layerVisible');

    this.viewer.setLayerVisible(node, visible, isolate);
    this.filterField.value = '';
};

/**
 * Override this method to specify the label for a node.
 * @param {Object} node
 * @returns {string} Label of the tree node
 */
LayersPanel.prototype.getNodeLabel = function (node) {
    return (node.isLayer || 0 === node.childCount) ? node.name : (node.name + " (" + node.childCount + ")");
};

/**
 * Override this to specify the CSS classes of a node. This way, in CSS, the designer
 * can specify custom styling per type.
 * By default, an empty string is returned.
 * @param {Object} node
 * @returns {string} CSS classes for the node
 */
LayersPanel.prototype.getNodeClass = function (node) {
    return '';
};

/**
 * Override this method to specify whether or not a node is a group node.
 * @param {Object} node
 * @returns {boolean} true if this node is a group node, false otherwise
 */
LayersPanel.prototype.isGroupNode = function (node) {
    return !node.isLayer;
};

/**
 * Override this method to specify if a tree node should be created for this node.
 * By default, every node will be displayed.
 * @param {Object} node
 * @returns {boolean} true if a node should be created, false otherwise
 */
LayersPanel.prototype.shouldInclude = function (node) {
    return true;
};

/**
 * Override this to do something when the user clicks on a tree node's icon.
 * By default, groups will be expanded/collapsed.
 * @param {Object} node
 * @param {Event} event
 */
LayersPanel.prototype.onIconClick = function(node, event) {
    this.setGroupCollapsed(node, !this.isGroupCollapsed(node));
};

/**
 * Collapse/expand a group node.
 * @param {Object} node - A node to collapse/expand in the tree.
 * @param {boolean} collapse - true to collapse the group, false to expand it.
 */
LayersPanel.prototype.setGroupCollapsed = function(node, collapse) {
    var delegate = this.tree.delegate();
    if (delegate.isTreeNodeGroup(node)) {
        var id = delegate.getTreeNodeId(node);
        this.tree.setCollapsed(id, collapse);

        this.resizeToContent();
    }
};

/**
 * Returns true if the group is collapsed.
 * @param {Object} node - The node in the tree.
 * @returns {boolean} - true if the group is collapsed, false otherwise.
 */
LayersPanel.prototype.isGroupCollapsed = function(node) {
    var delegate = this.tree.delegate();
    if (delegate.isTreeNodeGroup(node)) {
        var id = delegate.getTreeNodeId(node);
        return this.tree.isCollapsed(id);
    }
    return false;
};
/**
 * Override this method to do something when the user clicks on a tree node
 * @param {Object} node
 * @param {Event} event
 */
LayersPanel.prototype.onClick = function (node, event) {
};

/**
 * Override this to do something when the user double-clicks on a tree node
 * @param {Object} node
 * @param {Event} event
 */
LayersPanel.prototype.onDoubleClick = function (node, event) {
};

/**
 * Override this to do something when the user right-clicks on a tree node
 * @param {Object} node
 * @param {Event} event
 */
LayersPanel.prototype.onRightClick = function (node, event) {
};

/**
 * Override this to do something when the user clicks on an image
 * @param {Object} node
 * @param {Event} event
 */
LayersPanel.prototype.onImageClick = function (node, event) {
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
LayersPanel.prototype.getContentSize = function () {
    var filterContainer = this.filterContainer,
        height = filterContainer.clientHeight + 80,
        width = filterContainer.clientWidth;

    var tree = this.tree;
    if (tree) {
        var treeContainer = tree.getRootContainer();
        if (treeContainer) {
            return {
                height: treeContainer.clientHeight + height,
                width: Math.max(treeContainer.clientWidth, width)
            };
        }

    }
    return {height: height, width: width};
};

/**
 * Override this to create the HTMLContent for this node for appending to the
 * parent.  By default, a label and a visibility image are created.
 * @param {Object} node
 * @param {HTMLElement} parent
 */
LayersPanel.prototype.createNode = function (node, parent) {
    var image = document.createElement('div');
    if (parent.children && parent.children.length > 0) {
        parent.insertBefore(image, parent.children[0]);
    } else {
        parent.appendChild(image);
    }
    image.title = av.i18n.translate("Show/hide this layer");
    this.visibilityImages[node.id] = image;

    var label = document.createElement('label');
    label.textContent = this.getNodeLabel(node);
    parent.appendChild(label);

    var that = this;
    this.addEventListener(image, 'click', function (event) {
        that.onImageClick(node, event);
        event.stopPropagation();
    });
};

Autodesk.Viewing.UI.LayersPanel = LayersPanel;

})();;AutodeskNamespace('Autodesk.Viewing.UI');

/**
 *  SettingsPanel represents a panel specifically designed for application
 *  settings.
 *
 *  @class
 *  @augments Autodesk.Viewing.UI.DockingPanel
 *
 *  The user can add new options to each of the tabs.
 *
 *  @param {HTMLElement} parentContainer - The container for this panel.
 *  @param {string} id - The id to assign this panel.
 *  @param {string} title - The title of this panel.
 *  @param {Object=} [options] - An optional dictionary of options.
 *
 * @constructor
 */
Autodesk.Viewing.UI.SettingsPanel = function (parentContainer, id, title, options) {

    Autodesk.Viewing.UI.DockingPanel.call(this, parentContainer, id, title, options);

    this.panelTabs      = [];
    this.tabIdToIndex   = {};
    this.controls       = {};
    this.controlIdCount = 0;    // to generate unique ids for controls.

    var settings = this;

    var minWidth = options && options.width !== undefined ? options.width : 340;

    this.container.style.maxWidth = "800px";
    this.container.style.minWidth = minWidth + "px";
    this.container.style.top      = "100px";
    this.container.style.left = (parentContainer.offsetWidth/2 - 170) + "px"; //center it horizontally
    //this.container.style.left     = "220px"; // just needs an initial value dock overrides value
    this.container.style.position = "absolute";
    //this.container.dockRight = true;

    this.tabContainer = document.createElement("div");
    this.tabContainer.className = "settings-tabs";
    this.container.appendChild(this.tabContainer);

    this.tabs = document.createElement( "ul" );
    this.tabContainer.appendChild( this.tabs );

    this.heightAdjustment = options && options.heightAdjustment ? options.heightAdjustment : 110;
    this.createScrollContainer({left: false, heightAdjustment: this.heightAdjustment, marginTop:0 });

    // Add hovering effect.
    //
    this.mouseOver = false;
    this.addEventListener( this.container, "mouseover", function(event) {
        // This is the original element the event handler was assigned to
        var e = event.toElement || event.relatedTarget;
        if ( settings.mouseOver )
            return true;

        // Check for all children levels (checking from bottom up)
        var index = 0;
        while(e && e.parentNode && e.parentNode != window) {
            if (e.parentNode == this || e == this) {
                if(e.preventDefault) e.preventDefault();
                settings.mouseOver = true;

                for (var index = 0; index<settings.panelTabs.length; index++)
                    settings.panelTabs[index].classList.remove("selectedmouseout");
                return true;
            }
            e = e.parentNode;
        }
    });

    this.addEventListener( this.container, "mouseout", function(event) {
        // This is the original element the event handler was assigned to
        var e = event.toElement || event.relatedTarget;
        if (!settings.mouseOver)
            return;

        // Check for all children levels (checking from bottom up)
        while(e && e.parentNode && e.parentNode != window) {
            if (e.parentNode == this ||  e == this) {
                if(e.preventDefault) e.preventDefault();
                    return false;
            }
            e = e.parentNode;
        }
        settings.mouseOver = false;

        var selectedTab = null;
        for (var index=0; index<settings.panelTabs.length; index++) {
            if (settings.panelTabs[index].classList.contains("tabselected"))
                settings.panelTabs[index].classList.add("selectedmouseout");
        }
    });
};

Autodesk.Viewing.UI.SettingsPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.UI.SettingsPanel.prototype.constructor = Autodesk.Viewing.UI.SettingsPanel;

/**
 *  Sets the new visibility state of this SettingsPanel.
 *
 *  @param {boolean} show - The desired visibility state.
 *  @param {boolean} skipTransition - If true, skips initial opaque state and displays directly with final background color
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.setVisible = function( show )
{
    if (show) {
        // Since the container does not have width and when display set to none
        // getBoundingClientRect() returns 0, set the display to block before the
        // parent calculates the position and the panel.
        // NOTE: Setting the width for the container does not work here.
        this.container.style.display = "block";
    }

    Autodesk.Viewing.UI.DockingPanel.prototype.setVisible.call( this, show );
};

/**
 * Adds a new tab to the panel.
 *
 * @param {string} tabId - id for the tab dom element and for the tab
 * @param {string} tabTitle
 * @param {Object=} [options] - optional parameter that allows for additional
 *   options for the tab:
 *          tabClassName - class name for the Dom elements
 *          minWidth - min width for the tab
 *          index - index if the tab should be inserted instead of added at the end.
 * @returns {boolean} - true if the tab was added to the panel, false otherwise.
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.addTab = function( tabId, tabTitle, options ) {
    var settings = this;

    if (this.tabIdToIndex[tabId] !== undefined )
        return false;

    var tabDomClass = options && options.className !== undefined ? options.className : null;
    var minWidth    = options && options.width !== undefined ? options.width : 200;
    var tabIndex    = options && options.index !== undefined ? options.index : this.panelTabs.length;

    function select(e) {
        settings.selectTab( tabId );
    }

    var tab = document.createElement("li");
    tab.id  = tabId;

    var title = document.createElement("a");
    var span  = document.createElement("span");
    span.setAttribute("data-i18n", tabTitle);
    span.textContent = Autodesk.Viewing.i18n.translate(tabTitle);
    title.appendChild(span);
    tab.appendChild( title );

    this.tabs.appendChild( tab );

    var table = document.createElement("table");
    table.id  = tabId + "-table";
    table.className = "settings-table tftable " + tabDomClass;

    var tbody = document.createElement("tbody");
    table.appendChild(tbody);

    this.scrollContainer.appendChild( table );

    this.addEventListener( tab, "touchstart", touchStartToClick );
    this.addEventListener( tab, "click", select );

    this.panelTabs.push( tab );
    this.tabIdToIndex[tabId] = tabIndex;

    // Adjust the panel's minWidth.
    var currentMinWidth = this.container.style.minWidth ? parseInt(this.container.style.minWidth) : 0;
    if (minWidth > currentMinWidth)
        this.container.style.minWidth = minWidth + "px";

    return true;
};

/**
 * Removes the given tab from the panel.
 *
 * @param {string} tabId - tab to remove.
 * @return {boolean} - returns true if the tab was successfully removed, false otherwise.
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.removeTab = function( tabId ) {

    var tabIndex = this.tabIdToIndex[tabId];
    if (!tabIndex)
        return false;

    this.panelTabs.splice(tabIndex, 1);

    this.tabs.removeChild( tabDom );

    // Adjust the idToIndex table and add space (right margin) to all tabs except the last one.
    this.tabIdToIndex = {};
    var tabCount = this.panelTabs.length;
    for (var index=0; index<tabCount; index++) {
        var tab = this.panelTabs[index];
        this.tabIdToIndex[tab.id] = index;
    }
    return true;
};

/**
 * Returns true if a tab with given id exists.
 *
 * @param {string} tabId - tab id.
 * @returns {boolean} - true if the tab with given id exists, false otherwise.
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.hasTab = function(tabId) {
    var tabIndex = this.tabIdToIndex[tabId];
    var tab = this.panelTabs[tabIndex];
    return tab !== undefined;
};

/**
 * Makes a given tab visible and hides the other ones.
 *
 * @param {string} tabId - tab to select.
 * @returns {boolean} - true if the tab was selected, false otherwise.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.selectTab = function( tabId )
{
    if (this.isTabSelected(tabId))
        return false;

    var tabCount = this.panelTabs.length;
    for (var tabIndex=0; tabIndex<tabCount; tabIndex++) {
        var tab = this.panelTabs[tabIndex];
        var table = document.getElementById( tab.id + "-table" );
        if (tabId===tab.id) {
            tab.classList.add("tabselected");
            table.style.display = 'table';
            if (!this.mouseOver) {
                tab.classList.add("selectedmouseout");
            }
        }
        else {
            tab.classList.remove("tabselected");
            table.style.display = 'none';
            if (!this.mouseOver) {
                this.panelTabs[tabIndex].classList.remove("selectedmouseout");
            }
        }
    }

    this.resizeToContent();

    return true;
};

/**
 * Returns true if the given tab is selected (visible).
 *
 * @param {string} tabId - tab to check.
 * @returns {boolean} - returns true if the tab is selected, false otherwise.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.isTabSelected = function(tabId) {
    var tabIndex = this.tabIdToIndex[tabId];
    var tab = this.panelTabs[tabIndex];
    return tab && tab.classList.contains('tabselected');
};

/**
 * Creates a checkbox control and adds it to a given tab.
 *
 * @param {string} tabId - tab to which to add a new checkbox.
 * @param {string} caption - the text associated with the checkbox
 * @param {boolean} initialState - initial value for the checkbox (checked or not)
 * @param {function} onchange - callback that is called when the checkbox is changed
 * @param {Object|undefined} options - additional options:
 *      insertAtIndex {number} - index at which to insert a new checkbox
 * @returns {string} - id of a new control.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.addCheckbox = function(tabId, caption, initialState, onchange, options )
{
    var tabIndex = this.tabIdToIndex[tabId];
    if (tabIndex === undefined)
        return null;

    var table = document.getElementById( tabId + "-table" );
    var checkBoxElem = new Autodesk.Viewing.Private.OptionCheckbox(caption, table.tBodies[0], initialState, options);
    checkBoxElem.changeListener = function(e) {
        var checked = e.detail.target.checked;
        onchange(checked);
    };
    this.addEventListener(checkBoxElem, "change", checkBoxElem.changeListener);

    return this.addControl( tabId, checkBoxElem );
};

/**
 * Creates a slider control and adds it to a given tab.
 *
 * @param {string} tabId - tab to which to add a new slider.
 * @param {string} caption - the text associated with the slider
 * @param {number} min - min value of the slider
 * @param {number} max - max value of the slider
 * @param {number} initialValue - initial value for the slider
 * @param {function} onchange - callback that is called when the slider value is changed
 * @param {Object|undefined} options - additional options:
 *      insertAtIndex {number} - index at which to insert a new slider
 * @returns {string} - id of a new control.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.addSlider = function(tabId, caption, min, max, initialValue, onchange, options )
{
    var tabIndex = this.tabIdToIndex[tabId];
    if (tabIndex === undefined)
        return null;

    var table = document.getElementById( tabId + "-table" );

    var slider = new Autodesk.Viewing.Private.OptionSlider(caption, min, max, table.tBodies[0], options);
    slider.setValue(initialValue);
    slider.sliderElement.step = slider.stepperElement.step = 1;
    this.addEventListener(slider, "change", function(e) {
       onchange(e);
    });

    return this.addControl( tabId, slider );
};

/**
 *
 * @param {string} tabId - tab to which to add a new slider.
 * @param {string} caption - the text associated with the slider
 * @param {array}  items - list of items for the menu
 * @param {number} initialItemIndex - initial choice
 * @param {function} onchange - callback that is called when the menu selection is changed
 * @param {Object|undefined} options - additional options:
 *      insertAtIndex {number} - index at which to insert a new drop down menu.
 * @returns {string} - id of a new control.
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.addDropDownMenu = function(tabId, caption, items, initialItemIndex, onchange, options )
{
    var tabIndex = this.tabIdToIndex[tabId];
    if (tabIndex === undefined)
        return null;

    var table = document.getElementById( tabId + "-table" );

    var menu = new Autodesk.Viewing.Private.OptionDropDown(caption, table.tBodies[0], items, initialItemIndex, options );
    this.addEventListener(menu, "change", function(e) {
        onchange(e);
    });

    return this.addControl( tabId, menu );
};

/**
 * Adds a new control to a given tab.
 *
 * @param {string} tabId - tab to which to add a new.
 * @param {Object|HTMLElement} control - control to add to the given tab.
 * @param {Object|undefined} options - additional parameters:
 *      insertAtIndex {number}  - index at which to insert a new control.
 *      caption {string} - caption for the control.
 * @returns {string} - id of the added control.
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.addControl = function(tabId, control, options)
{
    var tabIndex = this.tabIdToIndex[tabId];
    if (tabIndex === undefined)
        return null;

    // If this is a generic control (not created by one of the convenient methods
    // like addCheckbox, addSlider, etc. then add it to the table first.
    //
    if (!control.hasOwnProperty("sliderRow")) {
        var atIndex = options && options.insertAtIndex ? options.insertAtIndex : -1;
        var caption = options && options.caption ? options.caption : null;

        var table = document.getElementById( tabId + "-table" );
        if (atIndex > table.length)
            atIndex = -1; // add it to the end.
        var sliderRow = table.tBodies[0].insertRow(atIndex);

        var cell = sliderRow.insertCell(0);
        if (caption) {
            var domCaption = document.createElement("div");
            domCaption.setAttribute( "data-i18n", caption );
            domCaption.textContent = Autodesk.Viewing.i18n.translate( caption );
            cell.appendChild( domCaption );
            cell = sliderRow.insertCell(1);
        }
        else {
            // Span the cell into 2 columns
            cell.colSpan = 2;
        }
        cell.appendChild( control );

        control.sliderRow = sliderRow;
        control.tbody = table.tBodies[0];
    }

    var controlId = "adsk_settings_control_id_" + this.controlIdCount.toString();
    this.controlIdCount = this.controlIdCount + 1;
    this.controls[controlId] = control;

    this.resizeToContent();

    return controlId;
};

/**
 * Removes a given checkbox from the settings panel.
 *
 * @param {string} checkboxId - checkbox to remove.
 * @returns {boolean} - true if the checkbox was removed, false otherwise.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.removeCheckbox = function(checkboxId)
{
    return this.removeControl( checkboxId );
};

/**
 * Removes a given slider from the settings panel.
 *
 * @param {string} sliderId - slider control to remove.
 * @returns {boolean} - true if the slider control was removed, false otherwise.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.removeSlider = function(sliderId)
{
    return this.removeControl( sliderId );
};

/**
 * Removes a given dropdown menu from the settings panel.
 *
 * @param {string} dropdownMenuId - checkbox to remove.
 * @returns {boolean} - true if the dropdown menu was removed, false otherwise.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.removeCheckbox = function(dropdownMenuId)
{
    return this.removeControl( dropdownMenuId );
};

/**
 * Removes a given control from the settings panel.
 *
 * @param {string} controlId - control to remove.
 * @returns {boolean} - true if the  control was removed, false otherwise.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.removeControl = function(controlId)
{
    var control;
    if (typeof controlId == "object" && controlId.tbody) {
        control = controlId;
    } else {
        control = this.controls[controlId];
    }

    if (control === undefined)
        return false;

    var tbody     = control.tbody;
    var sliderRow = control.sliderRow;
    var rowIndex  = sliderRow.rowIndex;

    tbody.deleteRow(rowIndex);

    delete this.controls[controlId];

    this.resizeToContent();

    return true;
};

/**
 * Returns a control with a given id.
 *
 * @param {string} controlId - checkbox id to return.
 * @returns {Object} - control object if if found, null otherwise.
 *
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.getControl = function(controlId)
{
    return (this.controls[controlId] !== undefined) ? this.controls[controlId] : null;
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
Autodesk.Viewing.UI.SettingsPanel.prototype.getContentSize = function () {

    var height = this.heightAdjustment;

    // If none of the tabs is selected, then take the fist one (case when
    // there is only one tab).
    var selectedTab = this.panelTabs.length > this.panelTabs[0] ? 0 : null;
    for (var tabIndex=0; tabIndex<this.panelTabs.length; tabIndex++) {
        var tab = this.panelTabs[tabIndex];
        if (this.isTabSelected(tab.id)) {
            selectedTab = tab;
            break;
        }
    }

    if (selectedTab) {
        var table = document.getElementById( tab.id + "-table" );
        height = height + table.clientHeight;
    }

    return {
        height: height,
        width:  this.container.clientWidth
    };
};
;
(function() {

"use strict";

/** @constructor 
 *
 * @alias Autodesk.Viewing.Private.AlertBox
 *
 */
var AlertBox = function () {
};

AlertBox.instances = [];

// static
AlertBox.displayError = function(container, msg, title, imgClass, hints ) {

    var alertBox = document.createElement("div");
    alertBox.className = "alertBox error";
    container.appendChild( alertBox );

    // Create the image element.
    var errorImageClass = imgClass;
    if (!errorImageClass)
        errorImageClass = "img-item-not-found";

    var alertBoxImg = document.createElement("div");
    alertBoxImg.className = "alertBoxImage " + errorImageClass;
    alertBox.appendChild( alertBoxImg );

    // Create the title & message element.
    var alertBoxMsg = document.createElement("div");
    alertBoxMsg.className = "alertBoxMsg";
    alertBox.appendChild( alertBoxMsg );

    var errorTitle = title;
    if (!errorTitle)
        errorTitle =  Autodesk.Viewing.i18n.translate( "Error Occurred", { "defaultValue" : "Error Occurred" } );

    var alertBoxTitle = document.createElement("div");
    alertBoxTitle.className = "alertBoxTitle";
    alertBoxTitle.textContent = errorTitle;
    alertBoxMsg.appendChild( alertBoxTitle );

    var alertBoxText = document.createElement("div");
    alertBoxText.className = "alertBoxText";
    alertBoxText.textContent = msg;
    alertBoxMsg.appendChild( alertBoxText );

    // Add additional content
    if (hints) {
        var content = document.createElement("div");
        content.className = "alertBoxContent";
        alertBoxMsg.appendChild( content );

        var hintsElement = document.createElement("ul");
        hintsElement.className = "alertBoxContent";
        for (var h=0; h<hints.length; h++) {
            var hint = hints[h];
            if (!hint)
                continue;

            var hintElem = document.createElement("li");
            hintsElement.appendChild( hintElem );

            var result = this.extractList(hint);
            if (result.list.length) {
                var unorderedlist = this.generateListElement(list);
                hintsElement.appendChild( unorderedlist );
            }
            hintElem.innerHTML = result.msg;
        }
        content.appendChild( hintsElement );
    }

    var alertBoxOK = document.createElement("div");
    alertBoxOK.className = "alertBoxOK";
    alertBoxOK.textContent = Autodesk.Viewing.i18n.translate( "OK", { "defaultValue" : "OK" } );

    var instance = { alertBox: alertBox, container: container };
    alertBoxOK.addEventListener("click", function(event) {
        alertBox.style.visibility = "hidden";
        container.removeChild( alertBox );
        AlertBox.instances.splice(AlertBox.instances.indexOf(instance), 1);
    });
    alertBox.appendChild( alertBoxOK );

    alertBox.style.visibility = "visible";

    AlertBox.instances.push(instance);
};

// static
AlertBox.displayErrors = function(container, imgClass, errors) {

    var alertBox = document.createElement("div");
    alertBox.className = "alertBox errors";
    container.appendChild( alertBox );

    // Create the image element.
    var errorImageClass = imgClass;
    if (!errorImageClass)
        errorImageClass = "img-item-not-found";

    var alertBoxImg = document.createElement("div");
    alertBoxImg.className = "alertBoxImage " + errorImageClass;
    alertBox.appendChild( alertBoxImg );

    // Create the title & message element.
    var alertBoxMsg = document.createElement("div");
    alertBoxMsg.className = "alertBoxMsg errors";
    alertBox.appendChild( alertBoxMsg );

    for (var i=0; i<errors.length; i++) {

        var errorTitle = errors[i].header;
        if (!errorTitle)
            errorTitle =  Autodesk.Viewing.i18n.translate( "Error", { "defaultValue" : "Error" } );

        var alertBoxTitle = document.createElement("div");
        alertBoxTitle.className = "alertBoxTitle errors";
        alertBoxTitle.textContent = errorTitle;
        alertBoxMsg.appendChild( alertBoxTitle );

        // Add message, there maybe a list of files at the end.
        var alertBoxText = document.createElement("div");
        alertBoxText.className = "alertBoxText errors";

        var msg = errors[i].msg;
        var result = this.extractList(msg);
        if (result.list.length) {
            var listElem = document.createElement("div");
            var unorderedlist = this.generateListElement(result.list);
            listElem.appendChild( unorderedlist );

            alertBoxText.textContent = result.msg;
            alertBoxText.appendChild( listElem );
        } else {
            alertBoxText.textContent = msg;
        }
        alertBoxMsg.appendChild( alertBoxText );

        // Add additional content
        if (errors[i].hints) {
            var hintsElement = document.createElement("ul");
            hintsElement.className = "alertBoxContent";
            var hints = errors[i].hints;
            for (var h=0; h<hints.length; h++) {
                var hint = hints[h];
                if (!hint)
                    continue;

                var hintElem = document.createElement("li");
                hintsElement.appendChild( hintElem );

                var result = this.extractList(hint);
                if (result.list.length) {
                    var unorderedlist = this.generateListElement(result.list);
                    hintsElement.appendChild( unorderedlist );
                }
                hintElem.innerHTML = result.msg;
            }
            alertBoxMsg.appendChild( hintsElement );
        }
    }

    var alertBoxOK = document.createElement("div");
    alertBoxOK.className = "alertBoxOK";
    alertBoxOK.textContent = Autodesk.Viewing.i18n.translate( "OK", { "defaultValue" : "OK" } );

    var instance = { alertBox: alertBox, container: container };
    alertBoxOK.addEventListener("click", function(event) {
        alertBox.style.visibility = "hidden";
        container.removeChild( alertBox );
        AlertBox.instances.splice(AlertBox.instances.indexOf(instance), 1);
    });
    alertBox.appendChild( alertBoxOK );

    alertBox.style.visibility = "visible";

    AlertBox.instances.push(instance);
};

AlertBox.extractList = function(msg) {
    var result = {
        "msg" : msg,
        "list" : []
    };

    if (msg && msg.indexOf("<ul>") != -1) {
        var parts = msg.split("<ul>");
        result.msg = parts[0];

        parts = parts[1].split("</ul>");
        result.list = parts[0].split(", ");
        if (result.list.length === 1) {
            // There maybe no spaces. Try just comma.
            result.list = parts[0].split(",");
        }
    }
    return result;
};


AlertBox.generateListElement = function(list) {
    var unorderedlist = document.createElement("ul");
    for (var l=0; l<list.length; l++) {
        var listElement = document.createElement("li");
        listElement.textContent = list[l];
        unorderedlist.appendChild( listElement );
    }

    return unorderedlist;
};


// static
AlertBox.dismiss = function() {
    // dismiss the topmost alert box
    if (AlertBox.instances.length > 0) {
        var instance = AlertBox.instances.pop();
        instance.alertBox.style.visibility = "hidden";
        instance.container.removeChild(instance.alertBox);
        return true;
    }
    return false;
};


Autodesk.Viewing.Private.AlertBox = AlertBox;

})();;(function() {

"use strict";

var av = Autodesk.Viewing;

/** @constructor */
var HudMessage = function () {
};

HudMessage.instances = [];

// static
HudMessage.displayMessage = function(container, messageSpecs, closeCB, buttonCB, checkboxCB ) {

    // If hud message is already up, return.
    if (HudMessage.instances.length > 0)
        return ;

    var msgTitle = messageSpecs.msgTitleKey;
    var msgTitleDefault = messageSpecs.msgTitleDefaultValue || msgTitle;
    var message    = messageSpecs.messageKey;
    var messageDefault = messageSpecs.messageDefaultValue || message ;
    var buttonText = messageSpecs.buttonText;
    var checkboxChecked = messageSpecs.checkboxChecked || false;

    var hudMessage = document.createElement("div");
    hudMessage.className = "hud";
    container.appendChild( hudMessage );

    var title = document.createElement("div");
    title.className = "hudTitle";
    title.textContent = av.i18n.translate( msgTitle, { "defaultValue" : msgTitleDefault } );
    title.setAttribute( "data-i18n", msgTitle );
    hudMessage.appendChild( title );

    if (closeCB) {
        var closeButton = document.createElement("div");
        closeButton.className = "hudClose";
        closeButton.innerHTML = "&times;";
        closeButton.addEventListener('click', function(e) {
            HudMessage.dismiss();
            if (closeCB)
                closeCB(e);
        });
        hudMessage.appendChild(closeButton);
    }

    var text = document.createElement("div");
    text.className = "hudMessage";
    text.textContent = av.i18n.translate( message, { "defaultValue" : messageDefault } );
    text.setAttribute( "data-i18n", messageDefault );
    hudMessage.appendChild( text );

    if (buttonCB) {
        var button = document.createElement("div");
        button.className = "hudButton";
        button.textContent = av.i18n.translate( buttonText, { "defaultValue" : buttonText } );
        button.setAttribute( "data-i18n", buttonText );
        button.addEventListener( "click", buttonCB );
        hudMessage.appendChild( button );
    }

    if (checkboxCB) {
        var checkbox = document.createElement("div");
        var cb = document.createElement("input");
        cb.className = "hudCheckbox";
        cb.type = "checkbox";
        cb.checked = checkboxChecked;
        checkbox.appendChild(cb);

        var checkboxText = "Do not show this message again";    // localized below

        var lbl = document.createElement("label");
        lbl.setAttribute('for', checkboxText);
        lbl.setAttribute("data-i18n", checkboxText);
        lbl.textContent = av.i18n.translate( checkboxText, { "defaultValue" : checkboxText } );
        checkbox.appendChild(lbl);
        cb.addEventListener( "change", checkboxCB );

        hudMessage.appendChild(checkbox);
    }

    var instance = { hudMessage: hudMessage, container: container };
    HudMessage.instances.push(instance);
};

HudMessage.dismiss = function() {
    // dismiss the topmost alert box
    if (HudMessage.instances.length > 0) {
        var instance = HudMessage.instances.pop();
        instance.hudMessage.style.visibility = "hidden";
        instance.container.removeChild(instance.hudMessage);
        return true;
    }
    return false;
};


Autodesk.Viewing.Private.HudMessage = HudMessage;

})();
;
(function() {

'use strict';

var avu = Autodesk.Viewing.UI,
    avp = Autodesk.Viewing.Private;

/**
 * Tree view control delegate
 * This class allows you to customize the behavior of a Tree view control.
 * Override the methods you want and pass an instance of this class to
 * the Tree constructor.
 * @constructor
 */
var TreeDelegate = function () {
};

TreeDelegate.prototype.constructor = TreeDelegate;

/**
 * Override this method to specify whether or not a node is a group node
 * @param {Object} node - Node in the model Document
 * @returns {boolean} true if this node is a group node, false otherwise
 */
TreeDelegate.prototype.isTreeNodeGroup = function (node) {
    throw 'isTreeNodeGroup is not implemented.';
};

/**
 * Override this method to specify the id for a node
 * @param {Object} node - Node in the model Document
 * @returns {string} Id of the tree node
 */
TreeDelegate.prototype.getTreeNodeId = function (node) {
    throw 'getTreeNodeId is not implemented.';
};

/**
 * Override this method to specify the label for a node
 * @param {Object} node - Node in the model Document
 * @returns {string} Label of the tree node
 */
TreeDelegate.prototype.getTreeNodeLabel = function (node) {
    return node.name;
};

/**
 * Override this method to specify if a tree node should be created for this node
 * @param {Object} node - Node in the model Document
 * @returns {boolean} true if a node should be created, false otherwise
 */
TreeDelegate.prototype.shouldCreateTreeNode = function (node) {
    return true;
};


/**
 * Iterates over the children of a given node and calls the callback with each child.
 */
TreeDelegate.prototype.forEachChild = function (node, callback) {
    var childCount = node.children ? node.children.length : 0;
    for (var childIndex = 0; childIndex < childCount; ++childIndex) {
        var child = node.children[childIndex];
        callback(child);
    }
};


/**
 * Override this to create the HTMLContent for this node for appending to the
 * parent.  By default, a label is created.
 *
 * @param {Object} node - Node in the model Document
 * @param {HTMLElement} parent - the parent for this content.
 * @param {Object=} [options] - An optional dictionary of options.  Current parameters:
 *                              {boolean} [localize] - when true, localization is attempted for the given node; false by default.
 *
 * @private
 */
TreeDelegate.prototype.createTreeNode = function (node, parent, options) {
    var label = document.createElement('label');
    parent.appendChild(label);

    var text = this.getTreeNodeLabel(node);
    if (options && options.localize) {
        label.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    }
    label.textContent = text;
};

/**
 * Override this method to do something when the user clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
TreeDelegate.prototype.onTreeNodeClick = function (tree, node, event) {};

/**
 * Override this to do something when the user clicks on this tree node's icon.
 * The default behavior is for the icons for group nodes to toggle the collapse/expand
 * state of that group.
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
TreeDelegate.prototype.onTreeNodeIconClick = function (tree, node, event) {
    if (tree.delegate().isTreeNodeGroup(node)) {
        tree.setCollapsed(node, !tree.isCollapsed(node));
    }
};

/**
 * Override this to do something when the user double-clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
TreeDelegate.prototype.onTreeNodeDoubleClick = function (tree, node, event) {};

/**
 * Override this to do something when the user right-clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
TreeDelegate.prototype.onTreeNodeRightClick = function (tree, node, event) {};


/**
 * Override this to specify the type of a node. This way, in css, the designer
 * can specify custom styling per type.
 * @param {Object} node - Node in the model Document
 * @returns {string} Class for the node
 */
TreeDelegate.prototype.getTreeNodeClass = function (node) {
    return '';
};

/**
 * Override this method to do something when the user hovers on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
*/
TreeDelegate.prototype.onTreeNodeHover = function (tree, node, event) {};

/**
 * Tree view control
 * @constructor
 * @param {TreeDelegate} delegate
 * @param {Object} root - A node in the model Document
 * @param {HTMLElement|string} parentContainer - Or parentContainerId
 * @param {Object} options
 */
var Tree = function (delegate, root, parentContainer, options) {
    this.myDelegate = delegate;
    this.mySelectedNodes = [];
    this.myOptions = options || {};

    var className = 'treeview';

    this.myGroupNodes = []; // <group> HTML elements in the tree

    this.nodeToElement = {};
    this.nodeIdToNode = {};

    var rootContainer = this.myRootContainer = this.createHtmlElement_(parentContainer, 'div', className);

    var rootElem = this.rootElem = this.createElement_(root, rootContainer, options, 0);

    this.setInputHandlers_();

    if(options && options.excludeRoot) {
        rootElem.classList.add("exclude");
    }

};

Tree.prototype.constructor = Tree;

/**
 * Show/hide the tree control
 * @param {boolean} show - true to show the tree control, false to hide it
 */
Tree.prototype.show = function (show) {
    var rootContainer = this.myRootContainer;
    if (show) {
        rootContainer.style.display = 'block'; // TODO: want fade in
    } else {
        rootContainer.style.display = 'none';
    }
};

/**
 * Get the root container
 * @nosideeffects
 * @returns {string}
 */
Tree.prototype.getRootContainer = function () {
    return this.myRootContainer;
};

/**
 * Get DOM element for a given logical tree node (or its integer id)
 * @nosideeffects
 * @returns {HTMLElement}
 */
Tree.prototype.getElementForNode = function (node) {

    //TODO: Remove this section once all places that hit it are gone
    if (typeof node !== "number" && typeof node !== "string") {
        //console.warn("Node object used where node ID should have");
        node = this.myDelegate.getTreeNodeId(node);
    }

    return this.nodeToElement[node];
};

/**
 * Get the tree delegate
 * @nosideeffects
 * @returns {TreeDelegate}
 */
Tree.prototype.delegate = function () {
    return this.myDelegate;
};

/**
 * Is the given group node in the tree collapsed?
 * @nosideeffects
 * @param {Object} group -The group node
 * @returns {boolean} true if group node is collapsed, false if expanded
 */
Tree.prototype.isCollapsed = function (group) {
    return this.hasClass(group, 'collapsed');
};

/**
 * Collapse/expand the given group node in the tree
 * @param {Object} group - the group node
 * @param {boolean} collapsed - true to collapse the group node, false to expand it
 */
Tree.prototype.setCollapsed = function (group, collapsed, recursive) {
    if (collapsed) {
        this.addClass(group, 'collapsed', recursive);
        this.removeClass(group, 'expanded', recursive);
    } else {
        this.addClass(group, 'expanded', recursive);
        this.removeClass(group, 'collapsed', recursive);
    }
};

/**
 * Collapse/expand all group nodes in the tree
 * @param {boolean} collapsed - true to collapse tree, false to expand it
 */
Tree.prototype.setAllCollapsed = function (collapsed) {
    var wantNode, changeNode;

    if (collapsed) {
        wantNode = function (node) {
            return node.classList.contains('expanded');
        };
        changeNode = function (node) {
            node.classList.add('collapsed');
            node.classList.remove('expanded');
        };

    } else {
        wantNode = function (node) {
            return node.classList.contains('collapsed');
        };
        changeNode = function (node) {
            node.classList.add('expanded');
            node.classList.remove('collapsed');
        };
    }

    for (var i = 0; i < this.myGroupNodes.length; ++i) {
        var node = this.myGroupNodes[i];
        if (wantNode(node)) {
            changeNode(node);
        }
    }
};

/**
 * Add the given nodes to the current selection
 * @param {Array.<Object>} nodes - nodes to add to the current selection
 */
Tree.prototype.addToSelection = function (nodes) {
    var tree = this;

    function addSingle(node) {
        var index = tree.mySelectedNodes.indexOf(node);
        if (index === -1) {
            tree.mySelectedNodes.push(node);
            return true;
        }
        return false;
    }

    var numNodes = nodes.length;
    for (var i = 0; i < numNodes; ++i) {
        var node = nodes[i];
        if (addSingle(node)) {
            this.addClass(node, 'selected');
        }
    }
};

/**
 * Remove the given nodes from the current selection
 * @param {Array.<Object>} nodes - The nodes to remove from the current selection
 */
Tree.prototype.removeFromSelection = function (nodes) {
    var tree = this;

    function removeSingle(node) {
        var index = tree.mySelectedNodes.indexOf(node);
        if (index !== -1) {
            tree.mySelectedNodes.splice(index, 1);
            return true;
        }
        return false;
    }

    for (var i = nodes.length - 1; i >= 0; --i) {
        var node = nodes[i];
        if (removeSingle(node)) {
            this.removeClass(node, 'selected');
        }
    }
};

/**
 * Set the current selection
 * @param {Array.<Object>} nodes - nodes to make currently selected
 */
Tree.prototype.setSelection = function (nodes) {
    this.removeFromSelection(this.mySelectedNodes);
    this.addToSelection(nodes);
    return this.mySelectedNodes;
};

/**
 * Clear the current selection
 */
Tree.prototype.clearSelection = function () {
    this.removeFromSelection(this.mySelectedNodes);
};

/**
 * Is the given node selected?
 * @nosideeffects
 * @param {Object} node - The tree node
 * @returns {boolean} - true if node is selected, false otherwise
 */
Tree.prototype.isSelected = function (node) {
    return this.hasClass(node, 'selected');
};

Tree.prototype.scrollTo = function (node) {
    var elem = this.getElementForNode(node);

    if (elem) {
        var total = elem.offsetTop;
        elem = elem.parentNode;
        while (elem && elem != this.myRootContainer) {
            total += elem.offsetTop;
            elem = elem.parentNode;
        }

        this.myRootContainer.parentNode.scrollTop = total;
    }
};


/**
 * Add a class to a node
 * @param {Number|Object} node - The tree node
 * @param {string} className
 * @returns {boolean} - true if the class was added, false otherwise
 */
Tree.prototype.addClass = function (node, className, recursive) {

    var elem = this.getElementForNode(node);
    if (elem) {

        if (recursive) {
            //It is intentional that the recursive add starts at the parent.
            elem = elem.parentNode;
            var top = this.myOptions.excludeRoot ? this.rootElem : this.myRootContainer;
            while (elem && elem !== top) {
                elem.classList.add(className);
                elem = elem.parentNode;
            }
        } else {
            elem.classList.add(className);
        }

        return true;
    }

    return false;
};

/**
 * Remove a class from a node
 * @param {Number|Object} node - The tree node or its dbId
 * @param {string} className
 * @returns {boolean} - true if the class was removed, false otherwise
 */
Tree.prototype.removeClass = function (node, className, recursive) {
    var elem = this.getElementForNode(node);
    if (elem) {

        if (recursive) {
            //It is intentional that the recursive add starts at the parent.
            elem = elem.parentNode;
            var top = this.myOptions.excludeRoot ? this.rootElem : this.myRootContainer;
            while (elem && elem !== top) {
                elem.classList.remove(className);
                elem = elem.parentNode;
            }
        } else {
            elem.classList.remove(className);
        }

        return true;
    }

    return false;
};

/**
 * Does the node have the given class?
 * @nosideeffects
 * @param {Number|Object} node - The node or its dbId
 * @param {string} className
 * @returns {boolean} true if the node has the given class, false otherwise
 */
Tree.prototype.hasClass = function (node, className) {
    return this.getElementForNode(node).classList.contains(className);
};


/**
 * Clears the contents of the tree
 */
Tree.prototype.clear = function () {

    var rootContainer = this.myRootContainer;
    while (rootContainer.hasChildNodes()) {
        rootContainer.removeChild(rootContainer.lastChild);
    }

    this.nodeToElement = {};
    this.nodeIdToNode = {};
};

/**
 * Given a node, create the corresponding HTML elements for the node and all of its descendants
 * @private
 * @param {Object} node - Node in the model Document
 * @param {HTMLElement} parentElement
 * @param {Object=} [options] - An optional dictionary of options.  Current parameters:
 *                              {boolean} [localize] - when true, localization is attempted for the given node; false by default.
 * @param {Number} [depth]
 */
Tree.prototype.createElement_ = function (node, parentElement, options, depth) {
    if (!node) {
        return null;
    }

    if (!this.myDelegate.shouldCreateTreeNode(node)) {
        return null;
    }

    var tree = this;
    var elem;

    function createElementForNode(parentElement, type, classes, theNode) {
        var root = tree.createHtmlElement_(parentElement, type, classes);
        var nodeId = tree.myDelegate.getTreeNodeId(theNode);
        root.setAttribute("lmv-nodeId", nodeId);

        var header = tree.createHtmlElement_(root, 'header');
        var icon = tree.createHtmlElement_(header, 'icon');

        icon.addEventListener('click', function (e) {
            tree.myDelegate.onTreeNodeIconClick(tree, node, e);
            e.stopPropagation();
            e.preventDefault();
        }, false);

        tree.myDelegate.createTreeNode(node, header, options);
        return root;
    }

    var nodeId = this.myDelegate.getTreeNodeId(node);

    if (tree.myDelegate.isTreeNodeGroup(node)) {
        elem = createElementForNode(parentElement, 'group', 'expanded', node);
        tree.nodeToElement[nodeId] = elem;
        tree.nodeIdToNode[nodeId] = node;

        var whichDepth = tree.myOptions.excludeRoot ? 1 : 0;

        if (depth == whichDepth)
            elem.style.left = "0px";

        // Remember this group node for use by setAllCollapsed().
        //
        tree.myGroupNodes.push(elem);

        tree.myDelegate.forEachChild(node, function(child) {
            tree.createElement_(child, elem, options, depth+1);
        });

    } else {
        elem = createElementForNode(parentElement, 'leaf', 'expanded', node);
        tree.nodeToElement[nodeId] = elem;
        tree.nodeIdToNode[nodeId] = node;

        var whichDepth = tree.myOptions.excludeRoot ? 1 : 0;

        if (depth == whichDepth)
            elem.style.marginLeft = "0px";
    }

    var c = tree.myDelegate.getTreeNodeClass(node);
    if (c) {
        elem.classList.add(c);
    }

    return elem;
};

Tree.prototype.setInputHandlers_ = function() {

    var tree = this;
    var rootElem = this.myRootContainer;

    var NODE_NOT_FOUND = null;
    var getNodeFromElement = function(eventTarget) {
        var ret = null;
        var found = false;
        do {
            if (!eventTarget || eventTarget === rootElem) {
                ret = null;
                found = true;  // not found
            } else if (eventTarget.hasAttribute("lmv-nodeId")) {
                ret = eventTarget;
                found = true;
            } else {
                eventTarget = eventTarget.parentElement;
            }
        } while(!found);

        if (ret) {
            var nodeId = ret.getAttribute("lmv-nodeId");
            return tree.nodeIdToNode[nodeId] || NODE_NOT_FOUND;
        }
        return NODE_NOT_FOUND;
    };

    if (isTouchDevice()) {
        this.hammer = new Hammer.Manager(rootElem, {
            recognizers: [
                [Hammer.Tap, {event: 'doubletap', taps: 2, interval: 400, threshold: 6, posThreshold: 30}],
                [Hammer.Press, { event: 'press', time: 500 } ]
            ],
            inputClass: Hammer.TouchInput
        });
        this.hammer.on("doubletap", function (event) {
            var node = getNodeFromElement(event.target);
            if (node === NODE_NOT_FOUND) return;
            tree.myDelegate.onTreeNodeDoubleClick(tree, node, event);
        });

        this.hammer.on('press', function (event) {
            var node = getNodeFromElement(event.target);
            if (node === NODE_NOT_FOUND) return;
            tree.myDelegate.onTreeNodeRightClick(tree, node, event);
        });
    }

    rootElem.addEventListener('click', function (event) {
        var node = getNodeFromElement(event.target);
        if (node === NODE_NOT_FOUND) return;
        tree.myDelegate.onTreeNodeClick(tree, node, event);
        event.stopPropagation();
        if(!event.target.classList.contains('propertyLink')) {
          event.preventDefault();
        }
    }, false);

    rootElem.addEventListener('dblclick', function (event) {
        var node = getNodeFromElement(event.target);
        if (node === NODE_NOT_FOUND) return;
        tree.myDelegate.onTreeNodeDoubleClick(tree, node, event);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    rootElem.addEventListener('contextmenu', function (event) {
        var node = getNodeFromElement(event.target);
        if (node === NODE_NOT_FOUND) return;
        tree.myDelegate.onTreeNodeRightClick(tree, node, event);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    rootElem.addEventListener('mouseover', function (event) {
        var node = getNodeFromElement(event.target);
        if (node === NODE_NOT_FOUND) return;
        tree.myDelegate.onTreeNodeHover(tree, node, event);
        event.stopPropagation();
        event.preventDefault();
    }, false);

    rootElem.addEventListener('mouseout', function (event) {
        // When the mouse leaves the element, set node to -1 (background), no highlight,
        var node = -1;
        tree.myDelegate.onTreeNodeHover(tree, node, event);
        event.stopPropagation();
        event.preventDefault();
    }, false);
};

/**
 * Create an HTML element
 * @private
 * @param {HTMLElement} parent - Parent element of the new HTML element
 * @param {string} tagName - New HTML element tag name
 * @param {string=} [className] - New HTML element class
 * @returns {HTMLElement} The newly-created HTML element
 */
Tree.prototype.createHtmlElement_ = function (parent, tagName, className) {
    var elem = document.createElement(tagName);
    parent.appendChild(elem);

    if (className) {
        elem.className = className;
    }

    return elem;
};

/**
 * Iterates through nodes in the tree in pre-order.
 * @param {Object|Number} node - node at which to start the iteration.
 * @param {function(Object, HTMLElement)} callback - callback function for each iterated node.
 */
Tree.prototype.iterate = function (node, callback) {
    if (node && this.myDelegate.shouldCreateTreeNode(node)) {
        var elem = this.getElementForNode(node);
        if (elem) {
            callback(node, elem);

            var scope = this;
            this.myDelegate.forEachChild(node, function(child) {
                scope.iterate(child, callback);
            });
        }
    }
};

// Alias Tree/TreeDelegate from Private namespace into UI namespace.
// This is temporary and should be removed eventually.
//
avp.TreeDelegate = avu.TreeDelegate = TreeDelegate;
avp.Tree = avu.Tree = Tree;

})();
;
(function() {

'use strict';

var BrowserDelegate = function ()
{
};

BrowserDelegate.prototype.constructor = BrowserDelegate;

BrowserDelegate.prototype.getNodeId = function(node)
{
    throw 'getId is not implemented.'
};

BrowserDelegate.prototype.getNodeLabel = function(node)
{
    return node.name;
};

BrowserDelegate.prototype.getNodeClass = function(node)
{
    return '';
};

BrowserDelegate.prototype.hasThumbnail = function(node)
{
    return false;
};

BrowserDelegate.prototype.getThumbnail = function(node)
{
    return null;
};

BrowserDelegate.prototype.onNodeClick = function(browser, node, event)
{
};

BrowserDelegate.prototype.onNodeHover = function(browser, node, event)
{
};

BrowserDelegate.prototype.selectItem = function(id)
{
};

BrowserDelegate.prototype.deselectItem = function(id)
{
};

BrowserDelegate.prototype.hasContent = function(node)
{
    return false;
};

BrowserDelegate.prototype.addContent = function(node, element)
{
};

var Browser = function ( delegate, items, parentContainerId )
{
    this.myDelegate = delegate;
    this.mySelectedIds = [];

    var prefix = 'browserview';
    this.myRootContainerId = parentContainerId + '-' + prefix;

    this.idToElement = {};

    this.myRootContainer = document.createElement("div");
    this.myRootContainer.id = this.myRootContainerId;
    this.myRootContainer.classList.add(prefix);

    var parent = document.getElementById(parentContainerId);
    parent.appendChild(this.myRootContainer);

    this.createElements(items, this.myRootContainer);
};

Browser.prototype.constructor = Browser;

Browser.prototype.show = function(show)
{
    if (show) {
        this.myRootContainer.classList.remove("browserHidden");
        this.myRootContainer.classList.add("browserVisible");
        this.myRootContainer.style.display = "block";
    } else {
        this.myRootContainer.classList.remove("browserVisible");
        this.myRootContainer.classList.add("browserHidden");
        this.myRootContainer.style.display = "none";
    }
};

Browser.prototype.getRootContainer = function()
{
    return this.myRootContainer;
};

Browser.prototype.delegate = function()
{
    return this.myDelegate;
};

Browser.prototype.addToSelection = function(ids)
{
    var browser = this;
    function addSingle(id)
    {
        var index = browser.mySelectedIds.indexOf(id);
        if(index==-1)
        {
            browser.mySelectedIds.push(id);
            return true;
        }
        return false;
    }

    for (var i = 0, len = ids.length; i < len; ++i) {
        var id = ids[i];
        if(addSingle(id)) {
            var item = browser.idToElement[id];
            if (item === undefined) {
                // Maybe the delegate knows what to do with it.
                browser.myDelegate.selectItem(id);
            } else {
                item.classList.add("selected");
            }
        }
    }
};

Browser.prototype.removeFromSelection = function(ids)
{
    var browser = this;
    function removeSingle(id)
    {
        var index = browser.mySelectedIds.indexOf(id);
        if(index!=-1)
        {
            browser.mySelectedIds.splice(index, 1);
            return true;
        }
        return false;
    }

    for (var i = ids.length - 1; i >= 0; --i) {
        var id = ids[i];
        if (removeSingle(id)) {
            var item = this.idToElement[id];
            if (item === undefined) {
                // Maybe the delegate knows what to do with it.
                browser.myDelegate.deselectItem(id);
            } else {
                item.classList.remove("selected");
            }
        }
    }
};

Browser.prototype.setSelection = function(ids)
{
    this.removeFromSelection(this.mySelectedIds);
    this.addToSelection(ids);
    return this.mySelectedIds;
};

Browser.prototype.clearSelection = function()
{
    this.removeFromSelection(this.mySelectedIds);
};

Browser.prototype.createElements = function(items, container)
{
    if (!items)
        return;

    var browser = this;
    for(var nodeIndex = 0; nodeIndex<items.length; nodeIndex++)
    {
        var node = items[nodeIndex];
        browser.createElement( node, container );
    }
};

Browser.prototype.createElement = function( browserNode, container )
{
    var browser = this;

    var id = browser.myDelegate.getNodeId(browserNode);

    var item = document.createElement("item");
    container.appendChild(item);
    this.idToElement[id] = item;

    item.onmouseover = function()
                        {
                            browser.myDelegate.onNodeHover(browser, browserNode);
                        };
    item.onclick = function (e) {
                            browser.myRootContainer.querySelector(".flipped").removeClass("flipped");
                            browser.myDelegate.onNodeClick(browser, browserNode, e);
                        };


	var card = document.createElement("div");
    card.classList.add("card");
    item.appendChild(card);

    var elemWrapper = document.createElement("div");
    elemWrapper.classList.add("browserElement");
    card.appendChild(elemWrapper);

    var label = browser.myDelegate.getNodeLabel(browserNode);
    var labelElem = document.createElement("label");
    labelElem.innerHTML = label;
    elemWrapper.appendChild(labelElem);
    labelElem.onclick = function(e) {
        browser.myDelegate.onNodeClick(browser, browserNode, e);
    };

    var thumbnailUrl = browser.myDelegate.getThumbnail(browserNode);
    if (thumbnailUrl)
    {
        var thumbElem = document.createElement("img");
        thumbElem.classList.add("thumb");
        if (av.isAuthorizationHeaderSet()) {
            // Code path for when cookies are disabled
            av.Document.requestThumbnailWithSecurity(thumbnailUrl, function onThumbnailSuccess(err, response){
                if (err) {
                    stderr("Failed to load thumbnail: " + thumbnailUrl);
                    return;
                }
                thumbElem.src = window.URL.createObjectURL(response);
                thumbElem.onload = function () {
                    window.URL.revokeObjectURL(thumbElem.src);
                };
            });
        } else {
            // Code path for when cookies are enabled
            thumbElem.src = thumbnailUrl;
        }
        elemWrapper.appendChild(thumbElem);
        thumbElem.onclick = function(e) {
            browser.myDelegate.onNodeClick(browser, browserNode, e);
        };
    }

    if (browser.myDelegate.hasContent( browserNode )) {
        browser.myDelegate.addContent( browserNode, card );
    }

    item.classList.add(browser.myDelegate.getNodeClass(browserNode));
};


Autodesk.Viewing.Private.BrowserDelegate = BrowserDelegate;
Autodesk.Viewing.Private.Browser = Browser;

})();;AutodeskNamespace('Autodesk.Viewing.Private');

(function() {

var avp = Autodesk.Viewing.Private;

avp.WEBGL_HELP_LINK = null;

avp.ErrorInfoData = {
    // UNKNOWN FAILURE
    1:   { 'img'             : "img-reload",                  // "icons/error_reload_in_viewer.png",
           'globalized-msg'  : "Viewer-UnknownFailure",
           'default-msg'     : "<title> Sorry </title>" +
                               "<message>We seem to have some technical difficulties and couldn't complete your request.</message> " +
                                    "<hint>Try loading the item again. </hint>" +
                                    "<hint>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    },

    // BAD DATA
    2:   { 'img'             : "img-unsupported",             // "icons/error_unsupported_file_type.png",
           'globalized-msg'  : "Viewer-BadData",
           'default-msg'     : "<title> Sorry </title>" +
                               "<message>The item you are trying to view was not processed completely. </message>" +
                                     "<hint>Try loading the item again.</hint>" +
                                     "<hint>Please upload the file again to see if that fixes the issue.</hint>"
    },

    // NETWORK ERROR
    3:  { 'img'             : "img-reload",                   // "icons/error_reload_in_viewer.png",
          'globalized-msg'  : "Viewer-NetworkError",
          'default-msg'     : "<title> Sorry </title>" +
                              "<message>We seem to have some technical difficulties and couldn't complete your request.</message>" +
                                    "<hint> Try loading the item again.</hint>" +
                                    "<hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    },

    // NETWORK_ACCESS_DENIED
    4: { 'img'             : "img-unloack",                   // "icons/error_unlock_upload.png",
         'globalized-msg'  : "Viewer-AccessDenied",
         'default-msg'     : "<title> No access </title>" +
                             "<message>Sorry. You don’t have the required privileges to access this item.</message>" +
                                    "<hint> Please contact the author</hint>"
    },

    // NETWORK_FILE_NOT_FOUND
    5: { 'img'             : "img-item-not-found",            //"icons/error_item_not_found.png",
         'globalized-msg'  : "Viewer-FileNotFound",
         'default-msg'     : "<title> Sorry </title>" +
                             "<message>We can’t display the item you are looking for. It may not have been processed yet. It may have been moved, deleted, or you may be using a corrupt file or unsupported file format.</message>" +
                                "<hint> Try loading the item again.</hint>" +
                                "<hint> Please upload the file again to see if that fixes the issue.</hint>" +
                                '<hint> <a href="http://help.autodesk.com/view/ADSK360/ENU/?guid=GUID-488804D0-B0B0-4413-8741-4F5EE0FACC4A" target="_blank">See a list of supported formats.</a></hint>'
    },

    // NETWORK_SERVER_ERROR
    6: { 'img'             : "img-reload",                    // "icons/error_reload_in_viewer.png",
         'globalized-msg'  : "Viewer-ServerError",
         'default-msg'     : "<title> Sorry </title>" +
                             "<message>We seem to have some technical difficulties and couldn't complete your request.</message>" +
                                    "<hint> Try loading the item again.</hint>" +
                                    "<hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    },


    // NETWORK_UNHANDLED_RESPONSE_CODE
    7: { 'img'             : "img-reload",                    // "icons/error_reload_in_viewer.png",
         'globalized-msg'  : "Viewer-UnhandledResponseCode",
         'default-msg'     : "<title> Network problem </title>" +
                             "<message>Sorry. We seem to have some technical difficulties and couldn't complete your request.</message>" +
                                "<hint> Try loading the item again.</hint>" +
                                "<hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    },

    // BROWSER_WEBGL_NOT_SUPPORTED
    8: { 'img'             : "img-unsupported",               // "icons/error_unsupported_file_type.png",
         'globalized-msg'  : "Viewer-WebGlNotSupported",
         'default-msg'     : "<title>Sorry</title><message>We can't show this item because this browser doesn't support WebGL.</message><hint>Try Google Chrome, Mozilla Firefox, or another browser that supports WebGL 3D graphics.</hint><hint>For more information, see the <a href=\"WEBGL_HELP\" target=\"_blank\">A360 browser reqirements.</a></hint>"
    },

    // BAD_DATA_NO_VIEWABLE_CONTENT
    9: { 'img'             : "img-item-not-found",            // "icons/error_item_not_found.png",
         'globalized-msg'  : "Viewer-NoViewable",
         'default-msg'     : "<title> No viewable content </title>" +
                             "<message>There’s nothing to display for this item. It may not have been processed or it may not have content we can display.</message>" +
                                    "<hint> Please contact the author.</hint>" +
                                    "<hint> Please upload the file again to see if that fixes the issue.</hint>"
    },

    // BROWSER_WEBGL_DISABLED
    10: { 'img'             : "img-unsupported",              // "icons/error_unsupported_file_type.png",
          'globalized-msg'  : "Viewer-WebGlDisabled",
          'default-msg'     : "<title>Sorry</title><message>We can't show this item because WebGL is disabled on this device.</message><hint> For more information see the <a href=\"WEBGL_HELP\" target=\"_blank\">A360 Help.</a></hint>"
    },

    // RTC_ERROR
    11: { 'img'             : "img-unsupported",              // "icons/error_unsupported_file_type.png",
          'globalized-msg'  : "Viewer-RTCError",
          'default-msg'     : "<title> Sorry </title>" +
                              "<message>We couldn’t connect to the Collaboration server.</message>" +
                              "<hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    }
};

avp.currentError  = null;
avp.currentErrors = null;

avp.ErrorHandler = function()
{
};

avp.ErrorHandler.prototype.constructor = avp.ErrorHandler;

avp.ErrorHandler.getErrorCode = function( networkStatus )
{
    if ( (networkStatus === 403) || ( networkStatus === 401) )
    {
        return Autodesk.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED;
    }
    else if (networkStatus === 404 )
    {
        return Autodesk.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND;
    }
    else if (networkStatus >= 500 )
    {
        return Autodesk.Viewing.ErrorCodes.NETWORK_SERVER_ERROR;
    }
    return Autodesk.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE;
};

avp.ErrorHandler.reportError = function( container, errorCode, errorMsg, statusCode, statusText, errorType )
{
    avp.ErrorHandler.currentError  = null;
    avp.ErrorHandler.currentErrors = null;

    // If there is no errorCode, just return (otherwise an empty alert box is being shown)
    if (!errorCode)
        return;
        
    if (avp.logger) {
        var errorLog = {
            category: "error",
            code: errorCode,
            message: errorMsg,
            httpStatusCode: statusCode,
            httpStatusText: statusText
        };
        avp.logger.log(errorLog, true);
    }

    avp.ErrorHandler.currentError = [container, errorCode, errorMsg, errorType];

    var errorInfo = avp.ErrorInfoData[errorCode];
    if (errorInfo)
    {
        var options = {
            "defaultValue" : ""
        };

        options.defaultValue = errorInfo['default-msg'];
        var imgClass = errorInfo["img"];
        var errorGlobalizedMsg = errorInfo['globalized-msg'];

        var error = this.parseErrorString( errorGlobalizedMsg, options );

        if (errorCode === Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_DISABLED ||
            errorCode === Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED)
        {
            var WEBGL_HELP_LINK = avp.WEBGL_HELP_LINK || "http://www.autodesk.com/a360-browsers";

            for (var i = 0; i < error.hints.length; i++) {
                var index = error.hints[i].indexOf('href="WEBGL_HELP"');
                if (index !== -1) {
                    error.hints[i] = error.hints[i].replace('href="WEBGL_HELP"', 'href="' + WEBGL_HELP_LINK + '"');
                }
            }
        }

        avp.AlertBox.displayError( container, error.msg, error.header, imgClass, error.hints );
    }
    else
    {
        var imgClass = "img-unsupported"; // "icons/error_unsupported_file_type.png";

        var options = {
            "defaultValue"          : "",
            "interpolationPrefix"   : "{",
            "interpolationSuffix"   : "}"
        };

        this.parseArguments( errorMsg, options );
        var error = this.parseErrorString( errorCode, options );

        if (!error.header)
            error.header = (errorType === "warning") ? Autodesk.Viewing.i18n.translate( "header-warning" ) : "";
        avp.AlertBox.displayError( container, error.msg, error.header, imgClass, error.hints );
    }
};

avp.ErrorHandler.reportErrors = function( container, errors )
{
    avp.ErrorHandler.currentError  = null;
    avp.ErrorHandler.currentErrors = null;

    if (!errors)
        return;

    avp.ErrorHandler.currentErrors = [container, errors];

    var options = {
        "defaultValue"          : "",
        "interpolationPrefix"   : "{",
        "interpolationSuffix"   : "}"
    };

    var formattedErrors = [];
    for (var i=0; i<errors.length; i++) {
        if (!errors[i].code)
            continue;

        this.parseArguments( errors[i].message, options );

        var error = this.parseErrorString( errors[i].code, options );
        if (!error.header)
            error.header = (errors[0].type === "warning") ? Autodesk.Viewing.i18n.translate( "header-warning", {"defaultValue" : "Warning"} ) : "";

        formattedErrors.push( error );
        
        if (avp.logger) {
            var errorLog = {
                category: "error",
                code: errors[i].code,
                message: errors[i].message
            };
            avp.logger.log(errorLog, true);
        }
    }

    if (!formattedErrors.length)
        return;

    // Default image.
    var imgClass = "img-unsupported"; // "icons/error_unsupported_file_type.png";

    avp.AlertBox.displayErrors( container, imgClass, formattedErrors );
};

avp.ErrorHandler.parseArguments = function( errorMsg, options )
{
    if (!errorMsg)
        return;

    // Add arguments
    if (typeof(errorMsg) === "string" ) {
        options.defaultValue = errorMsg;
    }
    else {
        // If there is an array, then there are arguments in the string.
        // Add them to the options (arguments are named: 0, 1, 2, ...
        options.defaultValue = errorMsg[0];
        for (var i=1; i<errorMsg.length; i++) {
            var arg = i-1;
            var argName = arg.toString();
            options[argName] = errorMsg[i];
        }
    }
};

avp.ErrorHandler.parseErrorString = function( errorCode, options )
{
    var error = {
        "msg"     : null,
        "msgList" : null,
        "header"  : null,
        "hints"   : null
    };

    if (!errorCode)
        return error;

    // Translate the message.
    var msg = Autodesk.Viewing.i18n.translate( errorCode, options );
    if (!msg)
        return error;

    // Split into header, message and hints. The messages may have the following format
    //   <title>header</title>text of the error message. <hint> hint-1 <hint> hint-2 ... <hint> hint-n
    //
    
    // Get the header
    if (msg.indexOf("<title>") != -1) {
        var parts = msg.split("<title>")[1].split("</title>");
        error.header = parts[0];
        msg = parts[1];
    }

    // Extract the message last.
    if (msg && msg.indexOf("<message>") != -1) {
        var parts = msg.split("<message>")[1].split("</message>");
        error.msg = parts[0];
        msg = parts[1];
    }
    else  {
        error.msg = msg;
    }

    // Extract the hints next.
    if (msg && msg.indexOf("<hint>") != -1) {
        // There are hints.
        error.hints = [];
        var hints = msg.split("<hint>");
        for (var h=0; h<hints.length; h++) {
            var hint = hints[h].split("</hint")[0];
            error.hints.push(hint);
        }
    }

    return error;
};

avp.ErrorHandler.localize = function()
{
    if (avp.AlertBox.instances.length > 0) {
        avp.AlertBox.dismiss();

        if (avp.ErrorHandler.currentError) {
            var container = avp.ErrorHandler.currentError.shift();
            var error = avp.ErrorHandler.currentError;
            avp.ErrorHandler.reportError(container, error[0], error[1], error[2]);
        } else {
            var container = avp.ErrorHandler.currentErrors.shift();
            var errors = avp.ErrorHandler.currentErrors[0];
            avp.ErrorHandler.reportErrors(container, errors);
        }
    }
};

})();;
(function() {

"use strict";

/**
 * An Extension is a way to configure add functionality to the viewer.  Derive from this
 * class and implement the load and optionally the unload methods.
 *
 * Register this extension by calling:
 * `Autodesk.Viewing.theExtensionManager.registerExtension('your_extension_id', Autodesk.Viewing.Extensions.<your_extension_class>); `
 *
 * Extensions are registered and loaded automatically by adding the Extension ID to the
 * config object passed to the viewer constructor.
 *
 * An example Extension is available at viewingservice/v1/viewers/SampleExtension/, and includes
 * these files:
 * * SampleExtension.js
 * * SampleLayersPanel.js
 * * SampleModelStructurePanel.js
 * * SamplePropertyPanel.js
 * * SampleLayersPanel.css
 * * SampleModelStructurePanel.css
 * * SamplePropertyPanel.css
 * 
 * @alias Autodesk.Viewing.Extension
 * @param {Viewer} viewer - the viewer to be extended.
 * @param {Object} options - An optional dictionary of options for this extension.
 * @constructor
 */
var Extension = function (viewer, options) {
    this.viewer = viewer;
    this.options = options;
};

/**
 * Override the load method to add functionality to the viewer.  Use the Viewer's APIs
 * to add/modify/replace/delete UI, register event listeners, etc.
 *
 * @returns {boolean} - True if the load was successful.
 */
Extension.prototype.load = function () {
    return true;
};

/**
 * Override the unload method to perform some cleanup of operations that were done
 * in load.
 *
 * @returns {boolean} - True if the unload was successful.
 */
Extension.prototype.unload = function () {
    return true;
};

/**
 * Gets the extension state as a plain object. Intended to be called when viewer state is requested.
 *
 * @param {Object} viewerState - Object to inject extension values.
 *
 * @virtual
 */
Extension.prototype.getState = function( viewerState ) {
};

/**
 * Restores the extension state from a given object.
 *
 * @param {Object} viewerState
 * @param {boolean} [immediate] - Whether the new view is applied with (true) or without transition (false)
 *
 * @returns {boolean} true if restore operation was successful.
 *
 * @virtual
 */
Extension.prototype.restoreState = function (viewerState, immediate) {
    return true;
};

Autodesk.Viewing.Extension = Extension;

})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;


/**
 * The ExtensionManager manages a set of extensions available to the viewer.
 * Register, retrieve, and unregister your extension using the singleton theExtensionManager.
 *
 * You can load/unload your registered extension into a Viewer by calling
 * {@link Autodesk.Viewing.Viewer#loadExtension|viewer.loadExtension(id, options)} and
 * {@link Autodesk.Viewing.Viewer#unloadExtension|viewer.unloadExtension(id)}, respectively.
 * @constructor
 */
var ExtensionManager = function () {
    var extensions = {};

    /**
     * Registers a new extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @param {Extension} extension - The Extension-derived class representing the extension.
     * @returns {boolean} - True if the extension was successfully registered.
     */
    function registerExtension(extensionId, extension) {
        if (!extensions.hasOwnProperty(extensionId)) {
            extensions[extensionId] = extension;
            return true;
        }
        return false;
    }

    /**
     * Returns the class representing the extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {!Extension} - The Extension-derived class if one was registered; null otherwise.
     */
    function getExtension(extensionId) {
        if (extensions.hasOwnProperty(extensionId)) {
            return extensions[extensionId];
        }
        return null;
    }

    /**
     * Unregisters an existing extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {boolean} - True if the extension was successfully unregistered.
     */
    function unregisterExtension(extensionId) {
        if (extensions.hasOwnProperty(extensionId)) {
            delete extensions[extensionId];
            return true;
        }
        return false;
    }

    return {
        registerExtension: registerExtension,
        getExtension: getExtension,
        unregisterExtension: unregisterExtension
    };
};

var theExtensionManager =  new ExtensionManager();

/***
 * Augments a class by extension load/unload functionality.
 */
var ExtensionMixin = function() {};

ExtensionMixin.prototype = {

    /**
     * Loads the extension with the given id and options.
     * For internal use only.
     *
     * @param {string} extensionId - The string id of the extension.
     * @param {Object} options - An optional dictionary of options.
     *
     * @returns {boolean} - True if the extension was successfully loaded.
     */
    loadExtension : function (extensionId, options) {
        
        if (!this.loadedExtensions)
            this.loadedExtensions = {};
    
        var success = false;
        if (!this.getExtension(extensionId)) {
            var extensionClass = theExtensionManager.getExtension(extensionId);
            if (extensionClass) {
                var extension = new extensionClass(this, options);
                success = extension.load();
                if (success) {
                    this.loadedExtensions[extensionId] = extension;
                    stderr('Extension loaded: ' + extensionId);
                }
            } else {
                stderr('Extension not found: ' + extensionId);
            }
        } else {
            stderr('Extension already loaded: ' + extensionId);
        }
        return success;
    },
    
    /**
     * Returns the loaded extension.
     * @param {string} extensionId - The string id of the extension.
     * @returns {?Object} - Extension.
     */
    getExtension : function (extensionId) {
        return (this.loadedExtensions && extensionId in this.loadedExtensions) ? this.loadedExtensions[extensionId] : null;
    },

    /**
     * Unloads the extension with the given id.
     * For internal use only.
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {boolean} - True if the extension was successfully unloaded.
     */
    unloadExtension : function (extensionId) {
        var success = false;
        var ext = this.getExtension(extensionId);
        if (ext) {
            success = ext.unload();
            stderr('Extension unloaded: ' + extensionId);
            delete this.loadedExtensions[extensionId];
        } else {
            stderr('Extension not found: ' + extensionId);
        }
        return success;
    },


    apply : function(object) {
    
        var me = ExtensionMixin.prototype;
    
        object.loadExtension = me.loadExtension;
        object.getExtension = me.getExtension;
        object.unloadExtension = me.unloadExtension;
    }

};


Autodesk.Viewing.theExtensionManager = theExtensionManager;
Autodesk.Viewing.ExtensionMixin = ExtensionMixin;

})();;
(function() {
	'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

avp.init_UnifiedCamera = function(THREE) {

if (typeof av.UnifiedCamera !== "undefined")
    return;

var UnifiedCamera = function ( clientWidth, clientHeight)
{
    THREE.Camera.call( this );

    this.fov = 45;
    this.near = 0.1;
    this.far = 100000;
    this.aspect = clientWidth / clientHeight;

    this.left = -clientWidth / 2;
    this.right = clientWidth / 2;
    this.top = clientHeight / 2;
    this.bottom = -clientHeight / 2;
    this.clientWidth = clientWidth;
    this.clientHeight = clientHeight;

    this.target  = new THREE.Vector3(0, 0, -1);
    this.worldup = new THREE.Vector3(0, 1, 0);

    this.orthographicCamera = new THREE.OrthographicCamera( this.left, this.right, this.top, this.bottom,  this.near, this.far );
    this.perspectiveCamera = new THREE.PerspectiveCamera( this.fov, this.aspect, this.near, this.far);

    this.zoom = 1;

    this.toPerspective();
};

//Constant FOV used to make math right for Ortho cameras.
UnifiedCamera.ORTHO_FOV = (2 * Math.atan(0.5)) * 180.0 / Math.PI;

UnifiedCamera.prototype = Object.create( THREE.Camera.prototype );

UnifiedCamera.prototype.clone = function ()
{
	var camera = new UnifiedCamera(this.right * 2.0, this.top * 2.0);

	THREE.Camera.prototype.clone.call( this, camera );

    camera.position.copy(this.position);
    camera.up.copy(this.up);
    if( this.target )
        camera.target = this.target.clone();
    if( this.worldup )
        camera.worldup = this.worldup.clone();
    if( this.worldUpTransform )
        camera.worldUpTransform = this.worldUpTransform.clone();

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;

	camera.near = this.near;
	camera.far = this.far;
    camera.fov = this.fov;
    camera.aspect = this.aspect;
    camera.zoom = this.zoom;

    camera.isPerspective = this.isPerspective;

    this.updateProjectionMatrix();

	return camera;
};

UnifiedCamera.prototype.__computeFovPosition = function(fov)
{
    if( Math.abs(this.fov - fov)  <= 0.0001 )
        return this.position.clone();

    var eye = this.target.clone().sub( this.position );

    var oldFOV = THREE.Math.degToRad(this.fov);
    var newFOV = THREE.Math.degToRad(fov);

    var distance = eye.length() * Math.tan(oldFOV * 0.5) / Math.tan(newFOV * 0.5);
    var offset = eye.normalize().multiplyScalar( -distance );

    return this.target.clone().add(offset);
};

UnifiedCamera.prototype.toPerspective = function()
{
    // Switches to the Perspective Camera

    if( !this.isPerspective && this.saveFov ) {
        this.position.copy(this.__computeFovPosition(this.saveFov));
        this.fov = this.saveFov;
    }

    this.perspectiveCamera.aspect = this.aspect;
    this.perspectiveCamera.near = this.near;
    this.perspectiveCamera.far = this.far;

    this.perspectiveCamera.fov = this.fov / this.zoom ;
    this.perspectiveCamera.updateProjectionMatrix();

    this.projectionMatrix = this.perspectiveCamera.projectionMatrix;

    this.isPerspective = true;
};

UnifiedCamera.prototype.toOrthographic = function()
{
    if( this.isPerspective ) {
        this.saveFov = this.fov;
        var newFov = UnifiedCamera.ORTHO_FOV;
        this.position.copy(this.__computeFovPosition(newFov));
        this.fov = newFov;
    }

    this.orthoScale = this.target.clone().sub(this.position).length();

    var halfHeight = this.orthoScale * 0.5;
    var halfWidth = halfHeight * this.aspect;

    this.left   = this.orthographicCamera.left   = -halfWidth;
    this.right  = this.orthographicCamera.right  =  halfWidth;
    this.top    = this.orthographicCamera.top    =  halfHeight;
    this.bottom = this.orthographicCamera.bottom = -halfHeight;

    this.orthographicCamera.near = this.near;
    this.orthographicCamera.far = this.far;

    this.orthographicCamera.updateProjectionMatrix();

    this.projectionMatrix = this.orthographicCamera.projectionMatrix;

    this.isPerspective = false;
};

UnifiedCamera.prototype.updateProjectionMatrix = function()
{
    if ( this.isPerspective ) {
        this.toPerspective();
    } else {
        this.toOrthographic();
    }
};

UnifiedCamera.prototype.setSize = function( width, height )
{
    this.aspect = width / height;
    this.left = -width / 2;
    this.right = width / 2;
    this.top = height / 2;
    this.bottom = -height / 2;

};


UnifiedCamera.prototype.setFov = function( fov )
{
    this.fov = fov;
    this.updateProjectionMatrix();
};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
UnifiedCamera.prototype.setLens = function ( focalLength, frameHeight )
{
    if ( frameHeight === undefined ) frameHeight = 24;

    var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

    this.setFov( fov );

    return fov;
};


UnifiedCamera.prototype.getCameraChangedEvent = function() {
    return {type: av.CAMERA_CHANGE_EVENT, camera: this};
};

av.UnifiedCamera = UnifiedCamera;

}

})();;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

    // Event types supported by this class.

    av.ESCAPE_EVENT                   = 'escape';
    av.PROGRESS_UPDATE_EVENT          = 'progress';
    av.FULLSCREEN_MODE_EVENT          = 'fullScreenMode';
    av.NAVIGATION_MODE_CHANGED_EVENT  = 'navmode';
    av.VIEWER_STATE_RESTORED_EVENT    = 'viewerStateRestored';
    av.VIEWER_RESIZE_EVENT            = 'viewerResize';
    av.VIEWER_UNINITIALIZED           = 'viewerUninitialized';

    av.MODEL_ROOT_LOADED_EVENT        = 'svfLoaded';
    av.GEOMETRY_LOADED_EVENT          = 'geometryLoaded';
    av.OBJECT_TREE_CREATED_EVENT      = 'propertyDbLoaded';
    av.OBJECT_TREE_UNAVAILABLE_EVENT  = 'propertyDbUnavailable';
    av.MODEL_UNLOADED_EVENT           = 'modelUnloaded';


    av.SELECTION_CHANGED_EVENT     = 'selection';
    av.AGGREGATE_SELECTION_CHANGED_EVENT = 'aggregateSelection';
    av.ISOLATE_EVENT               = 'isolate';
    av.HIDE_EVENT                  = 'hide';
    av.SHOW_EVENT                  = 'show';

    av.CAMERA_CHANGE_EVENT         = 'cameraChanged';
    av.EXPLODE_CHANGE_EVENT        = 'explodeChanged';
    av.CUTPLANES_CHANGE_EVENT      = 'cutplanesChanged';
    av.TOOL_CHANGE_EVENT           = 'toolChanged';
    av.RENDER_OPTION_CHANGED_EVENT = 'renderOptionChanged';
    av.LAYER_VISIBILITY_CHANGED_EVENT  = 'layerVisibility';
    av.RESET_EVENT                    = 'reset';

    av.ANIMATION_READY_EVENT = 'animationReady';

    /**
     * Navigation Mode constants.
     *
     * These constants are used to define the Navigation MODE.
     *
     * @enum {number}
     * @readonly
     * @deprecated
     */
    av.NAVIGATION_MODE = {
        ORBIT:  0,
        PAN:    1,
        DOLLY:  2,
        ROLL:   3,
        FOV:    4,
        TOUCH_PAN_DOLLY: 5,
        TOUCH_ROLL:      6,
        OTHER:           7
    };


    var isMobile = av.isMobileDevice();

    av.DefaultSettings = {
        "ambientShadows": true,
        "antialiasing": !isMobile,
        "groundShadow": true,
        "groundReflection": false,
        "progressiveRendering": true,
        "environmentMap": false,
        "openPropertiesOnSelect": false,
        "ghosting": true,
        "viewCube": !isMobile,
        "lineRendering": true,
        "lightPreset": avp.DefaultLightPreset,
        "backgroundColorPreset": null,
        "reverseMouseZoomDir": false,
        "reverseHorizontalLookDirection": false,
        "reverseVerticalLookDirection": false,
        "alwaysUsePivot": false,
        "zoomTowardsPivot": false,
        "orbitPastWorldPoles": true,
        "leftHandedMouseSetup": false,
        "clickToSetCOI": false,
        "optimizeNavigation": isMobile,
        "fusionOrbit": true,
        "fusionOrbitConstrained": true,
        "useFirstPersonNavigation" : true, // Replaces the "Walk" tool with the "First Person" tool
        "envMapBackground" : false,
        "renderPrism" : true,
        "firstPersonToolPopup" : true
    };



    /**
     *  This is the base class for all viewer implementations. It contains everything that is needed
     *  to connect to the Autodesk viewing service and display 3D models. It also includes
     *  basic navgiation support, and context menu and extension APIs.
     *
     *  @constructor
     *  @param {HTMLElement} container - The viewer container.
     *  @param {object} config - The initial settings object.
     *  @param {boolean} [config.startOnInitialize=true] - Set this to false if you want to defer the run to a later time
     *                                                     by calling run() explicitly.
     *
     *  @property {av.Navigation} navigation - The Navigation api object.
     *  @property {av.ToolController} toolController - The ToolController object.
     *  @property {av.ViewingUtilities} utilities - The ViewingUtilities object.
	 *  @alias Autodesk.Viewing.Viewer3D
     */
    var Viewer3D = function(container, config)
    {
        if (container) {
            this.clientContainer = container;
            this.container = document.createElement("div");
            this.container.className = "adsk-viewing-viewer";
            this.container.style.height = "100%";
            this.container.style.width = "100%";
            this.container.style.overflow = "hidden";

            this.container.classList.add( isTouchDevice() ? "touch" : "notouch");

            this.clientContainer.appendChild(this.container);

            this.config = config;


            this.contextMenu = null;
            this.contextMenuCallbacks = {};
            this.__firefoxLMBfix = false;
            this.started = false;


            // Create the canvas if it doesn't already exist
            if ( this.container.nodeName === "CANVAS") {
                throw 'Viewer must be initialized on a div [temporary]';
            }
            else
            {
                this.canvasWrap = document.createElement("div");
                this.canvasWrap.classList.add("canvas-wrap");

                this.canvas = document.createElement("canvas");
                this.canvas.tabIndex = 0;

                this.canvasWrap.appendChild(this.canvas);
                this.container.appendChild(this.canvasWrap);
            }

            this.canvas.viewer = this; //store a pointer to the viewer in the canvas

            // Preferences. Prefix is a bit odd, but a legacy result after refactoring.
            //
            this.prefs = new avp.Preferences(this, 'Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.');

        }

        this.running = false;
        this._pushedTool = '';
        this._defaultNavigationTool = '';

    };

    Viewer3D.prototype.constructor = Viewer3D;

    av.EventDispatcher.prototype.apply( Viewer3D.prototype );
    av.ScreenModeMixin.prototype.apply( Viewer3D.prototype );
    av.ExtensionMixin.prototype.apply( Viewer3D.prototype );


    /** @deprecated Use av.ScreenMode instead */
    Viewer3D.ScreenMode = av.ScreenMode;

    /**
     * Default (and supported) values for how the viewer canvas will respond to click interaction.
     * If also provides a location to disable certain canvas features, such as:
     * "disableSpinner", "disableMouseWheel" and "disableTwoFingerSwipe".
     *
     * Refer to setCanvasClickBehavior() for additional info.
     *
     */
    Viewer3D.kDefaultCanvasConfig = {
        "click": {
            "onObject": ["selectOnly"],
            "offObject": ["deselectAll"]
        },
        "clickAlt": {
            "onObject": ["setCOI"],
            "offObject": ["setCOI"]
        },
        "clickCtrl": {
            "onObject": ["selectToggle"],
            "offObject": ["deselectAll"]
        },
        "clickShift": {
            "onObject": ["selectToggle"],
            "offObject": ["deselectAll"]
        },

        // Features that support disabling
        "disableSpinner": false,
        "disableMouseWheel": false,
        "disableTwoFingerSwipe": false
    };


    /**
     * Initializes the viewer and loads any extensions specified in the constructor's
     * config parameter.
     *
     * @returns {int} - 0 if the viewer has started, an error code (same as that returned by initialize()) otherwise.
     */
    Viewer3D.prototype.start = function () {
        if (this.started) {
            return 0;
        }

        // Initialize
        var result = this.initialize();

        if (result === 0) {
            this.started = true;

            // Load the extensions specified in the config.
            //
            if (this.config && this.config.hasOwnProperty('extensions')) {
                var extensions = this.config.extensions;
                for (var i = 0; i < extensions.length; ++i) {
                    this.loadExtension(extensions[i], this.config);
                }
            }
        }
        return result;
    };



    Viewer3D.prototype.registerUniversalHotkeys = function()
    {
        var self = this;

        var onPress;
        var onRelease;
        var previousTool;
        var keys = av.theHotkeyManager.KEYCODES;

        // Add Fit to view hotkey
        onPress = function() {
            self.navigation.setRequestFitToView(true);
            return true;
        };
        av.theHotkeyManager.pushHotkeys("Autodesk.FitToView", [
            {
                keycodes: [keys.f],
                onPress: onPress
            }
        ]);

        // Add home hotkey
        onPress = function() {
            self.navigation.setRequestHomeView(true);
            return true;
        };
        av.theHotkeyManager.pushHotkeys("Autodesk.Home", [
            {
                keycodes: [keys.h],
                onPress: onPress
            },
            {
                keycodes: [keys.HOME],
                onPress: onPress
            }
        ]);

        // Escape
        onRelease = function() {
            // handle internal GUI components before firing the event to the client
            if (self.objectContextMenu && self.objectContextMenu.hide()) {
                return true;
            }

            // TODO: Could this all be unified somehow? If event listeners had priorities,
            //       we could intersperse listeners from the client and the viewer, which
            //       I think will eventually be required.

            self.fireEvent({ type: av.ESCAPE_EVENT });
            return true;
        };

        av.theHotkeyManager.pushHotkeys("Autodesk.Escape", [
            {
                keycodes: [keys.ESCAPE],
                onRelease: onRelease
            }
        ]);

        // Pan
        onPress = function() {
            previousTool = self.getActiveNavigationTool();
            return self.setActiveNavigationTool("pan");
        };
        onRelease = function() {
            return self.setActiveNavigationTool(previousTool);
        };
        var hotkeys = [
            {
                keycodes: [keys.SHIFT],
                onPress: onPress,
                onRelease: onRelease
            },
            {
                keycodes: [keys.SPACE],
                onPress: onPress,
                onRelease: onRelease
            }];
        av.theHotkeyManager.pushHotkeys("Autodesk.Pan", hotkeys, {tryUntilSuccess: true});
    };

    Viewer3D.prototype.createControls = function( ) {
        var self = this;
        var impl = self.impl;

        self.navigation = new av.Navigation(impl.camera);
        self.__initAutoCam(impl);

        self.utilities = new av.ViewingUtilities(impl, self.autocam, self.navigation);
        self.clickHandler = new av.DefaultHandler(impl, self.navigation, self.utilities);
        self.toolController = new av.ToolController(impl, self, self.autocam, self.utilities, self.clickHandler);
        self.toolController.registerTool( new av.GestureHandler(self) );

        self.toolController.registerTool( av.theHotkeyManager );
        self.toolController.activateTool( av.theHotkeyManager.getName() );

        self.registerUniversalHotkeys();

        self.toolController.registerTool( new av.OrbitDollyPanTool(impl, self) );
        self.toolController.activateTool( "gestures" );

        return self.toolController;
    };



    /**
     * Create any DOM and canvas elements, and
     * setup WebGL.
     *
     * @return {Number} - 0 if initialization was successful, av.ErrorCode otherwise.
     */
    Viewer3D.prototype.initialize = function()
    {
        var webGL = detectWebGL();
        if (webGL <= 0) {  // WebGL error.
            return webGL === -1 ? av.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED : av.ErrorCodes.BROWSER_WEBGL_DISABLED;
        }

        var self = this;

        // Add a callback for the panels to resize when the viewer resizes.
        //
        // Note, we can't pass viewer.resize() as the callback - it will not evaluate
        // 'this' as the viewer when it's called.  We save the viewer here as a closure
        // variable ensuring resize() is called on the viewer.
        //
        this.onResizeCallback = function(e) {
            self.resize();
        };
        window.addEventListener('resize', this.onResizeCallback, false);


        this.setScreenModeDelegate(this.config ? this.config.screenModeDelegate : undefined);


        this.initContextMenu();

        // Localize the viewer.
        this.localize();


        var dimensions = this.getDimensions();
        this.canvas.width = dimensions.width;
        this.canvas.height = dimensions.height;

        // For Safari and WKWebView and UIWebView on ios device with retina display,
        // needs to manually rescale our canvas to get the right scaling. viewport metatag
        // alone would not work.
        if (av.isIOSDevice() && window.devicePixelRatio) {
            this.canvas.width /= window.devicePixelRatio;
            this.canvas.height /= window.devicePixelRatio;
        }

        // the implementation of the canvas
        this.impl = new avp.Viewer3DImpl(this.canvas, this);
        this.impl.controls = this.createControls();
        this.setDefaultNavigationTool( "orbit" );
        this.model = null;

        if( this.impl.controls )
            this.impl.controls.setAutocam(this.autocam);

        var canvasConfig = (this.config && this.config.canvasConfig) ? this.config.canvasConfig : Viewer3D.kDefaultCanvasConfig;
        this.setCanvasClickBehavior(canvasConfig);

        // Create a div containing an image: this will be a
        // spinner (aka activity indicator) that tells the user
        // that the file is loading.
        //
        this.loader = document.createElement("div");
        this.loader.id = "loader";
        this.loader.className = "spinner";
        this.container.appendChild(this.loader);

        // Allow clients not load the spinner. This is needed for embedding viewer in a WebView on mobile,
        // where the spinner makes the UI looks less 'native'.
        if (!canvasConfig.disableSpinner) {
            // Generate circles for spinner
            for (var i=1; i<=3; i++) {
                var spinnerContainer = document.createElement("div");
                spinnerContainer.className = "bounce" + i;
                this.loader.appendChild(spinnerContainer);
            }
        }

        // Setup of AO, Ghosting, Env Lighting etc.
        this.initSettings();

        // Auxiliary class to get / restore the viewer state.
        this.viewerState = new avp.ViewerState( this );

        // The default behavior is to run the main loop immediately, unless startOnInitialize
        // is provided and is false.
        //
        if (!this.config || !this.config.hasOwnProperty("startOnInitialize") || this.config.startOnInitialize)
        {
            this.run();
        }

        window.NOP_VIEWER = this;

        return 0;   // No Error initializing.
    };

    Viewer3D.prototype.setUp = function (config) {

        this.config = config;

        // Load the extensions specified in the config.
        //
        if (this.config && this.config.hasOwnProperty('extensions')) {
            var extensions = this.config.extensions;
            for (var i = 0; i < extensions.length; ++i) {
                this.loadExtension(extensions[i], this.config);
            }
        }

        var canvasConfig = (this.config && this.config.canvasConfig) ? this.config.canvasConfig : Viewer3D.kDefaultCanvasConfig;
        this.setCanvasClickBehavior(canvasConfig);
    };

    Viewer3D.prototype.tearDown = function () {
        this.clearSelection();

        if (this.loadedExtensions) {
            for (var extensionId in this.loadedExtensions) {
                try {
                    // Extensions that fail to unload will end up terminating
                    // the viewer tearDown process.  Thus we protect from it
                    // here and log it (if available).
                    this.unloadExtension(extensionId);
                } catch (err) {
                    stderr("Failed to unload extension: " + extensionId);
                    console.log('  error: ' + err.message);
                    console.error('  stack:\n' + err.stack);
                    var logger = avp.logger;
                    if (logger) {
                        logger.log(
                            {
                                category:"error_unload_extension",
                                extensionId: extensionId,
                                error_message: err.message,
                                call_stack: err.stack
                            });
                    }
                }
            }
            this.loadedExtensions = null;
        }

        if (avp.logger) {
            avp.logger.reportRuntimeStats(true);
        }

        this.loader.style.display = "block";
        this.model = null;

        if (this.liveReviewClient) {
            this.liveReviewClient.destroy();
            this.liveReviewClient = null;
        }

        this.impl.unloadCurrentModel();
    };

    Viewer3D.prototype.run = function()
    {
        if( !this.running ) {
            this.resize();
            this.running = true;
            this.impl.run();
        }
    };


    /**
     * Localize the viewer. This method can be overwritten so that the subclasses
     * can localize any additional elements.
     *
     **/
    Viewer3D.prototype.localize = function()
    {
        av.i18n.localize();
    };

    Viewer3D.prototype.__initAutoCam = function(impl)
    {
        var self = this;

        var ourCamera = impl.camera;

        if( !ourCamera.pivot )
            ourCamera.pivot = new THREE.Vector3(0, 0, 0);

        if( !ourCamera.target )
            ourCamera.target = new THREE.Vector3(0, 0, 0);

        if( !ourCamera.worldup )
            ourCamera.worldup = ourCamera.up.clone();

        function autocamChange(upChanged)
        {
            if( self.autocamCamera.isPerspective !== ourCamera.isPerspective )
            {
                if( self.autocamCamera.isPerspective )
                    self.navigation.toPerspective();
                else
                    self.navigation.toOrthographic();
            }
            self.navigation.setVerticalFov(self.autocamCamera.fov, false);
            self.navigation.setView(self.autocamCamera.position, self.autocamCamera.target);
            self.navigation.setPivotPoint(self.autocamCamera.pivot);
            self.navigation.setCameraUpVector(self.autocamCamera.up);
            if( upChanged )
                self.navigation.setWorldUpVector(self.autocamCamera.worldup);

            self.impl.syncCamera(upChanged);
        }

        function pivotDisplay(state)
        {
            if( self.utilities )
                self.utilities.pivotActive(state, false);
            else
                self.impl.controls.pivotActive(state, false);
        }

        self.autocamCamera = ourCamera.clone();
        self.autocamCamera.target = ourCamera.target.clone();
        self.autocamCamera.pivot  = ourCamera.pivot.clone();
        self.autocamCamera.worldup = ourCamera.worldup.clone();

        self.autocam  = new Autocam(self.autocamCamera, self.navigation);
        self.autocam.cameraChangedCallback = autocamChange;
        self.autocam.pivotDisplayCallback = pivotDisplay;
        self.autocam.canvas = self.canvas;

        self.addEventListener("cameraChanged", function(evt)
        {
            var ourCamera = evt.camera;
            self.autocam.sync(ourCamera);
        });

        self.autocam.sync(ourCamera);
    };


    /**
     * Removes all created DOM elements
     * and performs any GL un-initialization that is needed.
     */
    Viewer3D.prototype.uninitialize = function(file)
    {

        window.removeEventListener('resize', this.onResizeCallback, false);
        this.onResizeCallback = null;


        this.canvas.parentNode.removeChild(this.canvas);
        this.canvas.viewer = null;
        this.canvas = null;
        this.canvasWrap = null;

        this.viewerState = null;

        if (avp.logger) {
            avp.logger.reportRuntimeStats();
            avp.logger.log({category:"viewer_destroy"}, true);
        }


        if( this.toolController ) {
            this.toolController.uninitialize();
            this.toolController = null;
            this.clickHandler = null;
            this.utilities = null;
        }

        if (this.navigation) {
            this.navigation.uninitialize();
            this.navigation = null;
        }

        if (this.impl){
            this.impl.dtor();
            this.impl = null;
        }

        this.loader = null;
        this.model = null;
        this.prefs = null;

        this.autocam.dtor();
        this.autocam = null;
        this.autocamCamera = null;

        av.theHotkeyManager.popHotkeys("Autodesk.FitToView");
        av.theHotkeyManager.popHotkeys("Autodesk.Home");
        av.theHotkeyManager.popHotkeys("Autodesk.Escape");
        av.theHotkeyManager.popHotkeys("Autodesk.Pan");
        av.theHotkeyManager.popHotkeys("Autodesk.Orbit");



        if (this.onDefaultContextMenu) {
            this.container.removeEventListener('contextmenu', this.onDefaultContextMenu, false);
            this.onDefaultContextMenu = null;
        }

        if (this.container && this.container.parentNode)
            this.container.parentNode.removeChild(this.container);
        this.container = null;

        if (this.screenModeDelegate) {
            this.screenModeDelegate.uninitialize();
            this.screenModeDelegate = null;
        }

        this.clientContainer = null;
        this.config = null;
        this.listeners = {};
        this.contextMenu = null;
        this.contextMenuCallbacks = null;

        this.fireEvent(av.VIEWER_UNINITIALIZED);

        //forget all event listeners
        this.listeners = {};

        stderr("viewer destroy");
    };


    /**
     * Unloads any loaded extensions and then uninitializes the viewer.
     */
    Viewer3D.prototype.finish = function() {
        this.tearDown();
        this.uninitialize();
    };


    /**
     * @deprecated Use loadModel instead
     * Load the file from the cloud or locally.
     * Asynchronously loads the document given its svfURN.
     *
     * On success: Calls onDocumentLoadedCallback.
     * On error: Displays an error AlertBox.
     * @param {string} svfURN The URN or filepath to load
     * @param {string} [sharedPropertyDbPath] Optional path to shared property database
     * @param {function} [onSuccessCallback] method gets called when initial loading is done and streaming starts
     * @param {function(int, string)} [onErrorCallback] method gets called when initial loading is done and streaming starts
     */
    Viewer3D.prototype.load = function(svfURN, sharedPropertyDbPath, onSuccessCallback, onErrorCallback)
    {
        var options = {
            ids: null,
            sharedPropertyDbPath: sharedPropertyDbPath
        };
        return this.loadModel(svfURN, options, onSuccessCallback, onErrorCallback);
    };


    /**
     * Loads a model into the viewer
     * @param {string} url the url to the model.
     * @param {Object} [options] - An optional dictionary of options.
     * @param {av.FileLoader} [options.fileLoader] - The file loader to use for this url.
     * @param {string} [options.sharedPropertyDbPath] - Optional path to shared property database.
     * @param {string} [options.ids] A list of object id to load.
     * @param {function} [onSuccessCallback] A method that gets called when initial loading is done and streaming starts.
     * @param {function(int, string)} [onErrorCallback] A method that gets called when loading fails.
     */
    Viewer3D.prototype.loadModel = function(url, options, onSuccessCallback, onErrorCallback)
    {
        var self = this;

        options = options || {};

        function registerDimensionSpecificHotkeys() {
            if (!av.theHotkeyManager)
                return;

            if (self.model.is2d()) {
                // Remove 3D specific hotkeys
                av.theHotkeyManager.popHotkeys("Autodesk.Orbit");
            } else {
                // Add 3D specific hotkeys
                // Orbit
                var previousTool;
                var onPress = function() {
                    previousTool = self.getActiveNavigationTool();
                    return self.setActiveNavigationTool("orbit");
                };
                var onRelease = function() {
                    return self.setActiveNavigationTool(previousTool);
                };
                var hotkeys = [
                    {
                        keycodes: [av.theHotkeyManager.KEYCODES.ALT],
                        onPress: onPress,
                        onRelease: onRelease
                    }];
                av.theHotkeyManager.pushHotkeys("Autodesk.Orbit", hotkeys, {tryUntilSuccess: true});
            }
        }

        function onSuccess( model ) {
            self.model = model;
            self.impl.addModel(self.model);

            if (self.loader)
                self.loader.style.display = "None";

            if (self.model.is2d())
                self.activateLayerState("Initial");

            registerDimensionSpecificHotkeys();

            if (onSuccessCallback) {
                onSuccessCallback();
            }
        }

        function onError( errorCode, errorMessage, statusCode, statusText ) {
            if (self.loader)
                self.loader.style.display = "None";
            if (onErrorCallback)
                onErrorCallback( errorCode, errorMessage, statusCode, statusText );
        }

        // Force a repaint when a file is fully done loading
        function forceRepaint() {
            self.impl.needsRender = true;
            self.removeEventListener(av.GEOMETRY_LOADED_EVENT, forceRepaint);
        }
        this.addEventListener(av.GEOMETRY_LOADED_EVENT, forceRepaint);

        var match = url.toLowerCase().match(/\.([a-z0-9]+$)/),
            fileExtension = match ? match[1] : null;

        var loader;
        if (options && options.fileLoader) {
            loader = options.fileLoader;
        } else {
            loader = av.FileLoaderManager.getFileLoaderForExtension(fileExtension);
        }

        return new loader(this.impl).loadFile(url, options, onSuccess, onError );
    };


    /**
     *
     * @returns {rect} Client Rectangle Bounds
     */
    Viewer3D.prototype.getDimensions = function() {
        if (this.container) {
            // NB: Getting dimensions of the client container instead of the container.
            //     At least in IE11, getting dimensions on the dynamically created
            //     child of the dynamically created parent returns a 0 height.
            var rect = {};
            if (this.getScreenMode() === av.ScreenMode.kFullScreen) {
                rect.width = screen.width;
                rect.height = screen.height;
            } else {
                rect = this.container.getBoundingClientRect();
            }

            return {
                width: rect.width,
                height: rect.height
            };
        }

        return null;
    };


    /**
     * Resizes the viewer.
     */
    Viewer3D.prototype.resize = function()
    {
        return this.impl.resize(this.container.clientWidth, this.container.clientHeight);
    };

    /**
     *
     * Gets the camera so it can be modified by the client.
     * @returns {THREE.camera} The active camera.
     */
    Viewer3D.prototype.getCamera = function()
    {
        return this.impl.camera;
    };

    /**
     * Gets the view state as a plain object.
     *
     * @param {Object} [filter] - Specifies which viewer values to get.
     * @returns {Object} viewers state.
     */
    Viewer3D.prototype.getState = function( filter ) {
        return this.viewerState.getState(filter);
    };

    /**
     * Restores the viewer state from a given object.
     * @param {Object} viewerState
     * @param {Object} [filter] - Similar in structure to viewerState used to filter out values
     *                            that should not be restored.
     * @param {boolean} [immediate] - Whether the new view is applied with (true) or without transition (false)
     *
     * @returns {boolean} true if restore operation was successful.
     */
    Viewer3D.prototype.restoreState = function (viewerState, filter, immediate)  {
        var success = this.viewerState.restoreState(viewerState, filter, immediate);
        if (success) {
            this.fireEvent({ type: av.VIEWER_STATE_RESTORED_EVENT, value: success });
        }
        return success;
    };

    /**
     * Sets the view from an array of parameters
     * @param {Array} params - View parameters:
     *  [position-x, position-y, position-z,
     *    target-x, target-y, target-z,
     *    up-x, up-y, up-z,
     *    aspect, fov (radians), orthoScale,
     *    isPerspective (0=perspective, 1=ortho)]
     */
    Viewer3D.prototype.setViewFromArray = function(params, name)
    {
        this.setActiveNavigationTool("orbit");

        //TODO: It might be best to get rid of the setViewFromArray API as it's not
        //very descriptive, and move the params->camera conversion to the bubble-reading
        //logic in ViewingApplication.

        //Make sure to apply any internal translation offset to the input camera
        var off = this.model ? this.model.getData().globalOffset : { x:0, y:0, z:0 };
        var camera = {
            position: new THREE.Vector3(params[0] - off.x, params[1] - off.y, params[2] - off.z),
            target: new THREE.Vector3(params[3] - off.x, params[4] - off.y, params[5] - off.z),
            up: new THREE.Vector3(params[6], params[7], params[8]),
            aspect: params[9],
            fov: THREE.Math.radToDeg(params[10]),
            orthoScale: params[11],
            isPerspective: !params[12]
        };

        this.impl.setViewFromCamera(camera);
    };

    /**
     * Sets the view from an array representing a view box
     *
     * Not applicable to 3D.
     *
     * @param {Array} viewbox - View parameters:
     *  [min-x, min-y, max-x, max-y]
     * @param {String} name - Optional named view name to also set the layer visibility state associated with this view
     */
    Viewer3D.prototype.setViewFromViewBox = function (viewbox, name)
    {
        var model = this.model;

        if( model && !model.is2d() )
        {
            console.warn("Viewer3D.setViewFromViewBox is not applicable to 3D");
            return;
        }

        //set the layer state if any
        //It's annoying to search the views and states as arrays,
        //but this is the only place we do this, so converting them
        //to hashmaps is not necessary (yet).
        if (name && name.length) {
            var metadata = model.getData().metadata;
            var views = metadata.views;

            var i;
            for (i=0; i<views.length; i++) {
                if (views[i].name == name)
                    break;
            }

            if (i < views.length) {
                var state_name = views[i].layer_state;
                if (state_name)
                    this.activateLayerState(state_name);
            }
        }

        //Finally set the camera
        this.impl.setViewFromViewBox(this.model, viewbox, name, false);
    };

    /**
     * Changes the active layer state.<br>
     * Get a list of all available layerStates and their active status through
     * [getLayerStates()]{@link Autodesk.Viewing.Viewer3D#getLayerStates}.
     *
     * @param {String} stateName - Name of the layer state to activate
     */
    Viewer3D.prototype.activateLayerState = function(stateName)
    {
        if (stateName && stateName.length) {
            var metadata = this.model.getData().metadata;
            var states = metadata.layer_states;
            if (!states) {
                return;
            }

            var j;
            for (j=0; j<states.length; j++) {
                if (states[j].name == stateName)
                    break;
            }

            if (j < states.length) {
                var layer_state = states[j];
                var visible = layer_state.visible_layers;

                var visMap = {};
                if (visible && 0 < visible.length) {
                    for (var k=0; k<visible.length; k++)
                        visMap[visible[k]] = 1;
                }

                var onlayers = [];
                var offlayers = [];

                for (var l in metadata.layers) {
                    var lname = metadata.layers[l].name;
                    if (visMap[lname] === 1)
                        onlayers.push(l);
                    else
                        offlayers.push(l);
                }

                this.impl.setLayerVisible(onlayers, true);
                this.impl.setLayerVisible(offlayers, false);
                this.fireEvent({type: av.LAYER_VISIBILITY_CHANGED_EVENT});
            }
        }
    };

    /**
     * Returns information for each layer state: name, description, active.<br>
     * Activate a state through [activateLayerState()]{@link Autodesk.Viewing.Viewer3D#activateLayerState}.
     * @returns {Array}
     */
    Viewer3D.prototype.getLayerStates = function () {
        var model = this.model,
            metadata = model ? model.getData().metadata : null,
            layers = metadata ? metadata.layers : null,
            layer_states = metadata ? metadata.layer_states : null;

        // No layers or no layer states? Nothing to do.
        //
        if (!layers || !layer_states) {
            return null;
        }

        // Which layers are currently visible?
        //
        var layerName,
            layerNames = {},
            currentVisibleLayers = {};

        for (var layer in layers) {
            if (layers.hasOwnProperty(layer)) {
                var index = parseInt(layer),
                    defn = layers[layer];

                layerName = (typeof defn === 'string') ? defn : defn.name;
                layerNames[layerName] = true;

                if (this.impl.isLayerVisible(index)) {
                    currentVisibleLayers[layerName] = true;
                }
            }
        }

        // Shallow equal()
        //
        function equal(a, b) {
            var aProps = Object.getOwnPropertyNames(a),
                bProps = Object.getOwnPropertyNames(b);

            if (aProps.length !== bProps.length) {
                return false;
            }

            for (var i = 0; i < aProps.length; ++i) {
                var propName = aProps[i];
                if (a[propName] !== b[propName]) {
                    return false;
                }
            }

            return true;
        }

        var layerStates = [],
            i, j;

        for (i = 0; i < layer_states.length; ++i) {
            var layer_state = layer_states[i],
                visible_layers = layer_state.visible_layers,
                layerStateVisibleLayers = {};

            if (!layer_state.hidden) { // Ignore hidden layer states
                if (visible_layers && 0 < visible_layers.length) {
                    for (j = 0; j < visible_layers.length; ++j) {
                        layerName = visible_layers[j];
                        if (layerNames.hasOwnProperty(layerName)) { // Ignore layers we don't know about
                            layerStateVisibleLayers[layerName] = true;
                        }
                    }
                }

                layerStates.push({
                    name: layer_state.name,
                    description: layer_state.description,
                    active: equal(currentVisibleLayers, layerStateVisibleLayers)
                });
            }
        }
        return (0 < layerStates.length) ? layerStates : null;
    };

    /**
     * Sets the view using the default view in the source file.
     */
    Viewer3D.prototype.setViewFromFile = function()
    {
        this.setActiveNavigationTool();
        this.impl.setViewFromFile(this.model);
    };

    /**
     * Gets the properties for an id. Once the properties are returned, the method raises a onPropertiesReady event.
     * @param {number} dbid
     * @param {function} [onSuccessCallback] call this callback once the properties are found.
     * @param {function(int, string)} [onErrorCallback] call this callback if the properties are not found, or another error occurs.
     */
    Viewer3D.prototype.getProperties = function(dbid, onSuccessCallback, onErrorCallback)
    {
        if (avp.logger) {
            avp.logger.log({ name: 'get_props_count', aggregate: 'count' });
        }

        if (this.model) {
            this.model.getProperties(dbid, onSuccessCallback, onErrorCallback);
        }
        else {
            if (onErrorCallback)
                onErrorCallback(av.ErrorCodes.BAD_DATA, "Properties failed to load since model does not exist");
        }
    };

    /**
     * Gets the viewer model object tree. Once the tree is received it will invoke the specified callback function.
     *
     * You can use the model object tree to get information about items in the model.  The tree is made up
     * of nodes, which correspond to model components such as assemblies or parts.
     *
     * @param {function} [onSuccessCallback] call this callback once the object tree is loaded.
     * @param {function(int, string)} [onErrorCallback] call this callback if the object tree is not found.
     */
    Viewer3D.prototype.getObjectTree = function(onSuccessCallback, onErrorCallback)
    {
        if (this.model) {
            this.model.getObjectTree(onSuccessCallback, onErrorCallback);
        }
        else {
            if (onErrorCallback)
                onErrorCallback(av.ErrorCodes.BAD_DATA, "ObjectTree failed to load since model does not exist");
        }
    };

    /**
     * Sets the click behavior on the canvas to follow config.
     * This is used to change the behavior of events such as selection or COI changed.
     *
     *  @example
     *  {
     *       "click": {
     *           "onObject": [ACTIONS],
     *           "offObject": [ACTIONS]
     *       },
     *       "clickCtrl": {
     *           "onObject": [ACTIONS],
     *           "offObject": [ACTIONS]
     *       },
     *       "clickShift": {
     *           ...
     *       },
     *       "clickCtrlShift": {
     *           ...
     *       },
     *       "disableSpinner": BOOLEAN
     *       "disableMouseWheel": BOOLEAN,
     *       "disableTwoFingerSwipe": BOOLEAN
     *  }
     *
     *  Actions can be any of the following:
     *  "selectOnly"
     *  "selectToggle"
     *  "deselectAll"
     *  "isolate"
     *  "showAll"
     *  "setCOI"
     *  "focus"
     *  "hide"
     *
     *  Boolean is either true or false
     *
     * @param {object} config parameter that meets the above layout
     */
    Viewer3D.prototype.setCanvasClickBehavior = function(config)
    {
        if (this.impl.controls.hasOwnProperty("setClickBehavior"))
            this.impl.controls.setClickBehavior(config);

        if( this.clickHandler )
            this.clickHandler.setClickBehavior(config);

        if (config && config.disableMouseWheel) {
            this.toolController.setMouseWheelInputEnabled(false);
        }

        if (config && config.disableTwoFingerSwipe) {
            var gestureHandler = this.toolController.getTool("gestures");
            if (gestureHandler) {
                gestureHandler.disableTwoFingerSwipe();
            }
        }
    };

    /**
     * Searches the elements for the given text.  When the search is complete,
     * the callback onResultsReturned(idArray) is invoked.
     * @param {string} text - the search term.
     * @param {function(idArray)} onSuccessCallback - the callback to invoke when search is complete.
     * @param {function(errorCode, errorMsg)} onErrorCallback - the callback to invoke when search is complete.
     * @param {string[]} [attributeNames] - restricts search to specific attribute names
     */
    Viewer3D.prototype.search = function(text, onSuccessCallback, onErrorCallback, attributeNames)
    {
        this.searchText = text;

        if (this.model) {
            this.model.search(text, onSuccessCallback, onErrorCallback, attributeNames);
        }
        else {
            if (onErrorCallback)
                onErrorCallback(av.ErrorCodes.BAD_DATA, "Search failed since model does not exist");
        }
    };

    /**
     * Returns an Array of the IDs of the currently hidden nodes.
     * When isolation is in place, there are no hidden nodes returned because
     * all nodes that are not isolated are considered hidden.
     *
     * @returns {Array} of nodes that are currently hidden, when no isolation is in place.
     */
    Viewer3D.prototype.getHiddenNodes = function () {
        return this.impl.visibilityManager.getHiddenNodes();
    };

    /**
     * Returns an array of the IDs of the currently isolated nodes.
     *
     * Not yet implemented for 2D.
     *
     * @returns {Array} of nodes that are currently isolated.
     */
    Viewer3D.prototype.getIsolatedNodes = function () {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.getIsolatedNodes is not yet implemented for 2D");
            return [];
        }

        return this.impl.visibilityManager.getIsolatedNodes();
    };

    /**
     * Isolates one of many sub-elements. You can pass in a node or an array of nodes to isolate.
     * Pass in null to reset isolation.
     *
     * Not yet implemented for 2D.
     *
     * @param {int[] | int} node A node ID or array of node IDs from the model tree {@link BaseViewer#getObjectTree}
     */
    Viewer3D.prototype.isolate = function(node)
    {
        if (!this.model) {
            // Silently abort //
            return;
        }

        if(this.model.is2d())
        {
            console.warn("Viewer3D.isolate is not yet implemented for 2D");
            return;
        }

        var self = this;
        this.model.getObjectTree(function() {
            if (avp.logger) {
                avp.logger.log({ name: 'isolate_count', aggregate: 'count' });
            }
            self.impl.visibilityManager.isolate(node);
        });
    };


    /**
     * @deprecated Isolates one of many sub-elements. You can pass in a dbid or an array of dbid to isolate.
     *
     * Not yet implemented for 2D.
     *
     * @param {array| int} dbids either an array or a single integer.
     *
     */
    Viewer3D.prototype.isolateById = function(dbIds) {

        console.warn("isolateById() is deprecated. Use isolate() instead.");
        return this.isolate(dbIds);

    };

    /**
     * Sets the background Color
     * @param {Number} red
     * @param {Number} green
     * @param {Number} blue
     * @param {Number} red2
     * @param {Number} green2
     * @param {Number} blue2
     */
    Viewer3D.prototype.setBackgroundColor = function(red, green, blue, red2, green2, blue2)
    {
        this.impl.setClearColors(red, green, blue, red2, green2, blue2);
    };

    /**
     * Toggles the selection for a given dbid. If it was unselected, it is selected.  If it was selected, it is unselected.
     *
     * Not yet implemented for 2D.
     *
     * @param {( number)} dbid
     */
    Viewer3D.prototype.toggleSelect = function(dbid)
    {
        if( this.model && this.model.is2d() )
        {
            // Fails because Model.getNodeById is not supported.
            console.warn("Viewer3D.toggleSelect is not yet implemented for 2D");
            return;
        }

        this.impl.selector.toggleSelection(dbid);
    };

    /**
     * Selects the array of ids. You can also just pass in a single id instead of an array.
     * @param {( number[] | number)} dbids
     */
    Viewer3D.prototype.select = function(dbids)
    {
        if (typeof dbids === "number") {
            dbids = [dbids];
        }

        this.impl.selector.setSelection(dbids);
    };


    /**
     * Clears the selection.
     */
    Viewer3D.prototype.clearSelection = function()
    {
        this.impl.selector.clearSelection();
        if (avp.logger) {
            avp.logger.log({ name: 'clearselection', aggregate: 'count' });
        }
    };

    /**
     * Returns information about the visibility of the current selection.
     * @returns {Object} hasVisible, hasHidden
     */
    Viewer3D.prototype.getSelectionVisibility = function () {
        return this.impl.selector.getSelectionVisibility();
    };

    /**
     * Returns the number of nodes in the current selection.
     * @returns {number}
     */
    Viewer3D.prototype.getSelectionCount = function () {
        return this.impl.selector.getSelectionLength();
    };

    /**
     * Sets selection granularity mode. Supported values are:
     *      Autodesk.Viewing.SelectionMode.LEAF_OBJECT -- always select the leaf objects in the hierarchy
     *      Autodesk.Viewing.SelectionMode.FIRST_OBJECT -- for a given node, selects the first non-composite
     *                                                    (layer, collection, model) on the path from the root to the given node,
     *                                                    and all children
     *      Autodesk.Viewing.SelectionMode.LAST_OBJECT -- for a given node, selects the nearest ancestor composite node and all
     *                                                     children. Selects the input node itself in case there is no composite node
     *                                                     in the path to the root node.
     */
    Viewer3D.prototype.setSelectionMode = function (mode) {
        this.impl.selector.setSelectionMode(mode);
    };


    /**
     * Returns the current selection.
     * @returns {int[]} An array of the IDs of the currently selected nodes.
     */
    Viewer3D.prototype.getSelection = function () {
        return this.impl.selector.getSelection();
    };

    /**
     * Returns the selected items from all loaded models.
     * @param {Function} callback -- optional callback to receive enumerated pairs of model and dbId for each selected object.
     *                               If no callback is given, an array of objects is returned.
     * @returns {Object[]} An array of objects with a model and selectionSet properties
     *                     for each model that has selected items in the scene
     */
    Viewer3D.prototype.getAggregateSelection = function(callback) {
        var res = this.impl.selector.getAggregateSelection();

        if (callback) {
            for (var i=0; i<res.length; i++) {
                for (var j=0; j<res[i].selection.length; j++) {
                    callback(res[i].model, res[i].selection[j]);
                }
            }
        }

        return res;
    };

    /**
     * Ensures the passed in dbid / ids are hidden.
     *
     * Not yet implemented for 2D.
     *
     * @param {( number[] | number)} node
     */
    Viewer3D.prototype.hide = function(node)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.hide is not yet implemented for 2D");
            return;
        }

        if (avp.logger) {
            avp.logger.log({ name: 'hide', aggregate: 'count' });
        }

        this.impl.visibilityManager.hide(node);
    };

    /**
     * @deprecated Use hide() instead.
     *
     * Not yet implemented for 2D.
     *
     * @param nodeId
     */
    Viewer3D.prototype.hideById = function(nodeId)
    {
        this.hide(nodeId);
    };

    /**
     * Ensures the passed in dbid / ids are shown.
     *
     * Not yet implemented for 2D.
     *
     * @param {( number[] | number)} node
     */
    Viewer3D.prototype.show = function(node)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.show is not yet implemented for 2D");
            return;
        }

        this.impl.visibilityManager.show(node);
    };

    /**
     * Ensures everything is visible. Clears all node isolation (3D) and turns on all layers (2D).
     */
    Viewer3D.prototype.showAll = function()
    {
        this.impl.visibilityManager.isolate();
        if (this.model.is2d()) {
            this.setLayerVisible(null, true);
        }

        if (avp.logger) {
            avp.logger.log({ name: 'showall', aggregate: 'count' });
        }
    };


    /**
     * Toggles the visibility of the given node.
     *
     * Not yet implemented for 2D.
     *
     * @param {( number)} node
     */
    Viewer3D.prototype.toggleVisibility = function(node)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.toggleVisibility is not yet implemented for 2D");
            return;
        }

        this.impl.visibilityManager.toggleVisibility(node);
    };

    /**
     * Returns true if every node is visible.
     * @returns {boolean}
     */
    Viewer3D.prototype.areAllVisible = function() {
        return this.impl.isWholeModelVisible(this.model);
    };

    /**
     * Explodes the model from the center of gravity.
     *
     * Not applicable to 2D.
     *
     * @param {number} scale - a value from 0.0-1.0 to indicate how much to explode.
     */
    Viewer3D.prototype.explode = function( scale)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.explode is not applicable to 2D");
            return;
        }

        if (avp.logger) {
            avp.logger.log({ name: 'explode_count', aggregate: 'count' });
        }

        this.impl.explode(scale);
    };

    /**
     * Returns the explode scale
     *
     * Not applicable to 2D.
     *
     * @returns {number} - a value from 0.0-1.0 indicating how exploded the model is.
     */
    Viewer3D.prototype.getExplodeScale = function()
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.getExplodeScale is not applicable to 2D");
            return 0;
        }

        return this.impl.getExplodeScale();
    };


    /**
     * Enables or disables the high quality rendering settings.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} useSAO - true or false to enable screen space ambient occlusion.
     * @param {boolean} useFXAA - true or false to enable fast approximate anti-aliasing.
     */
    Viewer3D.prototype.setQualityLevel = function(useSAO, useFXAA)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setQualityLevel is not applicable to 2D");
            return;
        }

        this.prefs.set('ambientShadows', useSAO);
        this.prefs.set('antialiasing', useFXAA);
        this.impl.togglePostProcess(useSAO, useFXAA);
    };


    /**
     * Toggles ghosting during search and isolate.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value is indicating whether ghosting is on or off
     */
    Viewer3D.prototype.setGhosting = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setGhosting is not applicable to 2D");
            return;
        }

        this.prefs.set('ghosting', value);
        this.impl.toggleGhosting(value);
    };

    /**
     * Toggles ground shadow.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value is indicating whether shadow is on or off
     */
    Viewer3D.prototype.setGroundShadow = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setGroundShadow is not applicable to 2D");
            return;
        }

        this.prefs.set('groundShadow', value);
        this.impl.toggleGroundShadow(value);
    };

    /**
     * Toggles ground reflection.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value is indicating whether reflection is on or off
     */
    Viewer3D.prototype.setGroundReflection = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setGroundReflection is not applicable to 2D");
            return;
        }

        this.prefs.set('groundReflection', value);
        this.impl.toggleGroundReflection(value);
    };

    /**
     * Toggles environment map for background.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value is indicating whether environment map for background is on or off
     */
    Viewer3D.prototype.setEnvMapBackground = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setEnvMapBackground is not applicable to 2D");
            return;
        }

        this.prefs.set('envMapBackground', value);
        this.impl.toggleEnvMapBackground(value);
    };

    /**
     * Toggles Prism Material rendering.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value is indicating whether Prism Material rendering is on or off
     */
    Viewer3D.prototype.setRenderPrism = function (value) {
        if (this.model && this.model.is2d()) {
            console.warn("Viewer3D.setRenderPrism is not applicable to 2D");
            return;
        }

        this.prefs.set('renderPrism', value);
        this.impl.toggleRenderPrism(value);
    };

    /**
     * Toggles first person tool popup.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value is indicating whether first person tool popup is showed or not
     */
    Viewer3D.prototype.setFirstPersonToolPopup = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setFirstPersonToolPopup is not applicable to 2D");
            return;
        }

        this.prefs.set('firstPersonToolPopup', value);
    };

    /**
     * Returns the state of first person tool popup
     *
     * Not applicable to 2D.
     *
     * @returns {boolean} - value is indicating whether first person tool popup is showed or not
     */
    Viewer3D.prototype.getFirstPersonToolPopup = function()
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.getFirstPersonToolPopup is not applicable to 2D");
            return;
        }

        return this.prefs.firstPersonToolPopup;
    };

    /**
     * Toggles whether progressive rendering is used. Warning: turning progressive rendering off
     * will have serious performance implications.
     * @param {boolean} value whether it is on or off
     */
    Viewer3D.prototype.setProgressiveRendering = function(value)
    {
        this.prefs.set('progressiveRendering', value);
        this.impl.toggleProgressive(value);
    };

    /**
     * Toggles whether the navigation should be optimized for performance. If set
     * to true, anti-aliasing and ambient shadows will be off while navigating.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value whether it is on or off
     */
    Viewer3D.prototype.setOptimizeNavigation = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setOptimizeNaviation is not applicable to 2D");
            return;
        }

        this.prefs.set('optimizeNavigation', value);
        this.impl.setOptimizeNavigation(value);
    };

    /**
     * Locks or unlocks navigation controls.
     *
     * When navigation is locked, certain operations (for example, orbit, pan, or fit-to-view)
     * are disabled.
     *
     * @param {boolean} value True if the navigation should be locked.
     *
     * @see {@link Autodesk.Viewing.Viewer3D#setNavigationLockSettings}
     */
    Viewer3D.prototype.setNavigationLock = function(value)
    {
        if (this.navigation.getIsLocked() !== value) {
            this.navigation.setIsLocked(value);
            this.fireEvent({ type: av.NAVIGATION_MODE_CHANGED_EVENT, id: this.getActiveNavigationTool() });
        }
    };

    /**
     * Gets the current state of the navigation lock.
     * @returns {boolean} True if the navigation controls are currently locked.
     */
    Viewer3D.prototype.getNavigationLock = function()
    {
        return this.navigation.getIsLocked();
    };

    /**
     * Updates the configuration of the navigation lock,
     * i.e., which actions are available when navigation is locked.
     *
     * The configurable actions are 'orbit', 'pan', 'zoom', 'roll', 'fov', 'walk', or 'gotoview'.
     * By default, none of the actions are enabled when the navigation is locked.
     *
     * @param {object} settings Map of <action>:<boolean> pairs specifying
     * whether the given action is *enabled* even when the navigation is locked.
     *
     * @see {@link Autodesk.Viewing.Viewer3D#setNavigationLock}
     */
    Viewer3D.prototype.setNavigationLockSettings = function(settings)
    {
        this.navigation.setLockSettings(settings);
        this.fireEvent({ type: av.NAVIGATION_MODE_CHANGED_EVENT, id: this.getActiveNavigationTool() });
    };

    /**
     * Gets the current configuration of the navigation lock.
     *  @returns {object} Map of <action>:<boolean> pairs specifying
     * whether the given action is *enabled* even when the navigation is locked.
     */
    Viewer3D.prototype.getNavigationLockSettings = function()
    {
        return this.navigation.getLockSettings();
    };

    /**
     * Swaps the current navigation tool for the tool with the provided name.
     * Will trigger NAVIGATION_MODE_CHANGED event if the mode actually changes.
     *
     * @param {string} [toolName] - The name of the tool to activate. By default it will switch to the default tool.
     *
     * @returns {boolean} - True if the tool was set successfully. False otherwise.
     *
     * @see {@link Viewer3D#getActiveNavigationTool|getActiveNavigationTool()}
     */
    Viewer3D.prototype.setActiveNavigationTool = function(toolName)
    {
        if(toolName === this._pushedTool || (!toolName && !this._pushedTool))
            return true;

        if( this._pushedTool ) {
            if( !this.impl.controls.deactivateTool(this._pushedTool) ) {
                return false;
            }

            this._pushedTool = null;
        }

        var isDefault = !toolName || toolName === this.getDefaultNavigationToolName();

        if (isDefault && this._pushedTool === null) {
            this.fireEvent({ type: av.NAVIGATION_MODE_CHANGED_EVENT, id: this.getDefaultNavigationToolName() });
            return true;
        }

        if( this.impl.controls.activateTool(toolName) ) {
            this._pushedTool = toolName;
            this.fireEvent({ type: av.NAVIGATION_MODE_CHANGED_EVENT, id: this._pushedTool });
            return true;
        }

        return false;
    };

    /**
     * Returns the name of the active navigation tool.
     * @returns {string} - The tool's name.
     *
     * @see {@link Viewer3D#setActiveNavigationTool|setActiveNavigationTool()}
     */
    Viewer3D.prototype.getActiveNavigationTool = function()
    {
        return this._pushedTool ? this._pushedTool : this._defaultNavigationTool;
    };

    /**
     * Sets the default navigation tool. This tool will always sit beneath the navigation tool on the tool stack.
     *
     * @param {string} toolName - The name of the new default navigation tool.
     */
    Viewer3D.prototype.setDefaultNavigationTool = function(toolName)
    {
        if (this._defaultNavigationTool) {
            this.impl.controls.deactivateTool(this._defaultNavigationTool);
        }

        if (this._pushedTool) {
            this.impl.controls.deactivateTool(this._pushedTool);
        }

        this.impl.controls.activateTool(toolName);
        this._defaultNavigationTool = toolName;

        if (this._pushedTool) {
            this.impl.controls.activateTool(this._pushedTool);
        }
    };

    /**
     * Returns the default navigation tool
     *
     * @returns {Object} - The default navigation tool.
     */
    Viewer3D.prototype.getDefaultNavigationToolName = function()
    {
        return this._defaultNavigationTool;
    };

    /**
     * Gets the current camera vertical field of view.
     * @returns { number } - the field of view in degrees.
     */
    Viewer3D.prototype.getFOV = function()
    {
        return this.navigation.getVerticalFov();
    };

    /**
     * Sets the current cameras vertical field of view.
     * @param { number } degrees - Field of view in degrees.
     */
    Viewer3D.prototype.setFOV = function(degrees)
    {
        this.navigation.setVerticalFov(degrees, true);
    };

    /**
     * Gets the current camera focal length.
     * @returns { number } - the focal length in millimetres.
     */
    Viewer3D.prototype.getFocalLength = function()
    {
        return this.navigation.getFocalLength();
    };

    /**
     * Sets the current cameras focal length.
     * @param { number } mm - Focal length in millimetres
     */
    Viewer3D.prototype.setFocalLength = function(mm)
    {
        this.navigation.setFocalLength(mm, true);
    };

    /**
     * Hides all lines in the scene.
     * @param {boolean} hide
     */
    Viewer3D.prototype.hideLines = function(hide){
        this.prefs.set('lineRendering', !hide);
        var that = this;

        function onGeometryLoaded() {
            that.impl.hideLines(hide);
            that.removeEventListener(av.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
        }

        if (!this.impl.hideLines(hide)) {
            this.addEventListener(av.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
        }
    };

    /**
     * @deprecated
     * Applies the camera to the current viewer's camera.
     * @param {THREE.Camera} camera - the camera to apply.
     * @param {boolean} [fit=false] - Do a fit to view after transition.
     */
    Viewer3D.prototype.applyCamera = function(camera, fit) {
        this.impl.setViewFromCamera(camera, true);
        if (fit)
            this.fitToView();
    };

    /**
     * Fits camera to objects by ID - Fits entire model if no id is provided.
     * @param {array| int} [objectIds] array of Ids, or null.
     */
    Viewer3D.prototype.fitToView = function(objectIds){

        var that = this;
        var instant = true;
        var model = that.model;

        var fit = function(){
            var fitTo = null;
            if( Array.isArray(objectIds) && (objectIds.length > 0) )
            {
                var bounds = new THREE.Box3();
                var box = new THREE.Box3();

                var instanceTree = model.getData().instanceTree;
                var fragList = model.getFragmentList();

                for (var i=0; i<objectIds.length; i++) {
                    instanceTree.enumNodeFragments(objectIds[i], function(fragId) {
                        fragList.getWorldBounds(fragId, box);
                        bounds.union(box);
                    }, true);
                }

                if( !bounds.empty() )
                    fitTo = bounds;
            }
            if( !fitTo || fitTo.empty() )
                fitTo = that.impl.getFitBounds();

            that.navigation.fitBounds(false, fitTo);

            that.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, checkGeomAndFit);
            that.removeEventListener(av.GEOMETRY_LOADED_EVENT, fit);

            return instant;
        };

        var checkGeomAndFit = function () {
            if(model && model.isLoadDone()){
                fit();
            } else {
                instant = false;
                that.addEventListener(av.GEOMETRY_LOADED_EVENT, fit);
            }
        };

        var propertyDB = model.getData().propertydb,
            propertyDBFileExists = propertyDB && propertyDB.attrs.length > 0;

        if (avp.logger) {
            avp.logger.log({ name: 'fittoview', aggregate: 'count' });
        }

        // This doesn't guarantee that an object tree will be created but it will be pretty likely
        if (!model.is2d() && propertyDBFileExists && objectIds !== null && objectIds !== undefined) {

            if (model && model.isObjectTreeCreated()) {
                checkGeomAndFit();
            } else {
                instant = false;
                this.addEventListener(av.OBJECT_TREE_CREATED_EVENT, checkGeomAndFit);
            }
        } else {
            // Fallback, fit to the model bounds
            this.navigation.fitBounds(false, this.impl.getFitBounds(true));
        }
    };

    /**
     * Modifies a click action configuration entry.
     * @param {string} what - which click config to modify (one of "click", "clickAlt", "clickCtrl", "clickShift", "clickCtrlShift").
     * @param {string} where - hit location selector (one of "onObject", "offObject").
     * @param {Array|string} newAction - action list (containing any of "setCOI", "selectOnly", "selectToggle", "deselectAll", "deselectAll", "isolate", "showAll", "hide", "focus").
     * @returns {boolean} False if specified entry is not found, otherwise true.
     */
    Viewer3D.prototype.setClickConfig = function(what, where, newAction)
    {
        var config = this.clickHandler ? this.clickHandler.getClickBehavior()
            : this.impl.controls.getClickBehavior();

        if( what in config )
        {
            var actions = config[what];
            if( where in actions )
            {
                actions[where] = newAction;
                return true;
            }
        }
        return false;
    };

    /**
     * Fetch a click action configuration entry.
     * @param {string} what - which click config to fetch (one of "click", "clickAlt", "clickCtrl", "clickShift", "clickCtrlShift").
     * @param {string} where - hit location selector (one of "onObject", "offObject").
     * @returns {Array} action list for the given entry or null if not found.
     */
    Viewer3D.prototype.getClickConfig = function(what, where)
    {
        var config = this.clickHandler ? this.clickHandler.getClickBehavior()
            : this.impl.controls.getClickBehavior();

        if( what in config )
        {
            var actions = config[what];
            if( where in actions )
                return actions[where];
        }
        return null;
    };

    /**
     * Modify the default click behaviour for the viewer.
     * @param {boolean} state - If true the default is to set the center of interest. If false the default is single select.
     * @param {boolean} [updatePrefs=true] - If true, the user preferences will be updated.
     */
    Viewer3D.prototype.setClickToSetCOI = function(state, updatePrefs)
    {
        if (updatePrefs !== false)
            this.prefs.set('clickToSetCOI', state);

        var currentOn = this.getClickConfig("click", "onObject");
        if( state )
        {
            if( currentOn.indexOf("setCOI") === -1 ) // Not already set?
            {
                this.setClickConfig("click", "onObject",  [ "setCOI" ]);
            }
        }
        else if( currentOn.indexOf("setCOI") >= 0 ) // Is currently set?
        {
            this.setClickConfig("click", "onObject",  [ "selectOnly" ]);
        }
    };


    /**
     * Initializes all gui settings to their defaults or to the session stored setting
     * This gives session stored settings priority
     */
    Viewer3D.prototype.initSettings = function() {

        this.prefs.load(av.DefaultSettings);

        this.prefs.tag('3d');
        this.prefs.tag('2d');
        this.prefs.untag('2d', [ // 3d only
            'viewCube',
            'alwaysUsePivot',
            'zoomTowardsPivot',
            'reverseHorizontalLookDirection',
            'reverseVerticalLookDirection',
            'orbitPastWorldPoles',
            'clickToSetCOI',
            'ghosting',
            'optimizeNavigation',
            'ambientShadows',
            'antialiasing',
            'groundShadow',
            'groundReflection',
            'lineRendering',
            'lightPreset',
            'envMapBackground',
            'renderPrism',
            'firstPersonToolPopup'
        ]);

        // Apply settings
        this.setQualityLevel(this.prefs.ambientShadows, this.prefs.antialiasing);
        this.setGroundShadow(this.prefs.groundShadow);
        this.setGroundReflection(this.prefs.groundReflection);
        this.setGhosting(this.prefs.ghosting);
        this.setProgressiveRendering(this.prefs.progressiveRendering);
        this.setClickToSetCOI(this.prefs.clickToSetCOI);
        this.setOptimizeNavigation(this.prefs.optimizeNavigation);
        this.hideLines(!this.prefs.lineRendering);
        this.setEnvMapBackground(this.prefs.envMapBackground);
        this.setRenderPrism(this.prefs.renderPrism);
        this.setFirstPersonToolPopup(this.prefs.firstPersonToolPopup);

        this.navigation.setUsePivotAlways(this.prefs.alwaysUsePivot);
        this.navigation.setReverseZoomDirection(this.prefs.reverseMouseZoomDir);
        this.navigation.setReverseHorizontalLookDirection(this.prefs.reverseHorizontalLookDirection);
        this.navigation.setReverseVerticalLookDirection(this.prefs.reverseVerticalLookDirection);
        this.navigation.setZoomTowardsPivot(this.prefs.zoomTowardsPivot);
        this.navigation.setOrbitPastWorldPoles(this.prefs.orbitPastWorldPoles);
        this.navigation.setUseLeftHandedInput(this.prefs.leftHandedMouseSetup);

        var bacStr = this.prefs.backgroundColorPreset;
        if (bacStr) {
            try {
                var bac = JSON.parse(bacStr);
                this.impl.setClearColors(bac[0],bac[1],bac[2],bac[3],bac[4],bac[5]);
            } catch(e) {
                this.prefs.set("backgroundColorPreset", null);
            }
        }

        var lightPreset = /*viewer.model.is2d() ? avp.DefaultLightPreset2d :*/ this.prefs.lightPreset;
        this.impl.setLightPreset(lightPreset);
    };

    /**
     * Sets the Light Presets (Environments) for the Viewer.
     *
     * Not applicable to 2D.
     *
     * Sets the preference in the UI
     * @param {Number} index - where
     * - 0 Simple Grey
     * - 1 Sharp Highlights
     * - 2 Dark Sky
     * - 3 Grey Room
     * - 4 Photo Booth
     * - 5 Tranquility
     * - 6 Infinity Pool
     * - 7 Simple White
     * - 8 Riverbank
     * - 9 Contrast
     * - 10 Rim Highlights
     * - 11 Cool Light
     * - 12 Warm Light
     * - 13 Soft Light
     * - 14 Grid Light
     * - 15 Plaza
     * - 16 Snow Field
     * @note this list is copied from the ones in Environments.js
     */

    Viewer3D.prototype.setLightPreset = function (index) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setLightPreset is not applicable to 2D");
            return;
        }

        this.prefs.set('lightPreset', index);

        this.impl.setLightPreset(index);
    };

    /**
     *  Set or unset a view navigation option which requests that orbit controls always orbit around the currently set pivot point.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true to request use of the pivot point. When false some controls may pivot around the center of the view. (Currently applies only to the view-cube orbit controls.)
     */
    Viewer3D.prototype.setUsePivotAlways = function (value) {
        this.prefs.set('alwaysUsePivot', value);
        this.navigation.setUsePivotAlways(value);
    };

    /**
     * Set or unset a view navigation option to reverse the default direction for camera dolly (zoom) operations.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true for reverse, false for default
     */
    Viewer3D.prototype.setReverseZoomDirection = function (value) {
        this.prefs.set('reverseMouseZoomDir', value);
        this.navigation.setReverseZoomDirection(value);
    };

    /**
     * Set or unset a view navigation option to reverse the default direction for horizontal look operations.
     *
     * Not applicable to 2D.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true for reverse, false for default
     */
    Viewer3D.prototype.setReverseHorizontalLookDirection = function (value) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setReverseHorizontalLookDirection is not applicable to 2D");
            return;
        }

        this.prefs.set('reverseHorizontalLookDirection', value);
        this.navigation.setReverseHorizontalLookDirection(value);
    };

    /**
     * Set or unset a view navigation option to reverse the default direction for vertical look operations.
     *
     * Not applicable to 2D.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true for reverse, false for default
     */
    Viewer3D.prototype.setReverseVerticalLookDirection = function (value) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setReverseVerticalLookDirection is not applicable to 2D");
            return;
        }

        this.prefs.set('reverseVerticalLookDirection', value);
        this.navigation.setReverseVerticalLookDirection(value);
    };

    /**
     * Get the state of the view navigation option that requests the default direction for camera dolly (zoom) operations to be towards the camera pivot point.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true for towards the pivot, false for default
     */
    Viewer3D.prototype.setZoomTowardsPivot = function (value) {
        this.prefs.set('zoomTowardsPivot', value);
        this.navigation.setZoomTowardsPivot(value);
    };

    /**
     * Set or unset a view navigation option to allow the orbit controls to move the camera beyond the north and south poles (world up/down direction). In other words, when set the orbit control will allow the camera to rotate into an upside down orientation. When unset orbit navigation should stop when the camera view direction reaches the up/down direction.
     *
     * Not applicable to 2D.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true to allow orbiting past the poles.
     */
    Viewer3D.prototype.setOrbitPastWorldPoles = function (value) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setOrbitPastWorldPoles is not applicable to 2D");
            return;
        }

        this.prefs.set('orbitPastWorldPoles', value);
        this.navigation.setOrbitPastWorldPoles(value);
    };

    /**
     * Set or unset a view navigation option which requests that mouse buttons be reversed from their default assignment. i.e. Left mouse operation becomes right mouse and vice versa.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true to request reversal of mouse button assignments.
     */
    Viewer3D.prototype.setUseLeftHandedInput = function (value) {
        this.prefs.set('leftHandedMouseSetup', value);
        this.navigation.setUseLeftHandedInput(value);
    };

    /**
     * Set visibility for a single layer, or for all layers.
     *
     * Not yet implemented for 3D.
     *
     * @param {?Array} nodes - An array of layer nodes, or a single layer node, or null for all layers
     * @param {boolean} visible - true to show the layer, false to hide it
     * @param {boolean=} [isolate] - true to isolate the layer
     */
    Viewer3D.prototype.setLayerVisible = function (nodes, visible, isolate) {
        if( this.model && !this.model.is2d() )
        {
            console.warn("Viewer3D.setLayerVisible is not yet implemented for 3D");
            return;
        }

        var that = this;

        function getLayerIndexes(node, visible) {
            var layerIndexes = [];

            if (node.isLayer) {
                layerIndexes.push(node.index);
            } else {
                var children = node.children;
                for (var i = 0; i < children.length; ++i) {
                    layerIndexes = layerIndexes.concat(getLayerIndexes(children[i]));
                }
            }

            return layerIndexes;
        }

        var layersRoot = that.model.getLayersRoot();
        if (!layersRoot || 0 === layersRoot.childCount) {
            return;
        }

        if (nodes === null) {
            nodes = [layersRoot];
        }
        if (!Array.isArray(nodes)) {
            nodes = [nodes];
        }

        if (isolate) {
            that.impl.setLayerVisible(getLayerIndexes(layersRoot), false);
            visible = true; // force this because isolate + not visible doesn't make sense
        }

        var layerIndexes = [];
        for (var i = 0; i < nodes.length; ++i) {
            layerIndexes = layerIndexes.concat(getLayerIndexes(nodes[i]));
        }
        that.impl.setLayerVisible(layerIndexes, visible);
        that.fireEvent({type: av.LAYER_VISIBILITY_CHANGED_EVENT});
    };

    /**
     * Returns true if the layer is visible.
     *
     * Not yet implemented for 3D.
     *
     * @param {Object} node - Layer node
     * @returns {boolean} true if the layer is visible
     */
    Viewer3D.prototype.isLayerVisible = function (node) {
        if( this.model && !this.model.is2d() )
        {
            console.warn("Viewer3D.isLayerVisible is not yet implemented for 3D");
            return false;
        }

        return !!(node && node.isLayer && this.impl.isLayerVisible(node.index));
    };

    /**
     * Returns true if any layer is hidden.
     *
     * Not yet implemented for 3D.
     *
     * @returns {boolean} true if any layer is hidden
     */
    Viewer3D.prototype.anyLayerHidden = function () {
        if( this.model && !this.model.is2d() )
        {
            console.warn("Viewer3D.anyLayerHidden is not yet implemented for 3D");
            return false;
        }

        var that = this;

        function anyLayerHidden(node) {
            if (node.isLayer) {
                return !that.impl.isLayerVisible(node.index);
            } else {
                var children = node.children;
                for (var i = 0; i < children.length; ++i) {
                    if (anyLayerHidden(children[i])) {
                        return true;
                    }
                }
            }
            return false;
        }

        var layersRoot = that.model.getLayersRoot();
        return !!(layersRoot && anyLayerHidden(layersRoot));
    };

    /**
     * If enabled, set ground shadow color
     *
     * Not applicable to 2D
     *
     * @param {THREE.Color} color
     */
    Viewer3D.prototype.setGroundShadowColor = function(color) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setGroundShadowColor is not applicable to 2D");
            return;
        }

        this.impl.setGroundShadowColor(color);
    };

    /**
     * If enabled, set ground shadow alpha
     *
     * Not applicable to 2D
     *
     * @param {float} alpha
     */
    Viewer3D.prototype.setGroundShadowAlpha = function(alpha) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setGroundShadowAlpha is not applicable to 2D");
            return;
        }

        this.impl.setGroundShadowAlpha(alpha);
    };

    /**
     * If enabled, set ground reflection color. This is reset to default when reflections toggled off.
     *
     * Not applicable to 2D
     *
     * @param {THREE.Color} color
     */
    Viewer3D.prototype.setGroundReflectionColor = function(color) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setGroundReflectionColor is not applicable to 2D");
            return;
        }

        this.impl.setGroundReflectionColor(color);
    };

    /**
     * If enabled, set ground reflection alpha. This is reset to default when reflections toggled off.
     *
     * Not applicable to 2D
     *
     * @param {float} alpha
     */
    Viewer3D.prototype.setGroundReflectionAlpha = function(alpha) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.setGroundReflectionAlpha is not applicable to 2D");
            return;
        }

        this.impl.setGroundReflectionAlpha(alpha);
    };

    /**
     * Returns a list of active cut planes
     *
     * Not applicable to 2D
     *
     * @return {THREE.Vector4[]} List of Vector4 plane representation {x:a, y:b, z:c, w:d}
     */
    Viewer3D.prototype.getCutPlanes = function() {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.getCutPlanes is not applicable to 2D");
            return [];
        }

        return this.impl.getCutPlanes();
    };

    /**
     * Apply a list of cut planes
     *
     * Not applicable to 2D
     *
     * @param {THREE.Vector4[]} planes - List of Vector4 plane representation: {x:a, y:b, z:c, w:d}
     * Plane general equation: ax + by + cz + d = 0 where a, b, and c are not all zero
     * Passing an empty list or null is equivalent to setting zero cut planes
     */
    Viewer3D.prototype.setCutPlanes = function(planes) {
        if( this.model && this.model.is2d() )
        {
            console.warn("Viewer3D.getCutPlanes is not applicable to 2D");
            return;
        }

        this.impl.setCutPlanes(planes);
    };

    /**
     * Captures the current screen image as Blob URL
     * Blob URL can be used like a regular image url (e.g., window.open, img.src, etc)
     * If no parameters are given, returns an image as Blob URL, with dimensions equal to current canvas dimensions
     * If width and height are given, returns asynchronously and calls the callback with the resized image as Blob URL
     * If no callback is given, displays the image in a new window.<br>
     * See also [getScreenShotBuffer()]{@link Autodesk.Viewing.Viewer3D#getScreenShotBuffer}.
     * @param  {int}      [w]  width of the requested image
     * @param  {int}      [h]  height of the requested image
     * @param  {Function} [cb] callback
     * @return {DOMString}     screenshot image Blob URL, if no parameters are given
     */
    Viewer3D.prototype.getScreenShot = function(w, h, cb) {
        return this.impl.getScreenShot(w, h, cb);
    };

    /**
     * Alternative call to [getScreenShot()]{@link Autodesk.Viewing.Viewer3D#getScreenShot}
     * which internally uses additional steps (more processing) to generate the screenshot.
     * @param  {int}      [w]  width of the requested image
     * @param  {int}      [h]  height of the requested image
     * @param  {Function} [cb] callback
     */
    Viewer3D.prototype.getScreenShotBuffer = function (w, h, cb) {
        return this.impl.getScreenShotBuffer(w, h, cb);
    };

    /**
     * Sets the object context menu.
     * @param {?ObjectContextMenu=} [contextMenu]
     */
    Viewer3D.prototype.setContextMenu = function (contextMenu) {

        if (this.contextMenu) {

            // Hide the current context menu, just in case it's open right now.
            // This does nothing if the context menu is not open.
            //
            this.contextMenu.hide();
        }

        this.contextMenu = contextMenu || null; // to avoid undefined
    };

    /**
     * Activates the default context menu.<br>
     * Contains options Isolate, Hide selected, Show all objects, Focus and Clear selection.
     *
     * @returns {boolean} Whether the default context menu was successfully set (true) or not (false)
     */
    Viewer3D.prototype.setDefaultContextMenu = function() {

        var ave = Autodesk.Viewing.Extensions;
        if (ave && ave.ViewerObjectContextMenu) {
            this.setContextMenu(new ave.ViewerObjectContextMenu(this));
            return true;
        }
        return false;
    };

    Viewer3D.prototype.triggerContextMenu = function (event) {
        if (this.config && this.config.onTriggerContextMenuCallback) {
            this.config.onTriggerContextMenuCallback(event);
        }

        if (this.contextMenu) {
            this.contextMenu.show(event);
            return true;
        }
        return false;
    };

    Viewer3D.prototype.triggerSelectionChanged = function (dbId) {
        if (this.config && this.config.onTriggerSelectionChangedCallback) {
            this.config.onTriggerSelectionChangedCallback(dbId);
        }
    };

    Viewer3D.prototype.triggerDoubleTapCallback = function (event) {
        if (this.config && this.config.onTriggerDoubleTapCallback) {
            this.config.onTriggerDoubleTapCallback(event);
        }
    }

    Viewer3D.prototype.triggerSingleTapCallback = function (event) {
        if (this.config && this.config.onTriggerSingleTapCallback) {
            this.config.onTriggerSingleTapCallback(event);
        }
    }

    Viewer3D.prototype.initContextMenu = function() {

        // Disable the browser's default context menu by default, or if explicitly specified.
        //
        var disableBrowserContextMenu = !this.config || (this.config.hasOwnProperty("disableBrowserContextMenu") ? this.config.disableBrowserContextMenu : true);
        if (disableBrowserContextMenu) {
            this.onDefaultContextMenu = function (e) {
                e.preventDefault();
            };
            this.container.addEventListener('contextmenu', this.onDefaultContextMenu, false);
        }

        var self = this;

        function isRightClick(event) {
            var button = event.button;

            // Check for Firefox spoof: Control+LMB converted to RMB.
            // The "buttons" property in Firefox will include 1 for LMB and 2 for RMB.
            if( "buttons" in event ) {
                // For button down the 1 bit will be on indicating LMB.
                // For button up it's off so check the flag to see if we
                // switched the down event.
                if( self.__firefoxLMBfix && !(event.buttons & 1) ) { // Button up?
                    self.__firefoxLMBfix = false;
                    button = 0;
                    // console.log("FIREFOX UP!!!");
                }
                else if( (button === 2) && (event.buttons & 1) ) {
                    button = 0;    // Convert back to reality.
                    self.__firefoxLMBfix = true;
                    // console.log("FIREFOX SUX!!!");
                }
            }

            var useLeftHandedInput = self.navigation ? self.navigation.getUseLeftHandedInput() : false;
            var rightButton = useLeftHandedInput ? 0 : 2;

            if( button === rightButton )
                return true;

            /* See SPK-930 and SPK-928
             var isMac = (navigator.userAgent.search("Mac OS") !== -1);
             var leftButton = (rightButton === 2) ? 0 : 2;
             return isMac && event.ctrlKey && (event.button === leftButton);
             */
            return false;
        }

        var canvas = this.canvas || this.container;

        canvas.addEventListener( 'mousedown',
            function(event) {
                if (isRightClick(event)) {
                    self.startX = event.clientX;
                    self.startY = event.clientY;
                }
            } );

        canvas.addEventListener( 'mouseup',
            function ( event ) {
                if (isRightClick(event) && event.clientX === self.startX && event.clientY === self.startY) {
                    self.triggerContextMenu(event);
                }
                return true;
            }, false );
    };


    /**
     * Registers a new callback that modifies the context menu.
     * This allows extensions and others to add, remove, or change items in the context menu.
     * Extensions that call registerContextMenuCallback() should call unregisterContextMenuCallback() in their unload().
     * @param {string} id - Unique id to identify this callback. Used by unregisterContextMenuCallback().
     * @param {function(Array, Object)} callback - Will be called before the context menu is displayed.
     * @see Viewer.unregisterContextMenuCallback
     * @see ObjectContextMenu.buildMenu
     *
     * @example
     * // Here's an example that appends a new context menu item:
     *
     * viewer.registerContextMenuCallback('MyExtensionName', function (menu, status) {
 *     if (status.hasSelected) {
 *         menu.push({
 *             title: 'My new context menu item with selected objects',
 *             target: function () {
 *                 alert('Do something with selected objects');
 *         });
 *     } else {
 *         menu.push({
 *             title: 'My new context menu item, no selected objects',
 *             target: function () {
 *                 alert('Do something else');
 *         });
 *     }
 * });
 */
    Viewer3D.prototype.registerContextMenuCallback = function (id, callback) {
        this.contextMenuCallbacks[id] = callback;
    };

    /**
     * Unregisters an existing callback that modifies the context menu.
     * Extensions that call registerContextMenuCallback() should call unregisterContextMenuCallback() in their unload().
     * @param {string} id - Unique id to identify this callback.
     * @returns {boolean} true if the callback was unregistered successfully.
     * @see Viewer.registerContextMenuCallback
     */
    Viewer3D.prototype.unregisterContextMenuCallback = function (id) {
        if (id in this.contextMenuCallbacks) {
            delete this.contextMenuCallbacks[id];
            return true;
        }
        return false;
    };

    /**
     * Runs all registered context menu callbacks.
     * @param {Array} menu - Context menu items.
     * @param {Object} status - Information about nodes.
     * @see ObjectContextMenu.buildMenu
     * @private
     */
    Viewer3D.prototype.runContextMenuCallbacks = function (menu, status) {
        for (var id in this.contextMenuCallbacks) {
            if (this.contextMenuCallbacks.hasOwnProperty(id)) {
                this.contextMenuCallbacks[id](menu, status);
            }
        }
    };

    /**
     * Play animation if animation data is available as part of model data.
     * If the model data does not contain any animation, this function call is a no op.
     * @param  {Function} [callback] Callback function that would be invoked at each frame of the animation.
     * The callback function takes a single input value, with value range between 0 and 100, inclusive, with value
     * 100 indicates the animation has finished playing.
     * @example
     * Here is an example of callback function.
     * function(value) {
     *     if (value < 100)
     *         console.log("Animation progress: " + value + "%.");
     *     else
     *         console.log("Animation finished.");
     * }
     */
    Viewer3D.prototype.playAnimation = function (callback) {
        var animator = this.impl.keyFrameAnimator;
        if (animator) {
            animator.play(0, callback);
        }
    };

    /**
     * Join a live review session.
     *
     * @param {string} [sessionId] - The live review session id to join.
     */
    Viewer3D.prototype.joinLiveReview = function (sessionId) {
        if (!this.liveReviewClient) {
            this.liveReviewClient = new avp.LiveReviewClient(this);
        }

        var liveReviewClient = this.liveReviewClient;
        avp.loadDependency("lmv_io", "socket.io-1.3.5.js", function(){
            liveReviewClient.joinLiveReviewSession(sessionId);
        });
    };

    /**
     * Leave a live review session.
     */
    Viewer3D.prototype.leaveLiveReview = function () {
        if (this.liveReviewClient) {
            this.liveReviewClient.leaveLiveReviewSession();
        }
    };

    /**
    * Returns a map which keys are the attributes names and the values is an object containing the dbIds and corresponding values
    * @param onSuccessCallback
    * @param onErrorCallback
    */
    Viewer3D.prototype.getAttributeToIdMap = function(onSuccessCallback, onErrorCallback)
    {
        if (this.model) {
            this.model.getAttributeToIdMap(onSuccessCallback, onErrorCallback);
        }
        else {
            if (onErrorCallback)
                onErrorCallback(av.ErrorCodes.UNKNOWN_FAILURE, "Function getAttributeToIdMap failed");
        }

    };

    /**
     * Set model units
     * @param Model units
     */
    Viewer3D.prototype.setModelUnits = function(modelUnits) {
        if (this.model) {
            this.model.getData().overriddenUnits = modelUnits;
        }
    };

    /**
     * Calculates the pixel position in client space coordinates of a point in world space.<br>
     * See also
     * [clientToWorld()]{@link Autodesk.Viewing.Viewer3D#clientToWorld}.
     * @param {THREE.Vector3} point Point in world space coordinates.
     * @returns {THREE.Vector3} Point transformed and projected into client space coordinates. Z value is 0.
     */
    Viewer3D.prototype.worldToClient = function(point) {
        return this.impl.worldToClient(point);
    };

    /**
     * Given coordinates in pixel screen space it returns information of the underlying geometry node.
     * Hidden nodes will not be taken into account. Returns null if there is no geometry in the specified location.
     * For 2d models, it will return null outside the paper.<br>
     * See also
     * [worldToClient()]{@link Autodesk.Viewing.Viewer3D#worldToClient}.
     *
     * @param {Number} clientX - X coordinate where 0 is left
     * @param {Number} clientY - Y coordinate where 0 is top
     * @param {Boolean} [ignoreTransparent] - Ignores transparent materials
     * @returns {Object|null} contains point attribute. 3d models have additional attributes.
     */
    Viewer3D.prototype.clientToWorld = function(clientX, clientY, ignoreTransparent) {

        return this.impl.clientToWorld(clientX, clientY, ignoreTransparent);
    };

    /**
     * Expose if the model has topology information
     * Only applicable to 3D
     * @returns {boolean} value is indicating whether the model has topology information
     */
    Viewer3D.prototype.modelHasTopology = function() {

        if (this.model && this.model.getData().topology) {
            return true;
        }

        return false;
    };

    /**
     * Changes color of the selection overlay.
     * @example
     *      viewer.setSelectionColor(new THREE.Color(0xFF0000)); // red color
     *
     * @param {THREE.Color} color
     */
    Viewer3D.prototype.setSelectionColor = function(color) {
        this.impl.setSelectionColor(color);
    };

Autodesk.Viewing.Viewer3D = Viewer3D;

})();
;
var av = Autodesk.Viewing;

/**
 * Error code constants
 *
 * These constants will be used in onErrorCallbacks.
 *
 * @enum {number}
 * @readonly
 */
av.ErrorCodes = {
    /** An unknown failure has occurred. */
    UNKNOWN_FAILURE: 1,

    /** Bad data (corrupted or malformed) was encountered. */
    BAD_DATA: 2,

    /** A network failure was encountered. */
    NETWORK_FAILURE: 3,

    /** Access was denied to a network resource (HTTP 403) */
    NETWORK_ACCESS_DENIED: 4,

    /** A network resource could not be found (HTTP 404) */
    NETWORK_FILE_NOT_FOUND: 5,

    /** A server error was returned when accessing a network resource (HTTP 5xx) */
    NETWORK_SERVER_ERROR: 6,

    /** An unhandled response code was returned when accessing a network resource (HTTP 'everything else') */
    NETWORK_UNHANDLED_RESPONSE_CODE: 7,

    /** Browser error: webGL is not supported by the current browser */
    BROWSER_WEBGL_NOT_SUPPORTED: 8,

    /** There is nothing viewable in the fetched document */
    BAD_DATA_NO_VIEWABLE_CONTENT: 9,

    /** Browser error: webGL is supported, but not enabled */
    BROWSER_WEBGL_DISABLED: 10,
    
    /** Collaboration server error */
    RTC_ERROR: 11

};;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

(function() {

"use strict";

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

av.HTTP_REQUEST_HEADERS = {};
av.ACM_SESSION_ID = undefined;

av.isAuthorizationHeaderSet = function() {
    for (var key in av.HTTP_REQUEST_HEADERS) {
        if (key === 'Authorization') {
            return true;
        }
    }
    return false;
};

function cloneRequestHeaders(headers) {
    var clone = {};
    for (var key in headers) {
        if (headers.hasOwnProperty(key))
            clone[key] = headers[key]; // Assignment should be fine since they are supposed to be strings.
    }
    return clone;
}

function getACMSessionID(acmHeaders, token, onErrorCallback, onLoadFn) {
    // The value of this can be anything. Required for some arcane reasons.
    acmHeaders.application = "autodesk";

    var xhr = new XMLHttpRequest();
    xhr.open("POST", ACM_SESSION_URL, true);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.setRequestHeader("Authorization", "Bearer " + token);

    xhr.onload = function () {
        if (xhr.status === 200) {
            av.ACM_SESSION_ID = (JSON.parse(xhr.responseText)).acmsession;
        }
        onLoadFn();
    };
    xhr.onerror = onErrorCallback;
    xhr.ontimeout = onErrorCallback;
    xhr.send(JSON.stringify(acmHeaders));

    // "application" header is only required for OSS end point, and should not be passed
    // with normal requests because this header is not in allowed header sets of APIGEE.
    delete acmHeaders.application;
}

function extractACMHeaderPairs(input) {
    var ret = {};
    for (var key in input) {
        if (key.indexOf("x-ads-acm") == -1) continue;
        ret[key] = input[key];
    }
    return ret;
}

function extractOAuth2AccessToken(input) {
    for (var key in input) {
        if (key === "oauth2AccessToken")
            return input[key];
    }
    return null;
}


/**
 * Document
 *
 *  This is the core model data class for all items and collections.
 *  It allows the client to load the model data from the cloud, it
 *  gives access to the root and provides a method for finding elements
 *  by id.
 *
 *  Typically, you load the document from the Viewing Service, parse it for
 *  the required content (for example, 3d geometries), then pass this on to
 *  the viewer to display.  You can also get some information about the document,
 *  such as the number of views it contains and its thumbnail image.
 *
 * You can view the json structure of a Document object by requesting it from
 * the viewing service, once you have been authenticated (eg a valid accessToken
 * is stored as a cookie):
 * https://viewing-dev.api.autodesk.com/viewingservice/v1/bubbles/[urn]
 *
 * @class
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.Document
 *
 *  @param {Object} dataJSON - json data representing the document
 *  @param {string} path - path to the document
 */
var Document = function( dataJSON, path )
{
    this.myPath = path;
    this.myData = dataJSON;
    this.myViewGeometry = {};
    this.myNumViews = {};
    this.myPropertyDb = null;

    // Search bubble for type="view" role="3d" children of type="geometry" role="3d" items.
    // Add count of view-3d items to parent geometry-3d items.
    // Collect geometry items of camera view items referenced by guid.
    //
    var self = this;

    function annotateViews(item) {
        if (!item) {
            return;
        }

        var childCount = item.children ? item.children.length : 0;
		var i;

        if (item.type === "geometry" && childCount) {
            var viewCount = 0;
            for (i = 0; i < childCount; i++) {
                var child = item.children[i];
                if (child && child.type === "view") {
                    self.myViewGeometry[child.guid] = item;
                    viewCount++;
                }
            }

            self.myNumViews[item.guid] = viewCount;

        } else if (item.mime == "application/autodesk-db" && item.urn) {
            //If there is a shared property database, remember its location

            //Of course, OSS is a storage system that mangles paths because why not,
            //so it needs special handling to extract the property database path
            if (item.urn.indexOf("urn:adsk.objects:os.object") === 0)
                self.myPropertyDb = item.urn.substr(0, item.urn.lastIndexOf("%2F")+3);
            else
                self.myPropertyDb = item.urn.substr(0, item.urn.lastIndexOf("/")+1);

        } else if (0 < childCount) {
            for (i = 0; i < childCount; i++) {
                annotateViews(item.children[i]);
            }
        }
    }
    annotateViews(dataJSON);

    // Traverse the document and populate the parent pointers (for each node, store its parent).
    //
    function traverse( item ) {
        if (!item)
            return;

        var len = item.children ? item.children.length : 0;
        for(var i=0; i < len; i++)
        {
            item.children[i].parent = item;
            traverse(item.children[i]);
        }
    }
    traverse(this.myData);
};

Document.prototype.constructor = Document;

/**
 * Static method to load the model data from the cloud.
 *
 *  @example
 *         // Load the model from the cloud
 *         var urn = 'dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOnRyYW5zbGF0aW9uXzI1X3Rlc3RpbmcvRFdGL0Nhci5kd2Y=';
 *         var seedFile  = "https://viewing-dev.api.autodesk.com/viewingservice/v1/" + urn;
 *         var jsonData = "";
 *         Autodesk.Document.load( seedFile, function( doc ) { jsonData=doc }, function( ) { } );
 *         var model = new Autodesk.Document(jsonData, 'path');
 *         var root  = model.getRootItem(); // top item of the hierarchy of the model data
 *         var item  = model.getItemById( "XXX02UUEs");
 *         var path = model.getFullPath(); // should be 'path'
 *
 *  @param {string} seedFile - The cloud urn of the file.
 *  @param {function(object)} onSuccessCallback - A function that is called when load succeeds.
 *  @param {function(int, string)} onErrorCallback - A function that is called when load fails.
 *  @param {dictionary}  - An optional list of key value pairs as access control properties, which includes a list of
 *  access control header name and values, and an OAuth 2.0 access token.
 */
Document.load = function( documentId, onSuccessCallback, onErrorCallback, accessControlProperties )
{

    // The function signature was changed and we removed the need for the Auth parameter
    // Check what the second parameter is if its a non function assign the others correctly
    // this will also work in the case of missing arguments
    if (typeof(arguments[1]) !== 'function') {
        console.log("Document.load called with deprecated (auth) parameter");
        if (typeof(arguments[2]) === 'function') {
            onSuccessCallback = arguments[2];
        }
        if (typeof(arguments[3]) === 'function') {
            onErrorCallback = arguments[3];
        }
     }

    function getDocumentPath(documentId)
    {
        // Handle local paths explicitly.
        //
        if(documentId.indexOf('urn:') === -1) {

            //Absolute URL
            if (documentId.indexOf("://") !== -1)
                return documentId;

            var relativePath = documentId;
            if(relativePath.indexOf('/') !== 0) {
                relativePath = '/' + relativePath;
            }
            return window.location.protocol + "//" + window.location.host + relativePath;
        }
        return documentId;
    }

    function getViewableCount( modelDocument ) {
        var viewableItems = Document.getSubItemsWithProperties(modelDocument.getRootItem(), {'type':'folder','role':'viewable'}, true);
        var root = viewableItems[0];
        var geometryItems = Document.getSubItemsWithProperties(root, {'type':'geometry'}, true);
        return geometryItems.length;
    }

    function getGlobalMessages(data, nestedKey) {

      var collectedmessages = [];
      var translateFailedCount = 0;
      var translateProgressCount = 0;
      nestedKey = nestedKey || "children";

      var traverse = function (obj) {
        var children = obj[nestedKey] || [];
        var messages = obj.messages || [];

        var errorMessages = messages.filter(function(msg) {
          return msg.type === 'error';
        });

        if(errorMessages.length > 0) {
          translateFailedCount += 1;
        }

        if(obj.status === 'inprogress') {
          translateProgressCount += 1;
        }

        Array.prototype.push.apply(collectedmessages, messages.slice(0));
        for(var i = children.length; i--; traverse(children[i]));
      };

      traverse(data);

      var progress = 'translated';

      progress = translateFailedCount > 0 ? "failed" : progress;
      progress = translateProgressCount > 0 ? 'processing' : progress;

      for(var i = collectedmessages.length; i--; collectedmessages[i].$translation = progress);

      return collectedmessages;

    }

    // Metering API requirement. See LMV-936
    // Applies only when fetching a 'bubble' document
    // Similar to doLoad() but it doesn't have to succeed.
    function notifyMeteringApi() {

        var documentPath = getDocumentPath(documentId);
        var options = {
            noBody: true, // Avoid downloading the whole bubble again
            headers : cloneRequestHeaders(av.HTTP_REQUEST_HEADERS),
            withCredentials:!!auth
        };
        var meteringHeader = {
            header: 'x-ads-ds-client',
            value: 'web_viewer'
        };
        options.headers[ meteringHeader.header ] = meteringHeader.value;

        var onFailure = function() {
            stderr('Failed to submit metering request: ' + meteringHeader.header);
        };
        var onSuccess = function() {
            stderr('Successfully submitted metering request: ' + meteringHeader.header);
        };

        av.Private.ViewingService.get(VIEWING_URL, 'bubbles', documentPath, onSuccess, onFailure, options);
    }

    function doLoad() {

        var documentPath = getDocumentPath(documentId);
        var messages;

        function onSuccess(data) {
            var regex = /<[^>]*script/;
            if (regex.test(data)) {
                if (onErrorCallback)
                    onErrorCallback(av.ErrorCodes.BAD_DATA, "Malicious document content detected Abort loading");
                return;
            }

            var items = typeof(data) === 'string' ? JSON.parse(data) : data;
            var document = new Document(items, documentPath);
            var viewableCount = getViewableCount(document);

            // Check if there are any viewables.
            if (viewableCount > 0) {
                messages = getGlobalMessages( document.getRootItem() );
                if (onSuccessCallback) {
                    onSuccessCallback(document, messages);
                }
                // notifyMeteringApi(); // Fire-and-forget
            }
            else {
                // If there are no viewables, report an error.
                //
                if (onErrorCallback) {
                    messages = getGlobalMessages( document.getRootItem() );
                    var errorCode =  av.ErrorCodes.BAD_DATA_NO_VIEWABLE_CONTENT;
                    var errorMsg  = "No viewable content";
                    onErrorCallback(errorCode, errorMsg, messages);
                }
            }
        }

        function onFailure(statusCode, statusText, data) {

            // If unauthorized and the first call for loading, will suppose third-party
            // cookies are disabled, and load again with token in request header.
            if (statusCode === 401 && LMV_THIRD_PARTY_COOKIE === undefined) {
                LMV_THIRD_PARTY_COOKIE = false;
                avp.refreshRequestHeader(avp.token.accessToken);
                doLoad();
            }
            else {
                var messages = getGlobalMessages(data);
                if (onErrorCallback) {
                    var errorMsg = "Error: " + statusCode + " (" + statusText + ")";
                    var errorCode = av.Private.ErrorHandler.getErrorCode(statusCode);
                    onErrorCallback(errorCode, errorMsg, statusCode, statusText, messages);
                }
            }
        }

        var options = { headers : cloneRequestHeaders(av.HTTP_REQUEST_HEADERS),
                        withCredentials:!!auth
        };

        av.Private.ViewingService.get(VIEWING_URL, 'bubbles', documentPath, onSuccess, onFailure, options);
    }

    if (accessControlProperties) {
        var acmHeaders = extractACMHeaderPairs(accessControlProperties);
        var oauth2Token = extractOAuth2AccessToken(accessControlProperties);
        av.HTTP_REQUEST_HEADERS = acmHeaders;
        getACMSessionID(acmHeaders, oauth2Token, onErrorCallback, function onACMSessionIdGet(){
            doLoad();
        });
    } else {
        doLoad();
    }
};

/**
 * This function is only used when Authorization is through Bearer token; aka when cookies are disabled.
 *
 * @param {string} thumbnailUrl - See Document.prototype.getThumbnailPath
 * @param {Function} onComplete - Node style callback function callback (err, response)
 */
Document.requestThumbnailWithSecurity = function(thumbnailUrl, onComplete) {

    var onSuccess = function(response){
        onComplete(null, response);
    };
    var onFailure = function(){
        onComplete('error', null);
    };

    var options = {
        withCredentials: false,
        responseType: 'blob',
        headers: av.HTTP_REQUEST_HEADERS,
        skipAssetCallback: true
    };

    av.Private.ViewingService.get(VIEWING_URL, 'thumbnails', thumbnailUrl, onSuccess, onFailure, options);
};

/**
 *  Returns the full path to the given urn.
 *  @param {string} urn - the urn of the document
 *  @returns {string}
 */
Document.prototype.getFullPath = function(urn)
{

    if (!urn)
        return urn;

	var fullPath = urn;

    if (av.Private.offline) {
        fullPath = decodeURIComponent(av.Private.offlineResourcePrefix) + fullPath.substr(fullPath.indexOf('/'));
    } else if(urn.indexOf('urn') === 0)
    {
        // Use viewing service.
        fullPath = VIEWING_URL +  "/items/" + urn;
    }
    // Handle local files.
    //
    else if(urn.indexOf('$file$') === 0 && this.myPath.indexOf('/bubble.json') !== -1) {
        fullPath = this.myPath.replace('/bubble.json', '') + urn.replace('$file$', '');
    }
    return fullPath;
};

/**
 *  Returns the path to the thumbnail of the item with the given id.
 *  @param {string} id - the id of the item.
 *  @param {int} width - the requested thumbnail width.
 *  @param {int} height - the requested thumbnail height.
 *  @returns {string}
 */
Document.prototype.getThumbnailPath = function(item, width, height)
{
    var requestedWidth = width ? width : 200;
    var requestedHeight = height ? height : 200;

    var ret = VIEWING_URL + "/thumbnails/" + this.myData.urn + "?guid=" + encodeURIComponent(item.guid) + "&width=" +
        requestedWidth + "&height=" + requestedHeight;
    if (av.ACM_SESSION_ID) {
        ret += "&acmsession=" + av.ACM_SESSION_ID;
    }
    return ret;
};

/**
 *  Returns the path to the viewable of the given item.
 *  @param {Object} item - the item whose viewable is requested.
 *  @returns {string}
 */
Document.prototype.getViewablePath = function(item)
{
    if(item.type === 'geometry') {
        var items = [];
        if(item.role === '3d') {
            items = Document.getSubItemsWithProperties(item, {
                'mime': 'application/autodesk-svf'
            }, false);
        }
        else if(item.role === '2d') {
            // first check for vector and if does not exist for tiles.
            items = Document.getSubItemsWithProperties(item, {
                'mime': 'application/autodesk-f2d'
            }, false);

            // old file does not have f2d yet - so load tile viewer
            if (items.length === 0) {
                items = Document.getSubItemsWithProperties(item, {
                    'role': 'tileRoot'
                }, true);
            }
        }
        if(items.length > 0)
        {
            return this.getFullPath(items[0].urn);
        }
    }
    else if(item.type === 'view') {
        var geometryItem = this.getViewGeometry(item);
        if (geometryItem) {
            return this.getViewablePath(geometryItem);
        }
    }

    return '';
};

/**
 * Returns the root path to a shared (across all sheets/views) property database's json files.
 * @returns {string}
 */
Document.prototype.getPropertyDbPath = function()
{
    return this.myPropertyDb;
};

/**
 *  Returns the root of the model data hierarchy.
 *  @returns {Object}
 */
Document.prototype.getRootItem = function()
{
    return this.myData;
};

/**
 *  Returns the id of this document.
 *  @returns {string}
 */
Document.prototype.getPath = function()
{
    return this.myPath;
};

/**
 * Returns an item from the model data hierarchy with the given id.
 * If the item is not found, null object is returned.
 *
 *  @param {string} id  - an id of the item to be found.
 *  @returns {Object} - item with a given id.
 */
Document.prototype.getItemById = function(id)
{
    function traverse( data ) {
        if (!data)
            return null;

        for (var key in data) {
            var val = data[key];
            if ( key === 'guid' && val === id )
                return data;

            if (val !== null && typeof(val) === "object" && key !== "parent") {
                //going on step down in the object tree!!
                var item = traverse( val );
                if (item)
                    return item;
            }
        }
        return null;
    }
    return traverse( this.myData );
};

/**
 * Static method that returns an array of all items with given properties.
 *
 *  @param {string} item - the document node to begin searching from.
 *  @param {Object} properties - map/list of the properties to search for.
 *  @param {bool} recursive - if true, searches recursively
 *  @returns {Object} - list of items that have given properties.
 *
 *  @example
 *  // search the document starting from the root element for all 2d geometry items
  geometryItems = Document.getSubItemsWithProperties(adocument.getRootItem(), {
                        'type' : 'geometry',
                        'role' : '2d'
                    }, true);
 */
Document.getSubItemsWithProperties = function(item, properties, recursive)
{
  var subItems = [];
  if(!item) return [];

  function hasProperties(item, properties)
  {
    for(var p in properties)
    {
      if (!(p in item) || (properties[p] !== item[p]))
        return false;
    }
    return true;
  }

  var len = item.children ? item.children.length : 0;
  for(var i=0; i < len; i++)
  {
    // Check if this child has this key and value.
    //
    var child = item.children[i];
    if(hasProperties(child, properties))
    {
      subItems.push(child);
    }

    // Search the descendants if requested.
    //
    if(recursive)
    {
      subItems.push.apply(subItems, Document.getSubItemsWithProperties(child, properties, recursive));
    }
  }
  return subItems;
};

/**
 * Return the parent geometry item for a given view item
 * @param {Object} item - view item
 * @returns {Object} The parent geometry item
 */
Document.prototype.getViewGeometry = function (item) {
    return this.myViewGeometry[item.guid];
};

/**
 * Return the number of view items underneath a geometry item.
 * @param {Object} item - geometry item
 * @returns {number} The number of view items underneath the geometry item.
 */
Document.prototype.getNumViews = function (item) {
    return this.myNumViews[item.guid] || 0;
};

/**
 * @deprecated Simply use item.parent instead.
 * Return parent ID of the given document node ID.
 * @param {string} item - the node ID.
 * @returns {string}
 */
Document.prototype.getParentId = function (itemId) {
    var item = this.getItemById(itemId);
    if (!item)
        return null;
    var parent = item.parent;
    return parent ? parent.guid : null;
};


/**
 * Return messages (error and warning messages) associated with a given item. It includes
 * item's messages as well as messages of all its parents.
 *
 * @param {string} itemId - guid of the item.
 * @param {bool} - if true the top messages that apply to the whole file are excluded.
 * @returns {Object} - returns an array of messages.
 */
Document.prototype.getMessages = function( item, excludeGlobal ) {

    var messages = [];
    if (!item)
        return messages;

    var root = null;
    if (excludeGlobal)
        root = this.getRootItem();

    var current = item;
    while (current) {

        if (excludeGlobal && parent===root)
            break;

        if (current.messages) {
            for (var i=0; i<current.messages.length; i++){
                messages.push( current.messages[i] );
            }
        }
        current = current.parent;
    }
    return messages;
};

av.Document = Document;


})();
;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

(function() {

	'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

/**
 * This is the core interface to camera controls and navigation. The active navigation object can normally be obtained from the "navigation" property of the Viewer3D instance. Client implementations should not normally instantiate this class directly.
 *  @class
 *  @param {THREE.Camera} camera - The main camera object used to render the scene.
 *  @constructor
 */
function Navigation(camera)
{
    var kMinFOV  = 6.88; // 200 mm
    var kMaxFOV  = 100;  // 10 mm
    var kEpsilon = 0.000001;

    this.__options = {
        dollyToPivot: false,
        orbitPastPoles: true,
        reverseDolly: false,
        reverseHorizontalLook: false,
        reverseVerticalLook: false,
        useLeftHandedInput: false,
        usePivotAlways: false,
        lockNavigation: false
    };

    // which actions are allowed when navigation is locked
    this.__lockSettings = {
        orbit: false,
        pan: false,
        zoom: false,
        roll: false,
        fov: false,
        gotoview: false,
        walk: false
    };

    this.__pivotIsSetFlag = false;
    this.__fitToViewRequested = false;
    this.__homeViewRequested = false;
    this.__transitionActive = false;
    this.__destinationView = null;
    this.__is2D = false;
    this.__isTouchDevice = false;
    this.__kEpsilon = kEpsilon;

    var _camera = null;

    var _viewport = { left: 0, top: 0, width: 1, height: 1 };

    this.uninitialize = function()
    {
        this.setCamera(null);
    };

    /**
     * Set or unset the current camera used for navigation. Normally set via the constructor.
     * The camera should be of type Autodesk.Viewing.UnifiedCamera.
     *  @param {Autodesk.Viewing.UnifiedCamera} camera - the current camera object.
     */
    this.setCamera = function(camera)
    {
        if( camera !== _camera )
        {
            _camera = camera;
            if( camera )
            {
                if( !camera.hasOwnProperty("target") )
                    camera.target = new THREE.Vector3(0, 0, 0);

                if( !camera.hasOwnProperty("pivot") )
                    camera.pivot = new THREE.Vector3(0, 0, 0);

                camera.worldup = camera.up.clone();  // Initial assumption!!
                camera.dirty = true;
            }
        }
    };

    /**
     *  @returns {THREE.Camera} - the current camera object.
     */
    this.getCamera = function()
    {
        return _camera;
    };

    /**
     * Set the current canvas viewport in screen coordinates.
     * Invoked internally on canvas resize.
     *  @param {Object} viewport - Rectangle with properties left, top, width, height.
     */
    this.setScreenViewport = function( viewport )
    {
        _viewport = viewport;
    };

    /**
     * Get the current canvas viewport in screen coordinates.
     *  @returns {Object} with properties left, top, width, height.
     */
    this.getScreenViewport = function()
    {
        return _viewport;
    };

    this.__setUp = function(up)
    {
        if( up && _camera )
        {
            var upCheck = up.clone().normalize();
            var diff = upCheck.sub( _camera.worldup );
            if( diff.lengthSq() !== 0.0 )
            {
                _camera.worldup.copy(up).normalize();
                _camera.dirty = true;
                return true;
            }
        }
        return false;
    };

    this.__getUp = function()
    {
        return _camera ? _camera.worldup : new THREE.Vector3(0, 1, 0);
    };

    /**
     * Sets the cameras position and view direction.
     *  @param {THREE.Vector3} position - the new position for the camera in world space.
     *  @param {THREE.Vector3} target - the point in world space that the camera should look towards.
     */
    this.setView = function( position, target )
    {
        if( _camera && position && target )
        {
            _camera.position.copy(position);
            _camera.target.copy(target);
            _camera.dirty = true;
        }
    };

    /**
     * Orient the camera's up direction with the current world up direction
     */
    this.orientCameraUp = function()
    {
        if( _camera && this.isActionEnabled('roll') )
        {
            _camera.up.copy(this.getAlignedUpVector()); // New up aligned with world up
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position of the pivot point for orbit navigation.
     */
    this.getPivotPoint = function()
    {
        return _camera ? _camera.pivot.clone() : new THREE.Vector3(0, 0, 0);
    };

    /**
     * Sets the Vector3 world space position of the pivot point for orbit navigation.
     *  @param {THREE.Vector3} pivot - the new pivot position.
     */
    this.setPivotPoint = function( pivot )
    {
        if( _camera && pivot )
        {
            _camera.pivot.copy(pivot);
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position of the camera.
     */
    this.getPosition = function()
    {
        return _camera ? _camera.position.clone() : new THREE.Vector3(0, 0, 1);
    };

    /**
     * Sets the Vector3 world space position of camera.
     *  @param {THREE.Vector3} pos - the new camera position.
     */
    this.setPosition = function( pos )
    {
        if( _camera && pos )
        {
            _camera.position.copy(pos);
            _camera.dirty = true;
        }
    };

    /**
     * Sets the Vector3 world space position towards which the camera should be pointing.
     *  @param {THREE.Vector3} target - the new camera look at point.
     */
    this.setTarget = function(target)
    {
        if( _camera && target )
        {
            _camera.target.copy(target);
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position towards which the camera is pointing.
     */
    this.getTarget = function()
    {
        return _camera ? _camera.target.clone() : new THREE.Vector3(0, 0, 0);
    };

    /**
     * Get the current camera view vector. This vector is not normalized and its
     * length is the distance between the camera position and the camera look at point.
     *  @returns {THREE.Vector3} the current camera view vector in world space.
     */
    this.getEyeVector = function ()
    {
        return _camera ? _camera.target.clone().sub( _camera.position ) : new THREE.Vector3(0, 0, -1);
    };

    /**
     *  @returns {number} the minimum allowed vertical field of view in degrees.
     */
    this.getFovMin = function()
    {
        return kMinFOV;
    };

    /**
     *  @returns {number} the maximum allowed vertical field of view in degrees.
     */
    this.getFovMax = function()
    {
        return kMaxFOV;
    };

    /**
     * Returns true if the point is visible.
     *
     * @param {THREE.Vector3} point - The point in world coordinates.
     *
     * @returns {boolean} - True if the point is within the camera's frustum.
     */
    this.isPointVisible = function(point)
    {
        var cameraFrustum = new THREE.Frustum().setFromMatrix(_camera.projectionMatrix.clone().multiply(_camera.matrixWorldInverse));
        return cameraFrustum.containsPoint(point);
    };

    /**
     * Set the current vertical field of view.
     *  @param {number} fov - the new field of view in degrees (value is clamped to the minimum and maximum field of view values).
     *  @param {boolean} adjustPosition - If true, the camera position will be modified to keep either the world space area
     *                                    of the view at the pivot point unchanged (if it is set and visible) or the world
     *                                    space area of view at the camera look at point unchanged.
     */
    this.setVerticalFov = function(fov, adjustPosition)
    {
        // If camera is not perspective don't allow fov change
        if( _camera && !_camera.isPerspective)
            return;

        if( fov < kMinFOV ) fov = kMinFOV;
        else if( fov > kMaxFOV ) fov = kMaxFOV;

        if( _camera && this.isActionEnabled('fov') )
        {
            if( Math.abs(_camera.fov - fov)  <= kEpsilon )
                return;

            if( adjustPosition )
            {
                var usePivot = this.__pivotIsSetFlag && this.isPointVisible(this.getPivotPoint());

                var pos = this.getPosition();
                var eye = this.getEyeVector();

                var oldFOV = THREE.Math.degToRad(_camera.fov);
                var newFOV = THREE.Math.degToRad(fov);

                var oldDistance = usePivot ? this.getPivotPlaneDistance() : eye.length();
                var newDistance = oldDistance * Math.tan(oldFOV * 0.5) / Math.tan(newFOV * 0.5);

                var delta = eye.normalize().multiplyScalar(oldDistance - newDistance);
                this.setPosition(pos.add(delta));

                if (usePivot) {
                    this.setTarget(this.getTarget().add(delta));
                }
            }
            // stderr("FOV " + _camera.fov.toFixed(3) + " => " + fov.toFixed(3));
            _camera.setFov(fov);
            _camera.dirty = true;
        }
    };

    /**
     * Compute camera position and look at point which will fit the given bounding box in the view frustum at the given field of view angle.
     *  @param {THREE.Vector3} oldpos - existing camera position
     *  @param {THREE.Vector3} oldcoi - existing camera look at point
     *  @param {number} fov - field of view to use for fit calculation in degrees
     *  @param {THREE.Box3} bounds - bounding box to fit
     *  @returns {Object} Object with properties "position" and "target".
     */
    this.computeFit = function(oldpos, oldcoi, fov, bounds)
    {
        if( !bounds || bounds.empty() )
            return {position: oldpos, target: oldcoi};

        var coi  = bounds.center();
        var size = bounds.size();
        var radius = 0.5 * Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
        if( radius === 0.0 )
            radius = 1.0;

        if( !this.getIs2D() )
        {
            // For wide angle views the fit is often too tight because of perspective
            // distortion, so fudge the radius based on the FOV...
            var fovFudge = Math.max(1.0, 0.9 + fov / kMaxFOV * 0.5);
            radius *= fovFudge;
        }
        var eye = oldpos.clone().sub(oldcoi).normalize();
        var fitToViewDistance = radius / Math.tan(THREE.Math.degToRad(fov * 0.5));
        eye.multiplyScalar( fitToViewDistance );

        var pos = coi.clone().add( eye );
        return {position: pos, target: coi};
    };

    /**
     * Compute a vector which is orthogonal to the given view and aligned with the world up direction.
     *  @param {THREE.Vector3} pos - view position
     *  @param {THREE.Vector3} coi - center of interest (view look at point)
     *  @returns {THREE.Vector3} up direction orthogonal to the given view
     */
    this.computeOrthogonalUp = function(pos, coi)
    {
        var worldUp = this.__getUp();
        var eye = coi.clone().sub(pos);
        if( eye.lengthSq() === 0.0 )    // Invalid view?
            return eye.copy(worldUp);

        var right = eye.clone().cross(worldUp);
        if( right.lengthSq() === 0 )
        {
            // If eye and up are colinear, perturb eye
            // to get a valid result:
            if( worldUp.z > worldUp.y )
                eye.y -= 0.0001;
            else
                eye.z -= 0.0001;

            right.crossVectors( eye, worldUp );
        }
        return right.cross(eye).normalize();
    };

    /**
     * Causes the current camera position to be changed in order to fit the given bounds into the current view frustum.
     *  @param {boolean} immediate - if false the camera position will animate to the new location.
     *  @param {THREE.Box3} bounds - bounding box to fit
     *  @param {boolean} reorient - if true the camera up direction will be reoriented with the world up.
     *  @returns {Object} Object with properties "position" and "target".
     */
    this.fitBounds = function(immediate, bounds, reorient)
    {
        var oldcoi = this.getTarget();
        var pos    = this.getPosition();

        if( !this.isActionEnabled('gotoview') || !bounds || bounds.empty() )
            return {position: pos, target: oldcoi};

        var fov = this.getVerticalFov();
        var fit = this.computeFit(pos, oldcoi, fov, bounds);
        var up  = reorient ? this.computeOrthogonalUp(pos, oldcoi) : _camera.up;

        if( immediate )
        {
            _camera.up.copy(up);
            this.setView(fit.position, fit.target);
        }
        else
        {
            this.setRequestTransitionWithUp( true, fit.position, fit.target, fov, up );
        }
        this.setPivotPoint(fit.target);
        this.setPivotSetFlag(true);

        return fit;
    };


    /**
     * Update the current camera projection matrix and orient the camera to the current look at point.
     * Invoked internally prior to rendering a new frame with the current camera.
     */
    this.updateCamera = function()
    {
        if( _camera )
        {
            _camera.updateProjectionMatrix();
            this.orient( _camera, _camera.target, _camera.position, _camera.up );
            _camera.dirty = false;
        }
    };

    this.setCamera(camera);
};

Navigation.prototype.constructor = Navigation;


Navigation.prototype.setIs2D = function( state )
{
    this.__is2D = !!state;
};

Navigation.prototype.getIs2D = function()
{
    return this.__is2D;
};

Navigation.prototype.setIsTouchDevice = function( state )
{
    this.__isTouchDevice = !!state;
};

Navigation.prototype.getIsTouchDevice = function()
{
    return this.__isTouchDevice;
};

/**
 * Rotate the given object so that its negative Z axis is directed towards the given point in world space. Used internally to orient the camera towards the target look at point. This is a modified version of the Object3D.lookAt method that uses different solution for the singular case when (view X up) == 0.
 *  @method
 *  @param {THREE.Object3D} object - the object to be oriented
 *  @param {THREE.Vector3} target - the world space point to orient towards
 *  @param {THREE.Vector3} from - the world space position of the object being rotated
 *  @param {THREE.Vector3} up - the direction to align the objects Y axis with
 */
Navigation.prototype.orient = function()
{
    var m1;
    var x;
    var y;
    var z;

    function init_three() {
        if (m1)
            return;

        m1 = new THREE.Matrix4();
        x = new THREE.Vector3();
        y = new THREE.Vector3();
        z = new THREE.Vector3();
    }

    return function ( object, target, from, up )
    {
        init_three();

        var te = m1.elements;

        z.subVectors( from, target ).normalize();
        if ( z.lengthSq() === 0 ) {
            z.z = 1;
        }
        x.crossVectors( up, z ).normalize();
        if ( x.lengthSq() === 0 ) {
            // If Z is up then cross with Y to get X
            // otherwize cross with Z to get X.
            if( up.z > up.y )
                z.y -= 0.0001;
            else
                z.z += 0.0001;

            x.crossVectors( up, z ).normalize();
        }
        y.crossVectors( z, x );

        te[0] = x.x; te[4] = y.x; te[8] = z.x;
        te[1] = x.y; te[5] = y.y; te[9] = z.y;
        te[2] = x.z; te[6] = y.z; te[10] = z.z;

        object.setRotationFromMatrix( m1 );
    };
}();

/**
 * Convert a vertical field of view angle in degrees to a 35mm camera focal length value.
 *  @param {number} fov - vertical field of view in degrees
 *  @returns {number} focal length in millimeters
 */
Navigation.prototype.fov2fl = function ( fov )
{
    // Note: the size of the 35mm camera back is 36x24mm.  Since we are setting and
    // getting the vertical FOV, we need to use the vertical measurement of 24mm, or
    // rather half of that (12.0) in our calculations.
    var k35mmVerticalCameraBackSize = 12.0;

    // Given a vertical field-of-view, return the focal length in millimeters
    // that it corresponds to in a 35mm film camera.
    var rads = THREE.Math.degToRad(fov);
    if (rads <= 0.0)
        rads = 0.0001;
    return Math.round( k35mmVerticalCameraBackSize / Math.tan(rads * 0.5) );
};

/**
 * Convert a 35mm camera focal length value to a vertical field of view angle in degrees.
 *  @param {number} fl - focal length in millimeters
 *  @returns {number} vertical field of view in degrees
 */
Navigation.prototype.fl2fov = function ( fl )
{
    // Note: the size of the 35mm camera back is 36x24mm.  Since we are setting and
    // getting the vertical FOV, we need to use the vertical measurement of 24mm, or
    // rather half of that (12.0) in our calculations.
    var k35mmVerticalCameraBackSize = 12.0;

    // Given a focal length, return the vertical field of view that
    // this would correspond to in a 35mm camera.
    if (fl <= 0)
        fl = 0.0001;

    var rads = 2.0 * Math.atan(k35mmVerticalCameraBackSize / fl);
    return THREE.Math.radToDeg(rads);
};

/**
 * Set the up direction for the camera. The given vector should be orthogonal to the current view direction.
 *  @method
 *  @param {THREE.Vector3} up - the new up direction vector
 */
Navigation.prototype.setCameraUpVector = function(up)
{
    if( this.isActionEnabled('roll') )
    {
        var camera = this.getCamera();
        camera.up.copy(up);
        camera.dirty = true;
    }
};

/**
 * Get the world space vector which is the current cameras up direction.
 *  @method
 *  @returns {THREE.Vector3} the current camera up direction (normalized)
 */
Navigation.prototype.getCameraUpVector = function()
{
    var right = this.getCameraRightVector(false);
    var eye   = this.getEyeVector();
    return right.cross(eye).normalize();
};

/**
 * Get the world space vector which is the orthogonal to the view direction and aligned with the world up direction.
 *  @method
 *  @returns {THREE.Vector3} the current camera up direction (normalized)
 */
Navigation.prototype.getAlignedUpVector = function()
{
    var right = this.getCameraRightVector(true);
    var eye   = this.getEyeVector();
    return right.cross(eye).normalize();
};

/**
 * Get the world space vector which is the right side direction of the current camera.
 *  @method
 *  @param {boolean} worldAligned - if true get the right vector aligned with the world up, otherwise use the current camera's up direction.
 *  @returns {THREE.Vector3} the current camera right direction, orthogonal to view and up (normalized)
 */
Navigation.prototype.getCameraRightVector = function(worldAligned)
{
    var right = new THREE.Vector3();
    var up  = worldAligned ? this.getWorldUpVector() : this.getCamera().up;
    var eye = this.getEyeVector();
    right.crossVectors(eye, up);
    if( right.lengthSq() === 0 )
    {
        // If eye and up are colinear, perturb eye
        // to get a valid result:
        if( up.z > up.y )
            eye.y -= 0.0001;
        else
            eye.z += 0.0001;

        right.crossVectors(eye, up);
    }
    return right.normalize();
};

/**
 * Change the current world up direction.
 *  @param {THREE.Vector3} up - the new world up direction
 *  @param {boolean} reorient - if true, make sure the camera up is oriented towards the world up direction.
 */
Navigation.prototype.setWorldUpVector = function(up, reorient)
{
    if( this.isActionEnabled('roll') )
    {
        this.__setUp(up);

        if( reorient )
            this.orientCameraUp();
    }
};

/**
 * Get the current world up direction.
 *  @returns {THREE.Vector3} the current world up direction (normalized)
 */
Navigation.prototype.getWorldUpVector = function()
{
    return this.__getUp().clone();
};

/**
 * Compute a world right direction based on the current world up direction. This will return the normalized cross product of the current up direction with one of the major axes to provide a usable world right direction.
 *  @method
 *  @returns {THREE.Vector3} the computed world right direction
 */
Navigation.prototype.getWorldRightVector = function()
{
    var right = new THREE.Vector3();
    right.copy(this.__getUp());

    if (Math.abs(right.z) <= Math.abs(right.y))
    {
        // Cross(Vertical, ZAxis)
        right.set(right.y, -right.x, 0);
    }
    else if (right.z >= 0)
    {
        // Cross(YAxis, Vertical)
        right.set(right.z, 0, -right.x);
    }
    else
    {
        // Cross(Vertical, YAxis)
        right.set(-right.z, 0, right.x);
    }
    return right.normalize();
};

/**
 *  @returns {number} the current camera vertical field of view in degrees
 */
Navigation.prototype.getVerticalFov = function()
{
    return this.getCamera().fov;
};

/**
 *  @returns {number} the current camera horizontal field of view in degrees
 */
Navigation.prototype.getHorizontalFov = function()
{
    var viewport = this.getScreenViewport();
    return this.getCamera().fov * (viewport.width / viewport.height);
};

/**
 *  @returns {number} the current camera focal length based on a 35mm camera lens model
 */
Navigation.prototype.getFocalLength = function()
{
    return this.fov2fl(this.getVerticalFov());
};

/**
 * Set the current cameras field of view using a 35mm camera focal length value
 *  @param {number} millimeters - focal length in millimeters
 *  @param {boolean} adjustPosition - If true, the camera position will be modified to keep either the world space area
 *                                    of the view at the pivot point unchanged (if it is set and visible) or the world
 *                                    space area of view at the camera look at point unchanged.
 */
Navigation.prototype.setFocalLength = function(millimeters, adjustPosition)
{
    this.setVerticalFov(this.fl2fov(millimeters), adjustPosition);
};

/**
 * Set or unset a view navigation option to reverse the default direction for camera dolly (zoom) operations.
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Navigation.prototype.setReverseZoomDirection = function( state )
{
    this.__options.reverseDolly = !!state;
};

/**
 * Set or unset a view navigation option to reverse the default direction for horizontal look operations.
 *
 * Not applicable to 2D.
 *
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Navigation.prototype.setReverseHorizontalLookDirection = function( state )
{
    if( this.getIs2D() )
    {
        console.warn("Autodesk.Viewing.Navigation.setReverseHorizontalLookDirection is not applicable to 2D");
        return;
    }

    this.__options.reverseHorizontalLookDirection = !!state;
};

/**
 * Set or unset a view navigation option to reverse the default direction for vertical look operations.
 *
 * Not applicable to 2D.
 *
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Navigation.prototype.setReverseVerticalLookDirection = function( state )
{
    if( this.getIs2D() )
    {
        console.warn("Autodesk.Viewing.Navigation.setReverseVerticalLookDirection is not applicable to 2D");
        return;
    }

    this.__options.reverseVerticalLookDirection = !!state;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default direction for camera dolly (zoom) operations.
 *  @returns {boolean} - value of the option, true for reverse, false for default
 */
Navigation.prototype.getReverseZoomDirection = function()
{
    return this.__options.reverseDolly;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default horizontal look direction
 *
 * Not applicable to 2D.
 *
 *  @returns {boolean} value of the option, true for reverse, false for default
 */
Navigation.prototype.getReverseHorizontalLookDirection = function()
{
    if( this.getIs2D() )
    {
        console.warn("Autodesk.Viewing.Navigation.getReverseHorizontalLookDirection is not applicable to 2D");
        return false;
    }

    return this.__options.reverseHorizontalLookDirection;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default vertical look direction
 *
 * Not applicable to 2D.
 *
 *  @returns {boolean} value of the option, true for reverse, false for default
 */
Navigation.prototype.getReverseVerticalLookDirection = function()
{
    if( this.getIs2D() )
    {
        console.warn("Autodesk.Viewing.Navigation.getReverseVerticalLookDirection is not applicable to 2D");
        return false;
    }

    return this.__options.reverseVerticalLookDirection;
};

/**
 * Set or unset a view navigation option to request the default direction for camera dolly (zoom) operations to be towards the camera pivot point. If unset the default direction would normally be towards the cursor position.
 *  @param {boolean} state - value of the option, true for towards the pivot, false for default
 */
Navigation.prototype.setZoomTowardsPivot = function( state )
{
    this.__options.dollyToPivot = !!state;
};

/**
 * Get the state of the view navigation option that requests the default direction for camera dolly (zoom) operations to be towards the camera pivot point.
 *  @returns {boolean} - value of the option, true for towards the pivot, false for default
 */
Navigation.prototype.getZoomTowardsPivot = function()
{
    return this.__options.dollyToPivot;
};

/**
 * Set or unset a view navigation option to allow the orbit controls to move the camera beyond the north and south poles (world up/down direction). In other words, when set the orbit control will allow the camera to rotate into an upside down orientation. When unset orbit navigation should stop when the camera view direction reaches the up/down direction.
 *
 * Not applicable to 2D.
 *
 *  @param {boolean} state - value of the option, true to allow orbiting past the poles.
 */
Navigation.prototype.setOrbitPastWorldPoles = function( state )
{
    if( this.getIs2D() )
    {
        console.warn("Autodesk.Viewing.Navigation.setOrbitPastWorldPoles is not applicable to 2D");
        return;
    }

    this.__options.orbitPastPoles = !!state;
};

/**
 * Get the state of the view navigation option that allows orbit controls to continue past the world up/down direction.
 *
 * Not applicable to 2D.
 *
 *  @returns {boolean} - value of the option, true if orbiting past the poles is allowed.
 */
Navigation.prototype.getOrbitPastWorldPoles = function()
{
    if( this.getIs2D() )
    {
        console.warn("Autodesk.Viewing.Navigation.orbitPastWorldPoles is not applicable to 2D");
        return false;
    }

    return this.__options.orbitPastPoles;
};

/**
 * Set or unset a view navigation option which requests that orbit controls always orbit around the currently set pivot point.
 *  @param {boolean} state - value of the option, true to request use of the pivot point. When false some controls may pivot around the center of the view. (Currently applies only to the view-cube orbit controls.)
 */
Navigation.prototype.setUsePivotAlways = function( state )
{
    this.__options.usePivotAlways = !!state;
};

/**
 * Get the state of the view navigation option that requests full use of the pivot point.
 *  @returns {boolean} - value of the option, if the pivot should be used as the orbit origin.
 */
Navigation.prototype.getUsePivotAlways = function()
{
    return this.__options.usePivotAlways;
};

/**
 * Set or unset a view navigation option which requests that mouse buttons be reversed from their default assignment. i.e. Left mouse operation becomes right mouse and vice versa.
 *  @param {boolean} state - value of the option, true to request reversal of mouse button assignments.
 */
Navigation.prototype.setUseLeftHandedInput = function( state )
{
    this.__options.useLeftHandedInput = !!state;
};

/**
 * Get the state of the view navigation option that requests mouse button reversal.
 *  @returns {boolean} - value of the option, true if reversal is requested.
 */
Navigation.prototype.getUseLeftHandedInput = function()
{
    return this.__options.useLeftHandedInput;
};

/**
 * Lock or unlock view modification operations.
 * For a more granular control of locked operations, see {@link setLockSettings}.
 *  @param {boolean} state - when true changes to the current camera parameters are not allowed.
 */
Navigation.prototype.setIsLocked = function( state )
{
    this.__options.lockNavigation = !!state;
};

/**
 * Get the state of the current view modification lock.
 * For a more granular control of locked operations, see {@link setLockSettings}.
 *  @returns {boolean} - true if view modifications are not currently allowed.
 */
Navigation.prototype.getIsLocked = function()
{
    return this.__options.lockNavigation;
};

/**
 * Set the availability of specific camera actions when navigation is locked using {@link setIsLocked}.
 *  @param {object} settings Map of <action>:<bool> pairs specifying whether the given camera
 *  action is *enabled* even when the navigation is locked.
 *  The configurable actions are 'orbit', 'pan', 'zoom', 'roll', 'fov', or 'gotoview'.
 *  By default, none of the camera actions are available when the navigation is locked.
 */
Navigation.prototype.setLockSettings = function(settings)
{
    for (var action in this.__lockSettings) {
        if (settings.hasOwnProperty(action)) {
            this.__lockSettings[action] = settings[action];
        }
    }
};

/**
 * Get the availability of specific camera actions when navigation is locked using {@link setIsLocked}.
 *  @returns {object} Map of <action>:<bool> pairs specifying whether the given camera
 *  action is *enabled* even when the navigation is locked.
 */
Navigation.prototype.getLockSettings = function()
{
    var settings = {};
    for (var action in this.__lockSettings) {
        settings[action] = this.__lockSettings[action];
    }
    return settings;
};

/**
 * Check the availability of a camera action.
 *  @param {string} action Camera action.
 *  @returns {boolean} True if the camera action is currently enabled.
 */
Navigation.prototype.isActionEnabled = function(action) {
    return !this.__options.lockNavigation || this.__lockSettings[action] === true;
};

/**
 * Set or unset a view navigation option which indicates that the pivot camera parameter is set and can be used for orbit and zoom controls.
 *  @param {boolean} state - value of the option. When not set orbit and zoom operations should occur at the look at position in the center of the current view.
 */
Navigation.prototype.setPivotSetFlag = function( state )
{
    this.__pivotIsSetFlag = !!state;
};

/**
 * Get the state of the view navigation option that indicates the pivot is set.
 *  @returns {boolean} - value of the option, true if pivot may be used.
 */
Navigation.prototype.getPivotSetFlag = function()
{
    return this.__pivotIsSetFlag;
};

/**
 * Issue a request to change the current cameras view position to fit the active model data into the current view frustum.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view.
 */
Navigation.prototype.setRequestFitToView = function( state )
{
    if( this.isActionEnabled('gotoview') )
        this.__fitToViewRequested = !!state;
};

/**
 * Get the state of the view navigation option requesting a camera repositioning to fit the active model data. Value will be false if a request has not been made or if having been made has been received and acted upon.
 *  @returns {boolean} - current state of the request.
 */
Navigation.prototype.getRequestFitToView = function()
{
    return this.__fitToViewRequested;
};

/**
 * Issue a request to change the current cameras view to the current "home" view. The home view includes position, view direction, world up direction and field of view.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view.
 */
Navigation.prototype.setRequestHomeView = function( state )
{
    if( this.isActionEnabled('gotoview') )
        this.__homeViewRequested = !!state;
};

/**
 * Get the state of the view navigation option requesting a camera change to the current "home" view. Value will be false if a request has not been made or if having been made has been received and acted upon.
 *  @returns {boolean} - current state of the request.
 */
Navigation.prototype.getRequestHomeView = function()
{
    return this.__homeViewRequested;
};

/**
 * Issue a request to transition the current cameras view to that specified by the parameters.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view.
 *  @param {THREE.Vector3} pos - the new camera position in world space
 *  @param {THREE.Vector3} coi - the point in world space that the camera should look towards.
 *  @param {number} fov - vertical field of view in degrees
 *  @param {boolean} reorient - set to true to recalculate up vector
 */
Navigation.prototype.setRequestTransition = function( state, pos, coi, fov, reorient )
{
    if( state )
    {
        this.__destinationView = {
            position: pos.clone(),
                 coi: coi.clone(),
                 fov: fov,
                  up: this.getCamera().up.clone(),
             worldUp: this.getWorldUpVector(),
            reorient: reorient
        };
    }
    else
        this.__destinationView = null;
};

/**
 * Issue a request to transition the current cameras view to that specified by the parameters which inlude both the camera up direction and optionally the world up direction.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view.
 *  @param {THREE.Vector3} pos - the new camera position in world space
 *  @param {THREE.Vector3} coi - the point in world space that the camera should look towards.
 *  @param {number} fov - vertical field of view in degrees
 *  @param {THREE.Vector3} up -  use this as the target camera up direction
 *  @param {THREE.Vector3} worldUp - (optional) use this as the target world up direction
 */
Navigation.prototype.setRequestTransitionWithUp = function( state, pos, coi, fov, up, worldUp )
{
    if( state )
    {
        this.__destinationView = {
            position: pos.clone(),
                 coi: coi.clone(),
                 fov: fov,
                  up: up.clone(),
             worldUp: worldUp ? worldUp : this.getWorldUpVector(),
            reorient: false
        };
    }
    else
        this.__destinationView = null;
};

/**
 * Get the state of the view navigation option requesting a camera transition to a new view.
 *  @returns {Object} - If a transition request is active, an object with properties "position" (Vector3), "coi" (Vector3), "fov" (Number), "up" (Vector3), "worldUp" (Vector3), "reorient" (boolean). Returns null when no transition is active.
 *  @see setRequestTransitionWithUp
 */
Navigation.prototype.getRequestTransition = function()
{
    return this.__destinationView;
};

/**
 * Set a status indicating that the current camera view is in a transitioning state.
 * Used internally to indicate that a transition is active.
 *  @param {boolean} state - value of the transtion status
 */
Navigation.prototype.setTransitionActive = function( state )
{
    this.__transitionActive = !!state;
};

/**
 *  Check the status of a view transition request.
 *  @returns {boolean} - value of the transtion status
 */
Navigation.prototype.getTransitionActive = function()
{
    return this.__transitionActive;
};

/**
 *  @param {number} atDistance - Distance from the camera at which to compute the view frustum size.
 *  @returns {THREE.Vector2} The size of the view frustum at this distance from the camera.
 */
Navigation.prototype.getWorldSize = function(atDistance)
{
    var viewport = this.getScreenViewport();
    var aspect = viewport.width / viewport.height;
    var worldHeight = 2.0 * atDistance * Math.tan(THREE.Math.degToRad(this.getCamera().fov * 0.5));
    var worldWidth  = worldHeight * aspect;

    return new THREE.Vector2(worldWidth, worldHeight);
};

/**
 *  Get a world point from normalized screen coordinates by projecting to the plane at the pivot point.
 *  @param {number} x - Normalized screen X coordinate in [0, 1] range (left == 0)
 *  @param {number} y - Normalized screen Y coordinate in [0, 1] range (top == 0)
 *  @returns {THREE.Vector3} - Point in world space
 */
Navigation.prototype.getWorldPoint = function(x, y)
{
    /*
    var x = (mouseX - this.viewport.left) / this.viewport.width;
    var y = (mouseY - this.viewport.top) / this.viewport.height;
    */
    y = 1.0 - y;    // Invert Y so 0 == bottom and map to [-1, 1]
    x = x * 2.0 - 1.0;
    y = y * 2.0 - 1.0;
    var camera = this.getCamera();
    var clickPoint;

    if( camera.isPerspective )
    {
        clickPoint = new THREE.Vector3(x, y, 1.0);
        clickPoint = clickPoint.unproject(camera);
    }
    var view     = this.getEyeVector();
    var position = this.getPosition();
    var direction, distance;

    if( !camera.isPerspective || isNaN(clickPoint.x) )
    {
        // Calculate a point based on the view...
        var xysize = this.getWorldSize(view.length());
        var trackX = this.getCameraRightVector(false).multiplyScalar( (x * 0.5) * xysize.x );
        var trackY = this.getCameraUpVector().multiplyScalar( (y * 0.5) * xysize.y );
        direction = view.clone().add(trackX).add(trackY).normalize();
        // console.log("GWP: ALT(" + direction.x.toFixed(3) + ", "+ direction.y.toFixed(3) + ", "+ direction.z.toFixed(3) + ")" + x + ", " + y);
    }
    else
    {
        direction = clickPoint.sub(position).normalize();
        // console.log("GWP: DIR(" + direction.x.toFixed(3) + ", "+ direction.y.toFixed(3) + ", "+ direction.z.toFixed(3) + ")");
    }
    var pivot = this.getPivotPoint();
    var usePivot = this.__pivotIsSetFlag && (this.getIs2D() || (camera.isPerspective && this.isPointVisible(pivot)));
    if( usePivot )
    {
        var denominator = direction.dot(view);
        distance = (denominator !== 0.0)
                 ? Math.abs(pivot.sub(position).dot(view)) / denominator
                 : pivot.sub(position).length();
    }
    else
    {
        distance = camera.isPerspective ? (camera.near + camera.far) * 0.5
                                        : camera.orthoScale;
    }
    return direction.multiplyScalar(distance).add(position);
};

/**
 * @returns {number} - The perpendicular distance from the camera to the plane containing the pivot point.
 */
Navigation.prototype.getPivotPlaneDistance = function()
{
    var pivot = this.getPivotPoint();
    var view  = this.getEyeVector();
    var position = this.getPosition();

    return pivot.sub(position).dot(view.normalize());
};

/**
 * Pan the camera a relative distance up/down or left/right.
 *  @param {number} deltaX - Normalized X distance to pan left/right (negative/positive).
 *  @param {number} deltaY - Normalized Y distance to pan down/up (negative/positive).
 *  @param {number} atDistance - Pan distance is scaled by the size of the view frustum at this distance from the camera.
 */
Navigation.prototype.panRelative = function( deltaX, deltaY, atDistance )
{
    if (!this.isActionEnabled('pan')) {
        return;
    }

    var trackSpeed = this.getWorldSize(atDistance);
    var offsetX = deltaX * trackSpeed.x;
    var offsetY = deltaY * trackSpeed.y;

    var trackX = this.getCameraRightVector(false).multiplyScalar( offsetX );
    var trackY = this.getCameraUpVector().multiplyScalar( offsetY );

    var offsetVector = trackX.add(trackY);

    this.setView( this.getPosition().add(offsetVector), this.getTarget().add(offsetVector) );
};

/**
 * Dolly the camera a distance along the vector from a given point to its current position. The dolly distance is clamped to not go past the point.
 *  @param {number} distance - World space distance to move the camera by.
 *  @param {THREE.Vector3} point - World space position used to define the dolly direction.
 */
Navigation.prototype.dollyFromPoint = function( distance, point )
{
    if( !this.isActionEnabled('zoom') || Math.abs(distance) <= this.__kEpsilon )
        return;

    var position = this.getPosition();
    var dollyVec = point.clone().sub(position);
    var oldLength = dollyVec.length();
    var newLength = oldLength + distance;
    var kMinDistance = this.__kEpsilon * 10;    // ???
    if( newLength < kMinDistance )
        newLength = kMinDistance;

    var scaleFactor = newLength / oldLength;
    if( Math.abs(scaleFactor - 1.0) > this.__kEpsilon )
    {
        dollyVec.multiplyScalar( scaleFactor );
        dollyVec.set(-dollyVec.x, -dollyVec.y, -dollyVec.z);
        var newPosition = dollyVec.add(point);

        // Compute a new look at point from the new position:
        var viewVec = this.getEyeVector();

        // For ortho cameras we must scale the view vector to actually
        // perform an ortho zoom operation:
        if( !this.getCamera().isPerspective )
            viewVec.multiplyScalar( scaleFactor );

        this.setView( newPosition, viewVec.add(newPosition) );
    }
};

/**
 *  Change current camera to perspective camera.
 *
 *  Not applicable to 2D.
 */
Navigation.prototype.toPerspective = function()
{
    if( this.getIs2D() )
    {
        console.warn("Autodesk.Viewing.Navigation.toPerspective is not applicable to 2D");
        return;
    }

    var camera = this.getCamera();

    if( !camera.isPerspective )
    {
        // stderr("Nav: toPerspective");
        camera.toPerspective();
        camera.dirty = true;
    }
};

/**
 *  Change current camera to orthographic camera
 */
Navigation.prototype.toOrthographic = function()
{
    var camera = this.getCamera();

    if( camera.isPerspective )
    {
        // stderr("Nav: toOrtho");
        camera.toOrthographic();
        camera.dirty = true;
    }
};


Navigation.snapToAxis = function(v) {
    var absv = new THREE.Vector3(Math.abs(v.x), Math.abs(v.y), Math.abs(v.z));

    if (absv.x > absv.y && absv.x > absv.z)
        v.set(v.x > 0 ? 1 : -1, 0, 0);
    else if (absv.y > absv.x && absv.y > absv.z)
        v.set(0, v.y > 0 ? 1 : -1, 0);
    else
        v.set(0, 0, v.z > 0 ? 1 : -1);

    return v;
};

Autodesk.Viewing.Navigation = Navigation;

})();
;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

(function() {

"use strict";

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

/**
 * Attach ViewingApplication to a div by id
 * and initializes common properties of the viewing application
 *
 * @class
 * @alias Autodesk.Viewing.ViewingApplication
 * @param {string} containerId - The id of the main container
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {bool} [options.disableBrowserContextMenu=true] - Disables the browser's default context menu.
 * @constructor
 */
var ViewingApplication = function(containerId, options) {
    this.appContainerId = containerId;
    this.container = document.getElementById(containerId);
    this.options = options;
    this.myRegisteredViewers = {};
    this.myDocument = null;
    this.myCurrentViewer = null;
    this.urn = null;
    this.selectedItem = null;
};

/**
 * Defines the 3D viewer type
 */
ViewingApplication.prototype.k3D = '3D';
/**
 * Defines the 2D viewer type
 */
ViewingApplication.prototype.k2D = '2D';


/**
 * Performs any necessary cleanup to allow the object to be garbage collected
 */
ViewingApplication.prototype.finish = function() {
    if (this.myCurrentViewer) {
        this.myCurrentViewer.finish();
        this.myCurrentViewer = null;
    }   
};

/**
 * Register a Viewer to be used with this ViewingApplication
 *
 * @param {} viewableType
 * @param {} viewerClass
 * @param {} config
 */
ViewingApplication.prototype.registerViewer = function(viewableType, viewerClass, config) {
    // Pass the disableBrowserContextMenu option down to the viewer config.
    //
    config = config || {};
    if (this.options && this.options.hasOwnProperty("disableBrowserContextMenu")) {
        // Don't override if the option was already explicitly specified.
        //
        if (!config.hasOwnProperty("disableBrowserContextMenu")) {
            config.disableBrowserContextMenu = this.options.disableBrowserContextMenu;
        }
    }

    this.myRegisteredViewers[viewableType] = {};
    this.myRegisteredViewers[viewableType].class = viewerClass;
    this.myRegisteredViewers[viewableType].config = config;
};

ViewingApplication.prototype.getViewerClass = function(viewableType) {
    return this.myRegisteredViewers.hasOwnProperty(viewableType) ? this.myRegisteredViewers[viewableType].class : null;
};

/**
 * Returns the container that will be used by the viewer
 * By default uses the same container as the appContainer
 * This method can be overridden to specify a different
 * sub container for the viewer
 *
 * @return MemberExpression
 */
ViewingApplication.prototype.getViewerContainer = function() {
    return document.getElementById(this.appContainerId);
};

/**
 * Returns a new instance of a Viewer of requested type
 *
 * @param {string} viewableType
 * @param {Object} config - Viewer configuration override.
 * @param {function(int,string)} onErrorCallback - this method is called when the viewer failed to initialize.
 * @return Viewer or null
 */
ViewingApplication.prototype.getViewer = function(viewableType, config, onErrorCallback) {
    if (viewableType in this.myRegisteredViewers) {

        // Merge the config object provided here with the config object provided
        // when the viewer type was registered. The former takes precedence.
        //
        var mergedConfig = {};
        var registeredViewerConfig = this.myRegisteredViewers[viewableType].config;
        var name;

        for (name in registeredViewerConfig) {
            if (registeredViewerConfig.hasOwnProperty(name)) {
                mergedConfig[name] = registeredViewerConfig[name];
            }
        }
        for (name in config) {
            if (config.hasOwnProperty(name)) {

                var configValue = config[name],
                    configValueIsArray = Array.isArray(configValue),
                    mergedConfigValue = mergedConfig[name],
                    mergedConfigValueIsArray = Array.isArray(mergedConfigValue);

                // If neither config value is an array, then the config value passed to
                // getViewer() overwrites the config value registered for this viewer.
                //
                if (!configValueIsArray || !mergedConfigValueIsArray) {
                    mergedConfig[name] = configValue;

                } else {

                    // But if one or the other config value is an array, then let's
                    // concatenate them. We need to make them both arrays to do that:
                    // they might be null/undefined, or they might be strings.
                    //
                    if (configValue) {
                        if (!configValueIsArray) {
                            configValue = [configValue];
                        }
                    } else {
                        configValue = [];
                    }
                    if (mergedConfigValue) {
                        if (!mergedConfigValueIsArray) {
                            mergedConfigValue = [mergedConfigValue];
                        }
                    } else {
                        mergedConfigValue = [];
                    }
                    mergedConfig[name] = mergedConfigValue.concat(configValue);

                }
            }
        }

        var viewerClass = this.myRegisteredViewers[viewableType].class;

        if (this.myCurrentViewer && this.myCurrentViewer.__proto__.constructor === viewerClass) {
            this.myCurrentViewer.tearDown();
            this.myCurrentViewer.setUp(mergedConfig);
            return this.myCurrentViewer;
        }

        this.setCurrentViewer(null);

        // If previous viewer.initialize() failed, then clean it up now.
        // This might happen if, for instance, we had a 3d viewer but
        // WebGL is not supported.
        // TODO: need a better solution
        //
        var container = this.getViewerContainer();
        while (container.hasChildNodes()) {
            container.removeChild(container.lastChild);
        }

        var viewer = new viewerClass(container, mergedConfig);
        var viewerInitCode = viewer.start();
        if (viewerInitCode === 0) {        // There were no errors initializing.
            this.setCurrentViewer(viewer);
            return viewer;
        }
        else {  // Initialization returned an error code.
            if (onErrorCallback)
                onErrorCallback( viewerInitCode, "Viewer failed to initialize" );
        }
    }
    return null;
};

/**
 * Sets this ViewingApplication's viewer to the provided viewer
 *
 *  @param {} viewer
 */
ViewingApplication.prototype.setCurrentViewer = function(viewer) {
    if (this.myCurrentViewer) {
        this.myCurrentViewer.finish();
    }
    this.myCurrentViewer = viewer;
};

/**
 * Returns the currently set Viewer
 *
 *  @return Viewer
 */
ViewingApplication.prototype.getCurrentViewer = function() {
    return this.myCurrentViewer;
};

/**
 * Asynchronously loads the document given its documentId
 * On success: Calls onDocumentLoadedCallback
 * On error: Calls onDocumentFailedToLaod callback
 *
 * @param {} documentId
 * @param {function} [onDocumentLoad]
 * @param {function} [onLoadFailed]
 * @param {dictionary} accessControlProperties - An optional list of key value pairs as access control properties, which includes a list of
 *  access control header name and values, and an OAuth 2.0 access token.
 */
ViewingApplication.prototype.loadDocument = function(documentId, onDocumentLoad, onLoadFailed, accessControlProperties) {
    var that = this;

    if (avp.logger) {
        avp.logger.log({
            category : "load_document",
            urn: (documentId.indexOf("urn:") == 0) ? documentId.substring(4) : documentId
        });
    }

    av.Document.load(documentId,
        function(document, errorsandwarnings) { // onLoadCallback
            that.myDocument = document;
            that.onDocumentLoaded(document, errorsandwarnings);
            if (onDocumentLoad) {
                onDocumentLoad(document, errorsandwarnings);
            }
        },
        function(errorCode, errorMsg, statusCode, statusText, errors) { // onErrorCallback
            that.onDocumentFailedToLoad(errorMsg, errorCode, errors);
            if (onLoadFailed)
                onLoadFailed(errorCode, errorMsg, statusCode, statusText, errors);
        },
        accessControlProperties
    );
};

/**
 * Default success callback for loadDocument
 * Logs the document that was loaded on console
 *
 * @param {} document
 */
ViewingApplication.prototype.onDocumentLoaded = function(document, errorsandwarnings) {
    console.log(document, errorsandwarnings);
};

/**
 * Default success callback for documentFailedToLoad
 * Logs the document that was loaded on console
 *
 * @param {string} errorCode - globalized error code.
 * @param {string} errorMsg  - error message to display
 * @parma {Array}  errors    - list of errors that come from other clients (translators)
 */
ViewingApplication.prototype.onDocumentFailedToLoad = function( errorCode, errorMsg, errors ) {
    console.log(errorCode, errorMsg, errors);
};

/**
 * Given a list of geometry items, possibly fetched through Autodesk.Viewing.Document.getSubItemsWithProperties,
 * it will return 1 single item from the list that should be the first one to be loaded.
 * The method will attempt to find the item marked with attribute 'useAsDefault' with true.
 * When none is found, it will return the first element from the list.
 *
 * @param {Array} geometryItems
 * @return {Object} item element contained in geometryItems
 */
ViewingApplication.prototype.getDefaultGeometry = function(geometryItems) {
    // Attempt to find the item marked with 'useAsDefault'
    for (var i= 0, len=geometryItems.length; i<len; ++i) {
        var isDefault = geometryItems[i]['useAsDefault'];
        if (isDefault === true || isDefault === 'true') {
            return geometryItems[i];
        }
    }
    return geometryItems[0];
};

/**
 * Asynchronously loads an individual item from a document into the correct viewer
 *
 * @param {} item
 * @param {} onSuccessCallback - This call back is called when the item is selected
 * @param {} onErrorCallback - This call back is called when the item fails to select.
 * @return Boolean
 */
ViewingApplication.prototype.selectItem = function(item, onSuccessCallback, onErrorCallback) {
    var urnToLoad = this.myDocument.getViewablePath(item);

    if (urnToLoad) {
        var viewerType, viewItem, title, viewGeometryItem, modelUnits;
        if (item.type === 'geometry' && item.role === '3d') {
            // This is for the case that initial view is a child of geometry in some DWF files
            // Set this view's camera as initial camera
            //var children = item.children;
            //if (children) {
            //    for (var i in children) {
            //        if (children.hasOwnProperty(i) && children[i].type === 'view') {
            //            viewItem = children[i];
            //            break;
            //        }
            //    }
            //}
            // This is for Revit files that have model units in bubble.json
            var properties = item.properties;
            if (properties) {
                for (var i in properties) {
                    if (properties.hasOwnProperty(i) && properties[i]._UnitLinear) {
                        modelUnits = properties[i]._UnitLinear;
                        break;
                    }
                }
            }
            viewerType = this.k3D;
            title = item.name;
            viewGeometryItem = item;
        } else if (item.type === "view" && item.role === "3d") {
            viewItem = item;
            viewerType = this.k3D;
            viewGeometryItem = this.myDocument.getViewGeometry(item);
            if (viewGeometryItem) {
                title = viewGeometryItem.name;
            }
        } else if (item.type === 'geometry' && item.role === '2d') {
            var subitems = Autodesk.Viewing.Document.getSubItemsWithProperties(item, {
                'mime': 'application/autodesk-f2d'
            }, false);

            if (subitems.length >0)
                viewerType= this.k3D;
            else
                viewerType = this.k2D;
            title = item.name;
            viewGeometryItem = item;
        } else if (item.type === 'view' && item.role === '2d') {
            viewItem = item;
            viewerType = this.k3D;
            viewGeometryItem = this.myDocument.getViewGeometry(item);
            if (viewGeometryItem) {
                title = viewGeometryItem.name;
            }
        }

        var logger = avp.logger;
        if (logger) {
            var idx = urnToLoad.indexOf("urn:");
            logger.log({
                category : "load_viewable",
                role : item.role,
                type : item.type,
                urn: (idx !== -1) ? urnToLoad.substring(idx+4) : urnToLoad
            });
        }
        

        // Check if there are any warnign or errors from translators.
        // Exclude the global ones (ones from the root node).
        var messages = this.myDocument.getMessages( item, true );

        if(viewerType) {
            var self = this;
            var urnAlreadyLoaded = (this.myCurrentViewer && this.urn === urnToLoad);
            var onLoadCallback = null;

            if (viewItem && viewItem.camera) {
                onLoadCallback = function() {
                    self.myCurrentViewer.setViewFromArray(viewItem.camera, viewItem.name);
                    if (modelUnits) {
                        self.myCurrentViewer.setModelUnits(modelUnits);
                    }
                    if(onSuccessCallback) {
                        onSuccessCallback(self.myCurrentViewer, item, messages );
                    }
                };
            } else if (viewItem && viewItem.viewbox) {
                onLoadCallback = function() {
                    self.myCurrentViewer.setViewFromViewBox(viewItem.viewbox, viewItem.name);
                    if (modelUnits) {
                        self.myCurrentViewer.setModelUnits(modelUnits);
                    }
                    if(onSuccessCallback) {
                        onSuccessCallback(self.myCurrentViewer, item, messages );
                    }
                };
            } else if (urnAlreadyLoaded) {
                onLoadCallback = function() {
                    self.myCurrentViewer.setViewFromFile();
                    if (modelUnits) {
                        self.myCurrentViewer.setModelUnits(modelUnits);
                    }
                    if(onSuccessCallback) {
                        onSuccessCallback(self.myCurrentViewer, item, messages );
                    }
                };
            } else {
                onLoadCallback = function() {
                    if (modelUnits) {
                        self.myCurrentViewer.setModelUnits(modelUnits);
                    }
                    if(onSuccessCallback) {
                        onSuccessCallback(self.myCurrentViewer, item, messages );
                    }
                };
            }

            var onFailedToLoadCallback = function( errorCode, errorMsg, statusCode, statusText ) {
                if (onErrorCallback)
                    onErrorCallback( errorCode, errorMsg, statusCode, statusText, messages );
            };

            var loaded = false;

            if (urnAlreadyLoaded) {
                if (onLoadCallback) {
                    onLoadCallback();
                }
                loaded = true;

            } else {
                this.urn = null;
                var config = {defaultModelStructureTitle: title, viewableName: title};

                // Add any extensions to the config.
                //
                if(item.hasOwnProperty('extensions')) {
                    config.extensions = Array.isArray(item.extensions) ? item.extensions : [item.extensions];
                }

                var viewer = this.getViewer(viewerType, config, onErrorCallback);
                if (viewer && viewer.load(this.myDocument.getFullPath(urnToLoad), this.myDocument.getPropertyDbPath(), onLoadCallback, onFailedToLoadCallback)) {
                    this.urn = urnToLoad;
                    loaded = true;
                }
            }

            if (loaded) {
                this.selectedItem = item;
                this.onItemSelected(item, viewGeometryItem);
                return true;
            }
        }
    }

    return false;
};

/**
 * Called when selectItem successfully loads an item
 *
 * @param {Object} item - can be either type 'view' or 'geometry'.
 * @param {Object} viewGeometryItem - can only be type 'geometry'. Will be the same as item if item is type 'geometry'.
 */
ViewingApplication.prototype.onItemSelected = function(item, viewGeometryItem) {
    stderr('Selected URL: http://' + location.host + location.pathname + '?document=urn:' + this.myDocument.getRootItem().guid + '&item=' + encodeURIComponent(item.guid));

    // notify observers a new item was selected.
    if(this.itemSelectedObservers) {
        var currentViewer = this.getCurrentViewer();
        for(var i = 0; i < this.itemSelectedObservers.length; ++i){
            var observer = this.itemSelectedObservers[i];
            observer.onItemSelected && observer.onItemSelected(currentViewer, item, viewGeometryItem);
        }
    }
};

/**
 * Adds objects to be notified when a new item is selected in the browser tree
 *
 * @param {object} observer Should implement function onItemSelected(viewer);
 */
ViewingApplication.prototype.addItemSelectedObserver = function(observer) {

    if(!this.itemSelectedObservers) {
        this.itemSelectedObservers = [];
    }
    this.itemSelectedObservers.push(observer);
};

/**
 * Finds the item within the current document and calls selectItem
 * @param {int} itemId
 * @param {function} [onItemSelectedCallback] - This call back is called when the item is selected
 * @param {function} [onItemFailedToSelectCallback] - This call back is called when the item fails to select
 * @return Boolean
 */
ViewingApplication.prototype.selectItemById = function(itemId, onItemSelectedCallback, onItemFailedToSelectCallback) {
    var item = this.myDocument.getItemById(itemId);
    if (item) {
        return this.selectItem(item, onItemSelectedCallback, onItemFailedToSelectCallback);
    }
    return false;
};

/**
 * Returns the node object containing metadata associated to the model currently loaded in the viewer
 * @returns {null|Object}
 */
ViewingApplication.prototype.getSelectedItem = function() {
    return this.selectedItem;
};


av.ViewingApplication = ViewingApplication;

})();
;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.ViewCubeUi = function (viewer) {
    this.viewer = viewer;

    this.cube = null; // Autocam.ViewCube
    this.viewcube = null;
    this.infoButton = null;
    this.homeViewContainer = null;
};

Autodesk.Viewing.Private.ViewCubeUi.prototype = {
    constructor: Autodesk.Viewing.UI.ViewCube,

    create: function () {
        var config = this.viewer.config,
            wantInfoButton = config && config.wantInfoButton !== undefined ? config.wantInfoButton : true;

        if (wantInfoButton) {
            this.initInfoButton();
        }
        this.initHomeButton();
    },

    initInfoButton: function () {
        if (0 < document.getElementsByClassName('infoButton').length) {
            return;
        }

        this.infoButton = document.createElement('div');
        this.infoButton.className = "infoButton";
        this.infoButton.style.cursor = "pointer";

        this.viewer.container.appendChild(this.infoButton);

        var self = this;
        this.infoButton.addEventListener("click", function (e) {
            var propertyPanel = self.viewer.getPropertyPanel(true);
            var visible = !propertyPanel.areDefaultPropertiesShown() || !propertyPanel.isVisible();

            if (visible) {
                propertyPanel.showDefaultProperties();
            }

            if (visible !== propertyPanel.isVisible()) {
                propertyPanel.setVisible(visible);
            }
        });
    },

    initHomeButton: function () {
        if (0 < document.getElementsByClassName('homeViewWrapper').length) {
            return;
        }

        var homeViewContainer = document.createElement('div');
        homeViewContainer.className = "homeViewWrapper";
        homeViewContainer.style.cursor = "pointer";

        this.viewer.container.appendChild(homeViewContainer);

        this.homeViewContainer = homeViewContainer;

        var self = this;
        homeViewContainer.addEventListener("click", function(e) {
            self.viewer.navigation.setRequestHomeView(true);
        });

        this._initHomeMenu(homeViewContainer);
    },

    _initHomeMenu: function (parent) {
        var viewer = this.viewer;
        var autocam = viewer.autocam;
        var self    = this;

        this.hideHomeViewMenu = function(e) {
            homeViewMenu.style.display = "none";
            document.removeEventListener("click", self.hideHomeViewMenu );
        };

        // Add the handle for the menu.
        var handle = document.createElement("div");
        handle.className = "homeViewMenuHandle";
        var image = document.createElement('img');
        var iconNormal = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsSAAALEgHS3X78AAAAIGNIUk0AAH7FAACLdgAA9UcAAIsOAABxUAAA6BUAADlYAAAfBMec4XAAAAEBSURBVHja7JcxCsIwFIb/V3oFx04v4iB4A3ev4Ak9iOABOhQcageHDh7iuVSwpW1eYmIFEwiFQvN9SZP/ERIRLNkyLNySQBLIhy+I6AhgE5F5FZHTpACAbV3X61h0Zs5nVwBAJiL0rd+eNuHvnQIArTEmplhrE7gAWEUUePSO/Vg1jJgFvQyYWoFoWTDMgLlNWDFzIyIUqjNzA6DSCpwBlMaYW4iZd+OU3bh2ARG5h5J4h3fj6nIghIQNbg2iTyQ0cFUS+kho4eoodpFwgTvVAo2EK9y5GM1J+MC9quGYhC98shaoPiQqAOwB7Hzhrxn1umMrABy6pxeT0t3w7wWeAwD5qe4YizvzugAAAABJRU5ErkJggg==";
        image.src = iconNormal;
        image.width = image.height = 18;
        handle.appendChild( image );
        handle.addEventListener( "mouseover", function(e) {
            image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsSAAALEgHS3X78AAAAIGNIUk0AAH7FAACLdgAA9UcAAIsOAABxUAAA6BUAADlYAAAfBMec4XAAAAEVSURBVHja7JcxDoJAEEX/rvY2HMEb6AEsaTDxBngKIzfgDBR6AxJtiI0egN7Ght6GWBIYGzVKQHaQDYU7yYSwxb5HMvs3CCJCnyXRcxkBIzAsLwyWpx0ARyNzn29m81oBAE60mmqj237smBkwAl9PAfIssv3Y1kbMs+j9VZQvIyHEGMBI40enRHSpFdCcBR8ZUJcD2rKgnAH1Q5gmnu3HXcOBNPGUBIrQDbqUeMKL0A2UBIjo2pXEO5yIrso50IVEE7wxiH6RUIErJWEbCVW4chRzJDhw1l2gIsGFPzdmNQBLLrZr6R7pcL69WrpHkovtGoDF2o8rUCXRFt5aoCzRFl4pwCwLwOTxBGOeXi3Mv+HfC9wHAAIQ03ZDDGqmAAAAAElFTkSuQmCC";
        });
        handle.addEventListener( "mouseleave", function(e) {
            image.src = iconNormal;
        });

        parent.appendChild( handle );

        // Add the RMB menu.
        var homeViewMenu = document.createElement('div');
        homeViewMenu.className = "homeViewMenu";
        this.viewer.container.appendChild( homeViewMenu );

        var setHome = document.createElement('div');
        setHome.className = "homeViewMenuItem";
        setHome.textContent = Autodesk.Viewing.i18n.translate("Set current view as Home");
        homeViewMenu.appendChild( setHome );

        setHome.addEventListener( "click", function(e) {
            autocam.setCurrentViewAsHome(false);
            self.hideHomeViewMenu(e);
        });

        var focusAndSetHome = document.createElement('div');
        focusAndSetHome.className = "homeViewMenuItem";
        focusAndSetHome.textContent = Autodesk.Viewing.i18n.translate("Focus and set as Home");
        homeViewMenu.appendChild( focusAndSetHome );

        focusAndSetHome.addEventListener( "click", function(e) {
            autocam.setCurrentViewAsHome(true);
            self.hideHomeViewMenu(e);
        });

        var resetHome = document.createElement('div');
        resetHome.className = "homeViewMenuItem";
        resetHome.textContent = Autodesk.Viewing.i18n.translate("Reset Home");
        homeViewMenu.appendChild( resetHome );

        resetHome.addEventListener( "click", function(e) {
            autocam.resetHome();
            self.hideHomeViewMenu(e);
        });

        parent.addEventListener( "mouseover", function(e) {
            if ((viewer.model && viewer.model.is2d()) || (viewer.prefs && !viewer.prefs.viewCube)) {
                handle.style.display = "block";
            }
        });

        parent.addEventListener( "mouseleave", function(e) {
            handle.style.display ="none";
        });

        handle.addEventListener("click", function(e) {
            if ((viewer.model && viewer.model.is2d()) || (viewer.prefs && !viewer.prefs.viewCube)) {
                homeViewMenu.style.display = "block";
                document.addEventListener("click", self.hideHomeViewMenu );
            }
            e.stopPropagation();
        });

        parent.addEventListener( "contextmenu", function(e) {
            if ((viewer.model && viewer.model.is2d()) || (viewer.prefs && !viewer.prefs.viewCube)) {
                homeViewMenu.style.display = "block";
                document.addEventListener("click", self.hideHomeViewMenu );
            }
        });
    },

    displayViewCube: function (display, updatePrefs) {
        if (updatePrefs !== false)
            this.viewer.prefs.set('viewCube', display);

        if (display && !this.cube) {
            this.viewcube = document.createElement("div");
            this.viewcube.className = "viewcube";
            this.viewer.container.appendChild(this.viewcube);
            this.cube = new Autocam.ViewCube("cube", this.viewer.autocam, this.viewcube, LOCALIZATION_REL_PATH);
        }
        else if (!this.cube) {
            this._positionHomeButton();
            return; //view cube is not existent and we want it off? Just do nothing.
        }

        this.viewcube.style.display = (display ? "block" : "none");

        this._positionHomeButton();

        if( display ) {
            this.viewer.autocam.refresh();
        }
    },

    _positionHomeButton: function () {
        if (this.homeViewContainer) {
            var viewCubeVisible = this.cube && this.viewcube && (this.viewcube.style.display === 'block'),
                containerBounds = this.viewer.container.getBoundingClientRect(),
                homeButtonBounds = this.homeViewContainer.getBoundingClientRect(),
                right;

            if (viewCubeVisible) {
                var viewCubeBounds = this.viewcube.getBoundingClientRect();
                right = containerBounds.left + containerBounds.width - viewCubeBounds.left - homeButtonBounds.width;

            } else if (this.infoButton) {
                var infoButtonBounds = this.infoButton.getBoundingClientRect();
                right = containerBounds.left + containerBounds.width - infoButtonBounds.left + infoButtonBounds.width - homeButtonBounds.width;
            } else {
                right = 10;
            }
            this.homeViewContainer.style.right = right + 'px';
        }
    },

    uninitialize: function () {
        if (this.viewcube) {
            this.viewer.container.removeChild(this.viewcube);
            this.viewcube = null;
        }

        this.infoButton = null;

        if (this.cube) {
            this.cube.dtor();
            this.cube = null;
        }

        this.homeViewContainer = null;
        this.hideHomeViewMenu = null;
        this.viewer = null;
    }
};
;
//TODO: This is used in several places, but should not be global, move it into some namepsace
function stringToDOM(str) {
    var d = document.createElement("div");
    d.innerHTML = str;
    return d.firstChild;
}


(function() {

'use strict';


var av = Autodesk.Viewing,
    avp = Autodesk.Viewing.Private,
    avu = Autodesk.Viewing.UI,
    ave = Autodesk.Viewing.Extensions;


    av.TOOLBAR_CREATED_EVENT          = 'toolbarCreated';

    /**
     * Viewer tools sets
     *
     * These constants are used to define the standard set of tools
     *
     * @enum {string}
     * @readonly
     * @memberof "Autodesk.Viewing"
     */
    av.TOOLBAR = {
        NAVTOOLSID:      "navTools",
        MODELTOOLSID:    "modelTools",
        SETTINGSTOOLSID: "settingsTools"
    };

    /**
     * Builds on the basic [Viewer3D]{@link Autodesk.Viewing.Viewer3D} by adding various common GUI elements.
     *
     * @class
     * @param {HTMLElement} container - The viewer container.
     * @param {Object} config - The initial settings object. See base class for details.
     * @alias Autodesk.Viewing.GuiViewer3D
     * @extends Autodesk.Viewing.Viewer3D
     * @constructor
     */
    var GuiViewer3D = function (container, config) {
        if (!config) config = {};

        // Explicitly set startOnInitialize = false, as we want to finish some initialization
        // before starting the main loop.
        //
        config.startOnInitialize = false;

        av.Viewer3D.call(this, container, config);

        this.toolbar = null;

        // Container for the UI docking panels
        this.dockingPanels = [];

        this.modelstructure = null;
        this.layersPanel = null;

    };

    GuiViewer3D.prototype = Object.create(av.Viewer3D.prototype);
    GuiViewer3D.prototype.constructor = GuiViewer3D;

    GuiViewer3D.prototype.initialize = function () {
        var viewerErrorCode = av.Viewer3D.prototype.initialize.call(this);

        if (viewerErrorCode > 0)    // ErrorCode was returned.
        {
            return viewerErrorCode;
        }

        var viewer = this;

        if (this.toolController) {
            var hottouch = new av.HotGestureTool(this);

            this.toolController.registerTool(hottouch);

            this.toolController.activateTool(hottouch.getName());
        }

        // Create toolbar that is attached to the bottom of the panel.
        this.getToolbar(true);

        this.addEventListener(av.FULLSCREEN_MODE_EVENT, function (e) {
            viewer.resizePanels({viewer: viewer});
            viewer.updateFullscreenButton(e.mode);
        });

        // Context menu
        if (!this.contextMenu) {
            this.setDefaultContextMenu();
        }

        // Create a progress bar. Shows streaming.
        //
        this.progressbar = new avp.ProgressBar(this.container);
        this.addEventListener(av.PROGRESS_UPDATE_EVENT, function (e) {
            if (e.percent !== undefined) {
                viewer.progressbar.setPercent(e.percent);
            }
        }, false);

        // There is no way on the API to get the current selection (yet?)
        //
        // We need to know if there is anything selected in order to process the
        // Escape key workflow, so track it manually.
        this.selectionActive = false;
        this.addEventListener(av.SELECTION_CHANGED_EVENT, function (event) {
            viewer.selectionActive = (event.dbIdArray.length > 0);

            if (viewer.prefs.openPropertiesOnSelect) {
                var propertyPanel = viewer.getPropertyPanel(true);
                propertyPanel.setVisible(viewer.selectionActive);
            }
        });

        this.addEventListener(av.ISOLATE_EVENT, function (event) {
            if (viewer.prefs.openPropertiesOnSelect || event.nodeIdArray[0] === viewer.model.getRootId()) {
                if (viewer.propertygrid) {
                    viewer.propertygrid.setVisible(event.nodeIdArray.length > 0 || viewer.selectionActive);
                }
            }
        });

        this.addEventListener(av.VIEWER_STATE_RESTORED_EVENT, function (event) {
            if (viewer.renderoptions) {
                viewer.renderoptions.syncUI();
            }

            var settingsPanel = viewer.getSettingsPanel(true);
            if (settingsPanel)
                settingsPanel.syncUI();

            // We don't really need to update these 2 values, because the panel is usually closed.
            // Leaving code here just in case it becomes necessary.
            //this.envSelect.setSelectedIndex(viewer.impl.currentLightPreset());
            //this.viewerOptionButton.displayLines.setValue(viewer.prefs.lineRendering);
        });

        this.addEventListener(av.VIEWER_RESIZE_EVENT, function (event) {

            viewer.resizePanels();

            if (viewer.viewCubeUi && viewer.viewCubeUi.cube)
                viewer.viewCubeUi.cube.refreshCube();

            viewer.updateToolbarButtons(event.width, event.height);

            if (viewer.centerToolBar) {
                viewer.centerToolBar();
            }
        });

        this.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, function (event) {
            viewer.updateToolbarButtons(viewer.container.clientWidth, viewer.container.clientHeight);
            viewer.centerToolBar();
        });

        this.initEscapeHandlers();

        // Now that all the ui is created, localize it.
        this.localize();

        // Now that all of our initialization is done, start the main loop.
        //
        this.run();

        return 0;   // No errors initializing.
    };

    GuiViewer3D.prototype.uninitialize = function () {

        if (this.viewerSettingsPanel) {
            this.viewerSettingsPanel.uninitialize();
            this.viewerSettingsPanel = null;
        }

        if (this.modelstructure) {
            this.modelstructure.uninitialize();
            this.modelstructure = null;
        }

        if (this.layersPanel) {
            this.layersPanel.uninitialize();
            this.layersPanel = null;
        }

        if (this.propertygrid) {
            this.propertygrid.uninitialize();
            this.propertygrid = null;
        }

        if (this.renderoptions) {
            this.renderoptions.uninitialize();
            this.renderoptions = null;
        }

        if (this.viewerOptionButton) {

            this.show3dOptionsNavigationTab = null;
            this.show3dOptionsPerformanceTab = null;
            this.viewerOptionButton = null;
        }

        av.theHotkeyManager.popHotkeys("Autodesk.ROLL");
        av.theHotkeyManager.popHotkeys("Autodesk.FOV");

        this.removeEventListener(av.RENDER_OPTION_CHANGED_EVENT, this.onRenderOptionChanged);
        this.onRenderOptionChanged = null;
        this.removeEventListener(av.VIEWER_STATE_RESTORED_EVENT, this.onRestoreState);
        this.onRestoreState = null;

        this.progressbar = null;

        this.modelTools = null;
        this.navTools = null;
        this.settingsTools = null;
        this.debugMenu = null;
        this.modelStats = null;
        this.explodeSlider = null;
        this.explodeSubmenu = null;
        this.centerToolBar = null;

        this.viewCubeUi.uninitialize();
        this.viewCubeUi = null;

        // Toolbar
        this.toolbar = null;

        av.Viewer3D.prototype.uninitialize.call(this);
    };

    GuiViewer3D.prototype.setUp = function (config) {
        if (!config) config = {};

        // Explicitly set startOnInitialize = false, as we want to finish some initialization
        // before starting the main loop.
        //
        config.startOnInitialize = false;

        this.getToolbar(true);

        av.Viewer3D.prototype.setUp.call(this, config);
    };

    GuiViewer3D.prototype.tearDown = function () {

        //TODO: this is unorthodox order of destruction, but we
        //need to call the super first so it unloads the extensions,
        //which need the GUI. We need to resolve this somehow.
        av.Viewer3D.prototype.tearDown.call(this);


        if (this.toolbar) {
            this.toolbar.container.parentNode.removeChild(this.toolbar.container);
            this.toolbar = null;
        }

        if (this.modelstructure) {
            this.setModelStructurePanel(null);
        }
        if (this.propertygrid) {
            this.setPropertyPanel(null);
        }
        if (this.viewerSettingsPanel) {
            this.setSettingsPanel(null);
        }
        if (this.layersPanel) {
            this.setLayersPanel(null);
        }
        if (this.renderoptions) {
            this.removePanel(this.renderoptions);
            this.renderoptions.uninitialize();
            this.renderoptions = null;
        }

        // Need to remove this event listener, in case that viewcube will show up when
        // changing sheets from 3D to 2D and the 3D model doesn't fully loaded.
        this.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.initViewCube);
    };

    GuiViewer3D.prototype.loadModel = function (url, options, onSuccessCallback, onErrorCallback) {
        var viewer = this;

        this.initViewCube = function () {
            viewer.displayViewCube(viewer.prefs.viewCube);
            viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, viewer.initViewCube);
        };

        var disabledExtensions = this.config.disabledExtensions;

        if (url.indexOf(".f2d") != -1 && !this.impl.model) {
            this.createUI("2d");
            if (viewer.prefs.useFirstPersonNavigation)
                this.unloadExtension('Autodesk.FirstPerson');
            else
                this.unloadExtension('Autodesk.Beeline');

            if (1) {
                //this.unloadExtension('Autodesk.VR');
            }

            // Make pan a default navigation tool.
            this.setDefaultNavigationTool("pan");

            // Make sure view cube and click to set COI are disabled (but don't update the preferences)
            this.setClickToSetCOI(false, false);
            this.displayViewCube(false, false);

            if (!disabledExtensions || (disabledExtensions && !disabledExtensions.measure)) {
                this.loadExtension('Autodesk.Measure', null);
            }
        }
        else { // 3d model
            this.createUI("3d");

            // Make orbit a default navigation tool.
            if (this.getDefaultNavigationToolName().indexOf("orbit") === -1)
                this.setDefaultNavigationTool("orbit");

            if (viewer.prefs.useFirstPersonNavigation)
                this.loadExtension('Autodesk.FirstPerson', null);
            else
                this.loadExtension('Autodesk.Beeline', null);

            if (1) {
                //this.loadExtension('Autodesk.VR', null);
            }

            this.loadExtension('Autodesk.Viewing.Oculus', null);
            if (this.prefs.fusionOrbit)
                this.loadExtension('Autodesk.Viewing.FusionOrbit', null);

            if (!disabledExtensions || (disabledExtensions && !disabledExtensions.measure)) {
                this.loadExtension('Autodesk.Measure', null);
            }

            if (!disabledExtensions || (disabledExtensions && !disabledExtensions.section)) {
                this.loadExtension('Autodesk.Section', null);
            }

            this.addEventListener(av.GEOMETRY_LOADED_EVENT, this.initViewCube);
        }


        //Used to initialize the modelstructure if it's already created
        //before the property db finishes loading
        var modelTreeInit = function() {
            if (viewer.modelstructure) {
                var onSuccess = function (instanceTree) {
                    var modelTitle = viewer.config.defaultModelStructureTitle ? viewer.config.defaultModelStructureTitle : '';
                    viewer.modelstructure.setModel(instanceTree, modelTitle);
                };
                var onFailure = function(insta) {
                    // Anything here?
                };
                viewer.model.getObjectTree(onSuccess, onFailure);
            }

            viewer.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, modelTreeInit);
        };

        this.addEventListener(av.OBJECT_TREE_CREATED_EVENT, modelTreeInit);

        return av.Viewer3D.prototype.loadModel.call(this, url, options, onSuccessCallback, onErrorCallback);
    };

    GuiViewer3D.prototype.createUI = function (mode) {
        var self = this;

        this.initHotkeys(mode);

        this.loadExtension('Autodesk.DefaultTools.NavTools', {mode: mode});
        this.initModelTools(mode);

        //Optional rendering options panel + button
        if (ENABLE_DEBUG) {
            this.initDebugTools();
        }

        // Dispatch a toolbar created event
        this.fireEvent({type: av.TOOLBAR_CREATED_EVENT});

        if (!this.viewCubeUi) {
            this.viewCubeUi = new avp.ViewCubeUi(this);
        }
        this.viewCubeUi.create();

        this.centerToolBar = function () {
            self.toolbar.container.style.left = 'calc(50% - ' + self.toolbar.getDimensions().width / 2 + 'px)';
        };
        this.toolbar.addEventListener(avu.ToolBar.Event.SIZE_CHANGED, this.centerToolBar);

        this.initModality();

        this.resize();

        //this.toolbar.addControl(this.searchMenu);
    };

    // "tooltip" string is localized by this method.
    GuiViewer3D.prototype.addOptionToggle = function (parent, tooltip, initialState, onchange, saveKey) {

        // Use the stored settings or defaults
        var storedState = saveKey ? this.prefs[saveKey] : null;
        initialState = (typeof storedState === 'boolean') ? storedState : initialState;

        var li = document.createElement("li");
        li.className = "toolbar-submenu-listitem";

        var cb = document.createElement("input");
        cb.className = "toolbar-submenu-checkbox";
        cb.type = "checkbox";
        cb.id = tooltip;
        li.appendChild(cb);

        var lbl = document.createElement("label");
        lbl.setAttribute('for', tooltip);
        lbl.setAttribute("data-i18n", tooltip);
        lbl.textContent = av.i18n.translate(tooltip);
        li.appendChild(lbl);

        parent.appendChild(li);

        cb.checked = initialState;

        cb.addEventListener("touchstart", touchStartToClick);
        lbl.addEventListener("touchstart", touchStartToClick);
        li.addEventListener("touchstart", touchStartToClick);

        cb.addEventListener("click", function (e) {
            onchange(cb.checked);
            e.stopPropagation();
        });

        lbl.addEventListener("click", function (e) {
            e.stopPropagation();
        });

        li.addEventListener("click", function (e) {
            onchange(!cb.checked);
            e.stopPropagation();
        });

        if (saveKey) {
            this.prefs.addListeners(saveKey, function (value) {
                cb.checked = value;
            }, function (value) {
                cb.checked = value;
                onchange(value);
            });
        }
        return cb;
    };

    // "label" string will be converted to localized string by this method
    GuiViewer3D.prototype.addOptionList = function (parent, label, optionList, initialIndex, onchange, saveKey) {

        // Use the stored settings or defaults
        var storedState = this.prefs[saveKey];
        initialIndex = (typeof storedState === 'number') ? storedState : initialIndex;

        // Wrap the onchange with the update to that setting
        var handler = function (e) {
            var selectedIndex = e.target.selectedIndex;
            onchange(selectedIndex);
            e.stopPropagation();
        };

        var selectElem = document.createElement("select");
        selectElem.className = 'optionDropDown';
        selectElem.id = "selectMenu_" + label;
        for (var i = 0; i < optionList.length; i++) {
            var item = document.createElement("option");
            item.value = i;
            item.setAttribute("data-i18n", optionList[i]);
            item.textContent = Autodesk.Viewing.i18n.translate(optionList[i]);
            selectElem.add(item);
        }

        var li = document.createElement("li");
        li.className = "toolbar-submenu-select";

        var lbl = document.createElement("div");
        lbl.className = "toolbar-submenu-selectlabel";
        lbl.setAttribute('for', label);
        lbl.setAttribute("data-i18n", label);
        lbl.textContent = av.i18n.translate(label);
        li.appendChild(lbl);
        li.appendChild(selectElem);

        parent.appendChild(li);

        selectElem.selectedIndex = initialIndex;
        selectElem.onchange = handler;
        selectElem.addEventListener("touchstart", function (e) {
            e.stopPropagation();
        });
        selectElem.addEventListener("click", function (e) {
            e.stopPropagation();
        });

        if (saveKey) {
            this.prefs.addListeners(saveKey, function (value) {
                selectElem.selectedIndex = value;
            }, function (value) {
                selectElem.selectedIndex = value;
                onchange(value);
            });
        }

        return selectElem;
    };

    GuiViewer3D.prototype.showViewer3dOptions = function (show) {
        var settingsPanel = this.getSettingsPanel(true);
        if (show && settingsPanel.isVisible()) {
            settingsPanel.setVisible(false);
        }
        settingsPanel.setVisible(show);
    };

    GuiViewer3D.prototype.showRenderingOptions = function (show) {
        this.renderoptions.setVisible(show);
    };

    GuiViewer3D.prototype.showLayerManager = function (show) {
        this.layersPanel.setVisible(show);
    };

    GuiViewer3D.prototype.initHotkeys = function (mode) {
        var viewer = this;
        var keys = av.theHotkeyManager.KEYCODES;
        var onPress;
        var onRelease;

        if (mode === "3d") {
            // Add FOV hotkey
            var previousToolForFOV;
            onPress = function () {
                if (viewer.toolController.getIsLocked() || !viewer.navigation.isActionEnabled('fov')) {
                    return false;
                }

                previousToolForFOV = viewer.getActiveNavigationTool();
                viewer.setActiveNavigationTool("fov");
                return true;
            };
            onRelease = function () {
                if (viewer.toolController.getIsLocked() || !viewer.navigation.isActionEnabled('fov')) {
                    return false;
                }

                viewer.setActiveNavigationTool(previousToolForFOV);
                return true;
            };
            av.theHotkeyManager.pushHotkeys("Autodesk.FOV", [
                {
                    keycodes: [keys.CONTROL, keys.SHIFT],
                    onPress: onPress,
                    onRelease: onRelease
                }
            ], {tryUntilSuccess: true});
        }

        // Add Roll hotkey
        var previousToolForRoll;
        onPress = function () {
            if (viewer.toolController.getIsLocked() || !viewer.navigation.isActionEnabled('roll')) {
                return false;
            }

            previousToolForRoll = viewer.getActiveNavigationTool();
            viewer.setActiveNavigationTool("worldup");
            return true;
        };
        onRelease = function () {
            if (viewer.toolController.getIsLocked() || !viewer.navigation.isActionEnabled('roll')) {
                return false;
            }

            viewer.setActiveNavigationTool(previousToolForRoll);
            return true;
        };
        av.theHotkeyManager.pushHotkeys("Autodesk.ROLL", [{
            keycodes: [keys.ALT, keys.SHIFT],
            onPress: onPress,
            onRelease: onRelease
        }], {tryUntilSuccess: true});
    };



    /**
     * Sets the model structure panel for displaying the loaded model.
     * @param {ModelStructurePanel} modelStructurePanel - the model structure panel to use, or null.
     *
     * @returns {boolean} true if the panel, or null, was set successfully; false otherwise.
     */
    GuiViewer3D.prototype.setModelStructurePanel = function (modelStructurePanel) {
        var self = this;
        if (modelStructurePanel instanceof av.UI.ModelStructurePanel || modelStructurePanel === null) {
            if (this.modelstructure) {
                this.modelstructure.setVisible(false);  // This ensures the button is in the correct state.
                this.removePanel(this.modelstructure);
                this.modelstructure.uninitialize();
            }
            this.modelstructure = modelStructurePanel;

            if (modelStructurePanel) {
                this.addPanel(this.modelstructure);

                modelStructurePanel.addVisibilityListener(function (visible) {
                    if (visible) {
                        self.onPanelVisible(modelStructurePanel, self);
                    }
                    self.settingsTools.structurebutton.setState(visible ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);
                });

                // If the model already exists, then set it now.  Otherwise, it will be
                // set later when the model is created in load().
                //
                if (self.model) {
                    self.model.getObjectTree(function (instanceTree) {
                        self.modelstructure.setModel(instanceTree);
                    });
                }
            }
            return true;
        }
        return false;
    };

    /**
     * Sets the layers panel for display 2d layers.
     * @param {!LayersPanel} layersPanel - the layers panel to use, or null
     *
     * Not yet implemented for 3D.
     *
     * @returns {boolean} true if the panel or null was set successfully, and false otherwise
     */
    GuiViewer3D.prototype.setLayersPanel = function (layersPanel) {
        var self = this;
        if( this.model && !this.model.is2d() )
        {
            console.warn("av.Viewer3D.setLayersPanel is not yet implemented for 3D");
            return false;
        }

        if (layersPanel instanceof av.UI.LayersPanel || !layersPanel) {
            if (this.layersPanel) {
                this.layersPanel.setVisible(false);
                this.removePanel(this.layersPanel);
                this.layersPanel.uninitialize();
            }

            this.layersPanel = layersPanel;
            if (layersPanel) {
                this.addPanel(layersPanel);

                layersPanel.addVisibilityListener(function (visible) {
                    if (visible) {
                        self.onPanelVisible(layersPanel, self);
                    }
                    self.settingsTools.layerButton.setState(visible ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);
                });
            }
            return true;
        }
        return false;
    };

    /**
     * Sets the property panel.
     * @param {!PropertyPanel} propertyPanel - the property panel to use, or null
     * @returns {boolean} true if the panel or null was set successfully, and false otherwise
     */
    GuiViewer3D.prototype.setPropertyPanel = function (propertyPanel) {
        var self = this;
        if (propertyPanel instanceof av.UI.PropertyPanel || !propertyPanel) {
            if (this.propertygrid) {
                this.propertygrid.setVisible(false);
                this.removePanel(this.propertygrid);
                this.propertygrid.uninitialize();
            }

            this.propertygrid = propertyPanel;
            if (propertyPanel) {
                this.addPanel(propertyPanel);

                propertyPanel.addVisibilityListener(function (visible) {
                    if (visible) {
                        self.onPanelVisible(propertyPanel, self);
                    }
                    self.settingsTools.propertiesbutton.setState(visible ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);
                });

            }
            return true;
        }
        return false;
    };

    GuiViewer3D.prototype.getPropertyPanel = function (createDefault) {
        if (!this.propertygrid && createDefault) {
            this.setPropertyPanel(new ave.ViewerPropertyPanel(this));
        }
        return this.propertygrid;
    };


    /**
     * Sets the viewer's settings panel.
     * @param {!SettingsPanel} settingsPanel - the settings panel to use, or null
     * @returns {boolean} true if the panel or null was set successfully, and false otherwise
     */
    GuiViewer3D.prototype.setSettingsPanel = function (settingsPanel) {
        if (settingsPanel instanceof av.UI.SettingsPanel || !settingsPanel) {
            if (this.viewerSettingsPanel ) {
                this.viewerSettingsPanel.setVisible(false);
                this.removePanel(this.viewerSettingsPanel);
                this.viewerSettingsPanel.uninitialize();
            }

            this.viewerSettingsPanel = settingsPanel;
            if (settingsPanel) {
                this.addPanel(settingsPanel);
            }
            return true;
        }
        return false;
    };

    GuiViewer3D.prototype.getSettingsPanel = function (createDefault) {
        if (!this.viewerSettingsPanel && createDefault) {
            this.setSettingsPanel(new ave.ViewerSettingsPanel(this, this.model.is2d() ? "2d" : "3d"));
        }
        return this.viewerSettingsPanel;
    };




    GuiViewer3D.prototype.initModelTools = function (mode) {
        var viewer = this;

        //var resetTooltip = null;
        if (mode === "3d") {
            if (!viewer.modelstructure) {
                var options = {
                    docStructureConfig: viewer.config.docStructureConfig
                    //TODO: visibility of search bar in browser panel
                };
                viewer.setModelStructurePanel(new ave.ViewerModelStructurePanel(viewer, 'Browser', options));
            }

            var structureButton = new avu.Button('toolbar-modelStructureTool');
            structureButton.setToolTip('Model browser');
            structureButton.setIcon("adsk-icon-structure");
            structureButton.onClick = function (e) {
                viewer.showModelStructurePanel(!viewer.modelstructure.isVisible());
            };

            this.settingsTools.addControl(structureButton);
            this.settingsTools.structurebutton = structureButton;

            this.initExplodeSlider();
            // this.initInspectTools();  // NOTE_NOP: don't need this

            //TODO: show only after complete load?
            //viewer.showModelStructurePanel(true);

            //resetTooltip = "Reset model";
        }
        else {
            var layersPanel = new ave.ViewerLayersPanel(this);
            this.setLayersPanel(layersPanel);

            var layerButton = new avu.Button('toolbar-layersTool');
            layerButton.setToolTip('Layer Manager');
            layerButton.setIcon("adsk-icon-layers");
            layerButton.onClick = function (e) {
                if (!viewer.layersPanel) {
                    viewer.setLayersPanel(new ave.ViewerLayersPanel(viewer));
                }

                viewer.showLayerManager(!viewer.layersPanel.isVisible());
            };
            this.settingsTools.addControl(layerButton);
            this.settingsTools.layerButton = layerButton;

            //resetTooltip = "Reset drawing";
        }

        // NOTE_NOP: turn off reset button
        // var resetModelButton = new avu.Button('toolbar-resetTool');
        // resetModelButton.setToolTip(resetTooltip);
        // resetModelButton.setIcon("adsk-icon-reset");
        // resetModelButton.onClick = function (e) {
        //     viewer.fireEvent({type: av.RESET_EVENT});
        // };
        // this.modelTools.addControl(resetModelButton);
        // this.modelTools.resetModelButton = resetModelButton;

        viewer.addEventListener(av.RESET_EVENT, function () {
            if (viewer.model && !viewer.model.is2d()) {
                viewer.explode(0);
                viewer.explodeSlider.value = 0;
            }
            viewer.showAll();
        });

        var propertiesButton = new avu.Button('toolbar-propertiesTool');
        propertiesButton.setToolTip('Properties');
        propertiesButton.setIcon("adsk-icon-properties");
        propertiesButton.onClick = function (e) {
            var propertyPanel = viewer.getPropertyPanel(true);
            propertyPanel.setVisible(!propertyPanel.isVisible());
        };
        propertiesButton.setVisible(!viewer.prefs.openPropertiesOnSelect);
        this.settingsTools.addControl(propertiesButton);
        this.settingsTools.propertiesbutton = propertiesButton;

        // New viewer options' panel
        var settingsPanel = new ave.ViewerSettingsPanel(this, mode);
        this.setSettingsPanel(settingsPanel);

        var viewerOptionButton = new avu.Button('toolbar-settingsTool');
        this.viewerOptionButton = viewerOptionButton;
        viewerOptionButton.setIcon("adsk-icon-settings");
        viewerOptionButton.setToolTip("Settings");
        this.settingsTools.addControl(viewerOptionButton);
        this.createViewerOptionsMenu(mode);

        if (ENABLE_DEBUG && mode === "3d") {
            this.renderoptions = new avp.RenderOptionsPanel(this);
            this.addPanel(this.renderoptions);

            var renderOptionsButton = new avu.Button('toolbar-renderOptionsTool');
            renderOptionsButton.setToolTip('Rendering options');
            renderOptionsButton.setIcon("adsk-icon-settings-render");
            renderOptionsButton.onClick = function (e) {
                viewer.showRenderingOptions(!viewer.renderoptions.isVisible());
            };
            this.settingsTools.addControl(renderOptionsButton);
        }

        if (this.canChangeScreenMode()) {
            var fullscreenButton = new avu.Button('toolbar-fullscreenTool', {collapsible: false});
            fullscreenButton.setToolTip('Full screen');
            fullscreenButton.setIcon("adsk-icon-fullscreen");
            fullscreenButton.onClick = function (e) {
                viewer.nextScreenMode();
            };
            this.settingsTools.addControl(fullscreenButton);
            this.settingsTools.fullscreenbutton = fullscreenButton;

            this.updateFullscreenButton(this.getScreenMode());
        }
    };

    GuiViewer3D.prototype.setPropertiesOnSelect = function (onSelect) {
        this.settingsTools.propertiesbutton.setVisible(!onSelect);
    };

    GuiViewer3D.prototype.addDivider = function (parent) {
        var item = document.createElement("li");
        item.className = "toolbar-submenu-horizontal-divider";
        parent.appendChild(item);
        return item;
    };

    GuiViewer3D.prototype.createViewerOptionsMenu = function (mode) {
        // TODO: Refactor this into a control
        var viewer = this;

        var subMenu = document.createElement('div');
        subMenu.id = 'toolbar-settingsToolSubmenu';
        subMenu.classList.add('toolbar-submenu');
        subMenu.classList.add('toolbar-settings-sub-menu');
        subMenu.classList.add('adsk-hidden');
        subMenu.mode = mode;

        // Temporarily attach it to the main container so that it can be
        // properly sized. Once it has a correct width (important for localization)
        // we will remove it from the container and attach it to the button.
        //
        this.container.appendChild(subMenu);

        if (mode === "3d") {
            // Environment map preset list
            var env_list = [];
            for (var i = 0; i < avp.LightPresets.length; i++) {
                env_list.push(avp.LightPresets[i].name);
            }

            this.viewerOptionButton.envList = this.addOptionList(subMenu, "Background and lighting", env_list, 4, function (selectedIndex) {
                if (viewer.blockEvent)
                    return;

                viewer.setLightPreset(selectedIndex);

            }, "lightPreset");

            this.onRenderOptionChanged = function (e) {
                viewer.blockEvent = true;
                if (viewer.viewerOptionButton.envList)
                    viewer.viewerOptionButton.envList.selectedIndex = viewer.impl.currentLightPreset();
                viewer.blockEvent = false;
                var panel = viewer.getSettingsPanel(true);
                panel.syncUI();
            };
            viewer.addEventListener(av.RENDER_OPTION_CHANGED_EVENT, this.onRenderOptionChanged);

            this.onRestoreState = function() {
                if (viewer.explodeSlider) {
                    viewer.explodeSlider.value = viewer.getExplodeScale();
                }
            };
            viewer.addEventListener(av.VIEWER_STATE_RESTORED_EVENT, this.onRestoreState);

            this.viewerOptionButton.displayLines = this.addOptionToggle(subMenu, "Display Lines", true, function (checked) {
                viewer.hideLines(!checked);
            }, "lineRendering");

            this.addDivider(subMenu);
        }

        var performanceOption = document.createElement("li");
        performanceOption.className = "toolbar-submenu-listitem";
        var perfLabel = document.createElement("label");
        perfLabel.setAttribute("data-i18n", "Performance and appearance settings");
        perfLabel.textContent = av.i18n.translate("Performance and appearance settings");
        performanceOption.appendChild(perfLabel);

        function show3dOptions(tab) {
            var panel = viewer.getSettingsPanel(true);
            if (!panel.isVisible() || !panel.isTabSelected(tab)) {
                viewer.showViewer3dOptions(true);
                panel.selectTab(tab);
            } else {
                viewer.showViewer3dOptions(false);
            }
        }

        this.show3dOptionsPerformanceTab = function () {
            show3dOptions(ave.ViewerSettingTab.Performance);
        };
        this.viewerOptionButton.performanceOption = performanceOption;
        this.viewerOptionButton.performanceOption.addEventListener("touchstart", touchStartToClick);
        this.viewerOptionButton.performanceOption.addEventListener("click", this.show3dOptionsPerformanceTab);
        subMenu.appendChild(this.viewerOptionButton.performanceOption);

        this.addDivider(subMenu);

        var navigationOption = document.createElement("li");
        navigationOption.className = "toolbar-submenu-listitem";
        var navigLabel = document.createElement("label");
        navigLabel.setAttribute("data-i18n", "Navigation and selection settings");
        navigLabel.textContent = av.i18n.translate("Navigation and selection settings");
        navigationOption.appendChild(navigLabel);

        this.show3dOptionsNavigationTab = function () {
            show3dOptions(ave.ViewerSettingTab.Navigation);
        };

        this.viewerOptionButton.navigationOption = navigationOption;
        this.viewerOptionButton.navigationOption.addEventListener("touchstart", touchStartToClick);
        this.viewerOptionButton.navigationOption.addEventListener("click", this.show3dOptionsNavigationTab);
        subMenu.appendChild(navigationOption);

        // Calculate width, disconnect from the main container and attach
        // as a submenu to the parent button.
        subMenu.style.width = subMenu.getBoundingClientRect().width + "px";
        this.container.removeChild(subMenu);

        /* Comment the below code to make fusion-like */

        //this.viewerOptionButton.onMouseOver = function(e) {
        //    subMenu.classList.remove('adsk-hidden');
        //};
        //
        //this.viewerOptionButton.onMouseOut = function(e) {
        //    subMenu.classList.add('adsk-hidden');
        //};

        //if (isTouchDevice()) {
        this.viewerOptionButton.onClick = function (e) {
            subMenu.classList.toggle('adsk-hidden');
            this.setState(this.getState() === avu.Button.State.ACTIVE ?
                avu.Button.State.INACTIVE : avu.Button.State.ACTIVE);
        };
        //}

        this.viewerOptionButton.container.appendChild(subMenu);
        this.viewerOptionButton.subMenu = subMenu;
    };

    GuiViewer3D.prototype.removeViewerOptionsMenu = function (mode) {
        var ob = this.viewerOptionButton;
    
        ob.container.removeChild(ob.subMenu);
        if (mode === "3d") {
            this.removeEventListener(Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT, this.onRenderOptionChanged);
            ob.envList = null;
        }

        ob.navigationOption.removeEventListener("touchstart", touchStartToClick);
        ob.navigationOption.removeEventListener("click", this.show3dOptionsNavigationTab);
        ob.navigationOption = null;
        ob.performanceOption.removeEventListener("touchstart", touchStartToClick);
        ob.performanceOption.removeEventListener("click", this.show3dOptionsPerformanceTab);
        ob.performanceOption = null;
    };

    GuiViewer3D.prototype.initDebugTools = function () {
        var debugGroup = new avu.ControlGroup('debugTools');
        this.debugMenu = debugGroup;

        // Create the debug submenu button and attach submenu to it.
        var debugButton = new avu.Button('toolbar-debugTool');
        debugButton.setIcon("adsk-icon-bug");
        debugGroup.addControl(debugButton);
        this.debugMenu.debugSubMenuButton = debugButton;

        this.createDebugSubmenu(this.debugMenu.debugSubMenuButton);

        this.toolbar.addControl(debugGroup);
    };

    GuiViewer3D.prototype.createDebugSubmenu = function (button) {
        // TODO: Refactor into a control
        var viewer = this;

        var subMenu = document.createElement('div');
        subMenu.id = 'toolbar-debugToolSubmenu';
        subMenu.classList.add('toolbar-submenu');
        subMenu.classList.add('toolbar-settings-sub-menu');
        subMenu.classList.add('adsk-hidden');

        this.debugMenu.subMenu = subMenu;
        this.debugMenu.subMenu.style.minWidth = "180px";

        // Temp connect to the main container to calculate the correct width
        this.container.appendChild(subMenu);

        this.initModelStats();
        this.addDivider(subMenu);

        // Add the language setting
        this.addDivider(subMenu);
        var langNames = ["English", "Chinese Simplified", "Chinese Traditional", "Japanese", "Czech", "Korean", "Polish", "Russian", "French", "German", "Italian", "Spanish", "Portuguese Brazil", "Turkish"];
        var langSymbols = ["en", "zh-Hans", "zh-Hant", "ja", "cs", "ko", "pl", "ru", "fr", "de", "it", "es", "pt-br", "tr"];

        function setLanguage() {
            viewer.localize();
        }

        var initialSelection = viewer.selectedLanguage ? viewer.selectedLanguage : 0;
        var langList = this.addOptionList(subMenu, "Language", langNames, initialSelection, function (selectedIndex) {
            var langSymb = langSymbols[selectedIndex];
            viewer.selectedLanguage = selectedIndex;
            avp.setLanguage(langSymb, setLanguage);
        }, null);
        langList.parentNode.style.paddingBottom = "15px";

        // Add display of errors
        this.addDivider(this.debugMenu.subMenu);
        var errorNames = ["UNKNOWN FAILURE", "BAD DATA", "NETWORK ERROR", "NETWORK ACCESS DENIED",
            "NETWORK FILE NOT FOUND", "NETWORK SERVER ERROR", "NETWORK UNHANDLED RESPONSE CODE",
            "BROWSER WEBGL NOT SUPPORTED", "BAD DATA NO VIEWABLE CONTENT"];

        var errorList = this.addOptionList(subMenu, "Error", errorNames, 0, function (errorIndex) {
            var errorCode = errorIndex + 1;
            avp.ErrorHandler.reportError(viewer.container, errorCode, "");
        }, null);
        errorList.parentNode.style.paddingBottom = "15px";

        var subMenuBounds = subMenu.getBoundingClientRect();
        this.debugMenu.subMenu.style.width = subMenuBounds.width + "px";
        this.container.removeChild(subMenu);
        button.container.appendChild(subMenu);

        // Check if the menu fits on the right site and if not, adjust the right edge.
        var right = subMenuBounds.left + subMenuBounds.width;
        var rightBoundary = this.container.getBoundingClientRect().right;
        if (right > rightBoundary) {
            var leftAdjustment = -(right - rightBoundary + 10) + "px";
            this.debugMenu.subMenu.style.left = leftAdjustment;
        }

        button.onMouseOver = function (e) {
            subMenu.classList.remove('adsk-hidden');
        };

        button.onMouseOut = function (e) {
            subMenu.classList.add('adsk-hidden');
        };

        if (isTouchDevice()) {
            button.onClick = function (e) {
                subMenu.classList.toggle('adsk-hidden')
            };
        }
    };

    GuiViewer3D.prototype.initModelStats = function () {

        var self = this;

        function updateModelStatContent(message) {
            var viewer = self.impl;
            var text = "";
            var model = self.model;
            if (model) {
                text += "Geom&nbsp;polys:&nbsp;" + viewer.modelQueue().getGeometryList().geomPolyCount + "<br>";
                text += "Instance&nbsp;polys:&nbsp;" + viewer.modelQueue().getGeometryList().instancePolyCount + "<br>";
                text += "Fragments:&nbsp;" + viewer.modelQueue().getFragmentList().getCount() + "<br>";
                text += "Geoms:&nbsp;" + viewer.modelQueue().getGeometryList().geoms.length + "<br>";
                text += "Loading&nbsp;time:&nbsp;" + (viewer.model.loader.loadTime/1000).toFixed(2) + " s" + "<br>";
            }
            text += "# " + (message || "");

            self.modelStats.innerHTML = text;
        }

        // On progress update debug text.
        //
        function createModelStats() {
            self.modelStats = document.createElement("div");
            self.modelStats.className = "statspanel";
            self.container.appendChild(self.modelStats);

            self.addEventListener(av.PROGRESS_UPDATE_EVENT, function (e) {
                if (e.message) {
                    updateModelStatContent(e.message);
                }
            });


            self.fpsDisplay = document.createElement("div");
            self.fpsDisplay.className = "fps";
            self.container.appendChild(self.fpsDisplay);
        }

        this.addOptionToggle(this.debugMenu.subMenu, "Model statistics", false, function (checked) {

            if (checked && !self.modelStats) {
                createModelStats();
                updateModelStatContent("");
            }

            self.modelStats.style.visibility = (checked ? "visible" : "hidden");
            self.fpsDisplay.style.visibility = (checked ? "visible" : "hidden");

            if (checked) {
                self.impl.fpsCallback = function(fps) {
                    self.fpsDisplay.textContent = "" + (0|fps);                
                }
            } else {
                self.impl.fpsCallback = null;
            }
        });

    };

    GuiViewer3D.prototype.initEscapeHandlers = function () {
        var viewer = this;

        this.addEventListener(av.ESCAPE_EVENT, function (event) {
            if (viewer.contextMenu && viewer.contextMenu.hide()) {
                return;
            }

            // Render options isn't enabled in release, so don't try to manipulate it
            if (viewer.renderoptions) {
                // Close render settings panel
                if (viewer.renderoptions.isVisible()) {
                    viewer.renderoptions.setVisible(false);
                    return;
                }
            }

            // TODO: stop any active animation

            // Reset default navigation mode:
            if (viewer.getActiveNavigationTool() !== viewer.getDefaultNavigationToolName()) {
                // Force unlock active tool:
                if (viewer.toolController)
                    viewer.toolController.setIsLocked(false);

                viewer.setActiveNavigationTool();
                avp.HudMessage.dismiss();
                return;
            }

            // Deselect
            if (viewer.selectionActive) {
                viewer.clearSelection();
                return;
            }

            // Show all if anything is hidden
            if (!viewer.areAllVisible()) {
                viewer.showAll();
                return;
            }

            // Close open alert windows
            if (avp.AlertBox.dismiss()) {
                return;
            }

            // Close open windows
            for (var i = 0; i < viewer.dockingPanels.length; ++i) {
                var panel = viewer.dockingPanels[i];
                if (panel.container.style.display !== "none" && panel.container.style.display !== "") {
                    // NB: Since the document structure panel state is reflected
                    //     in the toolbar, we need to update that as well.
                    if (panel.container === viewer.modelstructure) {
                        viewer.showModelStructurePanel(false);
                    } else {
                        panel.setVisible(false);
                    }
                    return;
                }
            }

            if (viewer.escapeScreenMode()) {
                return;
            }
        });
    };

    GuiViewer3D.prototype.displayViewCube = function (display, updatePrefs) {
        this.viewCubeUi.displayViewCube(display, updatePrefs);
    };


    /**
     * Returns a toolbar.
     *
     * @param {bool} create - if true and the toolbar does not exist, it will be created
     * @returns {av.UI.ToolBar?} - Returns the toolbar.
     */
    GuiViewer3D.prototype.getToolbar = function( create )
    {
        if (!this.toolbar) {
            if (create) {
                var AVU = av.UI;
                this.toolbar = new AVU.ToolBar( 'guiviewer3d-toolbar' );

                this.navTools = new AVU.RadioButtonGroup( av.TOOLBAR.NAVTOOLSID );
                this.modelTools = new AVU.ControlGroup( av.TOOLBAR.MODELTOOLSID );
                this.settingsTools = new AVU.ControlGroup( av.TOOLBAR.SETTINGSTOOLSID );

                this.toolbar.addControl(this.navTools);
                this.toolbar.addControl(this.modelTools);
                this.toolbar.addControl(this.settingsTools);

                this.container.appendChild(this.toolbar.container);
            }
        }
        return this.toolbar;
    };


    GuiViewer3D.prototype.showModelStructurePanel = function (show) {
        this.modelstructure.setVisible(show);
    };

    GuiViewer3D.prototype.onPanelVisible = function (panel) {

        // Shift this window to the top of the list, so that it will be closed first
        //
        this.dockingPanels.splice(this.dockingPanels.indexOf(panel), 1);
        this.dockingPanels.splice(0, 0, panel);
    };

    GuiViewer3D.prototype.updateFullscreenButton = function (mode) {
        var cls = "adsk-icon-fullscreen";

        switch (mode) {
            case av.ScreenMode.kNormal:
                if (!this.isScreenModeSupported(av.ScreenMode.kFullBrowser)) {
                    cls = 'adsk-icon-fullscreen';
                }
                break;
            case av.ScreenMode.kFullBrowser:
                if (this.isScreenModeSupported(av.ScreenMode.kFullScreen)) {
                    cls = 'adsk-icon-fullscreen';
                } else {
                    cls = 'adsk-icon-fullscreen-exit';
                }
                break;
            case av.ScreenMode.kFullScreen:
                cls = 'adsk-icon-fullscreen-exit';
                break;
        }

        this.settingsTools.fullscreenbutton.setIcon(cls);
    };

    GuiViewer3D.prototype.localize = function () {

        av.i18n.localize();

        if (this.viewerOptionButton && this.viewerOptionButton.subMenu) {
            var mode = this.viewerOptionButton.subMenu.mode;
            this.removeViewerOptionsMenu(mode);
            this.createViewerOptionsMenu(mode);
        }

        if (this.debugMenu && this.debugMenu.debugSubMenuButton) {
            this.debugMenu.debugSubMenuButton.container.removeChild(this.debugMenu.subMenu);
            this.createDebugSubmenu(this.debugMenu.debugSubMenuButton);
        }

        avp.ErrorHandler.localize();
    };


    /**
     * Adds a panel to the viewer.  The panel will be moved and resized if the viewer
     * is resized and the panel falls outside of the bounds of the viewer.
     *
     * @param {PropertyPanel} panel - the panel to add.
     * @returns {boolean} true if panel was successfully added.
     *
     */
    GuiViewer3D.prototype.addPanel = function(panel) {
        var index = this.dockingPanels.indexOf(panel);
        if(index === -1) {
            this.dockingPanels.push(panel);
            return true;
        }
        return false;
    };

    /**
     * Removes a panel from the viewer.  The panel will no longer be moved and
     * resized if the viewer is resized.
     *
     * @param {PropertyPanel} panel - the panel to remove.
     * @returns {boolean} true if panel was successfully removed.
     *
     */
    GuiViewer3D.prototype.removePanel = function(panel) {
        var index = this.dockingPanels.indexOf(panel);
        if(index > -1) {
            this.dockingPanels.splice(index, 1);
            return true;
        }
        return false;
    };

    /**
     * Resizes the panels currently held by the viewer.
     *
     * @param {object} [options] - An optional dictionary of options.
     * @param {array} [options.dockingPanels=all] - a list of panels to resize.
     * @param {object} [options.viewer] - the viewer to use, specify if this method is being used as a callback.
     * @param {object} [options.dimensions] - the area for the panels to occupy.
     * @param {number} options.dimensions.width - the width
     * @param {number} options.dimensions.height - the height
     */
    GuiViewer3D.prototype.resizePanels = function (options) {

        options = options || {};

        var toolbarHeight = this.toolbar.getDimensions().height;
        var dimensions = this.getDimensions();
        var maxHeight = dimensions.height;

        if (options.dimensions && options.dimensions.height) {
            maxHeight = options.dimensions.height;
        }
        else {
            options.dimensions = {
                height: dimensions.height,
                width: dimensions.width
            };
        }

        options.dimensions.height = maxHeight - toolbarHeight;

        var viewer = options ? options.viewer : null;
        if(!viewer) {
            viewer = this;
        }

        var dockingPanels = options ? options.dockingPanels : null;
        if(!dockingPanels) {
            dockingPanels = viewer.dockingPanels;
        }

        var viewerRect = viewer.container.getBoundingClientRect(),
            vt = viewerRect.top,
            vb = viewerRect.bottom,
            vl = viewerRect.left,
            vr = viewerRect.right,
            vw, vh;

        if (options && options.dimensions) {
            vw = options.dimensions.width;
            vh = options.dimensions.height;
            vb = options.dimensions.height;
        } else {
            vw = viewerRect.width;
            vh = viewerRect.height;
        }

        for (var i = 0; i < dockingPanels.length; ++i) {
            var panel = dockingPanels[i].container,
                panelRect = panel.getBoundingClientRect(),
                pt = panelRect.top,
                pb = panelRect.bottom,
                pl = panelRect.left,
                pr = panelRect.right,
                pw = panelRect.width,
                ph = panelRect.height;

            if (pw && ph) {

                // Panel width should not be greater than viewer width.
                //
                if (vw < pw) {
                    pw = Math.round(vw);
                    panel.style.width = pw + "px";
                }

                // Panel height should not be greater than viewer height.
                //
                if (vh < ph) {
                    ph = Math.round(vh);
                    panel.style.height = ph + "px";
                }

                // Adjust horizontally if panel extends beyond right edge of viewer or panel is docked.
                //
                if ((vr < pr) || panel.dockRight) {
                    pl = Math.round(vr - pw - vl);
                    panel.style.left = pl + "px";
                }

                // Adjust vertically if panel extends beyond bottom edge of viewer or panel is docked.
                //
                if ((vb < pb) || panel.dockBottom) {
                    pt = Math.round(vb - ph - vt);
                    if (pt < 0) {
                        pt = 0;
                    }
                    panel.style.top = pt + "px";
                }

                // Set panel max width/height based upon viewer width/height.
                //
                panel.style.maxWidth = Math.round(vw) + "px";
                panel.style.maxHeight = Math.round(vh) + "px";
            }
        }

    };

    GuiViewer3D.prototype.initExplodeSlider = function () {
        var viewer = this;

        var button = new avu.Button('toolbar-explodeTool');
        button.setIcon("adsk-icon-explode");
        button.setToolTip("Explode model");
        viewer.modelTools.addControl(button, {index: 0});

        var htmlString = '<div class="explode-submenu" style="display:none"><input class="explode-slider" type="range" min="0" max="1" step="0.01" value="0"/></div>';
        this.explodeSubmenu = stringToDOM(htmlString);

        // hack fix for iOS bug
        // range input not draggable when nested under button
        var parentDom;
        if (true || isIOSDevice()) {
            parentDom = document.querySelector("#toolbar-explodeTool").parentNode;
            this.explodeSubmenu.classList.add("ios");
        }
        else {
            parentDom = button.container;
        }
        parentDom.appendChild(this.explodeSubmenu);

        var slider = this.explodeSubmenu.querySelector(".explode-slider");
        viewer.explodeSlider = slider;
        slider.oninput = function (e) {
            viewer.explode(slider.value);
        };
        //oninput does not seem to work on IE11...
        slider.onchange = function (e) {
            viewer.explode(slider.value);
        };
        this.explodeSubmenu.onclick = function (e) {
            e.stopPropagation();
        };

        // hack to disable tooltip, actually also problem with ViewerSettingsPanel
        var tooltip = button.container.querySelector(".adsk-control-tooltip");

        button.onClick = function (e) {
            var state = button.getState();
            if (state === avu.Button.State.INACTIVE) {
                button.setState(avu.Button.State.ACTIVE);
                tooltip.style.display = "none";
                viewer.explodeSubmenu.style.display = "";

                // Explode is not handled via ToolController; log it separately for now
                if (avp.logger) {
                    avp.logger.log({category: 'tool_changed', name: 'explode'});
                }
            }
            else if (state === avu.Button.State.ACTIVE) {
                button.setState(avu.Button.State.INACTIVE);
                tooltip.style.display = "";
                slider.parentNode.style.display = "none";
                viewer.explode(0);
                viewer.explodeSlider.value = 0;
            }
        };
    };

    GuiViewer3D.prototype.initInspectTools = function () {
        var viewer = this;

        var inspectToolsButton = new avu.Button("toolbar-inspectTools");
        inspectToolsButton.setToolTip("Inspect");
        inspectToolsButton.setIcon("measure");
        inspectToolsButton.setVisible(false);
        this.modelTools.addControl(inspectToolsButton);

        var inspectSubmenu = new avu.RadioButtonGroup('toolbar-inspectSubMenu');
        inspectSubmenu.addClass('toolbar-vertical-group');
        inspectSubmenu.setVisible(false);
        this.modelTools.addControl(inspectSubmenu);

        // Insert at the beginning so the CSS selector works.
        inspectToolsButton.container.insertBefore(inspectSubmenu.container, inspectToolsButton.container.firstChild);

        inspectToolsButton.onMouseOver = function () {
            inspectSubmenu.setVisible(true);
        };

        inspectToolsButton.onMouseOut = function () {
            inspectSubmenu.setVisible(false);
        };

        if (isTouchDevice()) {
            inspectToolsButton.onClick = function (e) {
                inspectSubmenu.setVisible(!inspectSubmenu.isVisible());
            };
        }
    };

    GuiViewer3D.prototype.initModality = function () {

        function findToolbarParent(elem) {
            var MAX_DEPTH = 2;  // arbitrary
            var depth = 0;
            while (depth < MAX_DEPTH && elem.parentElement) {
                var eid = elem.id;
                if (eid.indexOf("toolbar-") === 0) {
                    // ignore arrow
                    if (eid.indexOf("arrow") === eid.length - 5)
                        return undefined;
                    // check if submenu, if so, return root button
                    var rootButton = findToolbarParent(elem.parentElement);
                    return rootButton || elem;
                }
                elem = elem.parentElement;
                depth++;
            }
        }

        function getButtonName(elem) {
            return elem.id.substring(8, elem.id.length);
        }

        function getButtonActive(elem) {
            return elem.classList.contains("active");
        }

        function simulateClick(elem) {
            elem.dispatchEvent(new Event("click"));
        }

        // tool names registered for modality management
        // this mapping determines what tools are allowed together
        // when a tool is activated, all other tools but the ones allowed here will be disabled
        var modalityMap = {
            orbitTools:    { explodeTool:1 },
            panTool:       { explodeTool:1 },
            zoomTool:      { explodeTool:1 },
            beelineTool:   {},
            sectionTool:   {},
            measureTool:   {},
            explodeTool:   {}
        };

        var activeButtons = {};
        function registerButton(name, button, register) {
            activeButtons[name] = register ? button : undefined;
            // console.log("modal "+ (register ? "+" : "-") +" " + name);
        }

        function handleModality(e) {
            if (e.target.classList.contains("clickoff"))
                return;

            var button = findToolbarParent(e.target);
            if (!button) return;

            var toolName = getButtonName(button);

            // not handled
            if (!modalityMap[toolName])
                return;

            // special case section button, do not handle if initial blank state
            // HACK: use icon class to detect this case
            if (toolName === "sectionTool" && (
                e.target.classList.contains("adsk-icon-section-analysis") ||
                e.target.querySelector(".adsk-icon-section-analysis")))
                return;

            // if already registered as active
            if (activeButtons[toolName]) {
                registerButton(toolName, button, false);

                // if out of sync, the button is actually inactive, we need to continue as usual
                if (getButtonActive(button))
                    return;
            }

            // loop active buttons, deactivate (i.e., click again) if not allowed in map
            for (var k in activeButtons) {
                var b = activeButtons[k];
                if (!b)
                    continue;
                var bname = getButtonName(b);
                if (!getButtonActive(b))    // button already inactive, we're is out of sync, so we just unregister
                    registerButton(bname, b, false);
                else if (!modalityMap[toolName][bname]) // if not allowed by map
                    simulateClick(b);   // HACKY!
            }

            // finally, register active button
            registerButton(toolName, button, true);
        }

        this.toolbar.container.addEventListener("click", handleModality, true);
    };

    /**
     * Changes visibility of buttons in toolbar to accommodate as many as possible
     * given the available space.  Think of it as a media query applied to the viewer
     * canvas only (as opposed to the whole website)
     */
    GuiViewer3D.prototype.updateToolbarButtons = function(width, height) {

        var toolbar = this.getToolbar(false);
        if (!toolbar) return;

        //console.log("resized " + width);
        var ctrl, display;

        // 310px threshold
        display = width > 310 ? "block" : "none";
        ctrl = this.modelTools.getControl('toolbar-explodeTool');
        if (ctrl) ctrl.setDisplay(display);

        // 380px threshold
        display = width > 380 ? "block" : "none";
        ctrl = this.modelTools.getControl('toolbar-collaborateTool');
        if (ctrl) ctrl.setDisplay(display);

        // 515px threshold
        display = width > 515 ? "block" : "none";
        var camMenu = this.navTools.getControl('toolbar-cameraSubmenuTool');
        if (camMenu) {
            camMenu.setDisplay(display);
            ctrl = camMenu.subMenu.getControl('toolbar-homeTool');
            if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('gotoview') ? 'block' : 'none');
            ctrl = camMenu.subMenu.getControl('toolbar-fitToViewTool');
            if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('gotoview') ? 'block' : 'none');
            ctrl = camMenu.subMenu.getControl('toolbar-focalLengthTool');
            if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('fov') ? 'block' : 'none');
            ctrl = camMenu.subMenu.getControl('toolbar-rollTool');
            if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('roll') ? 'block' : 'none');
        }

        // 700px threshold
        display = width > 700 ? "block" : "none";
        ctrl = this.modelTools.getControl('toolbar-measureTool');
        if (ctrl) ctrl.setDisplay(display);
        ctrl = this.modelTools.getControl('toolbar-sectionTool');
        if (ctrl) ctrl.setDisplay(display);

        // 740px threshold
        display = width > 740 ? "block" : "none";
        ctrl = this.navTools.getControl('toolbar-beelineTool');
        if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('walk') ? display : 'none');
        ctrl = this.navTools.getControl('toolbar-firstPersonTool');
        if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('walk') ? display : 'none');
        ctrl = this.navTools.getControl('toolbar-zoomTool');
        if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('zoom') ? display : 'none');
        ctrl = this.navTools.getControl('toolbar-panTool');
        if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('pan') ? display : 'none');
        ctrl = this.navTools.getControl('toolbar-orbitTools');
        if (ctrl) ctrl.setDisplay(this.navigation.isActionEnabled('orbit') ? display : 'none');
    };

    avp.GuiViewer3D = GuiViewer3D;

})();
;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avu = Autodesk.Viewing.UI;


/**
 * @class
 * This is the base class for controls. It is abstract and should not be instantiated directly.
 *
 * @param {String} id - The id for this control. Optional.
 * @param {Object} [options] - An optional dictionary of options.
 * @param {Boolean} [options.collapsible=true] - Whether this control is collapsible
 *
 * @constructor
 * @abstract
 * @memberof Autodesk.Viewing.UI
 */
function Control(id, options) {
    this._id = id;
    this._isCollapsible = !options || options.collapsible;

    this._toolTipElement = null;

    this._listeners = {};

    this.container = document.createElement('div');
    this.container.id = id;
    this.addClass('adsk-control');
};

/**
 * Enum for control event IDs.
 * @readonly
 * @enum {String}
 */
Control.Event = {
    VISIBILITY_CHANGED: 'Control.VisibilityChanged',
    COLLAPSED_CHANGED: 'Control.CollapsedChanged'
};

/**
 * Event fired when the visibility of the control changes.
 *
 * @event Autodesk.Viewing.UI.Control#VISIBILITY_CHANGED
 * @type {Object}
 * @property {String} controlId - The ID of the control that fired this event.
 * @property {Boolean} isVisible - True if the control is now visible.
 */

/**
 * Event fired when the collapsed state of the control changes.
 *
 * @event Autodesk.Viewing.UI.Control#COLLAPSED_CHANGED
 * @type {Object}
 * @property {String} controlId - The ID of the control that fired this event.
 * @property {Boolean} isCollapsed - True if the control is now collapsed.
 */

av.EventDispatcher.prototype.apply(Control.prototype);
Control.prototype.constructor = Control;

/**
 * The HTMLElement representing this control.
 *
 * @type {HTMLElement}
 * @public
 */
Control.prototype.container = null;

/**
 * Gets this control's ID.
 *
 * @returns {String} - The control's ID.
 */
Control.prototype.getId = function() {
    return this._id;
};

/**
 * Sets the visibility of this control.
 *
 * @param {Boolean} visible - The visibility value to set.
 *
 * @returns {Boolean} - True if the control's visibility changed.
 *
 * @fires Autodesk.Viewing.UI.Control#VISIBILITY_CHANGED
 */
Control.prototype.setVisible = function(visible) {
    var isVisible = !this.container.classList.contains('adsk-hidden');

    if (isVisible === visible) {
        return false;
    }

    if (visible) {
        this.container.classList.remove('adsk-hidden');
    } else {
        this.container.classList.add('adsk-hidden');
    }

    var event = {
        type: Control.Event.VISIBILITY_CHANGED,
        target: this,
        controlId: this._id,
        isVisible: visible
    };

    this.fireEvent(event);

    return true;
};

/**
 * Gets the visibility of this control.
 *
 * @returns {Boolean} - True if the this control is visible.
 */
Control.prototype.isVisible = function() {
    return !this.container.classList.contains('adsk-hidden');
};

/**
 * Sets the tooltip text for this control.
 *
 * @param {String} toolTipText - The text for the tooltip.
 *
 * @returns {Boolean} - True if the tooltip was successfully set.
 */
Control.prototype.setToolTip = function(toolTipText) {
    if (this._toolTipElement && this._toolTipElement.getAttribute("tooltipText") === toolTipText) {
        return false;
    }

    if (!this._toolTipElement) {
        this._toolTipElement = document.createElement('div');
        this._toolTipElement.id = this._id + '-tooltip';
        this._toolTipElement.classList.add('adsk-control-tooltip');
        this.container.appendChild(this._toolTipElement);
    }

    this._toolTipElement.setAttribute("data-i18n", toolTipText);
    this._toolTipElement.setAttribute("tooltipText", toolTipText);
    this._toolTipElement.textContent = Autodesk.Viewing.i18n.translate(toolTipText, { defaultValue: toolTipText });

    return true;
};

/**
 * Returns the tooltip text for this control.
 *
 * @returns {String?} - The tooltip text. Null if it's not set.
 */
Control.prototype.getToolTip = function() {
    return this._toolTipElement && this._toolTipElement.getAttribute("tooltipText");
};

/**
 * Sets the collapsed state of this control.
 *
 * @param {Boolean} collapsed - The collapsed value to set.
 *
 * @returns {Boolean} - True if the control's collapsed state changes.
 *
 * @fires Autodesk.Viewing.UI.Control#COLLAPSED_CHANGED
 */
Control.prototype.setCollapsed = function(collapsed) {
    if (!this._isCollapsible || this.isCollapsed() === collapsed) {
        return false;
    }

    if (collapsed) {
        this.container.classList.add('collapsed');
    } else {
        this.container.classList.remove('collapsed');
    }

    var event = {
        type: Control.Event.COLLAPSED_CHANGED,
        isCollapsed: collapsed
    };

    this.fireEvent(event);

    return true;
};

/**
 * Gets the collapsed state of this control.
 *
 * @returns {Boolean} - True if this control is collapsed.
 */
Control.prototype.isCollapsed = function() {
    return !!this.container.classList.contains('collapsed');
};

/**
 * Returns whether or not this control is collapsible.
 *
 * @returns {Boolean} - True if this control can be collapsed.
 */
Control.prototype.isCollapsible = function() {
    return this._isCollapsible;
};

/**
 * Adds a CSS class to this control.
 *
 * @param {String} cssClass - The name of the CSS class.
 *
 */
Control.prototype.addClass = function(cssClass) {
    this.container.classList.add(cssClass);
};

/**
 * Removes a CSS class from this control.
 *
 * @param {String} cssClass - The name of the CSS class.
 *
 */
Control.prototype.removeClass = function(cssClass) {

    this.container.classList.remove(cssClass);

};
    
/**
 * Returns the position of this control relative to the canvas.
 *
 * @returns {Object} - The top and left values of the toolbar.
 */
Control.prototype.getPosition = function() {
    var clientRect = this.container.getBoundingClientRect();

    return {top: clientRect.top, left: clientRect.left};
};

/**
 * Returns the dimensions of this control.
 *
 * @returns {Object}  - The width and height of the toolbar.
 */
Control.prototype.getDimensions = function() {
    var clientRect = this.container.getBoundingClientRect();

    return {width: clientRect.width, height: clientRect.height};
};

Control.prototype.setDisplay = function(value) {
    this.container.style.display = value;
};

Autodesk.Viewing.UI.Control = Control;

})();;
(function() {

"use strict";

var avu = Autodesk.Viewing.UI;

/**
 * @class
 * A class for grouping controls.
 *
 * @param {String} id - The id for this control group.
 * @param {Object} [options] - An optional dictionary of options.
 * @param {Boolean} [options.collapsible=true] - Whether this control group is collapsible
 *
 * @constructor
 * @augments Autodesk.Viewing.UI.Control
 * @memberof Autodesk.Viewing.UI
 */

function ControlGroup (id, options) {
    avu.Control.call(this, id, options);

    var self = this;

    this._controls = [];

    this.addClass('adsk-control-group');

    this.handleChildSizeChanged = function(event) {
        var sizeEvent = {
            type: ControlGroup.Event.SIZE_CHANGED,
            childEvent: event
        };
        self.fireEvent(sizeEvent);
    };
};

/**
 * Enum for control group event IDs.
 * @readonly
 * @enum {String}
 */
ControlGroup.Event = {
    // Inherited from Control
    VISIBILITY_CHANGED: avu.Control.Event.VISIBILITY_CHANGED,
    COLLAPSED_CHANGED: avu.Control.Event.COLLAPSED_CHANGED,

    SIZE_CHANGED: 'ControlGroup.SizeChanged',
    CONTROL_ADDED: 'ControlGroup.ControlAdded',
    CONTROL_REMOVED: 'ControlGroup.ControlRemoved'
};

/**
 * Event fired a control is added to the control group.
 *
 * @event Autodesk.Viewing.UI.ControlGroup#CONTROL_ADDED
 * @type {Object}
 * @property {String} control - The control that was added.
 * @property {Number} index - The index at which the control was added.
 */

/**
 * Event fired when a control is removed from the control group.
 *
 * @event Autodesk.Viewing.UI.ControlGroup#CONTROL_REMOVED
 * @type {Object}
 * @property {String} control - The control that was removed.
 * @property {Number} index - The index at which the control was removed.
 */

/**
 * Event fired when the size of the control group changes.
 *
 * @event Autodesk.Viewing.UI.ControlGroup#SIZE_CHANGED
 * @type {Object}
 * @property {Object?} childEvent - The event that the child fired.
 */

ControlGroup.prototype = Object.create(avu.Control.prototype);
ControlGroup.prototype.constructor = ControlGroup;

/**
 * Adds a control to this control group.
 *
 * @param {Autodesk.Viewing.UI.Control} control - The control to add.
 * @param {Object} [options] - An option dictionary of options.
 * @param {Object} [options.index] - The index to insert the control at.
 *
 * @returns {Boolean} - True if the control was successfully added.
 *
 * @fires Autodesk.Viewing.UI.ControlGroup#CONTROL_ADDED
 * @fires Autodesk.Viewing.UI.ControlGroup#SIZE_CHANGED
 */
ControlGroup.prototype.addControl = function(control, options) {

    var index = (options && options.index !== undefined) ? options.index : this._controls.length;

    if (this.getControl(control.getId()) !== null) {
        return false;
    }

    var addedEvent = {
        type: ControlGroup.Event.CONTROL_ADDED,
        control: control,
        index: index
    };

    if (index < this._controls.length) {
        this.container.insertBefore(control.container, this._controls[index].container);
        this._controls.splice(index, 0, control);
    } else {
        this.container.appendChild(control.container);
        this._controls.push(control);
    }

    // Listen for events on the child controls that may trigger a change in out size
    control.addEventListener(avu.Control.Event.VISIBILITY_CHANGED, this.handleChildSizeChanged);
    control.addEventListener(avu.Control.Event.COLLAPSED_CHANGED, this.handleChildSizeChanged);
    if (control instanceof ControlGroup) {
        control.addEventListener(ControlGroup.Event.SIZE_CHANGED, this.handleChildSizeChanged);
    }

    this.fireEvent(addedEvent);
    this.fireEvent(ControlGroup.Event.SIZE_CHANGED);

    return true;
};

/**
 * Returns the index of a control in this group. -1 if the item isn't found.
 *
 * @param {String|Autodesk.Viewing.UI.Control} control - The control ID or control instance to find
 *
 * @returns {Number} - True if the control was successfully removed.
 */
ControlGroup.prototype.indexOf = function(control) {
    for (var i = 0; i < this._controls.length; i++) {
        var c = this._controls[i];
        if (c === control || (typeof control === "string" && control === c.getId())) {
            return i;
        }
    }

    return -1;
};

/**
 * Removes a control from this control group.
 *
 * @param {String|Autodesk.Viewing.UI.Control} control - The control ID or control instance to remove
 *
 * @returns {Boolean} - True if the control was successfully removed.
 *
 * @fires Autodesk.Viewing.UI.ControlGroup#CONTROL_REMOVED
 * @fires Autodesk.Viewing.UI.ControlGroup#SIZE_CHANGED
 * 
 */
ControlGroup.prototype.removeControl = function(control) {

    var thecontrol = (typeof control === "string") ? this.getControl(control) : control;

    if (!thecontrol) {
        return false;
    }

    var index = this._controls.indexOf(thecontrol);
    this._controls.splice(index, 1);
    this.container.removeChild(thecontrol.container);

    var addedEvent = {
        type: ControlGroup.Event.CONTROL_REMOVED,
        control: thecontrol,
        index: index
    };

    // Remove listeners from children
    thecontrol.removeEventListener(avu.Control.Event.VISIBILITY_CHANGED, this.handleChildSizeChanged);
    thecontrol.removeEventListener(avu.Control.Event.COLLAPSED_CHANGED, this.handleChildSizeChanged);
    if (thecontrol instanceof ControlGroup) {
        thecontrol.removeEventListener(ControlGroup.Event.SIZE_CHANGED, this.handleChildSizeChanged);
    }

    this.fireEvent(addedEvent);
    this.fireEvent(ControlGroup.Event.SIZE_CHANGED);

    return true;
};

/**
 * Returns the control with the corresponding ID if it is in this control group.
 *
 * @param {String} controlId - The ID of the control.
 *
 * @returns {Autodesk.Viewing.UI.Control?} - The control or Null if it doesn't exist.
 */
ControlGroup.prototype.getControl = function(controlId) {
    for (var i = 0; i < this._controls.length; i++) {
        if (controlId === this._controls[i].getId()) {
            return this._controls[i];
        }
    }

    return null;
};

/**
 * Returns the number of controls in this control group.
 *
 * @returns {Number} - The number of controls.
 */
ControlGroup.prototype.getNumberOfControls = function() {
    return this._controls.length;
};

/**
 * Sets the collapsed state of this control group. Iterates over the child controls and calls child.setCollapsed(collapsed).
 *
 * @param {Boolean} collapsed - The collapsed value to set.
 *
 * @returns {Boolean} - True if at least one collapsible child's state changes
 *
 * @fires Autodesk.Viewing.UI.Control#COLLAPSED_CHANGED
 */
ControlGroup.prototype.setCollapsed = function(collapsed) {
    if (!this._isCollapsible) {
        return false;
    }

    var childHasCollapsed = false;

    this._controls.forEach(function(control) {
        if (control.isCollapsible() && control.setCollapsed(collapsed)) {
            childHasCollapsed = true;
        }
    });

    if (childHasCollapsed) {
        if (collapsed) {
            this.container.classList.add('collapsed');
        } else {
            this.container.classList.remove('collapsed');
        }

        this.fireEvent({
            type: ControlGroup.Event.COLLAPSED_CHANGED,
            isCollapsed: collapsed
        });
    }

    return childHasCollapsed;
};

Autodesk.Viewing.UI.ControlGroup = ControlGroup;
})();

;
(function() {

"use strict";

var avu = Autodesk.Viewing.UI;

/**
 * @class
 * This is the core class that represents a toolbar. It consists of {@link Autodesk.Viewing.UI.ControlGroup|ControlGroups}
 * that group controls by functionality.
 *
 * @alias Autodesk.Viewing.UI.ToolBar
 * @param {String} id - The id for this toolbar.
 * @param {Object} [options] - An optional dictionary of options.
 * @param {Boolean} [options.collapsible=true] - Whether this toolbar is collapsible
 *
 * @constructor
 * @augments Autodesk.Viewing.UI.ControlGroup
 * @memberof Autodesk.Viewing.UI
 */
function ToolBar(id, options) {
    avu.ControlGroup.call(this, id, options);

    this.removeClass('adsk-control-group');
    this.addClass('adsk-toolbar');
};

/**
 * Enum for toolbar event IDs.
 * @readonly
 * @enum {String}
 */
ToolBar.Event = {
    // Inherited from Control
    VISIBILITY_CHANGED: avu.Control.Event.VISIBILITY_CHANGED,
    COLLAPSED_CHANGED: avu.Control.Event.COLLAPSED_CHANGED,

    // Inherited from ControlGroup
    CONTROL_ADDED: avu.ControlGroup.Event.CONTROL_ADDED,
    CONTROL_REMOVED: avu.ControlGroup.Event.CONTROL_REMOVED,
    SIZE_CHANGED: avu.ControlGroup.Event.SIZE_CHANGED
};

ToolBar.prototype = Object.create(avu.ControlGroup.prototype);
ToolBar.prototype.constructor = ToolBar;

Autodesk.Viewing.UI.ToolBar = ToolBar;
})();;
(function() {

"use strict";

var avu = Autodesk.Viewing.UI;


/**
 * @class
 * A button control that can be added to toolbars.
 *
 * @param {String?} id - The id for this button. Optional.
 * @param {Object} [options] - An optional dictionary of options.
 * @param {Boolean} [options.collapsible=true] - Whether this button is collapsible.
 *
 * @constructor
 * @augments Autodesk.Viewing.UI.Control
 * @memberof Autodesk.Viewing.UI
 */
function Button (id, options) {
    avu.Control.call(this, id, options);

    var self = this;

    this._state = Button.State.INACTIVE;

    this.icon = document.createElement("div");
    this.icon.classList.add("adsk-button-icon");
    this.container.appendChild(this.icon);

    this.container.addEventListener('click', function(event) {
        self.fireEvent(Button.Event.CLICK);
        if (self.onClick)
            self.onClick(event);
        event.stopPropagation();
    });

    // Add rollover only if this is not a touch device.
    if ( !isTouchDevice() ) {
        this.container.addEventListener("mouseover", function(e) {
            self.onMouseOver(e);
        });

        this.container.addEventListener("mouseout", function(e) {
            self.onMouseOut(e);
        });
    } else {
        this.container.addEventListener("touchstart", touchStartToClick);
    }

    this.addClass('adsk-button');
    this.addClass(Button.StateToClassMap[this._state]);
};

/**
 * Enum for button event IDs.
 * @readonly
 * @enum {String}
 */
Button.Event = {
    // Inherited from Control
    VISIBILITY_CHANGED: avu.Control.Event.VISIBILITY_CHANGED,
    COLLAPSED_CHANGED: avu.Control.Event.COLLAPSED_CHANGED,

    STATE_CHANGED: 'Button.StateChanged',
    CLICK: 'click'
};

/**
 * Enum for button states
 * @readonly
 * @enum {Number}
 */
Button.State = {
    ACTIVE: 0,
    INACTIVE: 1,
    DISABLED: 2
};

/**
 * @private
 */
Button.StateToClassMap = (function() {
    var state = Button.State;
    var map = {};

    map[state.ACTIVE] = 'active';
    map[state.INACTIVE] = 'inactive';
    map[state.DISABLED] = 'disabled';

    return map;
}());


/**
 * Event fired when state of the button changes.
 *
 * @event Autodesk.Viewing.UI.Button#STATE_CHANGED
 * @type {Object}
 * @property {String} buttonId - The ID of the button that fired this event.
 * @property {Autodesk.Viewing.UI.Button.State} state - The new state of the button.
 */

Button.prototype = Object.create(avu.Control.prototype);
Button.prototype.constructor = Button;

/**
 * Sets the state of this button.
 *
 * @param {Autodesk.Viewing.UI.Button.State} state - The state.
 *
 * @returns {Boolean} - True if the state was set successfully.
 *
 * @fires Autodesk.Viewing.UI.Button#STATE_CHANGED
 */
Button.prototype.setState = function(state) {
    if (state === this._state) {
        return false;
    }

    this.removeClass(Button.StateToClassMap[this._state]);
    this.addClass(Button.StateToClassMap[state]);
    this._state = state;

    var event = {
        type: Button.Event.STATE_CHANGED,
        state: state
    };

    this.fireEvent(event);

    return true;
};

/**
 * Sets the icon for the button.
 *
 * @param {string} iconClass The CSS class defining the appearance of the button icon (e.g. image background).
 */
Button.prototype.setIcon = function(iconClass) {
    if (this.iconClass)
        this.icon.classList.remove(this.iconClass);
    this.iconClass = iconClass;
    this.icon.classList.add(iconClass);
};


/**
 * Returns the state of this button.
 *
 * @returns {Autodesk.Viewing.UI.Button.State} - The state of the button.
 */
Button.prototype.getState = function() {
    return this._state;
};

/**
 * Override this method to be notified when the user clicks on the button.
 * @param {MouseEvent} event
 */
Button.prototype.onClick = function(event) {

};

/**
 * Override this method to be notified when the mouse enters the button.
 * @param {MouseEvent} event
 */
Button.prototype.onMouseOver = function(event) {

};

/**
 * Override this method to be notified when the mouse leaves the button.
 * @param {MouseEvent} event
 */
Button.prototype.onMouseOut = function(event) {

};

Autodesk.Viewing.UI.Button = Button;
})();;
(function() {

    "use strict";

    var avu = Autodesk.Viewing.UI;

    /**
     * A comboButton with subMenu can be added to toolbars.
     *
     * @param {String} id - The id for this comboButton. Optional.
     * @param {Object} [options] - An optional dictionary of options.
     *
     * @constructor
     * @augments Autodesk.Viewing.UI.Button
	 * @memberof Autodesk.Viewing.UI
     */
    function ComboButton(id, options) {
        avu.Button.call(this, id, options);

        this.arrowButton = new avu.Button(id + 'arrow');
        this.arrowButton.addClass('adsk-button-arrow');
        this.arrowButton.removeClass('adsk-button');

        this.subMenu = new avu.RadioButtonGroup(id + 'SubMenu');
        this.subMenu.addClass('toolbar-vertical-group');
        this.subMenu.setVisible(false);

        this.container.insertBefore(this.subMenu.container, this.container.firstChild);
        this.container.insertBefore(this.arrowButton.container, this.container.firstChild);

        var scope = this;
        this.arrowButton.onClick = function(e) {
            scope.subMenu.setVisible(!scope.subMenu.isVisible());
        };

        this.toggleFlyoutVisible = function() {
            scope.subMenu.setVisible(!scope.subMenu.isVisible());
        };

        this.onClick = function(e) {
            scope.subMenu.setVisible(!scope.subMenu.isVisible());
        };

        this.subMenuActiveButtonChangedHandler = function(event) {
            if (event.isActiveButton) {
                scope.setIcon(event.target.getActiveButton().iconClass);
                scope.setToolTip(event.target.getActiveButton().getToolTip());
                scope.setState(avu.Button.State.ACTIVE);
                scope.onClick = event.button.onClick;
            }
            else {
                scope.setState(avu.Button.State.INACTIVE);
            }
        };

        this.subMenu.addEventListener(avu.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED, this.subMenuActiveButtonChangedHandler);

        // put up an invisible div to catch click-off close submenu
        var clickOff = stringToDOM('<div class="clickoff" style="position:fixed; top:0; left:0; width:100vw; height:100vh;"></div>');
        this.subMenu.container.insertBefore(clickOff, this.subMenu.container.firstChild);
        clickOff.addEventListener("click", function(e) {
            scope.subMenu.setVisible(false);
            e.stopPropagation();
        });

    };

    ComboButton.prototype = Object.create(avu.Button.prototype);
    ComboButton.prototype.constructor = ComboButton;


    /**
     * * Adds a new control to the combo fly-out
     */
    ComboButton.prototype.addControl = function(button) {
    /*
        if (this.subMenu.getNumberOfControls() === 0)
            this.onClick = button.onClick;
    */
        this.subMenu.addControl(button);
        button.addEventListener(avu.Button.Event.CLICK, this.toggleFlyoutVisible);

    };


    ComboButton.prototype.removeControl = function(button) {

        button.removeEventListener(avu.Button.Event.CLICK, this.toggleFlyoutVisible);

    };

    ComboButton.prototype.setState = function(state) {

        //Overloaded to inactivate children when the parent is inactivated
        if (state === avu.Button.State.INACTIVE) {
            var ab = this.subMenu.getActiveButton();
            if (ab) {
                ab.setState(avu.Button.State.INACTIVE);
            }
        }

        //Also call super
        avu.Button.prototype.setState.call(this, state);
    };

    /**
     * Copies tooltip (if any), icon and click handler into an internal attribute.
     * Can be restored through restoreDefault().
     */
    ComboButton.prototype.saveAsDefault = function() {
        this.defaultState = {};
        // Save tooltip
        if (this._toolTipElement && this._toolTipElement.getAttribute("tooltipText")) {
            this.defaultState.tooltip = this._toolTipElement.getAttribute("tooltipText");
        }
        // Save icon
        this.defaultState.icon = this.iconClass;
        // Save click handler
        this.defaultState.onClick = this.onClick;
    };

    /**
     * Restores visual settings previously stored through saveAsDefault().
     */
    ComboButton.prototype.restoreDefault = function() {
        if (!this.defaultState) return;
        if (this.defaultState.tooltip) {
            this.setToolTip(this.defaultState.tooltip);
        }
        if (this.defaultState.icon) {
            this.setIcon(this.defaultState.icon);
        }
        this.onClick = this.defaultState.onClick; // No check on this one.
        this.setState(avu.Button.State.INACTIVE);
    };

Autodesk.Viewing.UI.ComboButton = ComboButton;

})();
;
(function() {

"use strict";

var avu = Autodesk.Viewing.UI;

/**
 * @class
 * A group of controls that act like a radio group. I.e. Only one button may be active at a time.
 * Only accepts {@link Autodesk.Viewing.UI.Button|buttons}.
 *
 * @param {String} id - The id for this control group.
 * @param {Object} [options] - An optional dictionary of options.
 * @param {Boolean} [options.collapsible=true] - Whether this control group is collapsible
 *
 * @constructor
 * @augments Autodesk.Viewing.UI.ControlGroup
 * @memberof Autodesk.Viewing.UI
 */
function RadioButtonGroup(id, options) {
    avu.ControlGroup.call(this, id, options);

    var self = this;

    this._activeButton = null;

    this._handleButtonStateChange = function(event) {
        var states = avu.Button.State;

        if (event.state !== states.ACTIVE) {
            if (event.target === self._activeButton) {
                self._activeButton = null;
                self.fireEvent({
                    type: RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED,
                    button: event.target,
                    isActiveButton: false
                });
            }
            return;
        } else {
            self._activeButton = event.target;
            self.fireEvent({
                type: RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED,
                button: event.target,
                isActiveButton: true
            });
        }

        self._controls.forEach(function(control) {
            if (control !== event.target && control.getState() !== states.DISABLED) {
                control.setState(states.INACTIVE);
            }
        });
    }
};

/**
 * Enum for radio button group event IDs.
 * @readonly
 * @enum {String}
 */
RadioButtonGroup.Event = {
    ACTIVE_BUTTON_CHANGED: 'RadioButtonGroup.ActiveButtonChanged',

    // Inherited from Control
    VISIBILITY_CHANGED: avu.Control.Event.VISIBILITY_CHANGED,
    COLLAPSED_CHANGED: avu.Control.Event.COLLAPSED_CHANGED,

    // Inherited from ControlGroup
    CONTROL_ADDED: avu.ControlGroup.Event.CONTROL_ADDED,
    CONTROL_REMOVED: avu.ControlGroup.Event.CONTROL_REMOVED,
    SIZE_CHANGED: avu.ControlGroup.Event.SIZE_CHANGED
};

/**
 * Event fired when active button for this radio group changes.
 *
 * @event Autodesk.Viewing.UI.RadioButtonGroup#ACTIVE_BUTTON_CHANGED
 * @type {Object}
 * @property {Autodesk.Viewing.UI.Button} button - The button whose state is changing.
 * @property {Boolean} isActiveButton - Is the event target the currently active button.
 */

RadioButtonGroup.prototype = Object.create(avu.ControlGroup.prototype);
RadioButtonGroup.prototype.constructor = RadioButtonGroup;

/**
 * Adds a control to this radio button group. The control must be a {@link Autodesk.Viewing.UI.Button|button}.
 *
 * @param {Autodesk.Viewing.UI.Button} control - The button to add.
 * @param {Object} [options] - An option dictionary of options.
 * @param {Object} [options.index] - The index to insert the control at.
 *
 * @returns {Boolean} - True if the button was successfully added.
 *
 * @fires Autodesk.Viewing.UI.ControlGroup#CONTROL_ADDED
 * @fires Autodesk.Viewing.UI.ControlGroup#SIZE_CHANGED
 */
RadioButtonGroup.prototype.addControl = function(control, options) {
    if (!(control instanceof avu.Button)) {
        return false;
    }

    // Add listeners for radio functionality if we were successful
    if (avu.ControlGroup.prototype.addControl.call(this, control, options)) {
        control.addEventListener(avu.Button.Event.STATE_CHANGED, this._handleButtonStateChange);
        return true;
    }

    return false;
};

/**
 * Removes a control from this control group.
 *
 * @param {String|Autodesk.Viewing.UI.Control} control - The control ID or control instance to remove
 *
 * @returns {Boolean} - True if the control was successfully removed.
 *
 * @fires Autodesk.Viewing.UI.ControlGroup#CONTROL_REMOVED
 * @fires Autodesk.Viewing.UI.ControlGroup#SIZE_CHANGED
 */
RadioButtonGroup.prototype.removeControl = function(control) {

    var thecontrol = (typeof control == "string") ? this.getControl(control) : control;

    // Remove listeners for radio functionality if we were successful
    if (thecontrol !== null && avu.ControlGroup.prototype.removeControl.call(this, thecontrol)) {
        thecontrol.removeEventListener(avu.Button.Event.STATE_CHANGED, this._handleButtonStateChange);
        return true;
    }

    return false;
};

/**
 * Returns the active button in this radio button group.
 *
 * @returns {Autodesk.Viewing.UI.Button?} - The active button. Null if no button is active.
 */
RadioButtonGroup.prototype.getActiveButton = function() {
    return this._activeButton;
};

Autodesk.Viewing.UI.RadioButtonGroup = RadioButtonGroup;
})();;/** @license Copyright (c) 2015 Autodesk Inc. */
/** Version; @buildnum@ */

/**
 * Mobile callbacks wrapper, consolidating all calls to iOS and Android platforms
 */
AutodeskNamespace('Autodesk.Viewing');

function MobileCallbacks () {
    this.ios = window.webkit;
    this.android = window.JSINTERFACE;

    this.iosSend = function (commandName, args){
        window.webkit.messageHandlers.callbackHandler.postMessage({'command': commandName, 'data': args});
    };

    this.androidSend = window.JSINTERFACE;
}

var proto = MobileCallbacks.prototype;

proto.animationReady = function () {
    if (this.ios)
        this.iosSend('animationReady');
    else if (this.android)
        this.androidSend.animationReady();
};

proto.onSelectionChanged = function (dbId) {
    if (this.ios)
        this.iosSend('selectionChanged', dbId);
    else if (this.android)
        this.androidSend.onSelectionChanged(dbId);
};

proto.onLongTap = function (clientX, clientY) {
    if (this.ios)
        this.iosSend('onLongTap', [clientX, clientY]);
    else if (this.android)
        this.androidSend.onLongTap(clientX, clientY);
};

proto.onSingleTap = function (clientX, clientY) {
    if (this.ios)
        this.iosSend('onSingleTap', [clientX, clientY]);
    else if (this.android)
        this.androidSend.onSingleTap(clientX, clientY);
};

proto.onDoubleTap = function (clientX, clientY) {
    if (this.ios)
        this.iosSend('onDoubleTap', [clientX, clientY]);
    else if (this.android)
        this.androidSend.onDoubleTap(clientX, clientY);
};

proto.setRTCSession = function (id){
    if (this.ios)
        this.iosSend('setRTCSession', {'id':id});
    else if (this.android)
        this.androidSend.setRTCSessionID(id);
};

proto.putProperties = function (name, value){
    if (this.ios)
        this.iosSend('putProperties', {'name':name, 'value':value});
    else if (this.android)
        this.androidSend.putProperties(name, value);
};

proto.onPropertyRetrievedSuccess = function (){
    if (this.ios)
        this.iosSend('onPropertyRetrievedSuccess');
    else if (this.android)
        this.androidSend.onPropertyRetrievedSuccess();
};

proto.onPropertyRetrievedFailOrEmptyProperties = function (){
    if (this.ios)
        this.iosSend('onPropertyRetrievedFailOrEmptyProperties');
    else if (this.android)
        this.androidSend.onPropertyRetrievedFailOrEmptyProperties();
};

proto.resetAnimationStatus = function (){
    if (this.ios)
        this.iosSend('resetAnimationStatus');
    else if (this.android)
        this.androidSend.resetAnimationStatus();
};

proto.setPauseUI = function (){
    if (this.ios)
        this.iosSend('setPauseUI');
    else if (this.android)
        this.androidSend.setToPaused();
};

proto.updateAnimationTime = function (time){
    if (this.ios)
        this.iosSend('updateAnimationTime', time);
    else if (this.android)
        this.androidSend.updateAnimationTime(time);
};


proto.setLoadingProgress = function (progress){
    if (this.ios)
        this.iosSend('setLoadingProgress', progress);
    else if (this.android)
        this.androidSend.setLoadingProgress(progress);
};

proto.objectTreeCreated = function (){
    if (this.ios)
        this.iosSend('objectTreeCreated');
    else if (this.android)
        this.androidSend.objectTreeCreated();
};

proto.geometryLoaded = function (){
    if (this.ios)
        this.iosSend('geometryLoaded');
    else if (this.android)
        this.androidSend.geometryLoaded();
};

proto.putSheets = function (geomName, geomGuid){
    if (this.ios)
        this.iosSend('putSheets', [geomName, geomGuid]);
    else if (this.android)
        this.androidSend.putSheets(geomName, geomGuid);
};

proto.hideLoadingView = function (){
    if (this.android)
        this.androidSend.hideLoadingView();
};;/** @license Copyright (c) 2014 Autodesk Inc. */
/** Version : @buildnum@ */

Autodesk.Viewing.Extensions.ViewerPanelMixin = function()
{
    /**
     * Returns the parent's container bounding rectangle.
     *
     * @returns {ClientRect} - bounding rectangle of the parent.
     */
    this.getContainerBoundingRect = function () {
        var bounds = this.parentContainer.getBoundingClientRect();

        var toolbarBounds = {
            height: 0,
            width:  0,
            left:   0,
            bottom: 0,
            right:  0,
            top:    0
        };

        var toolbar = document.getElementsByClassName("toolbar-menu");
        if (toolbar && toolbar.length>0) {
            toolbarBounds = toolbar[0].getBoundingClientRect();
        }

        // TODO: This assumes that toolbar is horizontal and at the bottom.
        // Once the toolbar can be positioned somewhere else (top, right, left)
        // this code will need to be expanded to return the right bounds for each case.
        return {
            height: bounds.height - toolbarBounds.height,
            width:  bounds.width,
            left:   bounds.left,
            bottom: bounds.bottom - toolbarBounds.height,
            right:  bounds.right,
            top:    bounds.top
        };
    };
};;/** @license Copyright (c) 2014 Autodesk Inc. */
/** Version : @buildnum@ */

(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = Autodesk.Viewing.Private,
    avu = Autodesk.Viewing.UI,
    ave = Autodesk.Viewing.Extensions;


    var kDefaultDocStructureConfig = {
        "click": {
            "onObject": ["isolate"]
        },
        "clickCtrl": {
            "onObject": ["toggleVisibility"]
        }
    };


    ave.ViewerModelStructurePanel = function (viewer, title, options) {
        this.viewer = viewer;

        options = options || {};

        //TODO: base this on whether search is visible or not
        options.heightAdjustment = 75; //bigger than default because of search bar

        avu.ModelStructurePanel.call(this, viewer.container, viewer.container.id + 'ViewerModelStructurePanel', title, options);

        this.clickConfig = (options && options.docStructureConfig) ? options.docStructureConfig : kDefaultDocStructureConfig;
        this.isMac = (navigator.userAgent.search("Mac OS") !== -1);

        this.initSearchBox();

        this.prevSearchResults = [];
        this.prevSearchString = "";
    };

    ave.ViewerModelStructurePanel.prototype = Object.create(avu.ModelStructurePanel.prototype);
    ave.ViewerModelStructurePanel.prototype.constructor = ave.ViewerModelStructurePanel;
    ave.ViewerPanelMixin.call(ave.ViewerModelStructurePanel.prototype);

    ave.ViewerModelStructurePanel.prototype.initialize = function () {
        avu.ModelStructurePanel.prototype.initialize.call(this);

        var that = this;

        that.addEventListener(that.viewer, av.SELECTION_CHANGED_EVENT, function (event) {
            that.setSelection(event.nodeArray.slice());
        });
        that.addEventListener(that.viewer, av.ISOLATE_EVENT, function (event) {
            that.setIsolation(event.nodeIdArray.slice());
        });
        that.addEventListener(that.viewer, av.HIDE_EVENT, function (event) {
            that.setHidden(event.nodeIdArray.slice(), true);
        });
        that.addEventListener(that.viewer, av.SHOW_EVENT, function (event) {
            that.setHidden(event.nodeIdArray.slice(), false);
        });
    };

    ave.ViewerModelStructurePanel.prototype.uninitialize = function () {
        this.viewer = null;
        avu.ModelStructurePanel.prototype.uninitialize.call(this);
    };

    ave.ViewerModelStructurePanel.prototype.handleAction = function (actionArray, dbId) {
        for (var action in actionArray) {
            switch (actionArray[action]) {
                case "selectOnly":
                    this.viewer.select(dbId);
                    break;
                case "deselectAll":
                    this.viewer.select([]);
                    break;
                case "selectToggle":
                    this.viewer.toggleSelect(dbId);
                    break;
                case "isolate":
                    this.viewer.isolate(dbId);
                    break;
                case "showAll":
                    this.viewer.isolate(null);
                    break;
                case "focus":
                    this.viewer.fitToView();
                    break;
                case "hide":
                    this.viewer.hide(dbId);
                    break;
                case "show":
                    this.viewer.show(dbId);
                    break;
                case "toggleVisibility":
                    this.viewer.toggleVisibility(dbId);
                    break;
            }
        }
    };

    ave.ViewerModelStructurePanel.prototype.ctrlDown = function (event) {
        return (this.isMac && event.metaKey) || (!this.isMac && event.ctrlKey);
    };

    ave.ViewerModelStructurePanel.prototype.onClick = function (node, event) {
        if (this.isMac && event.ctrlKey) {
            return;
        }

        var that = this;

        var key = "click";
        if (that.ctrlDown(event)) {
            key += "Ctrl";
        }
        if (event.shiftKey) {
            key += "Shift";
        }
        if (event.altKey) {
            key += "Alt";
        }

        if (this.clickConfig && this.clickConfig[key]) {
            that.handleAction(this.clickConfig[key]["onObject"], node);
        }
        else {
            this.viewer.select(node);
        }
    };

    ave.ViewerModelStructurePanel.prototype.onDoubleClick = function (node, event) {
        this.handleAction(["focus"], node);
    };

    ave.ViewerModelStructurePanel.prototype.onHover = function (node, event) {
        this.viewer.impl.rolloverObjectNode(node);
    };

    ave.ViewerModelStructurePanel.prototype.onRightClick = function (node, event) {
        // Sometimes CTRL + LMB maps to a right click on a mac. Redirect it.
        if (this.isMac && event.ctrlKey && event.button === 0) {
            if (this.clickConfig && this.clickConfig["clickCtrl"]) {
                this.handleAction(this.clickConfig["clickCtrl"]["onObject"], node);
            }
            else {
                this.viewer.select(node);
            }

            return null;
        }

        var dbIds = [];

        // If the shift/control/command key is held down when right-clicking, then add this node
        // to the selection, instead of selecting only this node. This control/command key logic is
        // like the ViewController, which is slightly different than ctrlDown() here.
        // TODO: is this difference intentional?

        // Also: on the Mac, a control + left mouse button click is treated like a right mouse
        // button click, so ignore the control key in that case.
        //
        var shouldSelectNode = true;
        if (event.shiftKey || ((this.isMac && event.metaKey) || (event.ctrlKey && (this.isMac || event.button === 2)))) {
            var selectedNodes = this.viewer.impl.selector.getSelection();
            for (var i = 0; i < selectedNodes.length; ++i) {
                if (selectedNodes[i] !== node) {
                    dbIds.push(selectedNodes[i]);
                } else {
                    shouldSelectNode = false;
                }
            }
        }

        if (shouldSelectNode) {
            dbIds.push(node);
        }

        this.viewer.select(dbIds);

        return this.viewer.contextMenu.show(event);
    };

    ave.ViewerModelStructurePanel.prototype.setHidden = function (nodes, hidden) {

        //TODO: //BOGUS Should not have to do this -- figure out why the CAM
        //extension is calling this before the model tree is actually visible
        if (!this.uiCreated)
            this.createUI();

        for (var i = 0; i < nodes.length; ++i) {
            this.tree.iterate(nodes[i], function(node, elem) {
                elem.classList.toggle('dim', hidden);
                elem.classList.toggle('visible', !hidden);
            });
        }
    };

    ave.ViewerModelStructurePanel.prototype.setIsolation = function (nodes) {
        if (!this.rootId) {
            return;
        }
        this.tree && this.tree.iterate(this.rootId, function (node, elem) {
            elem.classList.remove('dim');
            elem.classList.remove('visible');
        });

        if (nodes.length > 0) {
            // If the root is isolated, we don't want to dim anything.
            //
            if (nodes.length === 1 && nodes[0] === this.rootId) {
                return;
            }

            this.setHidden([this.rootId], true);

            this.setHidden(nodes, false);
        }

        if (this.searchbox && !this.inSearchIsolate)
            this.searchbox.value = "";

    };

    ave.ViewerModelStructurePanel.prototype.initSearchBox = function () {
        var searchbox = document.createElement("input");
        searchbox.className = "toolbar-search-box";
        searchbox.type = "search";
        searchbox.results = 5;
        //searchbox.placeholder = av.i18n.translate("Search");
        searchbox.placeholder = av.i18n.translate("Filter by name");
        searchbox.incremental = "incremental";
        searchbox.autosave = this.container.id + "search_autosave";
        //searchbox.setAttribute("data-i18n", "[placeholder]Search");
        searchbox.setAttribute("data-i18n", "[placeholder]Filter by name");
        this.scrollContainer.parentNode.insertBefore(searchbox, this.scrollContainer);
        this.searchbox = searchbox;

        var viewer = this.viewer;
        var self = this;

        function doSearch() {
            //TODO: the search hit style class gets overridden by the islolation dim/visible classes
            //Also it needs to apply to exact nodes and not cascade down the tree.
            if (self.isSearching) {
                return; //don't send another search to the worker if one is in progress
            }

            for (var i=0; i<self.prevSearchResults.length; i++) {
                //self.tree.removeClass(self.prevSearchResults[i], "searchHit");
                self.tree.setCollapsed(self.prevSearchResults[i], true, true);
            }

            if (searchbox.value.length === 0) {
                self.isSearching = false;
                self.prevSearchString = "";
                viewer.isolate();
            } else {
                if (self.prevSearchString == searchbox.value)
                    return;

                self.isSearching = true;

                viewer.search(searchbox.value, function (resultIds) {
                    self.inSearchIsolate = true;
                    viewer.isolate(resultIds);
                    self.inSearchIsolate = false;

                    if (resultIds.length) {
                        for (var i=0; i<resultIds.length; i++) {
                            //self.tree.addClass(resultIds[i], "searchHit");
                            self.tree.setCollapsed(resultIds[i], false, true);
                        }
                        self.resizeToContent();
                        self.tree.scrollTo(resultIds[0]);
                    }

                    self.prevSearchResults = resultIds;
                    self.isSearching = false;
                }, null, ["name"]);
            }
        }

        var TIMEOUT = 500;
        var timeout;
        searchbox.addEventListener("input", function(e) {   // delayed: as typing
            clearTimeout(timeout);
            timeout = setTimeout(doSearch, TIMEOUT);
        });

        searchbox.addEventListener("change", function(e) {  // immediate: press enter, lose focus
            clearTimeout(timeout);
            doSearch();
        });
    };


})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avu = av.UI;

/** @constructor */
var ViewerPropertyPanel = function (viewer) {
    this.viewer = viewer;
    this.currentNodeIds = [];
    this.currentModel = null;
    this.isSelection = false;
    this.isDirty = true;
    this.propertyNodeId = null;
    avu.PropertyPanel.call(this, viewer.container, 'ViewerPropertyPanel', 'Object Properties Loading...');
};

ViewerPropertyPanel.prototype = Object.create(avu.PropertyPanel.prototype);
ViewerPropertyPanel.prototype.constructor = ViewerPropertyPanel;
av.Extensions.ViewerPanelMixin.call( ViewerPropertyPanel.prototype );

ViewerPropertyPanel.prototype.initialize = function () {
    avu.PropertyPanel.prototype.initialize.call(this);

    var that = this;

    that.addEventListener(that.viewer, av.AGGREGATE_SELECTION_CHANGED_EVENT, function (event) {

        if (event.selections && event.selections.length) {
            that.currentNodeIds = event.selections[0].dbIdArray;
            that.currentModel = event.selections[0].model;
            that.isSelection = event.selections[0].dbIdArray.length > 0;
        } else {
            that.isSelection = false;
        }

        that.isDirty = true;
        that.requestProperties();
    });

    that.addEventListener(that.viewer, av.ISOLATE_EVENT, function (e) {

        //In case of "isolate none" and an active selection set
        //do not clear the property panel contents;
        if (e.nodeIdArray.length == 0 && that.isSelection)
            return;

        that.currentModel = e.model;
        that.currentNodeIds = e.nodeIdArray;
        that.isDirty = true;
        that.requestProperties();
    });

    that.addEventListener(that.viewer, av.HIDE_EVENT, function (e) {
        that.isDirty = true;
        that.requestProperties();
    });

    that.addEventListener(that.viewer, av.SHOW_EVENT, function (e) {
        that.isDirty = true;
        that.requestProperties();
    });

    // Populate the ids with the current selection or isolation.
    //
    this.currentModel = that.viewer.model; //TODO: getSelection needs to return something better so we know which model
    this.currentNodeIds = that.viewer.getSelection();
    if (this.currentNodeIds.length === 0) {
        this.currentNodeIds = that.viewer.getIsolatedNodes();
    } else {
        this.isSelection = true; //remember that we are showing the properties of a selection so that we trump isolation.
    }
};

ViewerPropertyPanel.prototype.setTitle = function (title, options) {
    if (!title) {
        title = 'Object Properties';  // localized by DockingPanel.prototype.setTitle
        options = options || {};
        options.localizeTitle = true;
    }
    avu.PropertyPanel.prototype.setTitle.call(this, title, options);
};

ViewerPropertyPanel.prototype.setVisible = function (show) {
    avu.DockingPanel.prototype.setVisible.call(this, show);
    this.requestProperties();
};

ViewerPropertyPanel.prototype.visibilityChanged = function() {
    avu.DockingPanel.prototype.visibilityChanged.call(this);
    if (this.isVisible())
        this.requestProperties();
};

ViewerPropertyPanel.prototype.requestProperties = function () {
    if (this.isVisible() && this.isDirty) {
        if (this.currentNodeIds.length > 0) {
            this.setNodeProperties(this.currentNodeIds[this.currentNodeIds.length - 1]);
        } else {
            this.showDefaultProperties();
        }
        this.isDirty = false;
    }
};

ViewerPropertyPanel.prototype.setNodeProperties = function (nodeId) {
    var that = this;
    this.propertyNodeId = nodeId;
    that.currentModel.getProperties(nodeId, function (result) {
        that.setTitle(result.name);
        that.setProperties(result.properties);
        that.highlight(that.viewer.searchText);

        that.resizeToContent();

        if (that.isVisible()) {

            // Does the property panel overlap the mouse position? If so, then reposition
            // the property panel. Prefer a horizontal vs. vertical reposition.
            //
            var toolController = that.viewer.toolController,
                mx = toolController.lastClickX,
                my = toolController.lastClickY,
                panelRect = that.container.getBoundingClientRect(),
                px = panelRect.left,
                py = panelRect.top,
                pw = panelRect.width,
                ph = panelRect.height,
                canvasRect = that.viewer.canvas.getBoundingClientRect(),
                cx = canvasRect.left,
                cy = canvasRect.top,
                cw = canvasRect.width,
                ch = canvasRect.height;

            if ((px <= mx && mx < px + pw) && (py <= my && my < py + ph)) {
                if ((mx < px + (pw / 2)) && (mx + pw) < (cx + cw)) {
                    that.container.style.left = Math.round(mx - cx) + 'px';
                    that.container.dockRight = false;
                } else if (cx <= (mx - pw)) {
                    that.container.style.left = Math.round(mx - cx - pw) + 'px';
                    that.container.dockRight = false;
                } else if ((mx + pw) < (cx + cw)) {
                    that.container.style.left = Math.round(mx - cx) + 'px';
                    that.container.dockRight = false;
                } else if ((my + ph) < (cy + ch)) {
                    that.container.style.top = Math.round(my - cy) + 'px';
                    that.container.dockBottom = false;
                } else if (cy <= (my - ph)) {
                    that.container.style.top = Math.round(my - cy - ph) + 'px';
                    that.container.dockBottom = false;
                }
            }
        }
    });
};

ViewerPropertyPanel.prototype.showDefaultProperties = function () {
    var rootId = this.viewer.model.getRootId();
    if (rootId) {
        this.setNodeProperties(rootId);
    } else {
        this.propertyNodeId = null;
        this.setTitle('Model Properties', {localizeTitle: true});  // localized by DockingPanel.prototype.setTitle
        avu.PropertyPanel.prototype.showDefaultProperties.call(this);
    }
};

ViewerPropertyPanel.prototype.areDefaultPropertiesShown = function () {
    var rootId = this.viewer.model.getRootId();
    return this.propertyNodeId === rootId;
};

ViewerPropertyPanel.prototype.uninitialize = function () {
    avu.PropertyPanel.prototype.uninitialize.call(this);
    this.viewer = null;
};

ViewerPropertyPanel.prototype.onCategoryClick = function (category, event) {
    avu.PropertyPanel.prototype.onCategoryClick.call(this, category, event);
    this.resizeToContent();
};

ViewerPropertyPanel.prototype.onCategoryIconClick = function (category, event) {
    avu.PropertyPanel.prototype.onCategoryIconClick.call(this, category, event);
    this.resizeToContent();
};


Autodesk.Viewing.Extensions.ViewerPropertyPanel = ViewerPropertyPanel;


})();;(function() {

"use strict";


/**
 * ViewerLayersPanel
 * This is a panel for displaying the layers in a file.
 * @class
 * @augments Autodesk.Viewing.UI.LayersPanel
 *
 * @param {Viewer} viewer - The parent viewer.
 * @constructor
 */
var ViewerLayersPanel = function (viewer) {
    var parentContainer = viewer.container;
    Autodesk.Viewing.UI.LayersPanel.call(this, viewer, parentContainer, parentContainer.id + "ViewerLayersPanel");

    this.onRestoreStateBinded = this.onRestoreState.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT, this.onRestoreStateBinded);
};

ViewerLayersPanel.prototype = Object.create(Autodesk.Viewing.UI.LayersPanel.prototype);
ViewerLayersPanel.prototype.constructor = ViewerLayersPanel;
Autodesk.Viewing.Extensions.ViewerPanelMixin.call( ViewerLayersPanel.prototype );


ViewerLayersPanel.prototype.uninitialize = function() {
    if (this.onRestoreStateBinded) {
        this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT, this.onRestoreStateBinded);
        this.onRestoreStateBinded = null;
    }
    Autodesk.Viewing.UI.LayersPanel.prototype.uninitialize.call(this);
};

ViewerLayersPanel.prototype.onRestoreState = function() {
    this.update();
};

/**
 * Override this method to do something when the user clicks on a tree node
 * @override
 * @param {Object} node
 * @param {Event} event
 */
ViewerLayersPanel.prototype.onClick = function (node, event) {
    if (this.isMac && event.ctrlKey) {
        return;
    }
    var isolate = !(event.shiftKey || event.metaKey || event.ctrlKey);
    this.setLayerVisible(node, isolate);
};

/**
 * Override this to do something when the user right-clicks on a tree node
 * @param {Object} node
 * @param {Event} event
 */
ViewerLayersPanel.prototype.onRightClick = function (node, event) {
    var isolate = !(event.shiftKey || event.metaKey || event.ctrlKey);
    this.setLayerVisible(node, isolate);
};

/**
 * Override this to do something when the user clicks on an image
 * @override
 * @param {Object} node
 * @param {Event} event
 */
ViewerLayersPanel.prototype.onImageClick = function (node, event) {
    if (this.isMac && event.ctrlKey) {
        return;
    }
    this.setLayerVisible(node);
};

/**
 * Override this method to be notified when the user clicks on the title.
 * @override
 * @param {Event} event
 */
ViewerLayersPanel.prototype.onTitleClick = function (event) {
    this.viewer.setLayerVisible(null, true);
};

/**
 * Override this method to be notified when the user double-clicks on the title.
 * @override
 * @param {Event} event
 */
ViewerLayersPanel.prototype.onTitleDoubleClick = function (event) {
    this.viewer.fitToView();
};


Autodesk.Viewing.Extensions.ViewerLayersPanel = ViewerLayersPanel;

})();;
(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private,
    ave = Autodesk.Viewing.Extensions,
    avu = Autodesk.Viewing.UI;

/**
 * Viewer3dSettings Tabs.
 *
 * These constants are used to define the tabs in the ViewerSettingsPanel.
 *
 * @enum {number}
 * @readonly
 */
ave.ViewerSettingTab = {
    Navigation : "navigationtab",
    Performance: "performancetab"
};

/**
 * ViewerSettingsPanel
 * This is a panel for displaying the settings for the viewer.
 * @class
 *
 * @param {Viewer} viewer - the parent viewer
 * @param {string} mode - whether it is 3d or 2d mode (acceptable strings: "2d", "3d")
 * @constructor
 */
var ViewerSettingsPanel = function (viewer, mode) {

    this.viewer   = viewer;
    this.is3dMode = mode === "3d";

    avu.SettingsPanel.call(this, viewer.container, 'ViewerSettingsPanel', 'Settings', { width: 360, heightAdjustment: 155 } );

    this.addTab( "navigationtab", "Navigation and selection", { className: "navigation" } );
    this.addTab( "performancetab", "Performance and appearance", { className: "performance" } );

    this.restoreDiv = document.createElement('div');
    this.restoreDiv.className = 'viewer-restore-defaults';
    this.restoreDiv.setAttribute("data-i18n", "Restore default settings");
    this.restoreDiv.textContent = Autodesk.Viewing.i18n.translate("Restore default settings");

    this.addEventListener(this.restoreDiv, 'touchstart', touchStartToClick );
    this.addEventListener(this.restoreDiv, 'click', function () {
        var tag = viewer.model.is2d() ? '2d' : '3d';
        viewer.prefs.reset(tag);
    }, false);

    this.container.appendChild(this.restoreDiv);

    this.createNavigationPanel();
    this.createPerformancePanel();
};

ViewerSettingsPanel.prototype = Object.create(avu.SettingsPanel.prototype);
ViewerSettingsPanel.prototype.constructor = ViewerSettingsPanel;
ave.ViewerPanelMixin.call( ViewerSettingsPanel.prototype );

/**
 * Clean up when the viewer setting  is about to be removed.
 * @override
 */
ViewerSettingsPanel.prototype.uninitialize = function () {
    this.viewer = null;
    avu.SettingsPanel.prototype.uninitialize.call(this);
};

/**
 * Creates a checkbox element and adds it to the given tab.
 *
 * @param {number} tabId - tab id
 * @param {string} description - the text associated with the checkbox
 * @param {boolean} initialState - initial value for the checkbox (checked or not)
 * @param {function} onchange - callback that is called when the checkbox is changed
 * @param {string} saveKey - name of the preference associated with this checkbox.
 * @returns {HTMLElement} - it returns the checkbox element.
 *
 */
ViewerSettingsPanel.prototype.addCheckbox = function(tabId, description, initialState, onchange, saveKey)
{
    var viewer = this.viewer;

    // Use the stored settings or defaults
    var storedState = viewer.prefs[saveKey];
    initialState = (typeof storedState === 'boolean') ? storedState : initialState;

    function onChangeCB(checked) {
        viewer.prefs.set(saveKey, checked);
        onchange(checked);
    }

    var checkboxId = avu.SettingsPanel.prototype.addCheckbox.call(this, tabId, description, initialState, onChangeCB);
    var checkBoxElem = this.getControl(checkboxId);
    checkBoxElem.saveKey = saveKey;

    viewer.prefs.addListeners(saveKey, function (value) {
        checkBoxElem.setValue(value);
    }, function (value) {
        checkBoxElem.setValue(value);
        onchange(value);
    });

    return checkboxId;
};

/**
 * Removes an option from the given tab.
 *
 * @param {HTMLElement} checkBoxElem - checkbox to remove.
 *
 */
ViewerSettingsPanel.prototype.removeCheckbox = function(checkBoxElem)
{
    this.viewer.prefs.removeListeners(checkBoxElem.saveKey);
    this.removeEventListener(checkBoxElem, "change", checkBoxElem.changeListener);

    return avu.SettingsPanel.prototype.removeCheckbox.call(this, checkBoxElem);
};

/**
 *  Populates the navigation tab with the appropriate checkboxes.
 */
ViewerSettingsPanel.prototype.createNavigationPanel = function()
{
    var viewer = this.viewer;
    var navTab = ave.ViewerSettingTab.Navigation;

    if (this.is3dMode) {
        this.addCheckbox(navTab, "Show ViewCube", true, function(checked) {
            viewer.displayViewCube(checked);
        }, "viewCube");

        this.addCheckbox(navTab, "ViewCube acts on pivot", false, function(checked) {
            viewer.setUsePivotAlways(checked);
        }, "alwaysUsePivot");

        this.addCheckbox(navTab, "Zoom towards pivot", false, function(checked) {
            viewer.setZoomTowardsPivot(checked);
        }, "zoomTowardsPivot");

        this.addCheckbox(navTab, "Set pivot with left mouse button", false, function(checked) {
            viewer.setClickToSetCOI(checked);
        }, "clickToSetCOI");

        this.addCheckbox(navTab, "Fusion style orbit", false, function(checked) {
            if (checked)
                viewer.loadExtension('Autodesk.Viewing.FusionOrbit', null);
            else
                viewer.unloadExtension('Autodesk.Viewing.FusionOrbit', null);
        }, "fusionOrbit");

        this.addCheckbox(navTab, "First person walk", false, function(checked) {
            if (checked) {
                viewer.unloadExtension('Autodesk.Beeline', null);
                viewer.loadExtension('Autodesk.FirstPerson', null);
            }
            else {
                viewer.unloadExtension('Autodesk.FirstPerson', null);
                viewer.loadExtension('Autodesk.Beeline', null);
            }
        }, "useFirstPersonNavigation");

    }

     this.addCheckbox(navTab, "Reverse mouse zoom direction", false, function(checked) {
        viewer.setReverseZoomDirection(checked);
    }, "reverseMouseZoomDir");

    if (this.is3dMode) {
        this.addCheckbox(navTab, "Orbit past world poles", true, function(checked) {
            viewer.setOrbitPastWorldPoles(checked);
        }, "orbitPastWorldPoles");
    }

    this.addCheckbox(navTab, "Open properties on select", true, function(checked) {
        viewer.setPropertiesOnSelect(checked);
    }, "openPropertiesOnSelect");

    this.addCheckbox(navTab, "Left handed mouse setup", false, function(checked) {
        viewer.setUseLeftHandedInput(checked);
    }, "leftHandedMouseSetup");
};

/**
 *  Populates the performance tab with the appropriate checkboxes.
 */
ViewerSettingsPanel.prototype.createPerformancePanel = function()
{
    var viewer = this.viewer;
    var perfTab = ave.ViewerSettingTab.Performance;

    if (this.is3dMode) {
        this.ghosthiddenChkBoxId = this.addCheckbox(perfTab, "Ghost hidden objects", true, function(checked) {
            viewer.setGhosting(checked);
        }, "ghosting");

        this.optimizeNavigationhkBoxId = this.addCheckbox(perfTab, "Smooth navigation", av.isMobileDevice(), function(checked) {
            viewer.setOptimizeNavigation(checked);
        }, "optimizeNavigation");

        this.antialiasingChkBoxId = this.addCheckbox(perfTab, "Anti-aliasing", true, function(checked) {
            viewer.setQualityLevel(viewer.prefs.ambientShadows, checked);
        }, "antialiasing");

        this.ambientshadowsChkBoxId = this.addCheckbox(perfTab, "Ambient shadows", true, function(checked) {
            viewer.setQualityLevel(checked, viewer.prefs.antialiasing);
        }, "ambientShadows");

        this.groundShadowChkBoxId = this.addCheckbox(perfTab, "Ground shadow", true, function(checked) {
            viewer.setGroundShadow(checked);
        }, "groundShadow");

        this.groundReflectionChkBoxId = this.addCheckbox(perfTab, "Ground reflection", true, function(checked) {
            viewer.setGroundReflection(checked);
        }, "groundReflection");

        this.envMapBackgroundChkBoxId = this.addCheckbox(perfTab, "Environment map for background", true, function(checked) {
            viewer.setEnvMapBackground(checked);
        }, "envMapBackground");
    }

    this.progressiveRenderChkBoxId = this.addCheckbox(perfTab, "Progressive model display", true, function(checked) {
        viewer.setProgressiveRendering(checked);
    }, "progressiveRendering");
};

/**
 * Updates the values in the checkboxes based on what is in the prefs.
 */
ViewerSettingsPanel.prototype.syncUI = function() {

    var viewer = this.viewer;

    var antialiasingControl = this.getControl(this.antialiasingChkBoxId);
    if (antialiasingControl) {
        antialiasingControl.setValue(viewer.prefs.antialiasing);
    }

    var ambientshadowsgControl = this.getControl(this.ambientshadowsChkBoxId);
    if (ambientshadowsgControl) {
        ambientshadowsgControl.setValue(viewer.prefs.ambientShadows);
    }

    var groundShadowControl = this.getControl(this.groundShadowChkBoxId);
    if (groundShadowControl) {
        groundShadowControl.setValue(viewer.prefs.groundShadow);
    }

    var groundReflectionControl = this.getControl(this.groundReflectionChkBoxId);
    if (groundReflectionControl) {
        groundReflectionControl.setValue(viewer.prefs.groundReflection);
    }

    var envMapBackgroundControl = this.getControl(this.envMapBackgroundChkBoxId);
    if (envMapBackgroundControl) {
        envMapBackgroundControl.setValue(viewer.impl.isEnvMapBackground());
    }

    var progressiveRenderControl = this.getControl(this.progressiveRenderChkBoxId);
    if (progressiveRenderControl) {
        progressiveRenderControl.setValue(viewer.prefs.progressiveRendering);
    }

    var ghosthiddenControl = this.getControl(this.ghosthiddenChkBoxId);
    if (ghosthiddenControl) {
        ghosthiddenControl.setValue(viewer.prefs.ghosting);
    }

};

ave.ViewerSettingsPanel = ViewerSettingsPanel;

})();
;
(function() {

"use strict";

var avu = Autodesk.Viewing.UI;

/**
 * Constructs a ViewerObjectContextMenu object.
 * @param {Viewer} viewer
 * @constructor
 */
function ViewerObjectContextMenu(viewer) {
    avu.ObjectContextMenu.call(this, viewer);
}

ViewerObjectContextMenu.prototype = Object.create(avu.ObjectContextMenu.prototype);
ViewerObjectContextMenu.prototype.constructor = ViewerObjectContextMenu;

/**
 * Builds the context menu to be displayed.
 * @override
 * @param {Event} event - Browser event that requested the context menu
 * @param {Object} status - Information about nodes: numSelected, hasSelected, hasVisible, hasHidden.
 * @returns {?Array} An array of menu items.
 */
ViewerObjectContextMenu.prototype.buildMenu = function (event, status) {
    var that = this,
        menu = [],
        is2d = this.viewer.model.is2d();

    if (!is2d) {

        var viewport = this.viewer.container.getBoundingClientRect();
        var canvasX = event.clientX - viewport.left;
        var canvasY = event.clientY - viewport.top;

        var result = that.viewer.impl.hitTest(canvasX, canvasY, false);

        if (result && result.dbId) {

            var selSet = that.viewer.getSelection();

            if (selSet.indexOf(result.dbId) == -1)
                that.viewer.select(result.dbId);

            status.hasSelected = true;
            status.hasVisible = true;
        }
    }

    // the title strings here are added to the viewer.loc.json for localization
    if (!is2d && status.hasSelected) {
        menu.push({
            title: "Isolate",
            target: function () {
                var selected = that.viewer.getSelection();
                that.viewer.clearSelection();
                that.viewer.isolate(selected);
            }
        });
        if (status.hasVisible) {
            menu.push({
                title: "Hide Selected",
                target: function () {
                    var selected = that.viewer.getSelection();
                    that.viewer.clearSelection();
                    that.viewer.hide(selected);
                }
            });
        }
        if (status.hasHidden) {
            menu.push({
                title: "Show Selected",
                target: function () {
                    var selected = that.viewer.getSelection();
                    that.viewer.clearSelection();
                    that.viewer.show(selected);
                }
            });
        }
    }

    if (is2d) {
        menu.push({
            title: "Show All Layers",
            target: function () {
                that.viewer.setLayerVisible(null, true);
            }
        });
    } else {
        menu.push({
            title: "Show All Objects",
            target: function () {
                that.viewer.showAll();
            }
        });
    }

    if (!is2d && status.hasSelected) {
        menu.push({
            title: "Focus",
            target: function () {
                var selectedIds = that.viewer.getSelection();
                that.viewer.fitToView(selectedIds);
            }
        });
    }

    if (status.hasSelected) {
        menu.push({
            title: "Clear Selection",
            target: function () {
                that.viewer.clearSelection();
            }
        });
    }

    return menu;
};


Autodesk.Viewing.Extensions.ViewerObjectContextMenu = ViewerObjectContextMenu;

})();;
(function() {

'use strict';

var ns = AutodeskNamespace('Autodesk.Viewing.Extensions.CAM360');

function CAM360Extension(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
}

CAM360Extension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
CAM360Extension.prototype.constructor = CAM360Extension;

CAM360Extension.prototype.load = function() {
    var viewer = this.viewer;
    var modelStructurePanel = new ns.CAMModelStructurePanel(this.viewer, 'CAM Model Structure Loading', this.options);
    viewer.setModelStructurePanel(modelStructurePanel);

    // Change these viewer settings for CAM files.
    //
    viewer.hideLines(false);
    viewer.setGhosting(false);
    viewer.setQualityLevel(false, true);

    // Wait till the geometry has loaded before changing the light preset, to ensure that
    // our light preset is the last applied.
    //
    function setLightPresetToSimpleGrey() {
        viewer.impl.setLightPreset(0, true);
        viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, setLightPresetToSimpleGrey);
    }
    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, setLightPresetToSimpleGrey);

    return true;
};

CAM360Extension.prototype.unload = function () {
    // Remove the panel from the viewer.
    //
    this.viewer.setModelStructurePanel(null);
};

ns.CAM360Extension = CAM360Extension;

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.CAM360', ns.CAM360Extension);


})();;
(function() {

'use strict';

var ns = AutodeskNamespace('Autodesk.Viewing.Extensions.CAM360');
var ave = Autodesk.Viewing.Extensions;

function CAMModelStructurePanel(viewer, title, options) {
    ave.ViewerModelStructurePanel.call(this, viewer, title, options);
    this.viewer = viewer;
}

CAMModelStructurePanel.prototype = Object.create(ave.ViewerModelStructurePanel.prototype);
CAMModelStructurePanel.prototype.constructor = CAMModelStructurePanel;

CAMModelStructurePanel.prototype.sortCamNodes = function (instanceTree, onCamNodesSorted) {
    this.camNodes = [];
    this.camModelNodes = [];
    this.camSetupNodes = [];
    this.camStockNodes = [];
    this.camOperationNodes = [];
    this.camToolNodes = [];
    this.camFolderNodes = [];

    var that = this;

    // Find all of the nodes to process.
    //
    var nodeIdsToProcess = [];

    instanceTree.enumNodeChildren(instanceTree.getRootId(), function(dbId) {
        nodeIdsToProcess.push(dbId);
    }, true);

    nodeIdsToProcess.shift(); //take out the root

    function processNodeId(node, onNodeProcessed)
    {

        // Gets the p
        function getPropertyValue(properties, propertyName){
            for(var i = 0; i < properties.length; ++i) {
                var property = properties[i];
                if(property.displayName === propertyName) {
                    return property.displayValue;
                }
            }
            return null;
        }

        function onPropertiesRetrieved(result) {
            // Sort the nodes into the proper containers here.
            //
            var name = getPropertyValue(result.properties, '9429B915-D020-4CEB-971B-6ADD0A5D4BFA');

            if (name) {
                if(name == 'CAM_Setup') {
                    that.camSetupNodes.push(node);
                }
                else if(name == 'CAM_Operation') {
                    that.camOperationNodes.push(node);
                }
                else if (name === 'CAM_Tool') { // Check this.
                    that.camToolNodes.push(node);
                } else if (name === 'CAM_Stock') {  // Check this.
                    that.camStockNodes.push(node);
                } else if(name == 'CAM_Folder') {
                    that.camFolderNodes.push(node);
                }

                that.camNodes.push(node);

            } else {
                that.camModelNodes.push(node);
            }

            onNodeProcessed();
        }

        function onError(status, message, data) {
            onNodeProcessed();
        }

        that.viewer.getProperties(node, onPropertiesRetrieved, onError);

    }

    // Process the nodes one by one.
    //
    function processNext() {
        if(nodeIdsToProcess.length > 0) {
            processNodeId(nodeIdsToProcess.shift(), processNext);
        } else {
            // No more nodes to process - call the provided callback.
            //
            onCamNodesSorted();
        }
    }
    processNext();
};

CAMModelStructurePanel.prototype.setModel = function (instanceTree, modelTitle) {
    // Sort all of the cam nodes.  Once done, call setModel on the base class to build the UI, and
    // set the visibilities properly.
    //
    var that = this;
    that.sortCamNodes(instanceTree, function(){
        ave.ViewerModelStructurePanel.prototype.setModel.call(that, instanceTree, modelTitle);
        that.SetCAMNodeVisible(false);
        that.setVisible(true);

		// expand the setup node, and resize to fit.
		that.ExpandSetupNodes();
        that.resizeToContent();
    });
};

CAMModelStructurePanel.prototype.initialize = function() {
    ave.ViewerModelStructurePanel.prototype.initialize.call(this);

    var that = this;

    function onGeometryLoaded(e) {
        that.SetCAMNodeVisible(false);
        that.removeEventListener(that.viewer, Autodesk.Viewing.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
    }

    if (!this.viewer.model || !this.viewer.model.isLoadDone()) {
        that.addEventListener(that.viewer, Autodesk.Viewing.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
    }

    that.addEventListener(that.viewer, Autodesk.Viewing.SHOW_EVENT,
        function(e) {
            var nodes = e.nodeIdArray;
            if(nodes) {
                for (var k = 0; k < nodes.length; k++)
                    that.setCamNodeVisibility(nodes[k]);
            }
        });

    that.addEventListener(that.viewer, Autodesk.Viewing.SELECTION_CHANGED_EVENT,
        function(e) {
            var nodes = e.nodeArray;
            if(nodes) {
                for (var k = 0; k < nodes.length; k++)
                    that.HideHightlightCAMNode(nodes[k]);
            }
        });

    that.addEventListener(that.viewer, Autodesk.Viewing.ISOLATE_EVENT,
        function(e) {
            var nodes = e.nodeIdArray;
            if(nodes) {
                // show all
                if(nodes.length == 0) {
                    that.SetModelVisible();
                    that.SetCAMNodeVisible(true);
                }
                else {
                    for (var k = 0; k < nodes.length; k++)
                        that.setCamNodeVisibility(nodes[k]);
                }
            }
        });
};

CAMModelStructurePanel.prototype.IsCAMNode = function (node) {
    return this.camNodes.indexOf(node) !== -1;
};

CAMModelStructurePanel.prototype.IsCAMSetupNode = function (node) {
    return this.camSetupNodes.indexOf(node) !== -1;
};

CAMModelStructurePanel.prototype.IsCAMStockNode = function (node) {
    return this.camStockNodes.indexOf(node) !== -1;
};

CAMModelStructurePanel.prototype.IsCAMToolNode = function (node) {
    return this.camToolNodes.indexOf(node) !== -1;
};

CAMModelStructurePanel.prototype.IsCAMOperationNode = function (node) {
    return this.camOperationNodes.indexOf(node) !== -1;
};

CAMModelStructurePanel.prototype.IsCAMFolderNode = function (node) {
    return this.camFolderNodes.indexOf(node) !== -1;
};

CAMModelStructurePanel.prototype.shouldInclude = function (node) {
    // Exclude all stock nodes.
    //
    return !this.IsCAMStockNode(node);
};

CAMModelStructurePanel.prototype.isGroupNode = function (node) {
    // We consider cam operation nodes leaf nodes.
    //
    return this.IsCAMOperationNode(node) ? false : ave.ViewerModelStructurePanel.prototype.isGroupNode.call(this, node);
};

CAMModelStructurePanel.prototype.setNodeVisibility = function(node, visible) {
    if(visible){
        this.viewer.show(node);
    } else {
        this.viewer.hide(node)
    }
};

CAMModelStructurePanel.prototype.SetModelVisible = function () {
    if (!this.camModelNodes) return;

    for (var k = 0; k < this.camModelNodes.length; k++)
        this.setNodeVisibility(this.camModelNodes[k], true);
};

CAMModelStructurePanel.prototype.SetCAMNodeVisible = function (visible) {
    if (!this.camNodes) return;

    for (var k = 0; k < this.camNodes.length; k++) {
        this.setNodeVisibility(this.camNodes[k], visible);
    }
    this.SetToolNodeVisible(false);
};

CAMModelStructurePanel.prototype.SetToolNodeVisible = function (visible) {
    if (!this.camToolNodes) return;

    for (var k = 0; k < this.camToolNodes.length; k++)
        this.setNodeVisibility(this.camToolNodes[k], visible);
};

CAMModelStructurePanel.prototype.HideHightlightNode = function (node) {

    var viewer = this.viewer.impl;
    var that = this;

    that.instanceTree.enumNodeFragments(node, function(fragId) {
        viewer.highlightFragment(that.model, fragId, false, true);
    }, true);
};

// this is to hide the specific child node
CAMModelStructurePanel.prototype.HideHightlightCAMNode = function (node) {

    var isCamSetupNode = this.IsCAMSetupNode(node);
    var isCamOperaNode = this.IsCAMOperationNode(node);
    var isCamFolderNode = this.IsCAMFolderNode(node);

    var that = this;

    that.instanceTree.enumNodeChildren(node, function(dbId) {
        if (isCamSetupNode) {
            if (!that.IsCAMStockNode(dbId))
                that.HideHightlightNode(dbId);
        }
        else if (isCamOperaNode) {
            if (that.IsCAMToolNode(dbId))
                that.HideHightlightNode(dbId);
        }
        else if(isCamFolderNode) {
            that.HideHightlightNode(dbId);
        }
    }, false);

};


CAMModelStructurePanel.prototype.setCamNodeVisibility = function (nodeId) {
    var isCamSetupNode = this.IsCAMSetupNode(nodeId);
    var isCamOperaNode = this.IsCAMOperationNode(nodeId);
    var isCamFolderNode = this.IsCAMFolderNode(nodeId);
    var that = this;

    if (isCamSetupNode) {
        this.instanceTree.enumNodeChildren(nodeId, function(childNodeId) {
            var bStock = that.IsCAMStockNode(childNodeId);
            that.setNodeVisibility(childNodeId, bStock);
        });
    }
    else if (isCamOperaNode) {
        // hide the tool node
        this.instanceTree.enumNodeChildren(nodeId, function(childNodeId) {
            if (that.IsCAMToolNode(childNodeId)) {
                that.setNodeVisibility(childNodeId, false);
            }
        });
    }
    else if (isCamFolderNode) {
        this.instanceTree.enumNodeChildren(nodeId, function(childNodeId) {
            that.setNodeVisibility(childNodeId, false);
        });
    }

};


CAMModelStructurePanel.prototype.onClick = function (node, event) {
    ave.ViewerModelStructurePanel.prototype.onClick.call(this, node, event);

    this.SetModelVisible();

    this.setCamNodeVisibility(node);
	
	this.viewer.fitToView();
};

CAMModelStructurePanel.prototype.ExpandSetupNodes = function () {

    if (!this.camSetupNodes) return;

    for (var k = 0; k < this.camSetupNodes.length; k++)
        this.tree.setCollapsed(this.camSetupNodes[k], false);
};


ns.CAMModelStructurePanel = CAMModelStructurePanel;

})();;
(function() {

'use strict';


var av = Autodesk.Viewing,
    AVU = av.UI;

/**
 * AnimationExtension adds a toolbar with buttons (play/pause/forward/backward/goto start/end)
 * and timeline scrubber to control animation playback.
 */
var AnimationExtension = function(viewer, options) {
    av.Extension.call(this, viewer, options);
    this.viewer = viewer;
    this.animTools = null;
    this.animToolsId = "animationTools";
    this.playButton = null;
    this.prevAnimationTime = -1;
};

AnimationExtension.prototype = Object.create(av.Extension.prototype);
AnimationExtension.prototype.constructor = AnimationExtension;

/**
 * Converts seconds into Hours:Minutes:Seconds String
 * @param {Number} time in seconds
 * @returns {string}
 * @private
 */
function convertSecsToHMS(time) {
    var sign = "";
    if (time < 0) {sign="-"; time = -time;}
    var hrs = ~~(time / 3600);
    var mins = ~~((time % 3600) / 60);
    var secs = time % 60;
    var ret = sign;
    if (hrs > 0)
        ret += hrs + ":" + (mins < 10 ? "0" : "");
    ret += mins + ":" + (secs < 10 ? "0" : "");
    ret += secs.toFixed(2);
    return ret;
}

AnimationExtension.prototype.load = function() {
    var viewer = this.viewer;

    this.onPlayCallbackBinded = this.onPlayCallback.bind(this);
    this.onCameraChangeBinded = this.onCameraChange.bind(this);
    this.onExplodeBinded = this.onExplode.bind(this);
    this.onResizeBinded = this.onResize.bind(this);
    this.onEscapeBinded = this.onEscape.bind(this);

    viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
    viewer.addEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, this.onExplodeBinded);
    viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResizeBinded);
    viewer.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, this.onEscapeBinded);

    // init animations after object tree created and geometry loaded
    if (viewer.model && viewer.model.isObjectTreeCreated()) {
        this.onAnimationReady();
    } else {
        this.onAnimationReadyBinded = this.onAnimationReady.bind(this);
        viewer.addEventListener(Autodesk.Viewing.ANIMATION_READY_EVENT, this.onAnimationReadyBinded);
    }

    return true;
};

AnimationExtension.prototype.unload = function () {
    var viewer = this.viewer;

    if (this.onAnimationReadyBinded) {
        viewer.removeEventListener(Autodesk.Viewing.ANIMATION_READY_EVENT, this.onAnimationReadyBinded);
        this.onAnimationReadyBinded = null;
    }

    // stop animations
    this.rewind();
    viewer.impl.invalidate(true, true, true); // Required to reset animations when Extension unloads and viewer remains.

    this.onPlayCallbackBinded = null;

    if (this.animTools) {
        this.animTools.removeControl(this.animTools.timeText.getId());
        this.animTools.removeControl(this.animTools.timeline.getId());
        this.animTools.removeControl(this.animTools.timeLeftText.getId());
        this.animTools.removeControl(this.animTools.forwardButton.getId());
        this.animTools.removeControl(this.animTools.backwardButton.getId());
        this.animTools.removeControl(this.animTools.closeButton.getId());
    }

    if (this.toolbar) {
        this.toolbar.removeControl(this.animTools);
        this.toolbar.container.parentNode.removeChild(this.toolbar.container);
        this.toolbar = null;
    }

    if (this.playButton) {
        var toolbar = viewer.getToolbar(false);
        if (toolbar) {
            toolbar.getControl(av.TOOLBAR.MODELTOOLSID).removeControl(this.playButton.getId());
        }
    }

    // Remove event listeners
    viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);
    viewer.removeEventListener(av.EXPLODE_CHANGE_EVENT, this.onExplodeBinded);
    viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.onResizeBinded);
    viewer.removeEventListener(av.ESCAPE_EVENT, this.onEscapeBinded);

    if (this.onToolbarCreatedBinded) {
        viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        this.onToolbarCreatedBinded = null;
    }

    return true;
};

/**
 * Plays the animation. Invoke pause() to stop the animation.
 */
AnimationExtension.prototype.play = function() {

    if (this.isPlaying()) {
        return;
    }

    this.resetExplode(0, true);

    var viewer = this.viewer;
    var animator = viewer.impl.keyFrameAnimator;
    if (!animator) return;

    // restore previous animation if set
    if (this.prevAnimationTime > 0) {
        animator.goto(this.prevAnimationTime);
        this.prevAnimationTime = -1;
    }

    animator.play(0, this.onPlayCallbackBinded);

    this.updatePlayButton(animator.isPaused);
    if (viewer.toolbar) {
        viewer.toolbar.addClass('toolbar-animationMenuplacer');
    }
    if (this.animTools) {
        this.animTools.setVisible(true);
        if (!this.animTools.isPositionAdjusted) {
            this.adjustToolbarPosition();
            this.animTools.isPositionAdjusted = true;
        }
    }
};

/**
 * Pauses an active animation. Can resume by calling play()
 */
AnimationExtension.prototype.pause = function() {

    if (this.isPaused()) {
        return;
    }

    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return;
    animator.pause();

    // UI stuff
    this.updatePlayButton(animator.isPaused);
};

/**
 * Whether the animation is currently playing.
 * Always returns the opposite of isPaused()
 * @returns {Boolean}
 */
AnimationExtension.prototype.isPlaying = function() {

    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return false;
    return animator.isPlaying && !animator.isPaused;
};

/**
 * Wether the animation is currently paused.
 * Always returns the opposite of isPlaying()
 * @returns {Boolean}
 */
AnimationExtension.prototype.isPaused = function() {

    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return false;
    return animator.isPaused;
};

/**
 * Pauses and rewinds the animation.
 */
AnimationExtension.prototype.rewind = function() {
    this.setTimelineValue(0);
};

/**
 * Sets the animation at the very beginning (0), at the end(1) or anywhere in between.
 * For example, use value 0.5 to set the animation half way through it's completion.
 * Will pause a playing animation.
 *
 * @param {Number} scale - value between 0 and 1
 */
AnimationExtension.prototype.setTimelineValue = function(scale) {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return;
    scale = Math.min(Math.max(0,scale), 1);
    var time = scale * animator.duration;
    animator.goto(time);
    this.updateUI();
};

/**
 * Sets animation onto the previous keyframe.
 * Will pause the animation if playing.
 */
AnimationExtension.prototype.prevKeyframe = function() {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return;
    animator.prev();
    this.updateUI();
};

/**
 * Sets animation onto the next keyframe.
 * Will pause the animation if playing.
 */
AnimationExtension.prototype.nextKeyframe = function() {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return;
    animator.next();
    this.updateUI();
};

/**
 * Returns how many seconds does the animation take to complete.
 * See also:
 * - getDurationLabel()
 * - getCurrentTime()
 * @return {Number}
 */
AnimationExtension.prototype.getDuration = function() {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return 0;
    return animator.duration;
};

/**
 * Returns duration as a formatted String h:mm:ss (hours:minutes:seconds)
 * See also:
 * - getDuration()
 * - getCurrentTimeLabel()
 * @returns {string}
 */
AnimationExtension.prototype.getDurationLabel = function() {
    return convertSecsToHMS(this.getDuration());
};

/**
 * Returns the elapsed time (in seconds) of the animation.
 * See also:
 * - getDuration()
 * - getCurrentTimeLabel()
 * @return {Number}
 */
AnimationExtension.prototype.getCurrentTime = function() {
    var animator = this.viewer.impl.keyFrameAnimator;
    if (!animator) return 0;
    return animator.currentTime;
};

/**
 * Returns the current animation time as a formatted String h:mm:ss (hours:minutes:seconds)
 * See also:
 * - getCurrentTime()
 * - getDurationLabel()
 * @returns {string}
 */
AnimationExtension.prototype.getCurrentTimeLabel = function() {
    return convertSecsToHMS(this.getCurrentTime());
};



/**
 * @private
 */
AnimationExtension.prototype.onAnimationReady = function() {
    var viewer = this.viewer;

    if (this.onAnimationReadyBinded) {
        viewer.removeEventListener(Autodesk.Viewing.ANIMATION_READY_EVENT, this.onAnimationReadyBinded);
        this.onAnimationReadyBinded = null;
    }

    // Check for animator class
    if (!viewer.impl.keyFrameAnimator)
        return;

    // Add the ui only if an animation is available.
    if (viewer.toolbar && viewer.modelTools) {
        this.onToolbarCreated();
    } else {
        this.onToolbarCreatedBinded = this.onToolbarCreated.bind(this);
        viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
    }
};

/**
 *
 * @private
 */
AnimationExtension.prototype.updateUI = function() {

    var animator = this.viewer.impl.keyFrameAnimator;
    if (!this.animTools || !animator) {
        return;
    }
    this.animTools.input.value = animator.duration > 0 ? animator.currentTime / animator.duration * 100 : 0;
    this.animTools.lapse.value = convertSecsToHMS(animator.currentTime);
    this.animTools.lapseLeft.value = convertSecsToHMS(animator.currentTime-animator.duration);
    this.updatePlayButton(animator.isPaused);
    this.updateToolbarBackground();
};

/**
 * @private
 */
AnimationExtension.prototype.onPlayCallback = function(value) {

    // TODO: We should be able to replace this whole method body with a call to update().
    // The only problem for now is taht we would also need to change KeyFrameAnimator because
    // the onPlayCallback() is being invoked BEFORE the animation is paused.
    if (!this.animTools) return;

    var animator = this.viewer.impl.keyFrameAnimator;
    this.animTools.input.value = value;
    this.animTools.lapse.value = convertSecsToHMS(animator.currentTime);
    this.animTools.lapseLeft.value = convertSecsToHMS(animator.currentTime-animator.duration);

    if (value >= 100) {
        this.updatePlayButton(true);
    }
    this.updateToolbarBackground();
};

/**
 *
 * @param isPaused
 * @private
 */
AnimationExtension.prototype.updatePlayButton = function(isPaused) {
    if (!this.playButton) return;
    if (isPaused) {
        this.playButton.setIcon('toolbar-animationPlayIcon');
        this.playButton.setToolTip('Play');
    } else {
        this.playButton.setIcon('toolbar-animationPauseIcon');
        this.playButton.setToolTip('Pause');
    }
};

/**
 * Helper function that resets model explosion.
 * @param value
 * @param setSlider
 * @private
 */
AnimationExtension.prototype.resetExplode = function(value, setSlider) {
    var viewer = this.viewer;
    if (!viewer.model.is2d() && viewer.getExplodeScale() !== 0) {
        if (setSlider && viewer.explodeSlider) { // explodeSlider is only in GuiViewer3D instances
            viewer.explodeSlider.value = value;
        }
        viewer.explode(value);
    }
};

/**
 * @private
 */
AnimationExtension.prototype.adjustToolbarPosition = function() {
    // set timeline width
    var viewer = this.viewer;
    if (!viewer.toolbar) return;
    var fullwidth = viewer.toolbar.getDimensions().width;
    var viewportWidth = viewer.container.getBoundingClientRect().width;
    if (fullwidth > viewportWidth)
        fullwidth = viewer.modelTools.getDimensions().width;
    var inputWidth = fullwidth - (2 *
        this.animTools.backwardButton.getDimensions().width + 3 *
        this.animTools.timeText.getDimensions().width + this.animTools.closeButton.getDimensions().width) + 12;
    this.animTools.input.style.width = inputWidth + 'px';

    // center toolbar
    this.toolbar.container.style.left = 'calc(50% - ' + fullwidth/2 + 'px)';
};

/**
 * @private
 */
AnimationExtension.prototype.hideAnimateToolbar = function() {
    if (this.viewer.toolbar) {
        this.viewer.toolbar.removeClass('toolbar-animationMenuplacer');
    }
    if (this.animTools) {
        this.animTools.setVisible(false);
    }
};

/**
 * @private
 */
AnimationExtension.prototype.updateToolbarBackground = function() {
    if (!this.animTools) return;
    var input = this.animTools.input;
    var percentage = input.value;
    var col1 = "#ffffff", col2 = "#393939";
    input.style.background = "-webkit-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    input.style.background = "-moz-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    input.style.background = "-ms-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    input.style.background = "-o-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    input.style.background = "linear-gradient(to right,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
};

/**
 * @private
 */
AnimationExtension.prototype.onCameraChange = function() {
    if (this.viewer.toolController.cameraUpdated) {
        var animator = this.viewer.impl.keyFrameAnimator;
        if (!animator) return;
        if (animator.isPlaying && !animator.isPaused) {
            animator.pause();
            this.updatePlayButton(animator.isPaused);
        }
    }
};

/**
 * @private
 */
AnimationExtension.prototype.onResize = function() {
    if (!this.toolbar) return;
    if (this.viewer.container.clientWidth < (isTouchDevice() ? 560 : 600)) {
        this.toolbar.setCollapsed(true);
    } else {
        this.toolbar.setCollapsed(false);
        this.adjustToolbarPosition();
    }
};

/**
 * @private
 */
AnimationExtension.prototype.onEscape = function () {

    if (this.isPlaying()) {
        this.pause();
    } else {
        this.hideAnimateToolbar();
    }
};

/**
 * @private
 */
AnimationExtension.prototype.onExplode = function() {
    // reset animation
    var animator = this.viewer.impl.keyFrameAnimator;
    if (animator) {
        if (animator.currentTime !== 0) {
            this.prevAnimationTime = animator.currentTime;
            animator.goto(0);
        }
        this.updatePlayButton(true);
    }
    this.hideAnimateToolbar();
};

/**
 * @private
 */
AnimationExtension.prototype.onToolbarCreated = function() {

    var viewer = this.viewer;
    var that = this;

    if (this.onToolbarCreatedBinded) {
        viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        this.onToolbarCreatedBinded = null;
    }

    this.toolbar = new AVU.ToolBar('animation-toolbar');
    this.toolbar.addClass('toolbar-animationSubtoolbar');
    viewer.container.appendChild(this.toolbar.container);

    this.animTools = new AVU.ControlGroup(this.animToolsId);
    this.animTools.setVisible(false);
    this.toolbar.addControl(this.animTools);

    // play button at first of modelTools
    this.playButton = new AVU.Button('toolbar-animationPlay');
    this.playButton.setIcon('toolbar-animationPlayIcon');
    this.playButton.setToolTip('Play');
    this.playButton.onClick = function() {
        if (that.isPaused()) {
            that.play();
        } else {
            that.pause();
        }
    };
    viewer.modelTools.addControl(this.playButton);

    // override reset button's onClick method
    if (viewer.modelTools.resetModelButton) {
        viewer.modelTools.resetModelButton.onClick = function(e) {
            viewer.showAll();
            var animator = viewer.impl.keyFrameAnimator;
            if (animator) {
                animator.goto(0);
                input.value = 0;
                lapse.value = convertSecsToHMS(0);
                lapseLeft.value = convertSecsToHMS(-animator.duration);
                that.updatePlayButton(true);
            }
            that.resetExplode(0, true);
            that.updateToolbarBackground();
        };
    }

    // backward button
    this.animTools.backwardButton = new AVU.Button('toolbar-animationBackward');
    this.animTools.backwardButton.setToolTip('Previous keyframe');
    this.animTools.backwardButton.onClick = function(e) {
        var animator = viewer.impl.keyFrameAnimator;
        if (animator !== undefined && animator) {
            animator.prev();
            that.updateUI();
        }
    };
    this.animTools.backwardButton.addClass('toolbar-animationButton');
    this.animTools.backwardButton.setIcon('toolbar-animationBackwardIcon');
    this.animTools.addControl(this.animTools.backwardButton);

    // forward button
    this.animTools.forwardButton = new AVU.Button('toolbar-animationForward');
    this.animTools.forwardButton.setToolTip('Next keyframe');
    this.animTools.forwardButton.onClick = function(e) {
        var animator = viewer.impl.keyFrameAnimator;
        if (animator !== undefined && animator) {
            animator.next();
            that.updateUI();
        }
    };
    this.animTools.forwardButton.addClass('toolbar-animationButton');
    this.animTools.forwardButton.setIcon('toolbar-animationForwardIcon');
    this.animTools.addControl(this.animTools.forwardButton);

    // current time lapse
    this.animTools.timeText = new AVU.Control('toolbar-animationTimeLapse');
    var lapse = this.animTools.lapse = document.createElement("input");
    lapse.type = "text";
    lapse.value = "0";
    lapse.className = "animationTimeLapse";
    lapse.disabled = true;
    this.animTools.timeText.container.appendChild(lapse);
    this.animTools.timeText.addClass('toolbar-animationButton');
    this.animTools.addControl(this.animTools.timeText);

    // timeline
    this.animTools.timeline = new AVU.Control('toolbar-animationTimeline');
    var input = this.animTools.input = document.createElement("input");
    input.type = "range";
    input.value = "0";
    input.className = "animationTimeline";
    this.animTools.timeline.container.appendChild(input);
    input.addEventListener("input", function(e) {
        var animator = viewer.impl.keyFrameAnimator;
        if (animator !== undefined && animator) {
            var time = input.value * animator.duration / 100;
            lapse.value = convertSecsToHMS(time);
            lapseLeft.value = convertSecsToHMS(time-animator.duration);
            animator.goto(time);
            that.updatePlayButton(animator.isPaused);
            that.updateToolbarBackground();
        }
    });
    // tooltip for slider
    var inputTooltip = document.createElement("div");
    inputTooltip.className = "adsk-control-tooltip";
    inputTooltip.textContent = Autodesk.Viewing.i18n.translate("Click-drag to scrub");
    this.animTools.timeline.container.appendChild(inputTooltip);
    input.addEventListener("mouseover", function(event) {
        if (event.target === input)
            inputTooltip.style.visibility = "visible";
    });
    input.addEventListener("mouseout", function(event) {
        if (event.target === input)
            inputTooltip.style.visibility = "hidden";
    });

    this.animTools.timeline.addClass('toolbar-animationButton');
    this.animTools.timeline.addClass('toolbar-animationTimeline');
    this.animTools.addControl(this.animTools.timeline);

    // remaining time lapse
    this.animTools.timeLeftText = new AVU.Control('toolbar-animationRemainingTime');
    var lapseLeft = this.animTools.lapseLeft = document.createElement("input");
    lapseLeft.type = "text";
    lapseLeft.value = "0";
    lapseLeft.className = "animationTimeLapse";
    lapseLeft.disabled = true;
    this.animTools.timeLeftText.container.appendChild(lapseLeft);
    this.animTools.timeLeftText.addClass('toolbar-animationButton');
    this.animTools.addControl(this.animTools.timeLeftText);

    // close button
    this.animTools.closeButton = new AVU.Button('toolbar-animationClose');
    this.animTools.closeButton.setToolTip('Close animation timeline');
    this.animTools.closeButton.onClick = function() {
        that.hideAnimateToolbar();
    };
    this.animTools.closeButton.setIcon('toolbar-animationCloseIcon');
    this.animTools.closeButton.addClass('toolbar-animationButton');
    this.animTools.addControl(this.animTools.closeButton);
};

//TODO: Is it really necessary to expose it other than to ExtensionManager?
AutodeskNamespace('Autodesk.Viewing.Extensions.Fusion360');
Autodesk.Viewing.Extensions.Fusion360.AnimationExtension = AnimationExtension;

av.theExtensionManager.registerExtension('Autodesk.Fusion360.Animation', AnimationExtension);


})();;/**
 * Created by tstanev on 14-11-23.
 */
 
function init_WarpShader() {

if (typeof window.WarpShader !== "undefined")
	return; 

//Shader that implements Oculus VR headset image warping.
WarpShader = {

	uniforms: {
		"tDiffuse": { type: "t", value: null }, //Color buffer containing the rendered 3d model

		//Stereo rendering (Oculus) uniforms. Warp and aberration constants are from DK1 Rift.
		"scale": { type: "v2", value: new THREE.Vector2(1.0,1.0) },
		"scaleIn": { type: "v2", value: new THREE.Vector2(1.0,1.0) },
		"lensCenter": { type: "v2", value: new THREE.Vector2(0.0,0.0) },
		"hmdWarpParam": { type: "v4", value: new THREE.Vector4(1.0, 0.22, 0.24, 0.0) },
		"chromAbParam": { type: "v4", value: new THREE.Vector4(0.996, -0.004, 1.014, 0.0) }
	},


	defines: {
		//"OCULUS" : 1
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",

		"uniform vec2 scale;",
		"uniform vec2 scaleIn;",
		"uniform vec2 lensCenter;",
		"uniform vec4 hmdWarpParam;",
		'uniform vec4 chromAbParam;',


		"varying vec2 vUv;",


		"vec4 sampleColor() {",

			//In our case the source texture is one eye only, so we deviate from the sample
			"vec2 uv = (vUv*2.0)-1.0;", // range from [0,1] to [-1,1]

			"vec2 theta = (uv-lensCenter)*scaleIn;",
			"float rSq = theta.x*theta.x + theta.y*theta.y;",
			"vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);",
		     /*
		    "vec2 tc = (lensCenter + scale * rvector);",
		  	"tc = (tc+1.0)/2.0;", // range from [-1,1] to [0,1]

			"if (any(bvec2(clamp(tc, vec2(0.0,0.0), vec2(1.0,1.0))-tc)))",
			"  return vec4(0.0, 0.0, 0.0, 1.0);",

			"return texture2D( tDiffuse, tc);",
               */

			"  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);",
			"  vec2 tcBlue = (lensCenter + scale * rBlue);",
			"  tcBlue = (tcBlue+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue)))",
			"    return vec4(0.0, 0.0, 0.0, 1.0);",

			"  vec2 tcGreen = lensCenter + scale * rvector;",
			"  tcGreen = (tcGreen+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);",
			"  vec2 tcRed = lensCenter + scale * rRed;",
			"  tcRed = (tcRed+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  return vec4(texture2D(tDiffuse, tcRed).r, texture2D(tDiffuse, tcGreen).g, texture2D(tDiffuse, tcBlue).b, 1);",
		"}",


		"void main() {",

			"vec4 texel = sampleColor();",

			"gl_FragColor = texel;",
		"}"

	].join("\n")

};

};
AutodeskNamespace('Autodesk.Viewing.Extensions.Oculus');


Autodesk.Viewing.Extensions.Oculus.StereoRenderContext = function(options) {

    var _leftCamera, _rightCamera;
    var _leftContext, _rightContext;
    var _renderer;
    var _w, _h, _dpr;
    var _warpPassLeft, _warpPassRight;
    var _useWarp = options ? options.useWarp : true;

	// Specific HMD parameters
	var HMD = (options && options.HMD) ? options.HMD: {
		// Parameters from the Oculus Rift DK2
		hResolution: 1920,
		vResolution: 1080,
		hScreenSize: 0.12576,
		vScreenSize: 0.07074,
		interpupillaryDistance: 0.0635,
		lensSeparationDistance: 0.0635,
		eyeToScreenDistance: 0.041,
		distortionK : [1.0, 0.22, 0.24, 0.0],
		chromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]
	};


    var left = {}, right = {};
    var distScale = 1.0;
    var offsetProjection = 0.0;
    var fov = 100;
    var initial_fov,
        initial_aspect;
    var aspect = 1;

//See three.js OculusRiftEffect
	function computeCameraParams(HMD) {
		// Compute aspect ratio and FOV
		aspect = HMD.hResolution / (2*HMD.vResolution);

		// Fov is normally computed with:
		//   THREE.Math.radToDeg( 2*Math.atan2(HMD.vScreenSize,2*HMD.eyeToScreenDistance) );
		// But with lens distortion it is increased (see Oculus SDK Documentation)
		var r = -1.0 - (4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize);
		distScale = (HMD.distortionK[0] + HMD.distortionK[1] * Math.pow(r,2) + HMD.distortionK[2] * Math.pow(r,4) + HMD.distortionK[3] * Math.pow(r,6));
		fov = THREE.Math.radToDeg(2*Math.atan2(HMD.vScreenSize*distScale, 2*HMD.eyeToScreenDistance));

		// Compute camera projection matrices
		offsetProjection = 4 * (HMD.hScreenSize/4 - HMD.interpupillaryDistance/2) / HMD.hScreenSize;

		// Distortion shader parameters
		var lensShift = 4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize;
		left.lensCenter = new THREE.Vector2(lensShift, 0.0);
		right.lensCenter = new THREE.Vector2(-lensShift, 0.0);
	}


    this.init = function (glrenderer, width, height) {
    
        init_WarpShader();

        _renderer = glrenderer;

        //For Oculus targets, we want to cancel out the DPR
        //scale applied by the underlying render context
        _w = width;
        _h = height;
        _dpr = _renderer.getPixelRatio();

        computeCameraParams(HMD);

        _leftContext = new RenderContext();
        _rightContext = new RenderContext();

        _leftContext.settings.sao = _rightContext.settings.sao = false;
        _leftContext.settings.antialias = _rightContext.settings.antialias = false;
        _leftContext.settings.customPresentPass = _rightContext.settings.customPresentPass = _useWarp;

        _leftContext.init(_renderer, _w/2 * distScale / _dpr, _h * distScale / _dpr);
        _rightContext.init(_renderer, _h/2 * distScale / _dpr, _h * distScale / _dpr);

        this.settings = _leftContext.settings;

        if (_useWarp) {
            _warpPassLeft = new Autodesk.Viewing.Shaders.LmvShaderPass(WarpShader);
            _warpPassRight = new Autodesk.Viewing.Shaders.LmvShaderPass(WarpShader);

            var bpasses = [_warpPassLeft, _warpPassRight];
            for (var i=0; i<2; i++) {
                bpasses[i].material.blending = THREE.NoBlending;
                bpasses[i].material.depthWrite = false;
                bpasses[i].material.depthTest = false;

                bpasses[i].uniforms['hmdWarpParam'].value.set(HMD.distortionK[0], HMD.distortionK[1], HMD.distortionK[2], HMD.distortionK[3]);
                bpasses[i].uniforms['chromAbParam'].value.set(HMD.chromaAbParameter[0], HMD.chromaAbParameter[1], HMD.chromaAbParameter[2], HMD.chromaAbParameter[3]);
                bpasses[i].uniforms['scaleIn'].value.set(1.0,1.0/aspect);
                bpasses[i].uniforms['scale'].value.set(1.0/distScale, 1.0*aspect/distScale);
            }

            bpasses[0].uniforms['lensCenter'].value.copy(left.lensCenter);
            bpasses[1].uniforms['lensCenter'].value.copy(right.lensCenter);
        }
    };

	function applyCameraChanges(camera) {

		//Correct aspect ration. Stereo rendering cuts horizontal
		//size in half.
		_leftCamera.aspect = _rightCamera.aspect = aspect;

		//Apply field of view correction
		_leftCamera.fov = _rightCamera.fov = fov;

		//Offset real world camera position for each eye
		var unitsPerM = 1.0 / _leftContext.getUnitScale();
		var right = camera.target.clone().sub(camera.position).cross(camera.up).normalize();
		//right.multiplyScalar(0.5 * HMD.interpupillaryDistance * unitsPerM);
        right.multiplyScalar(1 * HMD.interpupillaryDistance * unitsPerM);
		//_leftCamera.position.sub(right);
		_rightCamera.position.add(right);
		//_leftCamera.target.sub(right);
		_rightCamera.target.add(right);

		_leftCamera.toPerspective();
		_rightCamera.toPerspective();

		//_leftCamera.projectionMatrix.elements[12] += offsetProjection;
		_rightCamera.projectionMatrix.elements[12] -= 2 * offsetProjection;

	}

    this.revertCameraChanges = function(camera) {
        console.log("REVERT Camera to normal");
        _leftCamera.fov = initial_fov;
        _leftCamera.aspect = initial_aspect;

        return _leftCamera;

    };

    //save camera state to revert back when oculus toggled off
    this.saveCameraState = function(camera){
        console.log(camera);
        initial_fov = camera.fov;
        initial_aspect = camera.aspect;
    };

    this.update = function(highResTimer) {

        var left = _leftContext.update(highResTimer);
        var right = _rightContext.update(highResTimer);

        return left || right;
    };

    this.beginScene = function (prototypeScene, camera, customLights, needClear) {
		//_leftCamera = camera.clone();
        _leftCamera = camera;
		_rightCamera = camera.clone();

        applyCameraChanges(camera);

        _leftContext.beginScene(prototypeScene, _leftCamera, customLights, needClear);
        _rightContext.beginScene(prototypeScene, _rightCamera, customLights, needClear);

        //camera.updateMatrixWorld();//Check if dirty first, only update then
        //TODO in vporttoray check if i should unproject?
    };


    this.renderScenePart = function (scene, colorTarget, saoTarget, idTarget) {
        _leftContext.renderScenePart(scene, colorTarget, saoTarget, idTarget);
        _rightContext.renderScenePart(scene, colorTarget, saoTarget, idTarget);
    };

    this.sceneDirty = function(camera, bbox) {
        _leftContext.sceneDirty(camera, bbox);
        _rightContext.sceneDirty(camera, bbox);
    };

    //TODO: get rid of this and combine it with composeFinalFrame
    this.endScene = function() {
        _leftContext.endScene();
        _rightContext.endScene();
    };

    this.clearAllOverlays = function () {
        _leftContext.clearAllOverlays();
        _rightContext.clearAllOverlays();
    };

    this.renderOverlays = function (overlays) {
        _leftContext.renderOverlays(overlays);
        _rightContext.renderOverlays(overlays);
    };


    this.composeFinalFrame = function (skipAOPass, progressiveDone) {
        //Make the final frame but skip presenting it
        //to the screen. We will do custom stuff
        _leftContext.composeFinalFrame(skipAOPass, progressiveDone, true);
        _rightContext.composeFinalFrame(skipAOPass, progressiveDone, true);

        //Compose the per-eye frames using viewports per eye
        _renderer.setViewport(0,0,_w/2,_h);
        _leftContext.presentBuffer(_warpPassLeft);

        _renderer.setViewport(_w/2,0,_w/2,_h);
        _rightContext.presentBuffer(_warpPassRight);

        _renderer.setViewport(0,0,_w,_h);
    };

    this.cleanup = function() {
        _leftContext.cleanup();
        _rightContext.cleanup();
    };

    this.setSize = function (w, h, force) {
        _w = w;
        _h = h;

        _leftContext.setSize(_w/2 * distScale / _dpr, _h * distScale / _dpr, force);
        _rightContext.setSize(_w/2 * distScale / _dpr, _h * distScale / _dpr, force);

        _renderer.setSize(w,h);
    };

    this.getMaxAnisotropy = function () {
        return _leftContext.getMaxAnisotropy();
    };

    this.hasMRT = function () {
        return _leftContext.hasMRT();
    };

    this.initPostPipeline = function (useSAO, useFXAA, useIDBuffer) {

        //override these
        useSAO = false; useFXAA = false; useIDBuffer = false;

        _leftContext.initPostPipeline(useSAO, useFXAA, useIDBuffer);
        _rightContext.initPostPipeline(useSAO, useFXAA, useIDBuffer);
    };

    this.setClearColors = function (colorTop, colorBot) {
        _leftContext.setClearColors(colorTop, colorBot);
        _rightContext.setClearColors(colorTop, colorBot);
    };


    this.setAOOptions = function (radius, intensity) {
        _leftContext.setAOOptions(radius, intensity);
        _rightContext.setAOOptions(radius, intensity);
    };

    this.getAORadius = function () {
        return _leftContext.getAORadius();
    };

    this.getAOIntensity = function() {
        return _leftContext.getAOIntensity();
    };

    this.setTonemapExposureBias = function (bias) {
        _leftContext.setTonemapExposureBias(bias);
        _rightContext.setTonemapExposureBias(bias);
    };

    this.getExposureBias = function () {
        return _leftContext.getExposureBias();
    };

    this.setTonemapMethod = function (value) {
        _leftContext.setTonemapMethod(value);
        _rightContext.setTonemapMethod(value);
    };

    this.getToneMapMethod = function () {
        return _leftContext.getToneMapMethod();
    };

    this.toggleTwoSided = function (isTwoSided) {
        _leftContext.toggleTwoSided(isTwoSided);
        _rightContext.toggleTwoSided(isTwoSided);
    };

    this.enter2DMode = function(idMaterial) {
        _leftContext.enter2DMode(idMaterial);
        _rightContext.enter2DMode(idMaterial);
    };

    //Returns the value of the ID buffer at the given
    //viewport location. Note that the viewport location is in
    //OpenGL-style coordinates [-1, 1] range.
    this.idAtPixel = function (vpx, vpy) {
        console.warn("idAtPixel not implemented in stereo context.");
        return 0;
    };


    this.overlayUpdate = function(highResTimer) {
        _leftContext.overlayUpdate(highResTimer);
        _rightContext.overlayUpdate(highResTimer);
    };

    this.rolloverObjectViewport = function (vpx, vpy) {
       /// console.warn("rolloverObjectViewport not implemented in stereo context");//TODO this is annoying
    };


    this.screenCapture = function() {
        console.warn("Screen capture not implemented by stereo render context");
        return null;
    };

	this.setUnitScale = function(metersPerUnit) {
		_leftContext.setUnitScale(metersPerUnit);
		_rightContext.setUnitScale(metersPerUnit);
	};

	this.getUnitScale = function() {
		return _leftContext.getUnitScale();
	}


};;AutodeskNamespace('Autodesk.Viewing.Extensions.Oculus');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avu = av.UI,
        aveo = ave.Oculus;

    var _vrHMD = null, _vrSensor = null;


    function HeadTrackingTool(viewer) {

        var _camera;
        var _viewer = viewer;

        var _headPos = new THREE.Vector3(0,0,0);
        var _headQuat = new THREE.Quaternion();
        var _turnQuat = new THREE.Quaternion();
        var _mView = new THREE.Matrix4();
        var _headPosBase = new THREE.Vector3(0,0,0);
        var _mViewBase = new THREE.Matrix4();
        var _mTmp = new THREE.Matrix4();
        var _sensorData, _lastId = 0;
        var _toModelUnits = 1.0;

        var SPEED_SCALE = 10.0;
        var LOOK_SCALE = 0.001;
        var _lastTime = -1.0;
        var _baseAzimuth = 0.0;

        var _W=0, _A=0, _S=0, _D=0, _Q=0, _E=0;

        var _ws;

        if (!_vrSensor)
            initWebSocket();
        else
            _sensorData = [0,0,0,0,0,0,0,0];


        this.getNames = function() {
            return ["headtracker"];
        };

        this.getName = function() {
            return "headtracker";
        };

        var _gamepadModule;
        this.activate = function(name) {

            _camera = _viewer.navigation.getCamera();

            resetOrientation();

            if (_viewer.model) {
                _toModelUnits = 1.0 / _viewer.model.getUnitScale();
                var box = _viewer.model.getBoundingBox();
                SPEED_SCALE = box.size().length() * 0.0001;

            }

            //if this browser supports gamepad, instantiate GamepadModule
            if(navigator.getGamepads || !!navigator.webkitGetGamepads || !!navigator.webkitGamepads){
                _gamepadModule = new Autodesk.Viewing.Extensions.GamepadModule(_viewer);
                _gamepadModule.activate(this.getName());
            }
        };

        this.deactivate = function(name) {
            _camera = null;
            if(_gamepadModule)
                _gamepadModule.deactivate();
        };

        this.update = function(timeStamp) {

            if (_lastTime < 0)
                _lastTime = timeStamp;

            var timeDelta = timeStamp - _lastTime;

            //the "go home" call may change the camera back to ortho... and we can't do ortho while walking...
            //HACK: Really, the home view should be set once when launch the extension, then set it back.
            if (!_camera.isPerspective)
                viewer.navigation.toPerspective();

            if (_vrSensor) {

                var state = _vrSensor.getState();
                _sensorData[0] = _lastId + 1;
                if (state.orientation) {
                    _sensorData[4] = state.orientation.x;
                    _sensorData[5] = state.orientation.y;
                    _sensorData[6] = state.orientation.z;
                    _sensorData[7] = state.orientation.w;
                }
                if (state.position) {
                    _sensorData[1] = state.position.x;
                    _sensorData[2] = state.position.y;
                    _sensorData[3] = state.position.z;
                }
            }

            if (_sensorData) {
                var id = _sensorData[0];
                if (id > _lastId) {

                    //Process head position offset
                    _camera.position.sub(_headPos);

                    _headPos.set(_sensorData[1],_sensorData[2],_sensorData[3]);
                    _headPos.sub(_headPosBase);
                    _headPos.multiplyScalar(_toModelUnits);
                    _headPos.applyMatrix4(_mViewBase);

                    _camera.position.add(_headPos);

                    _baseAzimuth += (_Q - _E) * timeDelta * LOOK_SCALE;
                    _turnQuat.setFromAxisAngle(_camera.worldup, _baseAzimuth);

                    //Derive the orientation matrix from the head tracking quaternion,
                    //the head turning quaternion, and the base orientation
                    _headQuat.set(_sensorData[4],_sensorData[5],_sensorData[6],_sensorData[7]);
                    _turnQuat.multiply(_headQuat);
                    _mTmp.makeRotationFromQuaternion(_turnQuat);
                    _mView.multiplyMatrices(_mViewBase, _mTmp);
                    var e = _mView.elements;

                    //Direction vector is the Z row of the view matrix
                    var dir = new THREE.Vector3(-e[8], -e[9], -e[10]);
                    var distance = _camera.target.clone().sub(_camera.position).length();

                    //Up vector is the Y row of the view matrix
                    _camera.up.set(e[4], e[5], e[6]);

                    //Process displacement motion due to WASD keys
                    var right = new THREE.Vector3(e[0], e[1], e[2]);
                    var moveForward = dir.clone().multiplyScalar((_W - _S) * timeDelta * SPEED_SCALE);
                    _camera.position.add(moveForward);

                    var moveRight = right.multiplyScalar((_D - _A) * timeDelta * SPEED_SCALE);
                    _camera.position.add(moveRight);

                    _camera.target.set(_camera.position.x, _camera.position.y, _camera.position.z);
                    _camera.target.add(dir.multiplyScalar(distance));
                }
                _lastId = id;
            }

            if (_ws) {
                if (_ws.readyState === 1) {
                    _ws.send("get\n");
                }
            }


            if(_gamepadModule){
                _camera = _gamepadModule.update(_camera);
            }

            _lastTime = timeStamp;

            return true;
        };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};

        this.handleKeyDown = function( event, keyCode ) {

            var handled = false;

            switch (keyCode) {
                case 38 :
                case 87 : _W = 1; handled = true; break;
                case 40 :
                case 83 : _S = 1; handled = true; break;
                case 37 :
                case 65 : _A = 1; handled = true; break;
                case 39:
                case 68 : _D = 1; handled = true; break;

                case 81 : _Q = 1; handled = true; break;
                case 69 : _E = 1; handled = true; break;
            }

            return handled;
        };

        this.handleKeyUp = function( event, keyCode ) {

            var handled = false;

            switch (keyCode) {
                case 38 :
                case 87 : _W = 0; handled = true; break;
                case 40 :
                case 83 : _S = 0; handled = true; break;
                case 37 :
                case 65 : _A = 0; handled = true; break;
                case 39 :
                case 68 : _D = 0; handled = true; break;

                case 81 : _Q = 0; handled = true; break;
                case 69 : _E = 0; handled = true; break;

                case 32 : resetOrientation(); handled = true; break;
            }

            return handled;
        };

        this.handleWheelInput = function(delta) { return false; };
        this.handleButtonDown = function(event, button) { return false; };
        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {return false;};
        this.handleGesture = function(event, touches) {return false;};
        this.handleTouchChange = function(event, touches) {return false;};
        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};


        function resetOrientation() {

            _mViewBase.copy(_camera.matrixWorld);
            _mViewBase.elements[12] = 0;
            _mViewBase.elements[13] = 0;
            _mViewBase.elements[14] = 0;

            if (_sensorData)
                _headPosBase.set(_sensorData[1],_sensorData[2],_sensorData[3]);
        }

        function initWebSocket() {

            //====================
            // This headtracker requires the following Oculus-WebSocket bridge library:
            // https://github.com/gyohk/threejs-typescript-oculusdk2
            // (Only need the OculusWebSocket part)
            //====================
            var ws = new WebSocket("ws://localhost:8888/ws");
            ws.onopen = function () {
                console.log("### Oculus Connected ####");
            };

            ws.onmessage = function (evt) {
                var message = evt.data;
                try {
                    _sensorData = JSON.parse(message);
                } catch (err) {
                    console.log(message);
                }
            };

            ws.onclose = function () {
                console.log("### Oculus Connection Closed ####");
            };
            //====================

            _ws = ws;
        }

    };


    //==================================================================================
    //Extension interface

    /** @constructor */
    aveo.Oculus = function (viewer, options) {
        av.Extension.call(this, viewer, options);

        this.viewer = viewer;
        this.context = null;
        this.initialized = false;
    };

    aveo.Oculus.prototype = Object.create(av.Extension.prototype);
    aveo.Oculus.prototype.constructor = ave.Oculus;


    aveo.Oculus.prototype.toggleOculus = function(state) {

        var viewer = this.viewer;

        if (state) {

            if (!this.context) {
                this.context = new aveo.StereoRenderContext( {useWarp:!_vrHMD} );
                this.context.saveCameraState(this.viewer.navigation.getCamera());
                viewer.impl.setUserRenderContext(this.context);

                //TODO: Not sure why we need this call in order to force the
                //stereo layout to fix itself.
                viewer.resize(viewer.canvas.clientWidth, viewer.canvas.clientHeight);

                viewer.displayViewCube(false, false);

                if (!viewer.navigation.isPerspective)
                    viewer.navigation.toPerspective();

                if (_vrHMD) {
                    launchFullscreen(viewer.impl.canvas, { vrDisplay: _vrHMD });
                } else {
                    launchFullscreen(viewer.impl.canvas);
                }

                if (!this.headTracker) {
                    this.headTracker = new HeadTrackingTool(viewer);
                    viewer.toolController.registerTool(this.headTracker);
                }

                viewer.toolController.activateTool("headtracker");
            }

        }
        else {

            if (this.context) {
                this.viewer.navigation.setCamera(this.context.revertCameraChanges());
                this.context = null;
                viewer.impl.setUserRenderContext(null);

                viewer.displayViewCube(viewer.prefs.get("viewCube"), false);

                viewer.toolController.deactivateTool("headtracker");

                exitFullscreen();
            }
        }


    };


    aveo.Oculus.prototype.createUI = function() {
        var scope = this;
        var viewer = this.viewer;

        this.oculusButton = new avu.Button('toolbar-oculusTool');
        this.oculusButton.setToolTip('Oculus VR Mode');
        this.oculusButton.setIcon("oculusIcon");

        this.oculusButton.onClick = function(e) {
            scope.toggleOculus(!scope.context);
        };

        viewer.modelTools.addControl(this.oculusButton);
    };


    aveo.Oculus.prototype.load = function () {

        var viewer = this.viewer;
        var scope = this;
        //scope.createUI(); comment in to test w/o oculus connection

        function onToolbarCreated(e) {
            viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            scope.createUI();
        }

        function onHMDDetected() {

            // add the button to the toolbar
            if(viewer.modelTools && viewer.modelTools.getNumberOfControls() > 0) {
                scope.createUI();
            } else {
                viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            }
        }

        function EnumerateVRDevices(vrdevs) {
            // First, find a HMD -- just use the first one we find
            for (var i = 0; i < vrdevs.length; ++i) {
                if (vrdevs[i] instanceof HMDVRDevice) {
                    _vrHMD = vrdevs[i];
                    break;
                }
            }

            if (!_vrHMD)
                return;

            // Then, find that HMD's position sensor
            for (var i = 0; i < vrdevs.length; ++i) {
                if (vrdevs[i] instanceof PositionSensorVRDevice &&
                    vrdevs[i].hardwareUnitId == _vrHMD.hardwareUnitId)
                {
                    _vrSensor = vrdevs[i];
                   break;
                }
            }

            if (!_vrHMD || !_vrSensor) {
                stderr("Didn't find a HMD and sensor!");
            } else {
                onHMDDetected();
            }

            scope.initialized = true;
        }


        if (navigator.getVRDevices) {
            navigator.getVRDevices().then(EnumerateVRDevices);
        } else if (navigator.mozGetVRDevices) {
            navigator.mozGetVRDevices(EnumerateVRDevices);
        } else {
            this.initialized = true;
        }


        return true;
    };

    aveo.Oculus.prototype.unload = function () {

        this.toggleOculus(false);

        return true;
    };

    av.theExtensionManager.registerExtension('Autodesk.Viewing.Oculus', aveo.Oculus);

})();;AutodeskNamespace('Autodesk.Viewing.Extensions.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        avp = av.Private,
        ave = av.Extensions,
        avec = ave.Collaboration;


    avec.InteractionInterceptor = function(viewtx) {

        this.getNames = function() {
            return ["intercept"];
        };

        this.getName = function() {
            return "intercept";
        };

        this.activate = function(name) { };
        this.deactivate = function(name) { };
        this.update = function(timeStamp) { return false; };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};
        this.handleKeyDown = function( event, keyCode ) {return false;};
        this.handleKeyUp = function( event, keyCode ) {return false;};

        this.handleWheelInput = function(delta) {
            viewtx.takeControl();
            return false;
        };

        this.handleButtonDown = function(event, button) {
            viewtx.takeControl();
//            stderr("click");
            return false;
        };

        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {
            viewtx.updatePointer(event);
            return false;
        };

        this.handleGesture = function(event) {
            viewtx.takeControl();
            return false;
        };

        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};
    };


    avec.ViewTransceiver = function(client) {

        var _this = this;
        var _viewer = this.viewer = null;
        var _blockEvents = false;
        var _haveControl = false;
        var _isDisconnected = false;
        var _lastInControl;
        var _client = this.client = client;
        var _ray = new THREE.Ray();
        var _pointer = null;
        var _pointerOn = false;

        this.channelId = null;

        var _viewerState;
        var VIEWER_STATE_FILTER = {
            seedURN: false,
            objectSet: true,
            viewport: false,
            cutplanes: true,
            renderOptions: {
                environment: false,
                ambientOcclusion: false,
                toneMap: {
                    exposure: false
                },
                appearance: false
            }
        };


        function onViewerState(evt) {
            _blockEvents = true;
            var state = JSON.parse(evt.data.msg);
            _viewerState.restoreState(state);
            _viewer.impl.invalidate(true, false, true);
            _blockEvents = false;
        }

        function reduceBits(v) {
            return Math.round(v * 1000) / 1000;
        }

        function reduceBitsV(v) {
            for (var i=0; i< v.length; i++)
                v[i] = reduceBits(v[i]);
        }

        function onCamera(e) {
            var v = e.data.msg;

            if (v[1] === true || _isDisconnected)
            {
                return;
            }

            if (v[0] != _lastInControl)
            {
                _lastInControl = v[0];
                e.data.lastInControl = v[0];
                _this.dispatchEvent({type: "controlChange", channelId: _this.channelId, data: e.data });
            }

            //For now, automatically relinquish camera control if we receive a remote command to move the camera
            _haveControl = false;

/*
            viewer.navigation.setRequestTransitionWithUp(true, new THREE.Vector3().set(v[1+0],v[1+1],v[1+2]),
                                                                new THREE.Vector3().set(v[1+3],v[1+4],v[1+5]),
                                                                _viewer.navigation.getCamera().fov,
                                                                new THREE.Vector3().set(v[1+6],v[1+7],v[1+8]));
*/

            _viewer.navigation.setView(new THREE.Vector3().set(v[2+0],v[2+1],v[2+2]),
                                       new THREE.Vector3().set(v[2+3],v[2+4],v[2+5]));
            _viewer.navigation.setCameraUpVector(new THREE.Vector3().set(v[2+6],v[2+7],v[2+8]));
        }

        function sendCamera(evt) {
            if (!_haveControl && !_isDisconnected)
                return;

            var c = evt.camera;
            var camParams = [ c.position.x, c.position.y, c.position.z,
                c.target.x, c.target.y, c.target.z,
                c.up.x, c.up.y, c.up.z
            ];

            reduceBitsV(camParams);
            camParams.unshift(_isDisconnected);
            camParams.unshift(client.getLocalId());

            _client.sendMessage("camera", camParams, _this.channelId);

            if (_lastInControl != camParams[0]) {
                _lastInControl = camParams[0];
                _this.dispatchEvent({type: "controlChange", channelId: _this.channelId, data: { lastInControl: _lastInControl } });
            }
        }


        function showPointer(show, x, y) {

            if (show && !_pointer) {
                _pointer = document.createElement("div");
                _pointer.classList.add("collabPointer");
            }

            if (show && !_pointerOn) {
                _viewer.container.appendChild(_pointer);
                _pointerOn = true;
            }
            else if (!show && _pointerOn) {
                _viewer.container.removeChild(_pointer);
                _pointerOn = false;
            }

            if (show) {
                //Note the 4px is half the width/height specified in the CSS,
                //so that the pointer is centered.
                _pointer.style.left = (x-6) + "px";
                _pointer.style.top = (y-6) + "px";
            }

        }

        function onPointer(e) {

            if (_haveControl)
                return; //shouldn't get here in theory, but let's check just in case

            if (_isDisconnected)
                return; //we can't show the pointer if the views don't match

            var v = e.data.msg;
            _ray.origin.set(v[1], v[2], v[3]);
            _ray.direction.set(v[4], v[5], v[6]);

            var pt = _ray.at(_viewer.getCamera().near);
            pt.project(_viewer.getCamera());

            pt = _viewer.impl.viewportToClient(pt.x, pt.y);

            //console.log(pt.x + " " + pt.y);
            showPointer(true, pt.x, pt.y);
        }


        function sendPointer(evt) {
            if (!_haveControl)
                return;

            //Note canvasX/Y are set by the ToolController to clientX/Y - canvas left/top.
            var vpVec = _viewer.impl.clientToViewport(evt.canvasX, evt.canvasY);
            _viewer.impl.viewportToRay(vpVec, _ray);

            var rayParams = [ _ray.origin.x, _ray.origin.y, _ray.origin.z,
                              _ray.direction.x, _ray.direction.y, _ray.direction.z ];

            reduceBitsV(rayParams);
            rayParams.unshift(client.getLocalId());

            _client.sendMessage("pointer", rayParams, _this.channelId);
        }


        function sendViewerState(e) {
            //if (!_haveControl)
            //    return;
            if (_blockEvents)
                return;

            var state = _viewerState.getState(VIEWER_STATE_FILTER);

            // TODO: if we kill the socket.io code path, this could be optimized
            // too by removing the JSON.stringify of the state. Pubnub automatically
            // does JSON serialization for us, with optimizations accordingly to their manual.
            client.sendMessage("state", JSON.stringify(state), _this.channelId);
        }


        this.takeControl = function() {
            _haveControl = true;
            showPointer(false);
        };

        this.updatePointer = function(e) {
            sendPointer(e);
        };

        this.connectCamera = function(set) {
            _isDisconnected = !set;
        };

        this.attach = function(viewer) {

            if (_viewer)
                this.detach();

            this.viewer = _viewer = viewer;
            _viewerState = new avp.ViewerState(_viewer);

            _client.addEventListener("cameraChange", onCamera);
            _client.addEventListener("pointerMove", onPointer);
            _client.addEventListener("viewerState", onViewerState);


            if (!_viewer.hasEventListener(av.CAMERA_CHANGE_EVENT, sendCamera))
                _viewer.addEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

            if (!_viewer.hasEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState)) {
                _viewer.addEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.addEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.addEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.addEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.addEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.addEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
                _viewer.addEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);
            }
        };


        this.detach = function() {

            if (_client) {
                _client.removeEventListener("cameraChange", onCamera);
                _client.removeEventListener("viewerState", onViewerState);
            }

            if (_viewer) {
                _viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

                _viewer.removeEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.removeEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);

                this.viewer = _viewer = null;
                _viewerState = null;
            }
        };

    };

    avec.ViewTransceiver.prototype.constructor = avec.ViewTransceiver;
    Autodesk.Viewing.EventDispatcher.prototype.apply( avec.ViewTransceiver.prototype );



})();;AutodeskNamespace('Autodesk.Viewing.Extensions.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avu = av.UI,
        avec = ave.Collaboration;

    //==================================================================================
    //Extension interface

    /** @constructor */
    ave.Collaboration.Collaboration = function (viewer, options) {
        av.Extension.call(this, viewer, options);
        if (options && options.rtc && options.rtc.disableRTCToolbarButton) {
            this.disableRTCToolbarButton = true;
        }
    };

    ave.Collaboration.Collaboration.prototype = Object.create(av.Extension.prototype);
    ave.Collaboration.Collaboration.prototype.constructor = ave.Collaboration.Collaboration;


    ave.Collaboration.Collaboration.prototype.initNetwork = function(force) {

        if (this.p2p && !force)
            return;

        this.viewtx = new avec.ViewTransceiver(this.client);
        this.interceptor = new avec.InteractionInterceptor(this.viewtx);
        this.viewer.toolController.registerTool(this.interceptor);

        this.p2p = new avp.P2PClient(this.client);
    };

    ave.Collaboration.Collaboration.prototype.createUI = function() {

        var scope = this;
        var viewer = this.viewer;

        this.initNetwork(false);

        this.panel = new avec.DockingCollabPanel(this.viewer, this.client, this.p2p, this.viewtx);
        ave.Collaboration.Collaboration.Panel = this.panel;

        // Create a comment toolbar button.
        this.collabButton = new avu.Button('toolbar-collaborateTool');
        this.collabButton.setToolTip('Live review');
        this.collabButton.setIcon("adsk-icon-live-review");
        this.collabButton.onClick = function(e) {
            var isVisible = scope.panel.isVisible();

            // Prevent instantiating multiple 'enter your name' box by
            // spamming collab button.
            if (document.getElementById("collabBox")) {
                return;
            }

            if (!isVisible && !scope.inviteDivInstantiated) {
                var w = new avec.CollabPromptBox();
                var container = viewer.container;
                w.start(container, function () {
                    scope.panel.setVisible(true, true);
                }, "Start a Live Review", "Start Review");
            }
            else {
                scope.panel.setVisible(false, true);
                scope.panel.reset();
            }
        };
        if (this.disableRTCToolbarButton) {
            this.collabButton.setVisible(false,true);
        }

        this.panel.addVisibilityListener(function(state) {
            if (state) {

                if (viewer.model) {
                    var svf = viewer.model.getData();

                    scope.viewtx.channelId = svf.basePath;
                    scope.viewtx.attach(viewer);

                    scope.client.connect(scope.viewtx.channelId); //use the just the URN as load balancer session ID for now.
                    scope.client.join(scope.viewtx.channelId);
                }

                viewer.toolController.activateTool(scope.interceptor.getName());

                var getColumbusURL = function () {
                    var ret;
                    switch (window.location.hostname) {
                        case "columbus-dev.autodesk.com" :
                            ret = "http://columbus-dev.autodesk.com/collab.html?";
                            break;
                        case "columbus-staging.autodesk.com" :
                            ret = "http://columbus-staging.autodesk.com/collab-stg.html?";
                            break;
                        default:
                            ret = "http://columbus-dev.autodesk.com/collab.html?";
                    }

                    return ret + "document=urn:";
                };

                var generateSharedURL = function () {
                    var baseURL = getColumbusURL();
                    var urn = viewer.model.getData().urn;
                    var ret = baseURL + urn;
                    if (avp.comment2Token) {
                        ret += ("&comment2Token=" + encodeURIComponent(avp.comment2Token));
                    }
                    return ret;
                };

                /*
                window.prompt("Send this URL to people you want to share and collaborate on this file!",
                  generateSharedURL());
                */

                scope.collabButton.setState(avu.Button.State.ACTIVE);

                if (avp.logger)
                    avp.logger.log({category:"viewer_rtc_start"});
            }
            else {

                if (avp.logger && scope.client.isConnected())
                    avp.logger.log({category:"viewer_rtc_stop"});

                scope.p2p.hangup();
                scope.viewtx.detach(viewer);
                scope.viewtx.channelId = null;
                scope.client.disconnect();
                scope.panel.reset();
                viewer.toolController.deactivateTool(scope.interceptor.getName());

                scope.collabButton.setState(avu.Button.State.INACTIVE);
            }
        });

        viewer.modelTools.addControl(this.collabButton);

        if (Autodesk.Viewing.Private.getParameterByName("invited")) {
            var w = new CollabPromptBox();
            var container = viewer.container;
            w.start(container, function () {
                scope.panel.setVisible(true, true);
            }, "Join a Live Review", "Join Review");
        }
    };


    ave.Collaboration.Collaboration.prototype.close = function () {
        this.panel.setVisible(false, true);
        this.panel.reset();
    };

    ave.Collaboration.Collaboration.prototype.load = function () {
        var viewer = this.viewer;
        var scope = this;

        function init() {

            scope.client = avp.MessageClient.GetInstance(scope.options ? scope.options.messageServerURL : undefined);
            
            scope.socketErrorHandler = function(evt) {
                avp.ErrorHandler.reportError(viewer.container, Autodesk.Viewing.ErrorCodes.RTC_ERROR, evt.data);
                scope.close();
            };
            
            scope.client.addEventListener("socketError", scope.socketErrorHandler);

            scope.presenceChannelId = window.location.host;

            if (scope.client.isConnected()) {
                //If the client is already connected, we assume that a presence service
                //is already joined by the embedding application.
                /*
                scope.client.addEventListener("userListChange", function(e) {
                    if (e.data.user && e.channelId == scope.presenceChannelId)
                        console.log(e.data.user.name + " is online.");
                    else if (e.userStatus == "left")
                        console.log(e.data.user.name + " went offline.");
                });
                */
            }
            else {
                //Standalone configuration, where no embedding application exists
                //Used for testing.
                //Moved to launch of the collaboration panel so we can connect with session ID for load balancing
                //this.client.connect();
                //this.client.join(this.presenceChannelId);
            }

            // add the button to the toolbar
            if (viewer.modelTools) {
                scope.createUI();
            } else {
                viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            }

            function onToolbarCreated(e) {
                viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
                scope.createUI();
            }
        }

        //Load the socket.io library if needed
        avp.loadDependency("lmv_io", "socket.io-1.3.5.js", init);

        return true;
    };

    ave.Collaboration.Collaboration.prototype.unload = function () {

        var viewer = this.viewer;
        
        this.client.removeEventListener("socketError", this.socketErrorHandler);
        this.socketErrorHandler = null;
        
        this.p2p.hangup();
        this.viewtx.detach(viewer);
        this.client.disconnect();

        if (this.panel) {
            this.panel.reset();
            this.panel.setVisible(false);
            this.panel.uninitialize();
            this.panel = null;
        }

        viewer.toolController.deactivateTool(this.interceptor.getName());
        this.interceptor = null;

        viewer.modelTools.removeControl(this.collabButton.getId());
        this.collabButton = null;

        return true;
    };

    av.theExtensionManager.registerExtension('Autodesk.Viewing.Collaboration', ave.Collaboration.Collaboration);

})(); // closure;AutodeskNamespace('Autodesk.Viewing.Extensions.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avu = av.UI,
        avec = ave.Collaboration;

    /**
     *  Start a Live Review Session.
     */
    Autodesk.Viewing.startLiveReviewSession = function () {
        if (!avec.Panel) return;
        avec.Panel.startSession();
    };

    /**
     *  End a Live Review Session.
     */
    Autodesk.Viewing.endLiveReviewSession = function () {
        if (!avec.Panel) return;
        avec.Panel.endSession();
    };

    var USE_PRESENCE = true;

    //==================================================================================

    function DockingCollabPanel(viewer, client, p2p, viewtx) {

        this.viewer = viewer;
        this.client = client;
        this.p2p = p2p;
        this.viewtx = viewtx;

        var panelId = 'CollabPanel';
        av.UI.DockingPanel.call(this, viewer.container, panelId, 'Live review');

        this.container.classList.add('collabPanel');

        this.container.style.height = "auto";
        this.container.dockRight = true;

        this.content = document.createElement("div");
        this.container.appendChild(this.content);
        this.content.classList.add("collabPanelContent");

		//Users list
		this.tableContainer = document.createElement("div");
		this.tableContainer.classList.add("userListTable", "dockingPanelScroll");

        this.table = document.createElement("table");
        this.table.classList.add("tftable");
        this.tbody = document.createElement("tbody");
        this.table.appendChild(this.tbody);

		this.tableContainer.appendChild(this.table);
        this.content.appendChild(this.tableContainer);

        // Invite button
        this.inviteDiv = document.createElement('div');
        this.inviteDiv.className = 'collabBoxOK';
        this.inviteDiv.style.float = 'left';
        this.inviteDiv.style.width = '232px';
        this.inviteDiv.setAttribute("data-i18n", "Invite");
        this.inviteDiv.textContent = Autodesk.Viewing.i18n.translate("Invite");
        this.content.appendChild(this.inviteDiv);
        this.inviteDiv.addEventListener("click", function(event) {
            var w = new CollabPromptBox();
            var container = viewer.container;
            w.start(container, function () {
                var subject = Autodesk.Viewing.i18n.translate("Please Join My Live Review");
                document.location.href = "mailto:?subject=" + subject;
            }, "Invite Others", "Email Invite", true);
        });

		//Chat history
        this.chatHistory = document.createElement("div");
        this.chatHistory.classList.add("chatHistory");
        this.chatHistory.classList.add("textEntry");
		this.chatHistory.classList.add("dockingPanelScroll");
        this.content.appendChild(this.chatHistory);


		//Text input entry
        this.chatPanel = document.createElement("div");
        this.chatPanel.classList.add("chatPanel");

        this.textInput = document.createElement("input");
        this.textInput.type = "text";
        this.textInput.classList.add("textEntry");
        this.textInput.placeholder = Autodesk.Viewing.i18n.translate("Type a message");
        this.chatPanel.appendChild(this.textInput);

        this.content.appendChild(this.chatPanel);

        this.isCameraConnected = true;

        var scope = this;

        this.addEventListener(client, "userListChange", function(e) {

            //Collab panel only cares about events on the collaboration channel
            if (e.channelId && e.channelId !== scope.viewtx.channelId)
                return;

            var ci = scope.client.getChannelInfo(scope.viewtx.channelId);
            if (!ci)
                return;

            scope.updateUsers(ci.users);
        });

        this.addEventListener(this.viewtx, "controlChange", function(e) {

            //Collab panel only cares about events on the collaboration channel
            if (e.channelId !== scope.viewtx.channelId)
                return;

            scope.updateUserInControl(e.data.lastInControl);
        });

        this.addEventListener(client, "chatReceived", function(e) {

            //Collab panel only cares about events on the collaboration channel
            if (e.channelId !== scope.viewtx.channelId)
                return;

            scope.updateChatHistory(e);
        });

        this.textInput.onkeyup = function(e) {
            scope.handleChatInput(e);
        };

        this.addEventListener(this.p2p, "remoteStreamAdded", function(e) {
            if (!scope.videoPanel)
                scope.createVideoPanel();

            scope.remoteVideo.src = window.URL.createObjectURL(e.data);
        });

        this.addEventListener(this.p2p, "localStreamAdded", function(e) {
            if (!scope.videoPanel)
                scope.createVideoPanel();

            scope.localVideo.src = window.URL.createObjectURL(e.data);
        });

        this.addEventListener(this.p2p, "remoteHangup", function(e) {
            scope.removeVideoPanel();
        });
    }

    DockingCollabPanel.prototype = Object.create(av.UI.DockingPanel.prototype);
    DockingCollabPanel.prototype.constructor = DockingCollabPanel;

    DockingCollabPanel.prototype.startSession = function () {
        var scope = this;
        var isVisible = this.isVisible();
        if (isVisible) return;
        var w = new CollabPromptBox();
        var container = this.viewer.container;
        w.start(container, function () {
            scope.setVisible(true, true);
        }, "Start a Live Review", "Start Review");
    };

    DockingCollabPanel.prototype.endSession = function () {
        var isVisible = this.isVisible();
        if (!isVisible) return;
        this.setVisible(false, true);
        this.reset();
    };

    DockingCollabPanel.prototype.updateUsers = function(users) {

        var scope = this;

        var tbody = document.createElement("tbody");

        for (var i=0; i<users.length; i++) {
            var row = tbody.insertRow(-1);
            row.id = users[i].id;

            var statusCell = row.insertCell(0);
            statusCell.style.width = "14px";
            statusCell.style.cursor = "default";
            var statusIcon = document.createElement("div");
            statusIcon.classList.add("statusBase");
            statusIcon.classList.add("statusNormal");
            statusIcon.innerHTML = "&#9679";
            statusCell.appendChild(statusIcon);

            var nameCell = row.insertCell(1);
            nameCell.textContent = users[i].name;

            //Video calling disabled.
            /*
            if (!users[i].isSelf) {
                var callCell = row.insertCell(2);
                callCell.classList.add("callButton");
                callCell.innerHTML = "&#9742";
                callCell.title = "Start audio/video call";

                callCell.onclick = function(e) {
                    var targetId = e.target.parentNode.id;

                    if (scope.p2p.getCurrentCallTarget() == targetId)
                        return;

                    if (scope.videoPanel) {
                        scope.p2p.hangup();
                        scope.removeVideoPanel();
                    }

                    scope.createVideoPanel();
                    scope.p2p.callUser(targetId);
                };
            } else {
                var callCell = row.insertCell(2);
                callCell.classList.add(scope.isCameraConnected ? "cameraButton" : "cameraDisconnectButton");
                callCell.innerHTML = "&#9788";
                callCell.title = "Connect/Disconnect Camera";

                callCell.onclick = function(e) {
                    var targetParent = e.target.parentNode;
                    var targetClassList = e.target.classList;

                    if (scope.isCameraConnected) {
                        targetClassList.remove("cameraButton");
                        targetClassList.add("cameraDisconnectButton");
                    } else {
                        targetClassList.remove("cameraDisconnectButton");
                        targetClassList.add("cameraButton");
                    }

                    scope.isCameraConnected = !scope.isCameraConnected;
                    scope.viewtx.connectCamera(scope.isCameraConnected);
                };
            }
            */
        }

        this.table.replaceChild(tbody, this.tbody);
        this.tbody = tbody;

        this.fixComponentPlacement();
    };

    DockingCollabPanel.prototype.updateUserInControl = function(id) {
        for (var i=0; i<this.tbody.rows.length; i++) {
            var r = this.tbody.rows[i];
            var icon = r.cells[0].childNodes[0];
            if (r.id == id) {
                icon.classList.remove("statusNormal");
                icon.classList.add("statusInControl");
                icon.innerHTML = "&#9784";
                r.cells[1].style.color = "#4CBA36";
            } else {
                icon.classList.remove("statusInControl");
                icon.classList.add("statusNormal");
                icon.innerHTML = "&#9679";
                r.cells[1].style.color = "#ffffff";
            }

        }
    };

    DockingCollabPanel.prototype.updateChatHistory = function(e) {

        var user = this.client.getUserById(e.data.from, e.channelId);

		//skip command strings
		if (e.data.msg.charAt(0) == "/")
			return;

//        var line = user.name + ": " + e.data.msg;

        if (this.chatHistory.lastUser != user.name) {

            var pEl = document.createElement("p");

            var nameEl = document.createElement("div");
            nameEl.classList.add("heading");
            nameEl.style.float = "left";
            nameEl.style.fontStyle = "normal";
            nameEl.style.color = "#857E7E";
            nameEl.textContent = user.name;
            pEl.appendChild(nameEl);

            var timeEl = document.createElement("div");
            timeEl.classList.add("heading");
            timeEl.style.textAlign = "right";
            timeEl.style.fontStyle = "normal";
            timeEl.style.color = "#857E7E";
            timeEl.textContent = new Date().toLocaleTimeString();
            pEl.appendChild(timeEl);

            this.chatHistory.appendChild(pEl);

            this.chatHistory.lastUser = user.name;
        } else {
            var br = document.createElement("br");
            this.chatHistory.appendChild(br);
        }

        var msgEl = document.createElement("span");
        msgEl.classList.add("messageText");
        msgEl.textContent = e.data.msg;
        this.chatHistory.appendChild(msgEl);

        this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
    };

    DockingCollabPanel.prototype.handleChatInput = function(e) {
        if (e.which != 13)
            return;
        if (this.textInput.value.length == 0)
            return;

        this.client.sendChatMessage(this.textInput.value, this.viewtx.channelId);
        this.textInput.value = "";
        this.textInput.placeholder = "";
    };

    DockingCollabPanel.prototype.fixComponentPlacement = function(e) {

        var heightAdj = this.tableContainer.offsetHeight + this.chatPanel.offsetHeight;

        if (this.videoPanel) {
            heightAdj += this.videoPanel.offsetHeight;
            this.chatHistory.style.height = "calc(100% - " + heightAdj + "px)";
        }
        else {
            this.chatHistory.style.height = "calc(100% - " + heightAdj + "px)";
        }

    };

    DockingCollabPanel.prototype.createVideoPanel = function(e) {
        this.videoPanel = document.createElement("div");
        this.videoPanel.classList.add("videoPanel");

        this.localVideo = document.createElement("video");
        this.localVideo.autoplay = true;
        this.localVideo.muted = true;
        this.localVideo.classList.add("videoInset");
        this.videoPanel.appendChild(this.localVideo);

        this.remoteVideo = document.createElement("video");
        this.remoteVideo.autoplay = true;
        this.remoteVideo.classList.add("videoMain");
        this.videoPanel.appendChild(this.remoteVideo);

        var scope = this;
        var closer = document.createElement("div");
        closer.classList.add("dockingPanelClose");
        closer.innerHTML="&times";
        closer.title = Autodesk.Viewing.i18n.translate("End video call");
        closer.onclick = function(e) {
            scope.p2p.hangup();
            scope.removeVideoPanel();
        };
        this.videoPanel.appendChild(closer);

        this.content.insertBefore(this.videoPanel, this.chatHistory);

        this.fixComponentPlacement();
    };

    DockingCollabPanel.prototype.removeCollabPrompt = function () {
        var box = document.getElementById("collabBox")
        if (box) {
            box.style.visibility = "hidden";
            this.viewer.container.removeChild(box);
        }
    };

    DockingCollabPanel.prototype.removeVideoPanel = function() {
        if (this.videoPanel)
            this.content.removeChild(this.videoPanel);
        this.videoPanel = null;
    };

    DockingCollabPanel.prototype.reset = function(e) {
        if (this.tbody) {
            var empty = document.createElement("tbody");
            this.table.replaceChild(empty, this.tbody);
            this.tbody = empty;
        }
        this.chatHistory.textContent = "";
        this.textInput.value = "";
        this.removeVideoPanel();
        this.removeCollabPrompt();
    };


    CollabPromptBox = function() {};
    CollabPromptBox.prototype.start = function (container, cb, titleText, buttonText, isInviteWindow) {
        if (!container) return;

        // Prevent multiple instantiations of invite boxes by spamming the 'Invite' button in collab panel.
        if (document.getElementById("collabBox")) {
            return;
        }

        var box = document.createElement("div");
        // If you change this id, make sure this.collabButton.onClick also updated to reflect new id.
        box.id = "collabBox";
        box.className = "collabBox";
        container.appendChild(box);

        var title = document.createElement("div");
        title.className = "collabBoxTitle";
        title.textContent = Autodesk.Viewing.i18n.translate(
            titleText,
            { "defaultValue" : titleText } );
        box.appendChild(title);

        var text = document.createElement("span");
        text.className = "collabBoxText";
        var label = "Enter your name";
        if (isInviteWindow) {
            label = "Review URL";
        }
        text.textContent = Autodesk.Viewing.i18n.translate(
            label,
            { "defaultValue" : label} );
        box.appendChild(text);

        var inputContainer = document.createElement("span");
        inputContainer.className = "collabBoxInputContainer";
        box.appendChild(inputContainer);
        var input = document.createElement("input");
        input.type = "text";
        input.className = "collabBoxInputText";
        if (isInviteWindow) {
            var url = window.location.toString();
            if (url.indexOf("?") == -1) {
                url += "?invited=true";
            } else {
                url += "&invited=true";
            }
            if (Autodesk.Viewing.Private.docItemId) {
                url += "&itemid=" + Autodesk.Viewing.Private.docItemId;
            }

            //Prevent Helios forwarding to Mobile app when the link is for RTC session (no RTC on Mobile)
            url += "&doNotRedirect=true";

            input.value = url;
        }
        inputContainer.appendChild(input);

        input.onkeyup = function(e) {
            if (e.keyCode == 13) {
                box.style.visibility = "hidden";
                container.removeChild(box);
                avp.setUserName(input.value);
                cb();
            }
        };

        var close = document.createElement("div");
        close.className = "collabBoxClose";
        close.innerHTML = "&times;";
        close.addEventListener("click", function(event) {
            box.style.visibility = "hidden";
            container.removeChild(box);
        });
        box.appendChild(close);

        if (isInviteWindow) {
            /*
            var copy = document.createElement("div");
            copy.className = "collabBoxCopy";
            copy.textContent = Autodesk.Viewing.i18n.translate( "Copy", { "defaultValue" : "Copy" } );
            copy.addEventListener("click", function(event) {

            });
            box.appendChild(copy);
            */
            var text = document.createElement("span");
            text.className = "collabBoxText";
            text.style.marginTop = "0px";
            var label = "Copy and send this URL to invite others";

            text.textContent = Autodesk.Viewing.i18n.translate(
                label,
                { "defaultValue" : label} );
            box.appendChild(text);
        }  else {
            var ok = document.createElement("div");
            ok.className = "collabBoxOK";
            ok.textContent = Autodesk.Viewing.i18n.translate( buttonText, { "defaultValue" : buttonText } );

            ok.addEventListener("click", function(event) {
                box.style.visibility = "hidden";
                container.removeChild(box);
                if (input.value.trim() !== "") {
                    avp.setUserName(input.value);
                }
                cb();
            });
            box.appendChild(ok);
        }
        box.style.visibility = "visible";

        input.focus();
        if (isInviteWindow)
            input.select();
    };

    avec.DockingCollabPanel = DockingCollabPanel;
    avec.CollabPromptBox = CollabPromptBox;


})();;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Beeline');

Autodesk.Viewing.Extensions.Beeline.BeelineExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.constructor = Autodesk.Viewing.Extensions.Beeline.BeelineExtension;

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;
    var AVU = Autodesk.Viewing.UI;

    // Register tool
    this.tool = new Autodesk.Viewing.Extensions.Beeline.BeelineTool(viewer.impl, viewer);
    viewer.toolController.registerTool(this.tool);

    // Add UI
    // Add beeline button
    this.createUI();

    // Add hotkey
    var previousTool;
    function onPress() {
        previousTool = viewer.getActiveNavigationTool();
        viewer.setActiveNavigationTool(self.tool.getName());
        return true;
    }
    function onRelease() {
        viewer.setActiveNavigationTool(previousTool ? previousTool : viewer.defaultNavigationToolName);
        return true;
    }
    this.HOTKEYS_ID = "Autodesk.Beeline.Hotkeys";
    var hotkeys = [
        {
            keycodes: [
                Autodesk.Viewing.theHotkeyManager.KEYCODES.CONTROL,
                Autodesk.Viewing.theHotkeyManager.KEYCODES.ALT
            ],
            onPress: onPress,
            onRelease: onRelease
        }
    ];
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.HOTKEYS_ID, hotkeys);

    // Register listeners
    this.onToolChanged = function (e) {
        if (e.toolName.indexOf('beeline') === -1) {
            return;
        }

        if (self.beelineButton) {
            var state = e.active ? AVU.Button.State.ACTIVE : AVU.Button.State.INACTIVE;
            self.beelineButton.setState(state);
        }
    };

    viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);

    return true;
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.createUI = function()
{
    var viewer = this.viewer;
    if (!viewer.getToolbar || !viewer.getSettingsPanel) return; // Add support for Viewer3D instance

    var toolbar = viewer.getToolbar(true);

    var AVU = Autodesk.Viewing.UI;
    var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);

    var beelineButtonId = "toolbar-beelineTool";

    /*var options = {
        defaultTooltipValue: "Walk to (double-click to Walk through)"
    };*/
    var beelineButton = new AVU.Button(beelineButtonId);
    beelineButton.setToolTip('Walk to');
    beelineButton.setIcon("adsk-icon-walk");
    beelineButton.onClick = function(e) {
        var state = beelineButton.getState();
        if (state === AVU.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool("beeline");
        } else if (state === AVU.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    };
    this.beelineButton = beelineButton;

    var cameraSubmenuTool = navTools.getControl('toolbar-cameraSubmenuTool');
    if (cameraSubmenuTool) {
        navTools.addControl(this.beelineButton, {index: navTools.indexOf(cameraSubmenuTool.getId())});
    } else {
        navTools.addControl(this.beelineButton);
    }

    // Add beeline settings to the viewer's setting panel.
    var that = this;
    var addViewerUIOptions = function() {
        viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, addViewerUIOptions);

        var navTab = Autodesk.Viewing.Extensions.ViewerSettingTab.Navigation;
        var viewerOptions = viewer.getSettingsPanel(true);
        that.viewerOption_LookHorId = viewerOptions.addCheckbox(navTab, "Reverse horizontal look direction", false, function(checked) {
            viewer.setReverseHorizontalLookDirection(checked);
        }, "reverseHorizontalLookDirection");

        that.viewerOption_LookVertId = viewerOptions.addCheckbox(navTab, "Reverse vertical look direction", false, function(checked) {
            viewer.setReverseVerticalLookDirection(checked);
        }, "reverseVerticalLookDirection");

    };

    if (this.viewer.getSettingsPanel(false)) {
        addViewerUIOptions();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, addViewerUIOptions);
    }
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Remove listeners
    viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = undefined;

    // Remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    // Remove the UI
    if (this.beelineButton) {
        // Button is created only if toolbar API is available
        var toolbar = viewer.getToolbar(false);
        if (toolbar) {
            toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.beelineButton.getId());
        }
        this.beelineButton = null;
    }

    // Remove the options from the Viewer SettingsPanel.
    if (viewer.getSettingsPanel) {
        viewer.getSettingsPanel(false).removeCheckbox(this.viewerOption_LookHorId);
        viewer.getSettingsPanel(false).removeCheckbox(this.viewerOption_LookVertId);
    }

    //Uh, why does the viewer need to keep track of this in addition to the tool stack?
    if (viewer.getActiveNavigationTool() == this.tool.getName())
        viewer.setActiveNavigationTool();

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Beeline', Autodesk.Viewing.Extensions.Beeline.BeelineExtension);;AutodeskNamespace('Autodesk.Viewing.Extensions.Beeline');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.Extensions.Beeline.BeelineTool = function( viewerImpl, viewerApi )
{
    var MODE = {
        GO_TO: 0,
        PASS_THROUGH: 1,
        DEFAULT: 0
    };

    // Constants
    var kDefaultFlightDuration = 1000; // milliseconds
    var kLookSensitivity = 0.8;
    var kMaxFocalLength = 28;
    var kDampingFactor = 0.7;

    // States
    var kStartState = 0;
    var kFlightState = 1;

    var self = this;
    var _viewerapi = viewerApi;
    var _container = viewerApi.container;
    var _autocam = viewerApi.autocam;
    var _navapi = viewerApi.navigation;
    var _viewerUtilities = viewerApi.utilities;
    var _names = ["beeline"];

    var _state = kStartState;
    var _isDragging = false;
    var _mouseButtons = 0;
    var _flightStartTime = null;
    var _flightDuration = null;
    var _intersectPointNear = new THREE.Vector3();
    var _intersectPointFar = new THREE.Vector3();
    var _flightStartPosition = new THREE.Vector3();
    var _flightEndPosition = new THREE.Vector3();
    var _haltAnimation = false;
    var _mouseXY = new THREE.Vector3();
    var _previousXY = new THREE.Vector3();

    var _expectedCameraState = null;
    var _touchType = null;

    function screenModeChanged()
    {
        self.revertToStartState();
    }

    // Utility methods
    function getCameraState(camera) {
        var state = {};

        state.target  = camera.target.clone();
        state.worldup = camera.worldup.clone();

        state.position = camera.position.clone();
        state.up = camera.up.clone();

        var props = ['isPerspective', 'fov', 'zoom', 'aspect', 'left', 'right', 'top', 'bottom'];
        for (var i = 0; i < props.length; i++) {
            state[props[i]] = camera[props[i]];
        }

        return state;
    }

    function compareCameraToState(camera, state) {
        var result = camera.target.equals(state.target) &&
            camera.position.equals(state.position) &&
            camera.worldup.equals(state.worldup) &&
            camera.up.equals(state.up);

        if (!result) {
            return false;
        }

        var props = ['isPerspective', 'fov', 'zoom', 'aspect', 'left', 'right', 'top', 'bottom'];
        for (var i = 0; i < props.length; i++) {
            if (camera[props[i]] !== state[props[i]]) {
                return false;
            }
        }

        return true;
    }

    function getIntersectionPoints(normalizedScreenPosition) {
        var viewportVec = new THREE.Vector3(normalizedScreenPosition.x, normalizedScreenPosition.y, 1.0);
        var result = viewerImpl.hitTestViewport(viewportVec.clone(), false);

        if (!result || !result.intersectPoint) {
            return [];
        }

        var caster = new THREE.Raycaster();
        var vector = viewportVec.clone();
        var camera = viewerImpl.camera;
        var end = new THREE.Vector3( vector.x, vector.y, 1.0 );

        vector.z = -1.0;
        vector = vector.unproject( camera );
        end = end.unproject( camera );
        end.sub(vector).normalize();
        caster.set(_navapi.isPerspective ? camera.position : vector, end);

        var intersects = [];

        // Get intersection points
        var frags = result.fragId instanceof Array ? result.fragId : [result.fragId];
        for (var i = 0; i < frags.length; i++) {
            var mesh = viewerImpl.getRenderProxy(viewerApi.model, frags[i]);

            VBIntersector.meshRayCast(mesh, caster, intersects);
        }

        intersects.sort(function(a,b) { return a.distance - b.distance;});

        return intersects;
    }

    function prepareCamera() {
        if (!_navapi.isPerspective) {
            _navapi.toPerspective();
            _viewerUtilities.activatePivot(false);
        }
        if (_navapi.getFocalLength() > kMaxFocalLength) {
            _navapi.setFocalLength(kMaxFocalLength, true);
        }
    }

    // Tool methdos
    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(toolName)
    {
        _mouseButtons = 0;
        viewerApi.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, screenModeChanged);
        _autocam.userLookSpeed = kLookSensitivity;
        this.showHUDMessage(true);
    };

    this.deactivate = function()
    {
        viewerApi.removeEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, screenModeChanged);
        this.revertToStartState();
        this.showHUDMessage(false);
    };

    this.getCursor = function()
    {
        if (_isDragging) {
            return "url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAQAAADYBBcfAAAACXBIWXMAABYlAAAWJQFJUiTwAAADGGlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjaY2BgnuDo4uTKJMDAUFBUUuQe5BgZERmlwH6egY2BmYGBgYGBITG5uMAxIMCHgYGBIS8/L5UBFTAyMHy7xsDIwMDAcFnX0cXJlYE0wJpcUFTCwMBwgIGBwSgltTiZgYHhCwMDQ3p5SUEJAwNjDAMDg0hSdkEJAwNjAQMDg0h2SJAzAwNjCwMDE09JakUJAwMDg3N+QWVRZnpGiYKhpaWlgmNKflKqQnBlcUlqbrGCZ15yflFBflFiSWoKAwMD1A4GBgYGXpf8EgX3xMw8BSMDVQYqg4jIKAUICxE+CDEESC4tKoMHJQODAIMCgwGDA0MAQyJDPcMChqMMbxjFGV0YSxlXMN5jEmMKYprAdIFZmDmSeSHzGxZLlg6WW6x6rK2s99gs2aaxfWMPZ9/NocTRxfGFM5HzApcj1xZuTe4FPFI8U3mFeCfxCfNN45fhXyygI7BD0FXwilCq0A/hXhEVkb2i4aJfxCaJG4lfkaiQlJM8JpUvLS19QqZMVl32llyfvIv8H4WtioVKekpvldeqFKiaqP5UO6jepRGqqaT5QeuA9iSdVF0rPUG9V/pHDBYY1hrFGNuayJsym740u2C+02KJ5QSrOutcmzjbQDtXe2sHY0cdJzVnJRcFV3k3BXdlD3VPXS8Tbxsfd99gvwT//ID6wIlBS4N3hVwMfRnOFCEXaRUVEV0RMzN2T9yDBLZE3aSw5IaUNak30zkyLDIzs+ZmX8xlz7PPryjYVPiuWLskq3RV2ZsK/cqSql01jLVedVPrHzbqNdU0n22VaytsP9op3VXUfbpXta+x/+5Em0mzJ/+dGj/t8AyNmf2zvs9JmHt6vvmCpYtEFrcu+bYsc/m9lSGrTq9xWbtvveWGbZtMNm/ZarJt+w6rnft3u+45uy9s/4ODOYd+Hmk/Jn58xUnrU+fOJJ/9dX7SRe1LR68kXv13fc5Nm1t379TfU75/4mHeY7En+59lvhB5efB1/lv5dxc+NH0y/fzq64Lv4T8Ffp360/rP8f9/AA0ADzT6lvFdAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAEtSURBVHja7JQxTkJBFEXPQ/xQEDG0ljRYSU1iLN2AtSWlC7Gw04QtGF2ApQVLIDY2hlgIDagJwWCOhf74JXxRYumbaib3ZO7c9zIhq1WBfzAfjJViDWPdYBq/w0pKITjhd7eGJwQkDu2I8rOFHYcmkqgDz4wfoeGZA01BHXtsbSla89ixZsH3an2LtpRUOQde28xFm17PgyPvVK1bl5yYEOtuq3rnyMQCXNJgiiTchuHCnhrGbYBMaXAJULGqlJz54O43bcFdH5xZUqpWJJWW7duza/tDmTWJbbv27Fs2PS2m1iZRNeGcI/aAEevOgCKnbAI7DNjjhUmk1ouf7xgHbLgF3MSzT7wCaxxSiW3hnsf4OngLotj3ILO74CoWTWzOIGcTXab4/6z+CnwbAGjXSZC++vLvAAAAAElFTkSuQmCC), auto";
        } else if (_mouseButtons <= 1) {
            return "url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAQdJREFUeNq0k0GOgzAMRZ+jHI4VO4410qzam0aCjbsoaS1PUgfoWIqAEPnZ3z8AN0DNWoFfVeUbC0BtrOtaISNhC3tvGkC2P7ZtY1kWgHul90JEtCYTkVqo7O844LPyeZ51RJ5atQ3biZeolFJ0miYd1d4nd5A/gB+g7E++AFB7VqzWIkKkfdW/d27P8RpE4p8jRy7Z9ZBOpSEgRRb0MAv0lmxZNEXJj0IACTvwrfeksJBW9a0Z6NEh+vl4UI6qHzHBJ4nyFQv6YoaG3Ls80X7vTIqS1W+vdWvArfuSG/pplPzTBRy6ybaLkSSHAFcThoCe/c6C81n7jUY6a78rHQigftBnQY8BAEubfpuApyq2AAAAAElFTkSuQmCC), auto";
        }

        return null;
    };

    this.update = function () {
        var camera = _navapi.getCamera();
        _isDragging = false;

        var moved = false;
        if (_mouseButtons === 1) {
            var deltaXY = _mouseXY.clone().sub(_previousXY);
            if (deltaXY.x !== 0 || deltaXY.y !== 0) {
                _isDragging = true;
                _previousXY.x += deltaXY.x * kDampingFactor;
                _previousXY.y += deltaXY.y * kDampingFactor;
                
                var worldDotCamera = _navapi.getWorldUpVector().dot(_navapi.getCameraUpVector());
                var horDirection = viewerApi.prefs.reverseHorizontalLookDirection ? -1 : 1;
                var vertDirection = viewerApi.prefs.reverseVerticalLookDirection ? -1 : 1;

                deltaXY.x *= worldDotCamera < 0 ? -horDirection : horDirection;
                deltaXY.y *= vertDirection;

                // Make sure we're synced with the camera
                _autocam.sync(_navapi.getCamera());
                _autocam.look(deltaXY);
                moved = true;

                _expectedCameraState = getCameraState(camera);
            }
        }
        return moved;
    };

    // Beeline methods
    this.revertToStartState = function()
    {
        _viewerUtilities.pivotActive(false);
        _state = kStartState;
        _haltAnimation = true;
    };

    this.attemptFlight = function(normalizedScreenPosition, mode)
    {
        if (!_navapi.isActionEnabled('walk')) {
            return;
        }

        var intersectionPoints = getIntersectionPoints(normalizedScreenPosition);

        if (intersectionPoints.length > 0) {
            _intersectPointNear = intersectionPoints[0].point;
            _intersectPointFar = intersectionPoints[intersectionPoints.length - 1].point;
            self.fly(kDefaultFlightDuration, mode);
        }
    };

    this.fly = function(duration, mode)
    {
        // Pivot needs to be set before altering focal length to make it less jarring for the user. Changing the focal
        // length alters the camera's position and we need the camera's position to calculate the far pivot. Instead,
        // use approximation of where the far pivot will be (i.e. _intersectPointFar).
        _viewerUtilities.setPivotPoint(mode === MODE.GO_TO ? _intersectPointNear : _intersectPointFar, true, true);
        prepareCamera();

        _flightStartPosition = _navapi.getPosition();
        _flightDuration = duration;
        switch (mode) {
            case MODE.GO_TO:
                // Fly 80% of the way there
                _flightEndPosition = _flightStartPosition.clone().lerp(_intersectPointNear, 0.8);
                break;

            case MODE.PASS_THROUGH:
                // Fly 2 near planes past the object.
                var near = _autocam.camera.near * 2;
                var distance = _intersectPointFar.clone().sub(_flightStartPosition).length();
                var nearRatio = near / distance;

                _viewerUtilities.setPivotPoint(_flightStartPosition.clone().lerp(_intersectPointFar, 1 + 10 * nearRatio), true, true);
                _flightEndPosition = _flightStartPosition.clone().lerp(_intersectPointFar, 1 + nearRatio);
                break;

            default:
                return;
        }

        _state = kFlightState;

        _haltAnimation = false;
        _flightStartTime = null;

        requestAnimationFrame(self.step);
    };

    // Animating the camera
    this.step = function(timestamp)
    {
        var camera = _navapi.getCamera();

        if (_haltAnimation) {
            return;
        }

        if (_flightStartTime === null) {
            _expectedCameraState = getCameraState(camera);

            _flightStartTime = timestamp;
        } else if (!compareCameraToState(camera, _expectedCameraState)) {
            self.revertToStartState();
            return;
        }

        var flightTime = timestamp - _flightStartTime;
        var t = flightTime < _flightDuration ? flightTime / _flightDuration : 1;

        var newPosition = _flightStartPosition.clone().lerp(_flightEndPosition, t);

        // Keep target the same distance as the pivot
        var viewVec = _navapi.getEyeVector();
        viewVec.multiplyScalar(_navapi.getPivotPoint().sub(_navapi.getPosition()).length() / viewVec.length());

        _navapi.setView(newPosition, viewVec.add(newPosition));

        _expectedCameraState = getCameraState(camera);

        _viewerUtilities.activatePivot(false);

        if (flightTime < _flightDuration) {
            requestAnimationFrame(self.step);
        } else {
            self.revertToStartState();
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this.handleGesture = function( event )
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();

        switch( event.type )
        {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                if( _touchType === "drag" )
                {
                    this.handleButtonUp(event, 0);
                    _touchType = null;
                    return true;
                }
                return false;
        }
        return false;
    };


    this.handleButtonDown = function( event, button )
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();

        _mouseButtons += 1 << button;

        if (button === 0) {
            _previousXY.x = _mouseXY.x = event.canvasX;
            _previousXY.y = _mouseXY.y = event.canvasY;
            return true;
        }
        return false;
    };

    this.handleButtonUp = function( event, button )
    {
        _mouseButtons -= 1 << button;

        if (button === 0) {
            return true;
        }
        return false;
    };

    this.handleSingleClick = function( event, button )
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();

        // Anything besides LMB should revert viewer to initial state
        if (button === 0) {
            var normalizedScreenLocation = {
                x: event.normalizedX,
                y: event.normalizedY
            };

            switch (_state) {
                case kStartState:
                    self.attemptFlight(normalizedScreenLocation, MODE.GO_TO);
                    break;

                case kFlightState:
                    self.revertToStartState();
                    break;

                default:
                    break;
            }
        } else {
            this.revertToStartState();
            return false;
        }

        return true;
    };

    this.handleSingleTap = function( event )
    {
        return this.handleSingleClick(event, 0);
    };

    this.handleDoubleTap = function( event )
    {
        if( event.pointers && event.pointers.length === 1 ) {
            self.attemptFlight({x: event.normalizedX, y: event.normalizedY}, MODE.PASS_THROUGH);
            return true;
        }
        return false;
    };

    this.handleDoubleClick = function( event, button )
    {
        if (button === 0) {
            self.attemptFlight({x: event.normalizedX, y: event.normalizedY}, MODE.PASS_THROUGH);
            return true;
        }

        return false;
    };

    this.handleMouseMove = function( event )
    {
        _mouseXY.x = event.canvasX;
        _mouseXY.y = event.canvasY;

        if (_mouseButtons === 1) {
            prepareCamera();
            return true;
        }

        return false;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.revertToStartState();
        return false;
    };

    this.showOrthoWarningMessage = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "Orthographic View Set",
            "messageKey"    : "The view is set to Orthographic Beeline",
            "messageDefaultValue"  : "The view is set to Orthographic. Using this tool will switch to Perspective."
        };
        var closeCallback = function() {}; // dummy callback function so that the 'X' is shown
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCallback);
    };

    this.showFocalWarningMessage = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "Long Focal Length View Set",
            "messageKey"    : "The view is set to a long focal length",
            "messageDefaultValue"  : "This view has a long focal length. Using this tool will set a short focal length."
        };
        var closeCallback = function() {}; // dummy callback function so that the 'X' is shown
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCallback);
    };

    this.watchCamera = function(e)
    {
        // If camera changed to ORTHO and we are still in Beeline mode
        // put up the warning message that the system will switch to perspective.
        // Similarly, warn for long focal length.
        if (_viewerapi.toolController.getActiveToolName() === _names[0] ||
            _viewerapi.toolController.getActiveToolName() === _names[1]) {
            var camera = _navapi.getCamera();
            var isOrtho = camera && !camera.isPerspective;
            var hasLongFocalLength = _navapi.getFocalLength() > kMaxFocalLength;

            if (isOrtho)
                self.showOrthoWarningMessage();
            else if (hasLongFocalLength)
                self.showFocalWarningMessage();
            else
                Autodesk.Viewing.Private.HudMessage.dismiss();
        }
    };

    this.showHUDMessage = function(state)
    {
        var camera = _navapi.getCamera();
        var isOrtho = camera && !camera.isPerspective;
        var hasLongFocalLength = _navapi.getFocalLength() > kMaxFocalLength;

        if (state && isOrtho) {
            self.showOrthoWarningMessage();
        } else if (state && hasLongFocalLength) {
            self.showFocalWarningMessage();
        } else {
            Autodesk.Viewing.Private.HudMessage.dismiss();
        }

        if (state) {
            _viewerapi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.watchCamera);
        } else {
            _viewerapi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.watchCamera);
        }
    };

};
;

(function() {

'use strict';

var avet = AutodeskNamespace('Autodesk.Viewing.Extensions.DefaultTools');

var av = Autodesk.Viewing,
    AVU = av.UI;

function createNavToggler(viewer, button, name) {
    return function() {
        var state = button.getState();
        if (state === AVU.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool(name);
            button.setState(AVU.Button.State.ACTIVE);
        } else if (state === AVU.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
            button.setState(AVU.Button.State.INACTIVE);
        }
    };
}

var NavToolsExtension = function(viewer, options) {
    av.Extension.call(this, viewer, options);
};

NavToolsExtension.prototype = Object.create(av.Extension.prototype);
NavToolsExtension.prototype.constructor = NavToolsExtension;

NavToolsExtension.prototype.load = function() {
    var viewer = this.viewer;

    // Register tools
    var fovtool  = new av.FovTool(viewer);
    var rolltool = new av.WorldUpTool(viewer.impl, viewer);

    viewer.toolController.registerTool( fovtool );
    viewer.toolController.registerTool( rolltool );

    this.createUI();
    this.initCameraStateMachine();
    this.initFocalLengthOverlay();

    return true;
};

NavToolsExtension.prototype.createUI = function()
{
    // Adds the UI for the default navigation tools (orbit, pan, dolly, camera controls)
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);
    var navActionDisplayMode = function(action) {
        return viewer.navigation.isActionEnabled(action) ? 'block' : 'none'
    };

    navTools.returnToDefault = function() {};

    if (this.options.mode === '3d') {
        var orbitToolsButton = new AVU.ComboButton('toolbar-orbitTools');
        orbitToolsButton.setToolTip('Orbit');
        orbitToolsButton.setIcon("adsk-icon-orbit-constrained");
        orbitToolsButton.setDisplay(navActionDisplayMode('orbit'));

        this.createOrbitSubmenu(orbitToolsButton);

        navTools.addControl(orbitToolsButton);
        navTools.orbittoolsbutton = orbitToolsButton;
        orbitToolsButton.setState(AVU.Button.State.ACTIVE);

        navTools.returnToDefault = function() {
            orbitToolsButton.setState(AVU.Button.State.ACTIVE);
        };
    }

    var panButton = new AVU.Button('toolbar-panTool');
    panButton.setToolTip('Pan');
    panButton.setIcon("adsk-icon-pan");
    panButton.onClick = createNavToggler(viewer, panButton, 'pan');
    panButton.setDisplay(navActionDisplayMode('pan'));

    navTools.addControl(panButton);
    navTools.panbutton = panButton;

    var dollyButton = new AVU.Button('toolbar-zoomTool');
    dollyButton.setToolTip('Zoom');
    dollyButton.setIcon("adsk-icon-zoom");
    dollyButton.onClick = createNavToggler(viewer, dollyButton, 'dolly');
    dollyButton.setDisplay(navActionDisplayMode('zoom'));

    navTools.addControl(dollyButton);
    navTools.dollybutton = dollyButton;

    var cameraButton = new AVU.ComboButton('toolbar-cameraSubmenuTool');
    cameraButton.setToolTip('Camera interactions');
    cameraButton.setIcon("adsk-icon-camera");
    cameraButton.saveAsDefault();
    this.createCameraSubmenu(cameraButton);
    navTools.addControl(cameraButton);
    navTools.camerabutton = cameraButton;
};


NavToolsExtension.prototype.createOrbitSubmenu = function(parentButton)
{
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    var freeOrbitButton = new AVU.Button('toolbar-freeOrbitTool');
    freeOrbitButton.setToolTip('Free orbit');
    freeOrbitButton.setIcon("adsk-icon-orbit-free");
    freeOrbitButton.onClick = createNavToggler(viewer, freeOrbitButton, 'freeorbit');

    parentButton.addControl(freeOrbitButton);
    navTools.freeorbitbutton = freeOrbitButton;

    var orbitButton = new AVU.Button('toolbar-orbitTool');
    orbitButton.setToolTip('Orbit');
    orbitButton.setIcon("adsk-icon-orbit-constrained");
    orbitButton.onClick = createNavToggler(viewer, orbitButton, 'orbit');

    parentButton.addControl(orbitButton);
    navTools.orbitbutton = orbitButton;

    parentButton.onClick = orbitButton.onClick; // default

};

NavToolsExtension.prototype.createCameraSubmenu = function(parentButton)
{
    var self = this;
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);
    var navActionDisplayMode = function(action) {
        return viewer.navigation.isActionEnabled(action) ? 'block' : 'none'
    };

    if (isTouchDevice()) {
        var homeButton = new AVU.Button('toolbar-homeTool');
        homeButton.setToolTip('Home');
        homeButton.setIcon("adsk-icon-home");
        homeButton.onClick = function () {
            viewer.navigation.setRequestHomeView(true);
            var defaultNavToolName = viewer.getDefaultNavigationToolName();
            viewer.setActiveNavigationTool(defaultNavToolName);
            parentButton.restoreDefault();
        };
        homeButton.setDisplay(navActionDisplayMode('gotoview'));

        parentButton.addControl(homeButton);
        navTools.homebutton = homeButton;
    }

    //options = { defaultTooltipValue : "Fit to view (F)" };
    var fitToViewButton = new AVU.Button('toolbar-fitToViewTool');
    fitToViewButton.setToolTip('Fit to view');
    fitToViewButton.setIcon("adsk-icon-fit-to-view");
    fitToViewButton.onClick = function(e) {
        // Need to map the objects to dbIds
        viewer.fitToView(self.options.mode === "3d" ? viewer.getSelection() : undefined);
        var defaultNavToolName = viewer.getDefaultNavigationToolName();
        viewer.setActiveNavigationTool(defaultNavToolName);
        parentButton.restoreDefault();
    };
    fitToViewButton.setDisplay(navActionDisplayMode('gotoview'));

    parentButton.addControl(fitToViewButton);
    navTools.fovbutton = fitToViewButton;

    if (this.options.mode === "3d") {
        //options.defaultTooltipValue = "Focal length (Ctrl+Shift drag)";
        var fovButton = new AVU.Button('toolbar-focalLengthTool');
        fovButton.setToolTip('Focal length');
        fovButton.setIcon("adsk-icon-fov");
        fovButton.onClick = createNavToggler(viewer, fovButton, 'fov');
        fovButton.setDisplay(navActionDisplayMode('fov'));

        parentButton.addControl(fovButton);
        navTools.fovbutton = fovButton;
    }

    //options.defaultTooltipValue = "Roll (Alt+Shift drag)";
    var rollButton = new AVU.Button('toolbar-rollTool');
    rollButton.setToolTip('Roll');
    rollButton.setIcon("adsk-icon-roll");
    rollButton.onClick = createNavToggler(viewer, rollButton, 'worldup');
    rollButton.setDisplay(navActionDisplayMode('roll'));

    parentButton.addControl(rollButton);
    navTools.rollbutton = rollButton;
};

NavToolsExtension.prototype.initCameraStateMachine = function(mode) {
    var self = this;
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    this.toolChangedHandler = function (e) {
        if (e.toolName === "fov") {
            self.showFocalLengthOverlay(e.active);
        }
    };
    viewer.addEventListener(av.TOOL_CHANGE_EVENT, this.toolChangedHandler);

    this.navChangedHandler = function(e) {
        if (viewer.getDefaultNavigationToolName() === e.id)
            navTools.returnToDefault();
    };
    viewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.navChangedHandler);
};

NavToolsExtension.prototype.initFocalLengthOverlay = function() {

    var container = this.focallength = document.createElement("div");

    container.className = "focallength";

    var table = document.createElement("table");
    var tbody = document.createElement("tbody");
    table.appendChild(tbody);

    container.appendChild(table);
    this.viewer.container.appendChild(container);

    var row = tbody.insertRow(-1);
    var cell = row.insertCell(0);
    cell.setAttribute( "data-i18n", "Focal Length" );
    cell.textContent = Autodesk.Viewing.i18n.translate( "Focal Length" );
    cell = row.insertCell(1);
    cell.textContent = '';
    cell.style.width = "4em";
    cell.style.textAlign = "right";
    this.fovCell = cell;

    container.style.visibility = "hidden";
};

NavToolsExtension.prototype.showFocalLengthOverlay = function(state)
{
    var self = this;
    var viewer = this.viewer;
    var myFocalLength = 0;

    function showFovHudMessage(yes) {
        if( yes ) {
            // Display a hud messages.
            var messageSpecs = {
                "msgTitleKey"   : "Orthographic View Set",
                "messageKey"    : "The view is set to Orthographic",
                "messageDefaultValue" : "The view is set to Orthographic. Changing the focal length will switch to Perspective."
            };
            av.Private.HudMessage.displayMessage(viewer.container, messageSpecs);
        }
        else {
            av.Private.HudMessage.dismiss();
        }
    }

    function showFov(yes) {
        if (yes) updateFOV();

        if( self.focallength )
            self.focallength.style.visibility = yes ? "visible" : "hidden";
    }

    function updateFOV() {
        var camFocalLength = viewer.getFocalLength();
        if( myFocalLength !== camFocalLength )
        {
            myFocalLength = camFocalLength;
            self.fovCell.textContent = camFocalLength.toString() + " mm";
        }
    }

    function watchFOV(e) {
        updateFOV();
        // If camera changed to ORTHO and we are still in FOV mode
        // put up the warning message that the system will switch to perspective.
        //
        if (viewer.toolController.getActiveToolName() === "fov") {
            var camera = viewer.navigation.getCamera();
            var isOrtho = camera && !camera.isPerspective;

            showFov(!isOrtho);
            showFovHudMessage(isOrtho);
        }
    }
    var camera = viewer.navigation.getCamera();
    var isOrtho = camera && !camera.isPerspective;

    showFov(state && !isOrtho);
    showFovHudMessage(state && isOrtho);

    if( state ) {
        viewer.addEventListener(av.CAMERA_CHANGE_EVENT, watchFOV);
    }
    else {
        viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, watchFOV);
    }
};

NavToolsExtension.prototype.unload = function () {
    this.destroyUI();

    return true;
};

NavToolsExtension.prototype.destroyUI = function () {
    // Removes the UI created in createUI
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(false);

    if (!toolbar) {
        return true;
    }

    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    if (!navTools) {
        return true;
    }

    if (this.options.mode === '3d') {
        navTools.orbittoolsbutton.subMenu.removeEventListener(AVU.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED, navTools.orbittoolsbutton.subMenuActiveButtonChangedHandler(navTools));
        navTools.removeControl(navTools.orbittoolsbutton.getId());
        navTools.orbittoolsbutton = null;
        navTools.orbitbutton.onClick = null;
        navTools.orbitbutton = null;
        navTools.freeorbitbutton.onClick = null;
        navTools.freeorbitbutton = null;
    }

    navTools.removeControl(navTools.panbutton.getId());
    navTools.panbutton.onClick = null;
    navTools.panbutton = null;

    navTools.removeControl(navTools.dollybutton.getId());
    navTools.dollybutton.onClick = null;
    navTools.dollybutton = null;

    navTools.camerabutton.subMenu.removeEventListener(AVU.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED, navTools.camerabutton.subMenuActiveButtonChangedHandler(navTools));
    navTools.removeControl(navTools.camerabutton.getId());
    navTools.camerabutton.onClick = null;
    navTools.camerabutton = null;

    navTools.rollbutton.onClick = null;
    navTools.rollbutton = null;
    navTools.fovbutton.onClick = null;
    navTools.fovbutton = null;

    this.focallength = null;

    // Remove Listeners
    viewer.removeEventListener(av.TOOL_CHANGE_EVENT, this.toolChangedHandler);
    this.toolChangedHandler = null;
    viewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.navChangedHandler);
    this.navChangedHandler = null;

    return true;
};

avet.NavToolsExtension = NavToolsExtension;

av.theExtensionManager.registerExtension('Autodesk.DefaultTools.NavTools', NavToolsExtension);

})();
;
(function() {

'use strict';

var avem = AutodeskNamespace('Autodesk.Viewing.Extensions.Measure'),
    av = Autodesk.Viewing,
    avu = av.UI;

/**
 * @class
 * Extension used to support distance and angle measure for 2d and 3d models.
 *
 * @tutorial feature_measure
 * @param {Autodesk.Viewing.Viewer3D} viewer - the viewer to be extended.
 * @param {Object} options - An optional dictionary of options for this extension.
 * @alias Autodesk.Viewing.Extensions.Measure.MeasureExtension
 * @constructor
*/
var MeasureExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

MeasureExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
MeasureExtension.prototype.constructor = MeasureExtension;


MeasureExtension.prototype.onToolbarCreated = function() {
    this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.bindedOnToolbarCreated);
    this.bindedOnToolbarCreated = null;
    this.createUI();
};

/**
 * Load measure extension.
 * @returns {boolean} true if measure extension is loaded successfully.
*/
MeasureExtension.prototype.load = function() {

    var self   = this;
    var viewer = this.viewer;

    this.escapeHotkeyId = 'Autodesk.Measure.Hotkeys.Escape';

    // Register the Measure tool
    if (!viewer.toolController){
        return false;
    }
    this.tool = new avem.MeasureTool(viewer, { onCloseCallback: function(e) {
        self.enableMeasureTool(false);
    }});
    viewer.toolController.registerTool(this.tool);

    if (this.viewer.toolbar) {
        this.createUI();
    } else {
        this.bindedOnToolbarCreated = this.onToolbarCreated.bind(this);
        this.viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, this.bindedOnToolbarCreated);
    }

    return true;
};

/**
 * Unload measure extension.
 * @returns {boolean} true if measure extension is unloaded successfully.
*/
MeasureExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Remove the ui from the viewer.
    this.destroyUI();
    if (this.bindedOnToolbarCreated) {
        this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.bindedOnToolbarCreated);
        this.bindedOnToolbarCreated = null;
    }

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

/**
 * Whether the measure tool is currently active.
 * @return {Boolean}
 */
MeasureExtension.prototype.isActive = function() {
    return this.tool.isActive();
};

/**
 * Enable/disable the measure tool.
 * @param {boolean} active - true to activate, false to deactivate.
 * @returns {boolean} true if a change in activeness occurred.
 */
MeasureExtension.prototype.setActive = function(active) {
    return this.enableMeasureTool(active);
};

/**
 * Toggles activeness of the measure tool.
 *
 * @return {Boolean} Whether the tool is active
 */
MeasureExtension.prototype.toggle = function() {
    if (this.isActive()) {
        this.enableMeasureTool(false);
    } else {
        this.enableMeasureTool(true);
    }
    return this.isActive();
};

/**
 * Get the current measurement in the measure tool.
 * @param {String} [unitType] - Optional measure unit, [ 'decimal-ft', 'ft', 'ft-and-decimal-in',
 *                            'decimal-in', 'fractional-in', 'm', 'cm', 'mm', 'm-and-cm' ]
 * @param {Number} [precision] - Optional measure precision index,  [ 0 - 0, 1 - 0.1, 2 - 0.01, 3 - 0.001, 4 - 0.0001, 5 - 0.00001 ]
 *                             when units type is 'ft', 'in' or 'fractional-in' [ 0 - 1, 1 - 1/2, 2 - 1/4, 3 - 1/8, 4 - 1/16, 5 - 1/32, 6 - 1/64 ]
 * @return {Object|null} Containing properties of the current measurement, or null.
 */
MeasureExtension.prototype.getMeasurement = function(unitType, precision) {
    var measurement = null;
    if (this.isActive()) {
        measurement = this.tool.getMeasurement(unitType, precision);
    }
    return measurement;
};

/**
 * Get all available units in measure tool.
 *
 * @return {Array} Containing all available units.
*/
MeasureExtension.prototype.getUnitOptions = function() {
    var units = [
        { name: 'Unknown', type: '' },
        { name: 'Decimal feet', type: 'decimal-ft' },
        { name: 'Feet and fractional inches', type: 'ft' },
        { name: 'Feet and decimal inches', type: 'ft-and-decimal-in' },
        { name: 'Decimal inches', type: 'decimal-in' },
        { name: 'Fractional inches', type: 'fractional-in' },
        { name: 'Meters', type: 'm' },
        { name: 'Centimeters', type: 'cm' },
        { name: 'Millimeters', type: 'mm' },
        { name: 'Meters and centimeters', type: 'm-and-cm' }
    ];

    return units;
};

/**
 * Get all available precisions in measure tool.
 * @param {Boolean} isFractional - set true to get fractional precisions
 * @return {Array} Containing all available precisions.
*/
MeasureExtension.prototype.getPrecisionOptions = function(isFractional) {

    if (isFractional)
        var precisions = ['1', '1/2', '1/4', '1/8', '1/16', '1/32', '1/64'];
    else
        var precisions = ['0', '0.1', '0.01', '0.001', '0.0001', '0.00001'];

    return precisions;
};

/**
 * Get the default measure unit in measure tool.
 *
 * @return {String} The default measure unit.
*/
MeasureExtension.prototype.getDefaultUnit = function() {
    var unit = this.viewer.model.getDisplayUnit();

    return unit;
};

/**
 * Enable/disable the measure tool.
 * @param {boolean} enable - true to enable, false to disable.
 * @returns {boolean} true if the tool state was changed.
 * @private
 */
MeasureExtension.prototype.enableMeasureTool = function(enable) {
    var toolController = this.viewer.toolController,
        isActive = this.tool.isActive();

    this.viewer.impl.disableRollover(enable);

    if (enable && !isActive) {
        toolController.activateTool("measure");
        if (this.measureToolButton) {
            this.measureToolButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        }
        return true;

    } else if (!enable && isActive) {
        toolController.deactivateTool("measure");
        if (this.measureToolButton) {
            this.measureToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
        }
        return true;
    }
    return false;
};



    /**
 * Create measure button in toolbar.
 * @private
*/
MeasureExtension.prototype.createUI = function()
{
    var self   = this;
    var viewer = this.viewer;

    this.measureToolButton = null;

    var toolbar = viewer.getToolbar(true);
    var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);

    // Create a button for the measure tool.
    this.measureToolButton = new avu.Button( "toolbar-measureTool");
    this.measureToolButton.setToolTip("Measure");
    this.measureToolButton.setIcon("adsk-icon-measure");
    this.measureToolButton.onClick = function(e) {
        self.enableMeasureTool(!self.tool.isActive());
    };
    this.onMeasureButtonStateChange = function(e) {
        if (e.state === avu.Button.State.ACTIVE) {
            self.enableMeasureTool(true);
        } else if (e.state === avu.Button.State.INACTIVE) {
            self.enableMeasureTool(false);
        }
    };
    this.measureToolButton.addEventListener(avu.Button.Event.STATE_CHANGED, this.onMeasureButtonStateChange);

    modelTools.addControl(this.measureToolButton, {index:0});

    // Escape hotkey to exit tool.
    //
    var hotkeys = [{
        keycodes: [
            av.theHotkeyManager.KEYCODES.ESCAPE
        ],
        onRelease: function () {
            return self.enableMeasureTool(false);
        }
    }];
    av.theHotkeyManager.pushHotkeys(this.escapeHotkeyId, hotkeys);
};

/**
 * Destroy measure button in toolbar.
 * @private
*/
MeasureExtension.prototype.destroyUI = function()
{
    var viewer = this.viewer;

    if (this.measureToolButton) {
        this.measureToolButton.removeEventListener(avu.Button.Event.STATE_CHANGED, this.onMeasureButtonStateChange);
    }

    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);
        if (modelTools) {
            if (this.measureToolButton) {
                var submenu = modelTools.getControl("toolbar-inspectSubMenu");
                if (submenu) {
                    submenu.removeControl(this.measureToolButton.getId());
                } else {
                    modelTools.removeControl(this.measureToolButton.getId());
                }
            }

            this.measureToolButton = null;
        }
    }

    av.theHotkeyManager.popHotkeys(this.escapeHotkeyId);
};

avem.MeasureExtension = MeasureExtension;
av.theExtensionManager.registerExtension('Autodesk.Measure', MeasureExtension);


})();;AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

//
// /** @constructor */
//
//
Autodesk.Viewing.Extensions.Measure.MeasureTool = function( viewer, options )
{
    var tool = this;

    var _viewer  = viewer;
    var _options = options;

    var _names  = ["measure"];
    var _active = false;

    var _firstClick = null;
    var _secondClick = null;
    var _isDragging = false;
    var _interacting = false;
    var _activePoint = 0;
    var _consumeSingleClick = false;
    var _firstClickGeometry = null;
    var _secondClickGeometry = null;

    var _units = "";
    var _precision = 3;
    var _distances = {};

    var _angle = 0;

    var _redraw = false;

    // UI.
    var _indicator = null;
    var _measurePanel = null;
    var _cursor = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKZJREFUeNrclLEKwzAQQ9+FgH/Nk7d8ViFT+6cG36IsNXgIdMg5kAoOIw8WSDoDvAEN04BdEhFjgCTR4e6klFxSIgDLSNydbdsAPgRCktRaUylFkfZ0Z2qtVTlnAfugGibwAur3JFrAxoBnYGEy1pGYmQCLLNB6Uqmw182M9eRS0yzqGo+y6D9rytSQR8vM7DKfbtHy4x+/xG8J+d4W9WAi8fxFOwYA8W0ypu2ZfcsAAAAASUVORK5CYII=), auto";

    // Snapper
    var _snapper = null;
    var _firstIntersectPoint = null;
    var _secondIntersectPoint = null;
    var _firstFaceNormal = null;
    var _secondFaceNormal = null;
    var _firstCircularArcCenter = null;
    var _secondCircularArcCenter = null;

    // Isolate Measurement
    var _isolateMeasure = false;
    var _firstClickNode = null;
    var _secondClickNode = null;

    // Multiple Viewports For 2D
    var _firstViewportIndex = null;
    var _secondViewportIndex = null;

    var _hasUI = Autodesk.Viewing.Private.GuiViewer3D && viewer instanceof Autodesk.Viewing.Private.GuiViewer3D;

    var _clip = null;

    this.register = function()
    {
        if (_hasUI && !_measurePanel) {
            _measurePanel = new Autodesk.Viewing.Extensions.Measure.MeasurePanel( tool, _viewer, "measure-panel", "Measure", options );
            _viewer.addPanel( _measurePanel );
        }

        if (!_snapper) {
            _snapper = new Autodesk.Viewing.Extensions.Measure.Snapper(viewer);
            _viewer.toolController.registerTool(_snapper);
        }
    };

    this.deregister = function()
    {
        this.deactivate();
        if (_measurePanel) {
            _viewer.removePanel( _measurePanel );
            _measurePanel.uninitialize();
        }

        _viewer.toolController.deregisterTool(_snapper);
        _snapper = null;
    };

    this.isActive = function()
    {
        return _active;
    };

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.getCursor = function() {
        return (_isDragging && !_interacting) ? null : _cursor;
    };

    function onCameraChange() {
        _indicator.updateLabelPositions();
    }

    function onReset() {
        tool.clearMeasurement();
    }

    this.activate = function()
    {
        _active = true;
        _activePoint = 0;
        _isDragging = false;

        if (!_units) {
            _units = _viewer.model.getDisplayUnit();
        }

        if (_viewer.model && _viewer.model.is2d()) {
            _precision = 3;
        }
        else {
            _precision = 1;
        }

        activateUI();

        _viewer.clearSelection();
        _viewer.toolController.activateTool("snapper");

       _viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
       _viewer.addEventListener(Autodesk.Viewing.RESET_EVENT, onReset);
    };

    this.deactivate = function()
    {
        _active = false;
        _firstClick = _secondClick = null;
        _distances = {};

        this.clearMeasurement();

        deactivateUI();

        if(_snapper && _snapper.isActive()) {
            _viewer.toolController.deactivateTool("snapper");
        }

        _viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
        _viewer.removeEventListener(Autodesk.Viewing.RESET_EVENT, onReset);
    };

    this.update = function()
    {
        return false;
    };

    this.getUnits = function() {
        return _units;
    };

    this.setUnits = function( units )
    {
        if (_units !== units ) {
            _units = units;

            // Update UI
            if (_indicator) {
                _indicator.updateDistance();
                //_indicator.updateLabels();
            }
        }
    };

    this.getPrecision = function() {
        return _precision;
    };

    this.setPrecision = function( precision ) {

        if (_precision !== precision ) {
            _precision = precision;

            // Update UI
            if (_indicator) {
                _indicator.updateDistance();
                //_indicator.updateLabels();
            }
        }
    };

    this.getDistance = function (name) {

        if (_viewer.model && _viewer.model.isLoadDone()) {
            var d = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, _distances[name] || 0);
            return Autodesk.Viewing.Private.formatValueWithUnits(d, _units, 3, _precision);
        }
    };

    this.getAngle = function() {

            return Autodesk.Viewing.Private.formatValueWithUnits(_angle, String.fromCharCode(0xb0), 3, _precision);
    };

    /**
     * TODO: We need to flesh out the return value here.
     *
     * @param unitType
     * @param precision
     * @returns {Object}
     */
    this.getMeasurement = function(unitType, precision) {

        _units = unitType || _units;
        _precision = precision || _precision;

        var geomTypes = ['Vertex', 'Edge', 'Face', 'Circular Arc', 'Curved Edge', 'Curved Face'];

        var measurement = {
            from: geomTypes[this.getFirstGeometry().type],
            to: geomTypes[this.getSecondGeometry().type],
            distance: this.getDistance('xyz'),
            deltaX: this.getDistance('x'),
            deltaY: this.getDistance('y'),
            deltaZ: this.getDistance('z'),
            angle: this.getAngle(),
            unitType: _units,
            precision: _precision
        };
        return measurement;
    };

    this.clearMeasurement = function() {
        _firstClick = _secondClick = null;
        _firstClickGeometry = _secondClickGeometry = null;
        _firstClickNode = _secondClickNode = null;
        _firstViewportIndex = _secondViewportIndex = null;
        _activePoint = 1;
        _distances = {};
        _angle = 0;
        _clip = null;

        if (_indicator) {
            _indicator.hide();
        }
        if (_measurePanel) {
            _measurePanel.updatePanel();
            _measurePanel.hideMeasureResult();

            if (_measurePanel.isolateMeasure) {
                this.clearIsolate();
            }
        }
        //if (_viewer.model.is2d() && _snapper) {
        //    _snapper.setClip();
        //}
        if (_viewer.model.is2d()) {
            viewer.impl.updateViewportId(0);

            if (_snapper)
                _snapper.setFirstClickVpId(null);
        }
    };

    this.clearRubberBand = function() {
        _secondClick = null;
        _secondClickGeometry = null;
        _indicator.hideClick('second');
    };

    this.clearFirstPick = function() {
        if (_secondClick) {
            _indicator.hide();

            _firstClick = _secondClick.clone();
            _firstClickGeometry = _secondClickGeometry;
            _firstIntersectPoint = _secondIntersectPoint;
            _firstFaceNormal = _secondFaceNormal;
            _firstClickNode = _secondClickNode;
            _firstViewportIndex = _secondViewportIndex;
            _firstCircularArcCenter = _secondCircularArcCenter;

            //if (_viewer.model.is2d()) {
            //    _indicator.drawGreyOutPlane(_firstViewportIndex);
            //
            //    // Need to pass the clip to Snapper (disable snapper in greying out area), only snap in the clip
            //    if (_snapper)
            //        _snapper.setClip(_clip);
            //}
            if (_viewer.model.is2d()) {
                // Pass viewport Id to LineShader to make all other geometries with different viewport transparent
                viewer.impl.updateViewportId(_firstViewportIndex);

                if (_snapper)
                    _snapper.setFirstClickVpId(_firstViewportIndex);
            }

            // redraw the first pick
            _redraw = true;
            if (_firstClickGeometry === SNAP_VERTEX) {
                _indicator.showFirstVertex(_firstClick);
            }
            else if (_firstClickGeometry === SNAP_EDGE) {
                _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
            }
            else if (_firstClickGeometry === SNAP_FACE) {
                _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
            }
            else if (_firstClickGeometry === SNAP_CIRCULARARC) {

                _firstClick.center = _secondClick.center;
                _firstClick.radius = _secondClick.radius;
                _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
            }
            else if (_firstClickGeometry === SNAP_CURVEDFACE) {

                _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
            }
            _redraw = false;

            _secondClick = null;
            _secondClickGeometry = null;
            _secondClickNode = null;
            _secondViewportIndex = null;
            _secondCircularArcCenter = null;
            _activePoint = 2;
            _distances = {};
            _angle = 0;

            if (_measurePanel && _measurePanel.isolateMeasure) {
                this.clearIsolate();
            }
        }
        else {
            this.clearMeasurement();
        }

        if (_measurePanel) _measurePanel.showSelection1();
    };

    this.clearSecondPick = function() {
        _secondClick = null;
        _secondClickGeometry = null;
        _secondClickNode = null;
        _secondViewportIndex = null;
        _activePoint = 2;
        _distances = {};
        _angle = 0;
        _indicator.hideClick('second');

        if (_measurePanel && _measurePanel.isolateMeasure) {
            this.clearIsolate();
        }

        if (_viewer.model.is2d()) {
            // Pass viewport Id to LineShader to make all other geometries with different viewport transparent
            viewer.impl.updateViewportId(_firstViewportIndex);

            if (_snapper)
                _snapper.setFirstClickVpId(_firstViewportIndex);
        }
    };

    this.getIndicator = function () {
        return _indicator;
    };

    this.getFirstGeometry = function () {
        return {"type": _firstClickGeometry, "geometry": _firstClick};
    };

    this.getSecondGeometry = function () {
        return {"type": _secondClickGeometry, "geometry": _secondClick};
    };

    this.getEdgeLength = function (edge) {
        return _indicator.getEdgeLength(edge);
    };

    this.getFaceArea = function (face) {
        return _indicator.getFaceArea(face);
    };

    this.getCircularArcRadius = function (edge) {
        return _indicator.getCircularArcRadius(edge);
    };

    this.isolateMeasurement = function () {
        if (_firstClickNode && _secondClickNode) {
            var nodeList = [_firstClickNode, _secondClickNode];
            _viewer.isolate(nodeList);
        }
    };

    this.clearIsolate = function() {
        _viewer.showAll();
    };

    this.isIdenticalEdges = function() {

        if (_firstClick.vertices.length === _secondClick.vertices.length) {

            for (var i = 0; i < _firstClick.vertices.length; i++) {
                if (!_firstClick.vertices[i].equals(_secondClick.vertices[i])) {
                    return false;
                }
            }
            return true;
        }

        return false;
    };

    this.isIdenticalFaces = function() {

        if (_firstClick.faceId && _secondClick.faceId) {
            if (_firstClick.fragId === _secondClick.fragId && _firstClick.faceId === _secondClick.faceId) {
                return true;
            }
        }
        else {
            if (_firstClick.vertices.length === _secondClick.vertices.length) {

                for (var i = 0; i < _firstClick.vertices.length; i++) {
                    if (!_firstClick.vertices[i].equals(_secondClick.vertices[i])) {
                        return false;
                    }
                }
                return true;
            }
        }

        return false;
    };

    this.isIdenticalGeometries = function() {

        if (_firstClickGeometry === _secondClickGeometry) {

            switch (_firstClickGeometry) {

                case SNAP_VERTEX:
                    if (_firstClick.equals(_secondClick))
                        return true;
                    break;
                case SNAP_EDGE: return this.isIdenticalEdges(); break;
                case SNAP_FACE: return this.isIdenticalFaces(); break;
                case SNAP_CIRCULARARC: return this.isIdenticalEdges(); break;
                case SNAP_CURVEDEDGE: return this.isIdenticalEdges(); break;
                case SNAP_CURVEDFACE: return this.isIdenticalFaces(); break;
                default: break;
            }
        }

        return false;
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this._handleMouseEvent = function (event) {

        if(_snapper.isSnapped()) {  // ray cast has intersection with mesh
            if (_activePoint === 0) {
                this.clearMeasurement();
                _activePoint = 1;
            }

            if (_activePoint === 1) {  // First Pick

                _firstViewportIndex = _snapper.getViewportIndex();
                _firstClickGeometry = _snapper.getHighlightGeometry();
                _firstIntersectPoint = _snapper.getIntersectPoint();

                //if (_viewer.model.is2d()) {
                //    _indicator.drawGreyOutPlane(_firstViewportIndex);
                //
                //    // Need to pass the clip to Snapper (disable snapper in greying out area), only snap in the clip
                //    if (_snapper)
                //        _snapper.setClip(_clip);
                //}

                // Only snap the geometries which belong to the same viewport as the first selection
                if (_viewer.model.is2d()) {
                    // Pass viewport Id to LineShader to make all other geometries with different viewport transparent
                    viewer.impl.updateViewportId(_firstViewportIndex);

                    if (_snapper)
                        _snapper.setFirstClickVpId(_firstViewportIndex);
                }

                _firstClick = _snapper.getGeometry();

                if (_firstClickGeometry === SNAP_VERTEX) {

                    _indicator.showFirstVertex(_firstClick);
                }
                else if (_firstClickGeometry === SNAP_EDGE || _firstClickGeometry === SNAP_CURVEDEDGE) {

                    _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
                }
                else if (_firstClickGeometry === SNAP_FACE) {

                    _firstFaceNormal = _snapper.getFaceNormal();
                    _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC) {

                    // TODO: need to get rid of _firstCircularArcCenter, use _firstClick.center instead.
                    _firstCircularArcCenter = _snapper.getCircularArcCenter();
                    _firstClick.center = _snapper.getCircularArcCenter();
                    _firstClick.radius = _snapper.getCircularArcRadius();
                    _indicator.showFirstEdge(_firstClick, _firstIntersectPoint);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE) {

                    _indicator.showFirstFace(_firstClick, _firstIntersectPoint);
                }

                _firstClickNode = _snapper.getSnapNode();
                if (_measurePanel) _measurePanel.showSelection1();

            } else if (_activePoint === 2) { // Second Pick

                var result = null; // result = [endPoint, endPoint] or result = angle

                _secondClickGeometry = _snapper.getHighlightGeometry();
                _secondIntersectPoint = _snapper.getIntersectPoint();

                _secondClick = _snapper.getGeometry();

                if (_secondClickGeometry === SNAP_CIRCULARARC) {
                    _secondClick.center = _snapper.getCircularArcCenter();
                    _secondClick.radius = _snapper.getCircularArcRadius();
                }

                // Do not measure between identical geometries since the measurement is always 0.
                if (this.isIdenticalGeometries()) {
                    return false;
                }

                if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_VERTEX) { // do vertex to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    _indicator.drawLine(_firstClick, _secondClick);

                    result = [_firstClick, _secondClick];

                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_EDGE) { // do edge to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.edgeToEdgeMeasure(_secondClick, _firstClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_FACE) { // do face to face measure

                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.faceToFaceMeasure(_firstIntersectPoint, _firstFaceNormal, _secondIntersectPoint, _secondFaceNormal);

                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_EDGE) { // do vertex to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToEdgeMeasure(_firstClick, _secondClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_VERTEX) { // do edge to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    result = _indicator.edgeToPointMeasure(_firstClick, _secondClick);

                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_FACE) { // do vertex to face measure

                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToFaceMeasure(_firstClick, _secondClick, _secondFaceNormal, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_VERTEX) { // do face to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    result = _indicator.faceToPointMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondClick);

                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_FACE) { // do edge to face measure

                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.edgeToFaceMeasure(_firstClick, _firstIntersectPoint, _secondClick, _secondFaceNormal, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_EDGE) { // do face to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.faceToEdgeMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_CIRCULARARC) { // do circular arc to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();

                    // When circular arcs have same center, measure the radius of arc instead of the distance of two centers
                    if (_firstCircularArcCenter.equals(_secondCircularArcCenter)) {
                        _secondClick = _indicator.nearestVertexInVertexToEdge(_secondIntersectPoint, _secondClick);
                        _secondClickGeometry = SNAP_VERTEX;

                        _indicator.showSecondVertex(_secondClick);

                        _indicator.drawLine(_firstCircularArcCenter, _secondClick);

                        result = [_firstCircularArcCenter, _secondClick];
                    }
                    else {
                        _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);
                        _indicator.drawLine(_firstCircularArcCenter, _secondCircularArcCenter);

                        result = [_firstCircularArcCenter, _secondCircularArcCenter];
                    }
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_VERTEX) { // do circular arc to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    _indicator.drawLine(_firstCircularArcCenter, _secondClick);

                    result = [_firstCircularArcCenter, _secondClick];

                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_CIRCULARARC) { // do vertex to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    _indicator.drawLine(_firstClick, _secondCircularArcCenter);

                    result = [_firstClick, _secondCircularArcCenter];
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_EDGE) { // do circular arc to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToEdgeMeasure(_firstCircularArcCenter, _secondClick, _secondIntersectPoint);

                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_CIRCULARARC) { // do edge to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.edgeToPointMeasure(_firstClick, _secondCircularArcCenter);

                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_FACE) { // do circular arc to face measure

                    _secondFaceNormal = _snapper.getFaceNormal();
                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.pointToFaceMeasure(_firstCircularArcCenter, _secondClick, _secondFaceNormal, _secondIntersectPoint);
                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_CIRCULARARC) { // do face to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.faceToPointMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, _secondCircularArcCenter);
                }
                // Below is for curved edge and curved face measure
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && _secondClickGeometry === SNAP_VERTEX) { // do curved edge to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    result = _indicator.curvedEdgeToVertexMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_CURVEDEDGE) { // do vertex to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToVertexMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && _secondClickGeometry === SNAP_CIRCULARARC) { // do curved edge to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToVertexMeasure(_firstClick, _secondCircularArcCenter);
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_CURVEDEDGE) { // do circular arc to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToVertexMeasure(_secondClick, _firstCircularArcCenter);
                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && _secondClickGeometry === SNAP_EDGE) { // do curved edge to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToEdgeMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_CURVEDEDGE) { // do edge to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToEdgeMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && _secondClickGeometry === SNAP_CURVEDEDGE) { // do curved edge to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToCurvedEdgeMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE && (_secondClickGeometry === SNAP_FACE || _secondClickGeometry === SNAP_CURVEDFACE)) { // do curved edge to face/curvedFace measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToFaceMeasure(_firstClick, _secondClick);
                }
                else if ((_firstClickGeometry === SNAP_FACE || _firstClickGeometry === SNAP_CURVEDFACE) && _secondClickGeometry === SNAP_CURVEDEDGE) { // do face/curvedFace to curved edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToFaceMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE && _secondClickGeometry === SNAP_VERTEX) { // do curved face to vertex measure

                    _indicator.showSecondVertex(_secondClick);

                    result = _indicator.curvedFaceToVertexMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_VERTEX && _secondClickGeometry === SNAP_CURVEDFACE) { // do vertex to curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToVertexMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE && _secondClickGeometry === SNAP_CIRCULARARC) { // do curved face to circular arc measure

                    _secondCircularArcCenter = _snapper.getCircularArcCenter();
                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToVertexMeasure(_firstClick, _secondCircularArcCenter);
                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC && _secondClickGeometry === SNAP_CURVEDFACE) { // do circular arc to curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToVertexMeasure(_secondClick, _firstCircularArcCenter);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE && _secondClickGeometry === SNAP_EDGE) { // do curved face to edge measure

                    _indicator.showSecondEdge(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToFaceMeasure(_secondClick, _firstClick);
                }
                else if (_firstClickGeometry === SNAP_EDGE && _secondClickGeometry === SNAP_CURVEDFACE) { // do edge to curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedEdgeToFaceMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE && (_secondClickGeometry === SNAP_FACE || _secondClickGeometry === SNAP_CURVEDFACE)) { // do curved face to face/curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToFaceMeasure(_firstClick, _secondClick);
                }
                else if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_CURVEDFACE) { // do face to curved face measure

                    _indicator.showSecondFace(_secondClick, _secondIntersectPoint);

                    result = _indicator.curvedFaceToFaceMeasure(_firstClick, _secondClick);
                }

                if (_consumeSingleClick) {

                    if (result.length === undefined) {

                        _angle = result;

                        if (_measurePanel) _measurePanel.showAngleResult();
                    }
                    else {

                        var ep1 = result[0].clone();
                        var ep2 = result[1].clone();

                        if (_viewer.model.is2d()) {
                            _viewer.model.pageToModel(ep1, ep2, _firstViewportIndex);
                        }

                        _distances.xyz = ep1.distanceTo(ep2);
                        _distances.x = Math.abs(ep1.x - ep2.x);
                        _distances.y = Math.abs(ep1.y - ep2.y);
                        _distances.z = Math.abs(ep1.z - ep2.z);

                        if (_measurePanel) {
                            // Add hideXYZ option because parallel faces should only display distance, not XYZ per Fusion's request
                            if (_firstClickGeometry === SNAP_FACE && _secondClickGeometry === SNAP_FACE)
                                _measurePanel.showDistanceResult(true);
                            else
                                _measurePanel.showDistanceResult();
                        }
                    }

                    if (_measurePanel) {
                        _measurePanel.showSelection2();
                        _measurePanel.updatePanel();
                    }
                    _indicator.updateDistance();
                    _indicator.updateAngle();

                    _secondClickNode = _snapper.getSnapNode();
                    _secondViewportIndex = _snapper.getViewportIndex();

                    if (_measurePanel && _measurePanel.isolateMeasure) {
                        this.isolateMeasurement();
                    }

                    // Clear the clip in snapper (enable snapper in greying out area) after the
                    // second selection, then user can select the objects in greying out area.
                    //if (_viewer.model.is2d() && _snapper)
                    //    _snapper.setClip();

                    if (_viewer.model.is2d()) {
                        viewer.impl.updateViewportId(0);

                        if (_snapper)
                            _snapper.setFirstClickVpId(null);
                    }
                }

                _indicator.updateLabelPositions();

            }
            return true;
        }
        else {  // show "rubber band" even when user is NOT over any 2nd pick geometry
            if (_activePoint === 2) {
                var cursorPosition = this.inverseProject(event.canvasX, event.canvasY);

                //if (_viewer.model.is2d() && !_viewer.model.pointInPolygon(cursorPosition.x, cursorPosition.y, _clip.contours, _clip.points))
                //    return false;

                if (_firstClickGeometry === SNAP_VERTEX) { // do vertex to vertex measure

                    _indicator.drawLine(_firstClick, cursorPosition);

                }
                else if (_firstClickGeometry === SNAP_EDGE) { // do edge to vertex measure

                    _indicator.edgeToPointMeasure(_firstClick, cursorPosition);

                }
                else if (_firstClickGeometry === SNAP_FACE) { // do face to vertex measure

                    _indicator.faceToPointMeasure(_firstClick, _firstFaceNormal, _firstIntersectPoint, cursorPosition);

                }
                else if (_firstClickGeometry === SNAP_CIRCULARARC) { // do circular arc to vertex measure

                    _indicator.drawLine(_firstCircularArcCenter, cursorPosition);

                }
                else if (_firstClickGeometry === SNAP_CURVEDEDGE) { // do curved edge to vertex measure

                    _indicator.curvedEdgeToVertexMeasure(_firstClick, cursorPosition);
                }
                else if (_firstClickGeometry === SNAP_CURVEDFACE) { // do curved face to vertex measure

                    _indicator.curvedFaceToVertexMeasure(_firstClick, cursorPosition);
                }
            }
        }
        return false;
    };

    this.inverseProject = function (canvasX, canvasY) {

        var camera = _viewer.navigation.getCamera(),
            containerBounds = _viewer.navigation.getScreenViewport(),
            p = new THREE.Vector3();

        p.x = canvasX / containerBounds.width * 2 - 1;
        p.y = -(canvasY / containerBounds.height * 2 - 1);
        p.z = 0;

        p = p.unproject(camera);

        return p;
    };

    this.handleButtonDown = function (event, button) {
        _isDragging = true;
        if (button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {

            _consumeSingleClick = true;
        }
        return false;
    };

    this.handleMouseMove = function (event) {
        _consumeSingleClick = false;
        if(_activePoint === 2) {
            this.clearRubberBand();
            this._handleMouseEvent(event);
        }
        return false;
    };

    this.handleButtonUp = function (event, button) {
        _isDragging = false;
        return false;
    };

    this.handleSingleClick = function (event, button) {
        if (_consumeSingleClick) {

            if (!this._handleMouseEvent(event)) {
                this.clearMeasurement();
                _activePoint = 0;
            }

            if (_activePoint === 1 || _activePoint === 2) {
                _activePoint = (_activePoint === 1) ? 2 : 0;
            }

            _consumeSingleClick = false;
        }
        return true;
    };

    this.handleDoubleClick = function( event, button ) {
        return true;
    };

    this.handleWheelInput = function (delta) {
        _indicator.updateScale();
        return false;
    };

    this.handleSingleTap = function (event) {
        return this.handleSingleClick(event);
    };

    this.handleDoubleTap = function(event) {
        return true;
    };

    this.handleResize = function() {
        if (_indicator) {
            _indicator.updateLabelPositions();
        }
    };

    // Create UI and initially hide it.
    function activateUI( )
    {
        if (!_indicator) {
            _indicator = new Indicator( _viewer );
        }
        _indicator.hide();

        if (_measurePanel) {
            _measurePanel.setVisible(true);
            _measurePanel.updatePanel();

            if (_viewer.model && _viewer.model.is2d()) {
                _measurePanel.isolate.setVisibility(false);
            }

            if (!_units) {
                _measurePanel.disableUnitOption();
            }
            else {
                _measurePanel.disableUnitOption(0);  // disable "Unknown" option when the model has units
            }
        }
    }

    function deactivateUI()
    {
        if (_indicator) {
            _indicator.hide();
            _indicator.destroy();
        }

        _distances = {};

        if (_measurePanel) {
            _measurePanel.setVisible(false);
            _measurePanel.updatePanel();
        }
    }

    // /** @constructor */
    function Indicator( viewer )
    {
        var that = this,
            _simple = false,
            kIndicatorColor = 0x1E8FFF,
            kIndicatorOpacity = 0.7,
            kEndPointOverlayName = 'MeasureTool-endPoint',
            kEdgeOverlayName = 'MeasureTool-edge',
            kFaceOverlayName = 'MeasureTool-face',
            kAngleOverlayName = 'MeasureTool-angle',
            kAngleOutlineOverlayName = 'MeasureTool-angle-outline',
            kExtensionLineOverlayName = 'MeasureTool-extensionLine',
            kExtensionFaceOverlayName = 'MeasureTool-extensionFace',
            kGreyOutPlaneOverlayName = 'MeasureTool-greyOutPlane',
            _materialPoint = null,
            _materialLine = null,
            _materialFace = null,
            _materialAngle = null,
            _materialAngleOutline = null,
            _materialExtensionLine = null,
            _materialExtensionFace = null,
            _materialGreyOutPlane = null,
            _endPoints = {first: {}, second: {}},
            _edges = {first: {}, second: {}},
            _faces = {first: {}, second: {}},
            _lines = {
                xyz: {axis: false, color: 'FF9900'},
                x:   {axis: true,  color: 'F12C2C'},
                y:   {axis: true,  color: '0BB80B'},
                z:   {axis: true,  color: '2C2CF1'}
            },
            _angleLabel = {},
            _labels = [],
            kHudOffset = 4; // pixels

        this.showFirstVertex = function( position )
        {
            var scale = this.setScale(position);
            this.showEndPoint('first', position, scale);
        };

        this.showSecondVertex = function( position )
        {
            var scale = this.setScale(position);
            this.showEndPoint('second', position, scale);
        };

        this.showEndPoint = function (name, position, scale) {
            if (!_materialPoint) {
                _materialPoint = new THREE.MeshPhongMaterial({
                    color: kIndicatorColor,
                    ambient: kIndicatorColor,
                    opacity: kIndicatorOpacity,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kEndPointOverlayName);
            }

            var endPoint = _endPoints[name],
                mesh = endPoint.mesh;

            if (!mesh) {
                endPoint.geometry = new THREE.SphereGeometry(1.0);
                mesh = endPoint.mesh = new THREE.Mesh(endPoint.geometry, _materialPoint);
                _viewer.impl.addOverlay(kEndPointOverlayName, mesh);
            }

            mesh.scale.x = scale;
            mesh.scale.y = scale;
            mesh.scale.z = scale;
            mesh.position.set(position.x, position.y, position.z);
            mesh.visible = true;

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);

            if (_consumeSingleClick || _redraw) {

                var label = endPoint.label;
                if (!label) {

                    label = endPoint.label = document.createElement('div');
                    label.className = 'measure-label';
                    _viewer.container.appendChild(label);

                    label.style.pointerEvents = 'none';

                    var label_icon = document.createElement('div');
                    label_icon.className = 'adsk-icon-' + name + ' measure-label-icon';
                    label.appendChild(label_icon);
                }

                label.classList.toggle('visible', true);

                endPoint.position = position.clone();

                this.updateLabelPositions();
            }
        };

        // Set scale for vertex and extension dashed line
        this.setScale = function (point) {

            var pixelSize = 5;

            var navapi = _viewer.navigation;
            var camera = navapi.getCamera();

            var view = navapi.getEyeVector();
            var position = navapi.getPosition();

            var p = point.clone();

            var distance = camera.isPerspective ? p.sub(position).dot(view.normalize())
                : navapi.getEyeVector().length();

            var fov = navapi.getVerticalFov();
            var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

            var viewport = navapi.getScreenViewport();
            var devicePixelRatio = window.devicePixelRatio || 1;
            var scale = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

            return scale;
        };

        // Update scale for vertex, edge, line and extension dash line
        this.updateScale = function() {

            var overlay = _viewer.impl.overlayScenes[kEndPointOverlayName];
            if (overlay) {
                var scene = overlay.scene;

                for (var i = 0; i < scene.children.length; i++) {
                    var pointMesh = scene.children[i];
                    if (pointMesh) {

                        var scale = this.setScale(pointMesh.position);
                        pointMesh.scale.x = scale;
                        pointMesh.scale.y = scale;
                        pointMesh.scale.z = scale;
                    }
                }
            }

            overlay = _viewer.impl.overlayScenes[kExtensionLineOverlayName];
            if (overlay) {
                var scene = overlay.scene;

                for (var i = 0; i < scene.children.length; i++) {
                    var extensionLine = scene.children[i];
                    if (extensionLine) {

                        var dashScale = this.setScale(extensionLine.geometry.vertices[0]);
                        extensionLine.material.dashSize = dashScale * 4;
                        extensionLine.material.gapSize = dashScale * 2;
                    }
                }
            }

            overlay = _viewer.impl.overlayScenes[kEdgeOverlayName];
            if (overlay) {
                var scene = overlay.scene;

                for (var i = 0; i < scene.children.length; i++) {
                    var cylinderMesh = scene.children[i];
                    if (cylinderMesh) {
                        this.setCylinderScale(cylinderMesh);
                    }
                }
            }

            overlay = _viewer.impl.overlayScenes[kAngleOutlineOverlayName];
            if (overlay) {
                var scene = overlay.scene;

                for (var i = 0; i < scene.children.length; i++) {
                    var cylinderMesh = scene.children[i];
                    if (cylinderMesh) {
                        this.setCylinderScale(cylinderMesh);
                    }
                }
            }

            for (var name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        this.setCylinderScale(item.line);
                    }
                }
            }
        };

        this.showFirstEdge = function(geom, point)
        {
            this.showEdge('first', geom, point);
        };

        this.showSecondEdge = function(geom, point)
        {
            this.showEdge('second', geom, point);
        };

        this.showEdge = function(name, geom, point) {

            if (!_materialLine) {

                _materialLine = new THREE.MeshPhongMaterial({
                    color: kIndicatorColor,
                    ambient: kIndicatorColor,
                    opacity: kIndicatorOpacity,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });

                _viewer.impl.createOverlayScene(kEdgeOverlayName);
            }

            var edge = _edges[name];

            if (edge.line) {
                _viewer.impl.removeMultipleOverlays(kEdgeOverlayName, edge.line);
            }

            edge.line = this.drawEdgeAsCylinder(geom, _materialLine, 5, 1);
            _viewer.impl.addMultipleOverlays(kEdgeOverlayName, edge.line);

            if (_consumeSingleClick || _redraw) {

                var label = edge.label;
                if (!label) {

                    label = edge.label = document.createElement('div');
                    label.className = 'measure-label';
                    _viewer.container.appendChild(label);

                    label.style.pointerEvents = 'none';

                    // Stop showing length of edges per Jay's request
                    //var label_text = document.createElement('div');
                    //label_text.className = 'measure-label-text';
                    //label.appendChild(label_text);
                    var label_icon = document.createElement('div');
                    label_icon.className = 'adsk-icon-' + name + ' measure-label-icon';
                    label.appendChild(label_icon);
                }

                //label.children[0].textContent = this.getEdgeLength(geom);
                label.classList.toggle('visible', true);

                edge.intersectPoint = point.clone();

                this.updateLabelPositions();
            }
        };

        // This is a workaround to deal with the limitation on linewidth on Windows due to the ANGLE library
        this.drawEdgeAsCylinder = function(geom, material, linewidth, type) {

            // The array for all cylinders
            var edge = [];

            if (type == 1) { // LinePieces
                for (var i = 0; i < geom.vertices.length; i += 2) {
                    var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, linewidth);
                    this.setCylinderScale(cylinder);
                    edge.push(cylinder);
                }
            }
            else { // LineStrip
                for (var i = 0; i < geom.vertices.length - 1; i++) {
                    var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, linewidth);
                    this.setCylinderScale(cylinder);
                    edge.push(cylinder);
                }
            }


            return edge;
        };

        // This is a workaround to deal with the limitation on linewidth on Windows due to the ANGLE library
        this.drawLineAsCylinder = function(geom, material, linewidth) {

            var line;

            if (geom.vertices.length == 2) {
                line = this.cylinderMesh(geom.vertices[0], geom.vertices[1], material, linewidth);
                this.setCylinderScale(line);
            }

            return line;
        };

        this.cylinderMesh = function(pointX, pointY, material, linewidth) {

            var direction = new THREE.Vector3().subVectors(pointY, pointX);
            var orientation = new THREE.Matrix4();
            orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
            orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
                0, 0, 1, 0,
                0, -1, 0, 0,
                0, 0, 0, 1));

            var edgeGeometry = new THREE.CylinderGeometry(0.1 * linewidth, 0.1 * linewidth, direction.length(), 8, 1, true);
            var edge = new THREE.Mesh(edgeGeometry, material);
            edge.applyMatrix(orientation);
            edge.position.x = (pointY.x + pointX.x) / 2;
            edge.position.y = (pointY.y + pointX.y) / 2;
            edge.position.z = (pointY.z + pointX.z) / 2;

            return edge;
        };

        // Set scale for cylinder
        this.setCylinderScale = function (cylinderMesh) {

            var scale = this.setScale(cylinderMesh.position);
            cylinderMesh.scale.x = scale;
            cylinderMesh.scale.z = scale;
        };

        this.showFirstFace = function(geom, point) {

            this.showFace('first', geom, point);
        };

        this.showSecondFace = function(geom, point) {

            this.showFace('second', geom, point);
        };

        this.showFace = function(name, geom, point) {

            if (!_materialFace) {
                _materialFace = new THREE.MeshPhongMaterial({
                        color: kIndicatorColor,
                        ambient: kIndicatorColor,
                        opacity: kIndicatorOpacity,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _viewer.impl.createOverlayScene(kFaceOverlayName);
            }

            var face = _faces[name];

            if (face.mesh) {
                _viewer.impl.removeOverlay(kFaceOverlayName, face.mesh);
            }

            face.mesh = new THREE.Mesh(geom, _materialFace);
            _viewer.impl.addOverlay(kFaceOverlayName, face.mesh);

            if (_consumeSingleClick || _redraw) {

                var label = face.label;
                if (!label) {

                    label = face.label = document.createElement('div');
                    label.className = 'measure-label';
                    _viewer.container.appendChild(label);

                    label.style.pointerEvents = 'none';

                    // Stop showing area of faces per Jay's request
                    //var label_text = document.createElement('div');
                    //label_text.className = 'measure-label-text';
                    //label.appendChild(label_text);
                    var label_icon = document.createElement('div');
                    label_icon.className = 'adsk-icon-' + name + ' measure-label-icon';
                    label.appendChild(label_icon);
                }

                //label.children[0].textContent = this.getFaceArea(geom);
                label.classList.toggle('visible', true);

                face.intersectPoint = point.clone();

                this.updateLabelPositions();
            }
        };

        this.drawExtensionFace = function(geom, intersectPoint, normal) {

            if (!_materialExtensionFace) {
                _materialExtensionFace = new THREE.MeshPhongMaterial({
                        color: 0x66CCFF,
                        ambient: 0x00CCFF,
                        opacity: 0.2,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _viewer.impl.createOverlayScene(kExtensionFaceOverlayName);
            }

            var face = new THREE.Mesh(geom, _materialExtensionFace);

            face.position.set(intersectPoint.x, intersectPoint.y, intersectPoint.z);
            var V = face.position.clone();
            V.add(normal);
            face.lookAt(V);
            face.updateMatrixWorld();

            _viewer.impl.addOverlay(kExtensionFaceOverlayName, face);
        };

        this.drawGreyOutPlane = function(vpId) {

            if (!_materialGreyOutPlane) {
                _materialGreyOutPlane = new THREE.MeshPhongMaterial({
                        color: 0x000000,
                        ambient: 0x000000,
                        opacity: 0.5,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _viewer.impl.createOverlayScene(kGreyOutPlaneOverlayName);
            }

            var pw = _viewer.model.getMetadata('page_dimensions', 'page_width');
            var ph = _viewer.model.getMetadata('page_dimensions', 'page_height');

            var paperShape = new THREE.Shape();
            paperShape.moveTo(0, 0);
            paperShape.lineTo(pw, 0);
            paperShape.lineTo(pw, ph);
            paperShape.lineTo(0, ph);
            paperShape.lineTo(0, 0);

            var clip = _clip = _viewer.model.getClip(vpId);

            // TODO: Need to handle multiple contours in clip, for now we only draw the first one.
            var cntr = clip.contours[0];
            var clipPath = new THREE.Path();
            clipPath.moveTo(clip.points[cntr[0]].x, clip.points[cntr[0]].y);
            for (var i = 1; i < cntr.length; i++) {
                clipPath.lineTo(clip.points[cntr[i]].x, clip.points[cntr[i]].y);
            }
            clipPath.lineTo(clip.points[cntr[0]].x, clip.points[cntr[0]].y);

            paperShape.holes.push(clipPath);

            var paperGeom = new THREE.ShapeGeometry(paperShape);
            var paperMesh = new THREE.Mesh(paperGeom, _materialGreyOutPlane);

            _viewer.impl.addOverlay(kGreyOutPlaneOverlayName, paperMesh);
        };

        this.getEdgeLength = function(edge) {

            var length = 0;
            var eg = edge.clone();
            var vertices = eg.vertices;
            for (var i = 0; i < vertices.length; i += 2) {

                if (_viewer.model.is2d()) {
                    _viewer.model.pageToModel(vertices[i], vertices[i + 1], _firstViewportIndex);
                }

                length += vertices[i].distanceTo(vertices[i + 1]);
            }

            length = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, length);

            return Autodesk.Viewing.Private.formatValueWithUnits(length, _units, 3, _precision);
        };

        this.getCircularArcRadius = function(edge) {

            var radius = edge.radius;

            if (radius) {
                if (_viewer.model.is2d()) {
                    var pt1 = edge.center.clone();
                    var pt2 = edge.vertices[0].clone();
                    _viewer.model.pageToModel(pt1, pt2, _firstViewportIndex);
                    radius = pt1.distanceTo(pt2);
                }

                radius = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, radius);
                return Autodesk.Viewing.Private.formatValueWithUnits(radius, _units, 3, _precision);
            }
        };

        this.getFaceArea = function(face) {

            var area = 0;
            var vertices = face.vertices;
            var V1 = new THREE.Vector3();
            var V2 = new THREE.Vector3();

            for (var i = 0; i < vertices.length; i += 3) {

                V1.subVectors(vertices[i + 1], vertices[i]);
                V2.subVectors(vertices[i + 2], vertices[i]);

                area += V1.length() * V2.length() * Math.sin(V1.angleTo(V2)) / 2;
            }

            area = Autodesk.Viewing.Private.convertUnits(_viewer.model.getUnitString(), _units, area, 'square');

            if (_units) {

                return Autodesk.Viewing.Private.formatValueWithUnits(area, _units+'^2', 3, _precision);
            }
            else {

                return Autodesk.Viewing.Private.formatValueWithUnits(area, null, 3, _precision);
            }

        };

        this.updateLabels = function() {

            if (_firstClickGeometry === SNAP_EDGE) { // edge

                _edges['first'].label.children[0].textContent = this.getEdgeLength(_firstClick);
            }
            else if (_firstClickGeometry === SNAP_FACE) { // face

                _faces['first'].label.children[0].textContent = this.getFaceArea(_firstClick);
            }

            if (_secondClickGeometry === SNAP_EDGE) { // edge

                _edges['second'].label.children[0].textContent = this.getEdgeLength(_secondClick);
            }
            else if (_secondClickGeometry === SNAP_FACE) { // face

                _faces['second'].label.children[0].textContent = this.getFaceArea(_secondClick);
            }

        };

        this.updateLabelPositions = function () {
            function project(x, y, z) {
                var camera = _viewer.navigation.getCamera(),
                    containerBounds = _viewer.navigation.getScreenViewport(),
                    p = new THREE.Vector3(x, y, z);

                p = p.project(camera);

                return {
                    x: Math.round(( p.x + 1) / 2 * containerBounds.width) + 5,    // Add 5px to make the label not to be on the object
                    y: Math.round((-p.y + 1) / 2 * containerBounds.height) + 5    // Add 5px to make the label not to be on the object
                };
            }

            function placeLabelXYZ(item) {
                var p1 = item.p1,
                    p2 = item.p2,
                    p1xy = project(p1.x, p1.y, p1.z),
                    p2xy = project(p2.x, p2.y, p2.z),
                    dx = p2xy.x - p1xy.x,
                    dy = p2xy.y - p1xy.y,
                    xy = project(p2.x, p2.y, p2.z),
                    x = xy.x,
                    y = xy.y,
                    labelRect = item.label.getBoundingClientRect();

                if (0 < dy) {
                    y += kHudOffset;
                } else {
                    y -= (labelRect.height + kHudOffset);
                }
                if ((dx < 0) || (0 < dy)) {
                    x -= (labelRect.width + kHudOffset);
                } else {
                    x += kHudOffset;
                }

                return {x: x, y: y};
            }

            function placeLabelAxis(item, itemXYZ) {
                var p1 = item.p1,
                    p2 = item.p2,
                    mx = p1.x + (p2.x - p1.x) / 2,
                    my = p1.y + (p2.y - p1.y) / 2,
                    mz = p1.z + (p2.z - p1.z) / 2,
                    xy = project(mx, my, mz),
                    x = xy.x,
                    y = xy.y,
                    p1xyz = itemXYZ.p1,
                    p2xyz = itemXYZ.p2,
                    p1xy = project(p1xyz.x, p1xyz.y, p1xyz.z),
                    p2xy = project(p2xyz.x, p2xyz.y, p2xyz.z),
                    cx = (x + p1xy.x + p2xy.x) / 3,
                    cy = (y + p1xy.y + p2xy.y) / 3,
                    dx = x - cx,
                    dy = y - cy,
                    labelRect = item.label.getBoundingClientRect(),
                    halfLabelWidth = labelRect.width / 2,
                    halfLabelHeight = labelRect.height / 2;

                x -= halfLabelWidth;
                y -= halfLabelHeight;

                if (0 < dx) {
                    x += halfLabelWidth;
                } else {
                    x -= halfLabelWidth;
                }

                if (0 < dy) {
                    y += halfLabelHeight;
                } else {
                    y -= halfLabelHeight;
                }

                return {x: x, y: y};
            }

            for (var name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name],
                        label = item.label;

                    if (label) {
                        var xy = project((item.p1.x + item.p2.x)/2, (item.p1.y + item.p2.y)/2, (item.p1.z + item.p2.z)/2); // TODO: avoid collisions for labels
                        label.style.top  = xy.y + 'px';
                        label.style.left = xy.x + 'px';
                        _labels.push(label);
                    }
                }
            }

            if (_angleLabel) {

                label = _angleLabel.label;

                if (label) {
                    var xy = project((_angleLabel.p1.x + _angleLabel.p2.x)/2, (_angleLabel.p1.y + _angleLabel.p2.y)/2, (_angleLabel.p1.z + _angleLabel.p2.z)/2); // TODO: avoid collisions for labels
                    label.style.top = xy.y + 'px';
                    label.style.left = xy.x + 'px';
                    _labels.push(label);
                }
            }

            for (var name in _faces) {
                if (_faces.hasOwnProperty(name)) {
                    var face = _faces[name],
                        label = face.label,
                        point = face.intersectPoint;

                    if (label && point) {
                        var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                        label.style.top  = xy.y + 'px';
                        label.style.left = xy.x + 'px';
                        _labels.push(label);
                    }
                }
            }

            for (var name in _edges) {
                if (_edges.hasOwnProperty(name)) {
                    var edge = _edges[name],
                        label = edge.label,
                        point = edge.intersectPoint;

                    if (label && point) {
                        var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                        label.style.top  = xy.y + 'px';
                        label.style.left = xy.x + 'px';
                        _labels.push(label);
                    }
                }
            }

            for (var name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name],
                        label = endPoint.label,
                        point = endPoint.position;

                    if (label && point) {
                        var xy = project(point.x, point.y, point.z); // TODO: avoid collisions for labels
                        label.style.top  = xy.y + 'px';
                        label.style.left = xy.x + 'px';
                        _labels.push(label);
                    }
                }
            }

            for (var i = 0; i < _labels.length; i++) {
                for (var j = 0; j < i; j++) {
                    this.labelsOverlapDetection(_labels[j], _labels[i]);
                }
            }
            _labels = [];
        };

        this.labelsOverlapDetection = function(label1, label2) {

            var rect1 = label1.getBoundingClientRect();
            var rect2 = label2.getBoundingClientRect();

            //if ((rect2.top <= rect1.bottom && rect2.top >= rect1.top) || (rect2.bottom <= rect1.bottom && rect2.bottom >= rect1.top)) {
            if (rect2.top <= rect1.bottom && rect2.bottom >= rect1.top) {
                if (rect2.right >= rect1.left && rect2.right <= rect1.right) {
                    label2.style.left = parseInt(label2.style.left, 10) - (rect2.right - rect1.left) + 'px';
                }
                else if (rect2.left >= rect1.left && rect2.left <= rect1.right) {
                    label2.style.left = parseInt(label2.style.left, 10) + (rect1.right - rect2.left) + 'px';
                }
                else if (rect2.left <= rect1.left && rect2.right >= rect1.right) {
                    label2.style.left = parseInt(label2.style.left, 10) + (rect1.right - rect2.left) + 'px';
                }
            }
        };

        // Draw distance measurement
        this.drawLine = function( p1, p2, /*optional*/ hideXYZ )
        {
            function updateLine(name, x1, y1, z1, x2, y2, z2, showAxis) {
                var item = _lines[name],
                    line = item.line,
                    label = item.label,
                    p1 = new THREE.Vector3(x1, y1, z1),
                    p2 = new THREE.Vector3(x2, y2, z2);

                if (line) {
                    _viewer.impl.removeOverlay('MeasureTool-' + name, line);
                    item.line = null;
                }
                if (label) {
                    label.classList.remove('visible');
                }

                if (p1.distanceTo(p2) >= Math.pow(0.1, _precision) && showAxis) {

                    var show = (name === 'xyz' || (!_simple && _consumeSingleClick));

                    if (!line) {
                        item.material = new THREE.MeshBasicMaterial({
                            color: parseInt(item.color, 16),
                            depthTest: false,
                            depthWrite: false
                        });
                        item.overlayName = 'MeasureTool-' + name;
                        _viewer.impl.createOverlayScene(item.overlayName);

                    }

                    // make the rubber band 50% transparent.
                    if (_consumeSingleClick) {
                        item.material.opacity = 1;
                    }
                    else {
                        item.material.opacity = kIndicatorOpacity;
                    }

                    _viewer.impl.clearOverlay(item.overlayName);

                    var geometry = item.geometry = new THREE.Geometry();
                    geometry.vertices.push(p1);
                    geometry.vertices.push(p2);

                    var linewidth = (name === 'xyz' ? 5 : (name === 'z' ? 1 : 2));
                    line = item.line = that.drawLineAsCylinder(geometry, item.material, linewidth);
                    _viewer.impl.addOverlay(item.overlayName, line);

                    line.visible = show;

                    item.p1 = p1;
                    item.p2 = p2;

                    if (name != 'xyz' || _consumeSingleClick) {

                        if (!label) {
                            label = item.label = document.createElement('div');
                            label.className = 'measure-length';

                            if (name === 'xyz') {
                                var text = document.createElement('div');
                                text.className = 'measure-length-text';
                                label.appendChild(text);

                                // This button is for Markup and Comments
                                //var button = document.createElement('div');
                                //button.className = 'measure-length-button';
                                //button.style.cursor = 'pointer';
                                //button.addEventListener('click', function (event) {
                                //
                                //}, true);
                                //label.appendChild(button);

                            }

                            label.style.pointerEvents = 'none';

                            if (item.axis) {
                                //label.style.color = '#' + item.color;
                                //label.style.backgroundColor = 'transparent';
                                //label.textContent = name.toUpperCase();
                                label.className = 'adsk-icon-axis-' + name + ' measure-label-axis measure-label-axis-' + name;
                            }

                            _viewer.container.appendChild(label);
                        }

                        if (!item.axis) {
                            that.updateDistance();
                        }
                        label.classList.toggle('visible', show);
                    }
                }
            }

            // If the line aligns with one of axis, then don't show axis
            function displayAxis(p1, p2) {
                var prec = Math.pow(0.1, _precision);

                if ((Math.abs(p1.x - p2.x) >= prec && Math.abs(p1.y - p2.y) < prec && Math.abs(p1.z - p2.z) < prec)
                    || (Math.abs(p1.y - p2.y) >= prec && Math.abs(p1.x - p2.x) < prec && Math.abs(p1.z - p2.z) < prec)
                    || (Math.abs(p1.z - p2.z) >= prec && Math.abs(p1.x - p2.x) < prec && Math.abs(p1.y - p2.y) < prec)) {
                    return false;
                }

                return true;
            }

            updateLine('xyz', p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, true);

            var up = _viewer.navigation.getAlignedUpVector(),
                x = Math.abs(up.x),
                y = Math.abs(up.y),
                z = Math.abs(up.z);

            var showAxis = hideXYZ ? false : displayAxis(p1, p2);

            if (z > x && z > y) { // z up
                updateLine('x', p1.x, p1.y, p1.z, p2.x, p1.y, p1.z, showAxis);
                updateLine('y', p2.x, p1.y, p1.z, p2.x, p2.y, p1.z, showAxis);
                updateLine('z', p2.x, p2.y, p1.z, p2.x, p2.y, p2.z, showAxis);

            } else if (y > x && y > z) { // y up
                updateLine('x', p1.x, p1.y, p1.z, p2.x, p1.y, p1.z, showAxis);
                updateLine('z', p2.x, p1.y, p1.z, p2.x, p1.y, p2.z, showAxis);
                updateLine('y', p2.x, p1.y, p2.z, p2.x, p2.y, p2.z, showAxis);

            } else { // x up - do we ever see this?
                updateLine('y', p1.x, p1.y, p1.z, p1.x, p2.y, p1.z, showAxis);
                updateLine('z', p1.x, p2.y, p1.z, p1.x, p2.y, p2.z, showAxis);
                updateLine('x', p1.x, p2.y, p2.z, p2.x, p2.y, p2.z, showAxis);
            }

            this.updateLabelPositions();
        };

        // Update distance measurement label
        this.updateDistance = function () {
            var label = _lines.xyz.label;
            if (label) {
                label.children[0].textContent = "~ " + tool.getDistance('xyz');
            }
        };

        // Update angle measurement label
        this.updateAngle = function() {
            var label = _angleLabel.label;
            if (label) {
                label.children[0].textContent = "~ " + tool.getAngle();
            }
        };

        this.drawExtensionLine = function(point, lineStart, lineEnd) {

            var p1, p2;
            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            X0.subVectors(lineEnd, lineStart);
            X0.multiplyScalar(param);
            nearestPoint = X0.add(lineStart);


            if (param < 0) {
                p1 = lineStart;
                p2 = nearestPoint;
            }
            else if (param > 1) {
                p1 = lineEnd;
                p2 = nearestPoint;
            }
            else {
                return;
            }

            if (!_materialExtensionLine) {

                _materialExtensionLine = new THREE.LineDashedMaterial({
                    color: 0x0033FF,
                    linewidth: 1,
                    dashSize: 1,
                    gapSize: 0.5,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kExtensionLineOverlayName);
            }

            // make the rubber band 50% transparent.
            if (_consumeSingleClick) {
                _materialExtensionLine.opacity = 1;
            }
            else {
                _materialExtensionLine.opacity = kIndicatorOpacity;
            }

            var dashScale = this.setScale(p1);
            _materialExtensionLine.dashSize = dashScale * 4;
            _materialExtensionLine.gapSize = dashScale * 2;

            var geometry = new THREE.Geometry();
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);

            geometry.computeLineDistances();

            var line = new THREE.Line(geometry, _materialExtensionLine);
            _viewer.impl.addOverlay(kExtensionLineOverlayName, line);
        };

        this.drawExtensionLinePointToPoint = function(lineStart, lineEnd) {

            var p1 = lineStart;
            var p2 = lineEnd;

            if (!_materialExtensionLine) {

                _materialExtensionLine = new THREE.LineDashedMaterial({
                    color: 0x0033FF,
                    linewidth: 1,
                    dashSize: 1,
                    gapSize: 0.5,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kExtensionLineOverlayName);
            }

            // make the rubber band 50% transparent.
            if (_consumeSingleClick) {
                _materialExtensionLine.opacity = 1;
            }
            else {
                _materialExtensionLine.opacity = kIndicatorOpacity;
            }

            var dashScale = this.setScale(p1);
            _materialExtensionLine.dashSize = dashScale * 4;
            _materialExtensionLine.gapSize = dashScale * 2;

            var geometry = new THREE.Geometry();
            geometry.vertices.push(p1);
            geometry.vertices.push(p2);

            geometry.computeLineDistances();

            var line = new THREE.Line(geometry, _materialExtensionLine);
            _viewer.impl.addOverlay(kExtensionLineOverlayName, line);
        };

        // Get the two nearest endpoints between two line segments
        this.nearestPointsInSegmentToSegment = function (p1, p2, p3, p4) {

            var smallNum = 0.001;
            var u = new THREE.Vector3();
            var v = new THREE.Vector3();
            var w = new THREE.Vector3();

            u.subVectors(p2, p1);
            v.subVectors(p4, p3);
            w.subVectors(p1, p3);

            var a = u.dot(u);
            var b = u.dot(v);
            var c = v.dot(v);
            var d = u.dot(w);
            var e = v.dot(w);
            var D = a * c - b * b;
            var sc, sN, sD = D;
            var tc, tN, tD = D;

            // Compute the line parameters of the two closest points
            if (D < smallNum) { // the lines are almost parallel
                sN = 0.0;  // for using point p1 on segment p1p2
                sD = 1.0;  // to prevent possible division by 0.0 later
                tN = e;
                tD = c;
            }
            else {  // get the closest points on the infinite lines
                sN = b * e - c * d;
                tN = a * e - b * d;
                if (sN < 0.0) {  // sc < 0 => the s = 0 is visible
                    sN = 0.0;
                    tN = e;
                    tD = c;
                }
                else if (sN > sD) {  // sc > 1 => the s = 1 edge is visible
                    sN = sD;
                    tN = e + b;
                    tD = c;
                }
            }

            if (tN < 0.0) {  // tc < 0 => the t = 0 edge is visible
                tN = 0.0;
                // recompute sc for this edge
                if (-d < 0.0)
                    sN = 0.0;
                else if (-d > a)
                    sN = sD;
                else {
                    sN = -d;
                    sD = a;
                }
            }
            else if (tN > tD) {  // tc > 1 => the t = 1 edge is visible
                tN = tD;
                // recompute sc for this edge
                if ((-d + b) < 0.0)
                    sN = 0;
                else if ((-d + b) > a)
                    sN = sD;
                else {
                    sN = -d + b;
                    sD = a;
                }
            }

            // finally do the division to get sc and tc
            sc = Math.abs(sN) < smallNum ? 0.0 : sN / sD;
            tc = Math.abs(tN) < smallNum ? 0.0 : tN / tD;

            // get the difference of the two closest points
            u.multiplyScalar(sc);
            v.multiplyScalar(tc);
            w.add(u);
            w.sub(v);

            //return w.length();

            u.add(p1);
            v.add(p3);
            return [u, v];
        };

        // Measure from Edge to Edge
        this.edgeToEdgeMeasure = function(edge1, edge2, intersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge1);
            var p1 = eps[0].clone();
            var p2 = eps[1].clone();
            eps = _snapper.getEndPointsInEdge(edge2);
            var p3 = eps[0].clone();
            var p4 = eps[1].clone();

            var va = this.nearestPointInPointToLine(p1, p3, p4);
            var vb = this.nearestPointInPointToLine(p2, p3, p4);

            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();

            v1.subVectors(p1, p2);
            v2.subVectors(p3, p4);
            v1.normalize();
            v2.normalize();

            // Draw distance line between parallel edges
            if (this.isEqualVectors(v1, v2, smallNum) || this.isInverseVectors(v1, v2, smallNum)) {

                // Measure the endpoint closest to the intersection point
                if (p1.distanceTo(intersectPoint) <= p2.distanceTo(intersectPoint)) {

                    this.drawLine(p1, va);
                    this.drawExtensionLine(p1, p3, p4);
                    return [p1, va];
                }
                else {

                    this.drawLine(p2, vb);
                    this.drawExtensionLine(p2, p3, p4);
                    return [p2, vb];
                }
            }
            else {  // Draw arc

                // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
                // because we don't want to draw the arc so big, this is consistent with Fusion
                var newEp = this.nearestPointInPointToLine(intersectPoint, p1, p2);

                var angle = this.angleVectorToVector(v1, v2);

                // Find the nearest endpoints of the two edges
                // Draw arc between p1p2 and p3p4
                if (p1.distanceTo(p3) < p1.distanceTo(p4) && p1.distanceTo(p3) < p2.distanceTo(p3) && p1.distanceTo(p3) < p2.distanceTo(p4)) {

                    this.drawAngleLineToLine(p1, newEp, p3, p4, angle);
                }
                // Draw arc between p1p2 and p4p3
                else if (p1.distanceTo(p4) < p1.distanceTo(p3) && p1.distanceTo(p4) < p2.distanceTo(p3) && p1.distanceTo(p4) < p2.distanceTo(p4)) {

                    this.drawAngleLineToLine(p1, newEp, p4, p3, angle);
                }
                // Draw arc between p2p1 and p3p4
                else if (p2.distanceTo(p3) < p1.distanceTo(p3) && p2.distanceTo(p3) < p1.distanceTo(p4) && p2.distanceTo(p3) < p2.distanceTo(p4)) {

                    this.drawAngleLineToLine(p2, newEp, p3, p4, angle);
                }
                // Draw arc between p2p1 and p4p3
                else {  // if (p2.distanceTo(p4) < p1.distanceTo(p3) && p2.distanceTo(p4) < p1.distanceTo(p4) && p2.distanceTo(p4) < p2.distanceTo(p3)) {

                    this.drawAngleLineToLine(p2, newEp, p4, p3, angle);
                }

                return angle;
            }

        };

        // Measure between Curved Edge and Straight Edge
        this.curvedEdgeToEdgeMeasure = function (curvedEdge, edge) {

            var minDist = Number.MAX_VALUE;
            var nP1 = null;
            var nP2 = null;

            var vertices = curvedEdge.vertices;
            var eps = _snapper.getEndPointsInEdge(edge);

            for (var i = 0; i < vertices.length; i += 2) {
                var tempPs = this.nearestPointsInSegmentToSegment(vertices[i], vertices[i + 1], eps[0], eps[1]);
                var dist = tempPs[0].distanceTo(tempPs[1]);
                if (dist < minDist) {
                    minDist = dist;
                    nP1 = tempPs[0];
                    nP2 = tempPs[1];
                }
            }

            this.drawLine(nP1, nP2);

            return [nP1, nP2];
        };

        // Measure between Curved Edge and Curved Edge
        this.curvedEdgeToCurvedEdgeMeasure = function (edge1, edge2) {

            var minDist = Number.MAX_VALUE;
            var nP1 = null;
            var nP2 = null;

            var vertices1 = edge1.vertices;
            var vertices2 = edge2.vertices;

            for (var i = 0; i < vertices1.length; i += 2)
                for (var j = 0; j < vertices2.length; j += 2) {
                    var tempPs = this.nearestPointsInSegmentToSegment(vertices1[i], vertices1[i + 1], vertices2[j], vertices2[j + 1]);
                    var dist = tempPs[0].distanceTo(tempPs[1]);
                    if (dist < minDist) {
                        minDist = dist;
                        nP1 = tempPs[0];
                        nP2 = tempPs[1];
                    }
                }

            this.drawLine(nP1, nP2);

            return [nP1, nP2];
        };

        // Get the nearest point on the line segment from point to line segment
        this.nearestPointInPointToSegment = function (point, lineStart, lineEnd) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            if (param < 0) {
                nearestPoint = lineStart;
            }
            else if (param > 1) {
                nearestPoint = lineEnd;
            }
            else {
                X0.subVectors(lineEnd, lineStart);
                X0.multiplyScalar(param);
                nearestPoint = X0.add(lineStart);
            }

            return nearestPoint;
        };

        // Get the nearest point on the line from point to line
        this.nearestPointInPointToLine = function(point, lineStart, lineEnd) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();
            var nearestPoint;
            var param;

            X0.subVectors(lineStart, point);
            X1.subVectors(lineEnd, lineStart);
            param = X0.dot(X1);
            X0.subVectors(lineEnd, lineStart);
            param = -param / X0.dot(X0);

            X0.subVectors(lineEnd, lineStart);
            X0.multiplyScalar(param);
            nearestPoint = X0.add(lineStart);

            return nearestPoint;
        };

        // Measure from Point to Edge
        this.pointToEdgeMeasure = function(point, edge, intersectPoint) {

            var eps = _snapper.getEndPointsInEdge(edge);

            var lineStart = eps[0];
            var lineEnd = eps[1];

            var X0 = this.nearestPointInPointToLine(point, lineStart, lineEnd);
            var X1 = this.nearestPointInPointToLine(intersectPoint, lineStart, lineEnd);

            var p1 = new THREE.Vector3();
            p1.subVectors(X1, X0);
            p1.add(point);

            this.drawLine(p1, X1);

            this.drawExtensionLinePointToPoint(point, p1);

            return [point, X0];
        };

        // Measure from Edge to Point
        this.edgeToPointMeasure = function(edge, point) {

            var eps = _snapper.getEndPointsInEdge(edge);

            var lineStart = eps[0];
            var lineEnd = eps[1];

            var X0 = this.nearestPointInPointToLine(point, lineStart, lineEnd);

            this.drawLine(point, X0);

            this.drawExtensionLine(point, lineStart, lineEnd);

            return [point, X0];
        };

        // Measure between Curved Edge and Vertex
        this.curvedEdgeToVertexMeasure = function(edge, point) {

            var vertices = edge.vertices;
            var minDist = Number.MAX_VALUE;
            var nearestPoint = null;

            for (var i = 0; i < vertices.length; i += 2) {

                var nP = this.nearestPointInPointToSegment(point, vertices[i], vertices[i + 1]);
                var dist = point.distanceTo(nP);
                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = nP;
                }
            }

            this.drawLine(point, nearestPoint);

            return [point, nearestPoint];
        };

        // Measure from Face to Face
        this.faceToFaceMeasure = function(p1, n1, p2, n2) {

            var smallNum = 0.01;
            var firstNormal = n1.clone();
            var secondNormal = n2.clone();

            var angle = this.angleVectorToVector(n1, n2);

            if (((firstNormal.x <= secondNormal.x + smallNum) && (firstNormal.x >= secondNormal.x - smallNum)
                && (firstNormal.y <= secondNormal.y + smallNum) && (firstNormal.y >= secondNormal.y - smallNum)
                && (firstNormal.z <= secondNormal.z + smallNum) && (firstNormal.z >= secondNormal.z - smallNum))
                || ((firstNormal.x <= -secondNormal.x + smallNum) && (firstNormal.x >= -secondNormal.x - smallNum)
                && (firstNormal.y <= -secondNormal.y + smallNum) && (firstNormal.y >= -secondNormal.y - smallNum)
                && (firstNormal.z <= -secondNormal.z + smallNum) && (firstNormal.z >= -secondNormal.z - smallNum)))
            {
                var X0 = new THREE.Vector3();
                X0.subVectors(p1, p2);
                var t = firstNormal.dot(X0) / firstNormal.dot(secondNormal);

                X0.addVectors(p2, secondNormal.multiplyScalar(t));

                //var dist = new THREE.Vector3();
                //dist.subVectors(X0, p1);
                //var extendFace = _faces['first'].mesh.geometry.clone();
                //extendFace.applyMatrix(new THREE.Matrix4().makeTranslation(dist.x, dist.y, dist.z));

                var dist = X0.distanceTo(p1) * 2;
                var extendFace = new THREE.PlaneBufferGeometry(dist, dist);
                this.drawExtensionFace(extendFace, p1, n1);
                //this.drawExtensionLinePointToPoint(p1, X0);

                this.drawLine(p2, X0, true);
                return [p2, X0, angle];
            }
            else {

                //this.drawLine(p1, p2);
                //return [p1, p2, angle];

                angle = this.drawAngleFaceToFace(p1, n1, p2, n2);
                return angle;
            }
        };

        this.angleVectorToVector = function(v1, v2) {

            var a = v1.angleTo(v2) * 180 / Math.PI;
            return a;
        };

        // Find the intersection of two nonparallel planes
        this.intersectPlaneToPlane = function(p1, n1, p2, n2) {

            var u = new THREE.Vector3();
            u.crossVectors(n1, n2);
            var ax = (u.x >= 0 ? u.x : -u.x);
            var ay = (u.y >= 0 ? u.y : -u.y);
            var az = (u.z >= 0 ? u.z : -u.z);

            var maxc;  // max coordinate
            if (ax > ay) {
                if (ax > az)
                    maxc = 1;
                else
                    maxc = 3;
            }
            else {
                if (ay > az)
                    maxc = 2;
                else maxc = 3;
            }

            var iP = new THREE.Vector3(); // intersect point
            var d1, d2;
            d1 = -n1.dot(p1);
            d2 = -n2.dot(p2);

            switch (maxc) {

                case 1:  // intersect with x = 0
                    iP.x = 0;
                    if (u.x !== 0) {
                        iP.y = (d2 * n1.z - d1 * n2.z) / u.x;
                        iP.z = (d1 * n2.y - d2 * n1.y) / u.x;
                    }
                    else {
                        iP.y = - (d2 * n1.z) / (n1.z * n2.y);
                        iP.z = - (d1 * n2.y) / (n1.z * n2.y);
                    }
                    break;
                case 2:
                    iP.y = 0;
                    if (u.y !== 0) {
                        iP.x = (d1 * n2.z - d2 * n1.z) / u.y;
                        iP.z = (d2 * n1.x - d1 * n2.x) / u.y;
                    }
                    else {
                        iP.x = - (d1 * n2.z) / (n1.x * n2.z);
                        iP.z = - (d2 * n1.x) / (n1.x * n2.z);
                    }
                    break;
                case 3:
                    iP.z = 0;
                    if (u.z !== 0) {
                        iP.x = (d2 * n1.y - d1 * n2.y) / u.z;
                        iP.y = (d1 * n2.x - d2 * n1.x) / u.z;
                    }
                    else {
                        iP.x = - (d2 * n1.y) / (n1.y * n2.x);
                        iP.y = - (d1 * n2.x) / (n1.y * n2.x);
                    }
                    break;
            }

            var iP2 = new THREE.Vector3();
            iP2.addVectors(iP, u.multiplyScalar(100));

            var vP1 = this.nearestPointInPointToLine(p1, iP, iP2);
            var vP2 = this.nearestPointInPointToLine(p2, iP, iP2);

            return [vP1, vP2];

        };

        this.drawAngle = function (p, ep1, ep2, n, angle, midPoint) {

            var smallNum = 0.001;

            if (!_materialAngle) {

                _materialAngle = new THREE.MeshPhongMaterial({
                        color: 0x999999,
                        ambient: 0x999999,
                        opacity: 0.5,
                        transparent: true,
                        depthTest: false,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    }
                );

                _materialAngleOutline = new THREE.MeshBasicMaterial({
                    color: 0xFF9900,
                    depthTest: false,
                    depthWrite: false
                });

                _viewer.impl.createOverlayScene(kAngleOverlayName, _materialAngle);
                _viewer.impl.createOverlayScene(kAngleOutlineOverlayName, _materialAngleOutline);
            }

            _viewer.impl.clearOverlay(kAngleOverlayName);
            _viewer.impl.clearOverlay(kAngleOutlineOverlayName);


            // draw arc of angle
            var radius = p.distanceTo(ep1);
            var segments = 100;
            //angle = angle * Math.PI / 180;

            var circleGeometry = new THREE.CircleGeometry(radius, segments, 0, angle * Math.PI / 180);
            var arc = new THREE.Mesh(circleGeometry, _materialAngle);

            var center = arc.geometry.vertices[0].clone();
            arc.geometry.vertices.push(center);


            // Translate and rotate the arc to the plane where it should lie in
            arc.position.set(p.x, p.y, p.z);
            var V = arc.position.clone();
            V.add(n);
            arc.lookAt(V);
            arc.updateMatrixWorld();


            // Rotate the arc in the plane to the right place
            var vA = arc.geometry.vertices[1].clone();
            var vB = arc.geometry.vertices[arc.geometry.vertices.length - 2].clone();
            vA.applyMatrix4(arc.matrixWorld);
            vB.applyMatrix4(arc.matrixWorld);

            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var v3 = new THREE.Vector3();
            var v4 = new THREE.Vector3();
            v1.subVectors(vA, p);
            v2.subVectors(vB, p);
            v3.subVectors(ep1, p);
            v4.subVectors(ep2, p);

            var a13 = v1.angleTo(v3);
            var a14 = v1.angleTo(v4);
            var a23 = v2.angleTo(v3);
            var a24 = v2.angleTo(v4);

            //console.log(a13 * 180 / Math.PI + " " + a14 * 180 / Math.PI + " " + a23 * 180 / Math.PI + " " + a24 * 180 / Math.PI);

            var ra;
            // The arc is in the right place
            if (((a13 <= smallNum && a13 >= -smallNum) || (a14 <= smallNum && a14 >= -smallNum))
                && ((a23 <= smallNum && a23 >= -smallNum) || (a24 <= smallNum && a24 >= -smallNum))) {

                ra =0;
            }
            // The arc needs to be rotated 180 degree to the right place
            else if (((a13 <= Math.PI + smallNum && a13 >= Math.PI - smallNum) || (a14 <= Math.PI + smallNum && a14 >= Math.PI - smallNum))
                && ((a23 <= Math.PI + smallNum && a23 >= Math.PI - smallNum) || (a24 <= Math.PI + smallNum && a24 >= Math.PI - smallNum))) {

                ra = Math.PI;
            }
            // The arc needs to be rotated a13 radian
            else if ((a13 <= a23 + smallNum && a13 >= a23 - smallNum) || (a13 <= a24 + smallNum && a13 >= a24 - smallNum)) {

                ra = a13;
            }
            // The arc needs to be rotated a14 radian
            else {

                ra = a14;
            }

            var rotWorldMatrix = new THREE.Matrix4();
            rotWorldMatrix.makeRotationAxis(n, ra);
            //arc.matrix.multiply(rotWorldMatrix);
            rotWorldMatrix.multiply(arc.matrix);
            arc.matrix = rotWorldMatrix;
            arc.rotation.setFromRotationMatrix(arc.matrix);

            // Check if rotate to the wrong direction, if so, rotate back twice of the degree
            arc.updateMatrixWorld();
            vA = arc.geometry.vertices[1].clone();
            vB = arc.geometry.vertices[arc.geometry.vertices.length - 2].clone();
            vA.applyMatrix4(arc.matrixWorld);
            vB.applyMatrix4(arc.matrixWorld);

            v1.subVectors(vA, p);
            v2.subVectors(vB, p);

            a13 = v1.angleTo(v3);
            a14 = v1.angleTo(v4);
            a23 = v2.angleTo(v3);
            a24 = v2.angleTo(v4);

            //console.log(a13 * 180 / Math.PI + " " + a14 * 180 / Math.PI + " " + a23 * 180 / Math.PI + " " + a24 * 180 / Math.PI);

            if (a13 >= smallNum && a14 >= smallNum) {

                var rotWorldMatrix = new THREE.Matrix4();
                rotWorldMatrix.makeRotationAxis(n, - ra * 2);
                //arc.matrix.multiply(rotWorldMatrix);
                rotWorldMatrix.multiply(arc.matrix);
                arc.matrix = rotWorldMatrix;
                arc.rotation.setFromRotationMatrix(arc.matrix);
            }

            // draw outline of the arc
            var outlineGeometry = new THREE.CircleGeometry(radius * 0.9, segments, 0, angle * Math.PI / 180);
            outlineGeometry.vertices.splice(0, 1);
            arc.updateMatrixWorld();
            outlineGeometry.applyMatrix(arc.matrixWorld);
            var outline = this.drawEdgeAsCylinder(outlineGeometry, _materialAngleOutline, 2.5, 0);


            // draw lines of angle
            var geom1 = new THREE.Geometry();
            var geom2 = new THREE.Geometry();
            geom1.vertices.push(arc.geometry.vertices[0].clone(), arc.geometry.vertices[1].clone());
            geom2.vertices.push(arc.geometry.vertices[0].clone(), arc.geometry.vertices[arc.geometry.vertices.length - 2].clone());
            geom1.applyMatrix(arc.matrixWorld);
            geom2.applyMatrix(arc.matrixWorld);
            var line1 = this.drawLineAsCylinder(geom1, _materialAngleOutline, 2.5);
            var line2 = this.drawLineAsCylinder(geom2, _materialAngleOutline, 2.5);


            _viewer.impl.addOverlay(kAngleOverlayName, arc);
            _viewer.impl.addMultipleOverlays(kAngleOutlineOverlayName, outline);
            _viewer.impl.addOverlay(kAngleOutlineOverlayName, line1);
            _viewer.impl.addOverlay(kAngleOutlineOverlayName, line2);

            // This is used for angle label's position
            midPoint.copy(arc.geometry.vertices[Math.round(arc.geometry.vertices.length / 2) - 1]);
            midPoint.applyMatrix4(arc.matrixWorld);
        };

        // Draw angle between face to face
        this.drawAngleFaceToFace = function (p1, n1, p2, n2) {

            var vPs = this.intersectPlaneToPlane(p1, n1, p2, n2);

            var X1 = new THREE.Vector3();
            var X2 = new THREE.Vector3();
            X1.subVectors(p1, vPs[0]);
            X2.subVectors(p2, vPs[1]);

            var angle = this.angleVectorToVector(X1, X2);

            var p = vPs[0].clone();
            var n = new THREE.Vector3();
            n.crossVectors(n1, n2);
            n.normalize();

            vPs = this.intersectPlaneToPlane(p1, n1, p, n);
            var ep1 = vPs[0].clone();
            vPs = this.intersectPlaneToPlane(p2, n2, p, n);
            var ep2 = vPs[0].clone();

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_consumeSingleClick) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    label.style.pointerEvents = 'none';

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }

            return angle;
        };

        // Draw angle between line to line
        this.drawAngleLineToLine = function (p1, p2, p3, p4, angle) {

            var p = p1;
            var n = new THREE.Vector3();
            var n1 = new THREE.Vector3();
            var n2 = new THREE.Vector3();
            n1.subVectors(p1, p2);
            n2.subVectors(p3, p4);
            n.crossVectors(n1, n2);
            n.normalize();


            var ep1 = p2;
            var ep2 = new THREE.Vector3();
            ep2.subVectors(p, p3);
            ep2.add(p4);

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_consumeSingleClick) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    label.style.pointerEvents = 'none';

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }
        };

        // Find the intersection point of two nonparallel lines
        this.intersectLineToLine = function(p1, v1, p2, v2) {

            var X0 = new THREE.Vector3();
            var X1 = new THREE.Vector3();

            X0.subVectors(p2, p1);
            X0.cross(v2);
            X1.crossVectors(v1, v2);

            var scalar = X0.divide(X1);

            X1 = v1.clone();
            X1.multiplyScalar(scalar);
            X0.addVectors(p1, X1);

            return X0;
        };

        // Find the nearest point from point to plane
        this.nearestPointInPointToPlane = function(p1, p2, n) {

            var nearestPoint = new THREE.Vector3();
            var norm = n.clone();
            var X0 = new THREE.Vector3();
            X0.subVectors(p1, p2);

            var sn = -norm.dot(X0);
            var sd = norm.dot(norm);
            var sb = sn / sd;

            nearestPoint.addVectors(p1, norm.multiplyScalar(sb));
            return nearestPoint;
        };

        // Measure from face to vertex
        this.faceToPointMeasure = function(face, normal, intersectPoint, point) {

            var p = face.vertices[0];

            var X0 = this.nearestPointInPointToPlane(point, p, normal);

            var p1 = intersectPoint.clone();
            var p2 = new THREE.Vector3();
            p2.subVectors(p1, X0);
            p2.add(point);

            //var dist = new THREE.Vector3();
            //dist.subVectors(X0, p1);
            //var extendFace = face.clone();
            //extendFace.applyMatrix(new THREE.Matrix4().makeTranslation(dist.x, dist.y, dist.z));

            var dist = X0.distanceTo(intersectPoint) * 2;
            var extendFace = new THREE.PlaneBufferGeometry(dist, dist);
            this.drawExtensionFace(extendFace, intersectPoint, normal);

            this.drawLine(point, X0);
            //this.drawExtensionLinePointToPoint(p1, X0);
            return [point, X0];
        };

        // Find the nearest point from point to triangle
        this.nearestPointInPointToTriangle = function(point, a, b, c) {

            var nearestPoint;
            var minDist = Number.MAX_VALUE;

            nearestPoint = this.pointProjectsInTriangle(point, a, b, c);
            if (nearestPoint) {
               return nearestPoint;
            }

            var p = this.nearestPointInPointToSegment(point, a, b);
            if (point.distanceTo(p) < minDist) {
                minDist = point.distanceTo(p);
                nearestPoint = p.clone();
            }

            p = this.nearestPointInPointToSegment(point, a, c);
            if (point.distanceTo(p) < minDist) {
                minDist = point.distanceTo(p);
                nearestPoint = p.clone();
            }

            p = this.nearestPointInPointToSegment(point, b, c);
            if (point.distanceTo(p) < minDist) {

                nearestPoint = p.clone();
            }

            return nearestPoint;
        };

        // Measure from point to face
        this.pointToFaceMeasure = function(point, face, normal, intersectPoint) {

            var p = face.vertices[0];

            var X0 = this.nearestPointInPointToPlane(point, p, normal);

            var p1 = intersectPoint.clone();
            var p2 = new THREE.Vector3();
            p2.subVectors(p1, X0);
            p2.add(point);

            this.drawLine(p1, p2);
            this.drawExtensionLinePointToPoint(point, p2);
            return [point, X0];

        };

        // Measure between Curved Face and Vertex
        this.curvedFaceToVertexMeasure = function(face, point) {

            var minDist = Number.MAX_VALUE;
            var nearestPoint;
            var vertices = face.vertices;

            for (var i = 0; i < vertices.length; i += 3) {
                var tempP = this.nearestPointInPointToTriangle(point, vertices[i], vertices[i + 1], vertices[i + 2]);
                if (point.distanceTo(tempP) < minDist) {
                    minDist = point.distanceTo(tempP);
                    nearestPoint = tempP;
                }
            }

            this.drawLine(nearestPoint, point);

            return [nearestPoint, point];
        };

        this.pointProjectsInTriangle = function(point, a, b, c) {

            var u = new THREE.Vector3();
            var v = new THREE.Vector3();
            var w = new THREE.Vector3();
            var n = new THREE.Vector3();

            u.subVectors(b, a);
            v.subVectors(c, a);
            n.crossVectors(u, v);
            w.subVectors(point, a);

            u.cross(w);
            var r = u.dot(n) / n.dot(n);
            w.cross(v);
            var b = w.dot(n) / n.dot(n);
            var a = 1 - r - b;

            if (a >= 0 && a <= 1 && b >= 0 && b <= 1 && r >= 0 && r <= 1) {

                var normal = THREE.Triangle.normal(a, b, c);
                var nearestPoint = this.nearestPointInPointToPlane(point, a, normal);

                return nearestPoint;
            }
        };

        this.nearestPointsInLineSegmentToTriangle = function(p1, p2, a, b, c) {

            // The closest pair of points between a line segment and a triangle can always be found either
            // (a) between an endpoint of the segment an the triangle interior or
            // (b) between the segment and an edge of the triangle.

            var nearestPoints = [];
            var minDist = Number.MAX_VALUE;

            var p3, p4;

            var pp1 = this.pointProjectsInTriangle(p1, a, b, c);
            if (pp1 && p1.distanceTo(pp1) < minDist) {
                minDist = p1.distanceTo(pp1);
                nearestPoints[0] = p1;
                nearestPoints[1] = pp1;
            }

            var pp2 = this.pointProjectsInTriangle(p2, a, b, c);
            if (pp2 && p2.distanceTo(pp2) < minDist) {
                minDist = p2.distanceTo(pp2);
                nearestPoints[0] = p2;
                nearestPoints[1] = pp2;
            }

            p3 = a;
            p4 = b;
            var p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
            if (p[0].distanceTo(p[1]) < minDist) {
                minDist = p[0].distanceTo(p[1]);
                nearestPoints[0] = p[0].clone();
                nearestPoints[1] = p[1].clone();
            }

            p3 = a;
            p4 = c;
            p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
            if (p[0].distanceTo(p[1]) < minDist) {
                minDist = p[0].distanceTo(p[1]);
                nearestPoints[0] = p[0].clone();
                nearestPoints[1] = p[1].clone();
            }

            p3 = b;
            p4 = c;
            p = this.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
            if (p[0].distanceTo(p[1]) < minDist) {

                nearestPoints[0] = p[0].clone();
                nearestPoints[1] = p[1].clone();
            }

            return nearestPoints;
        };

        // Find the two nearest points between edge and face
        this.nearestPointsInEdgeToFace = function(p1, p2, face) {

            var nearestPoints = [];
            var minDist = Number.MAX_VALUE;

            for (var i = 0; i < face.vertices.length; i += 3) {

                var tempPs = this.nearestPointsInLineSegmentToTriangle(p1, p2, face.vertices[i], face.vertices[i + 1], face.vertices[i + 2]);
                if (tempPs[0].distanceTo(tempPs[1]) < minDist) {
                    minDist = tempPs[0].distanceTo(tempPs[1]);
                    nearestPoints = tempPs;
                }
            }

            return nearestPoints;
        };

        // Find the two nearest points between triangle and triangle
        this.nearestPointsInTriangleToTriangle = function (a1, b1, c1, a2, b2, c2) {

            // A pair of closest points between two triangles can be found by computing the closest points between
            // segment and triangle for all six possible combinations of an edge from one triangle tested against
            // the other triangle. But segment-triangle distance tests are fairly expensive,  and thus a better
            // realization is that the closest pair of points between T1 and T2 can be found to occur either on
            // an edge from each triangle or as a vertex of one triangle and a point interior to the other triangle.
            // In all, six vertex-triangle tests and nine edge-edge tests are required.

            var self = this;
            var nearestPoints = [];
            var minDist = Number.MAX_VALUE;

            function vertexToTriangleTest(point, a, b, c) {

                var p = self.pointProjectsInTriangle(point, a, b, c);
                if (p && point.distanceTo(p) < minDist) {
                    minDist = point.distanceTo(p);
                    nearestPoints[0] = point;
                    nearestPoints[1] = p;
                }
            }

            function edgeToEdgeTest(p1, p2, p3, p4) {

                var p = self.nearestPointsInSegmentToSegment(p1, p2, p3, p4);
                if (p[0].distanceTo(p[1]) < minDist) {
                    minDist = p[0].distanceTo(p[1]);
                    nearestPoints = p;
                }
            }

            // a1
            vertexToTriangleTest(a1, a2, b2, c2);

            // b1
            vertexToTriangleTest(b1, a2, b2, c2);

            // c1
            vertexToTriangleTest(c1, a2, b2, c2);

            // a2
            vertexToTriangleTest(a2, a1, b1, c1);

            // b2
            vertexToTriangleTest(b2, a1, b1, c1);

            // c2
            vertexToTriangleTest(c2, a1, b1, c1);

            // edge a1b1 and a2b2
            edgeToEdgeTest(a1, b1, a2, b2);

            // edge a1b1 and a2c2
            edgeToEdgeTest(a1, b1, a2, c2);

            // edge a1b1 and b2c2
            edgeToEdgeTest(a1, b1, b2, c2);

            // edge a1c1 and a2b2
            edgeToEdgeTest(a1, c1, a2, b2);

            // edge a1c1 and a2c2
            edgeToEdgeTest(a1, c1, a2, c2);

            // edge a1c1 and b2c2
            edgeToEdgeTest(a1, c1, b2, c2);

            // edge b1c1 and a2b2
            edgeToEdgeTest(b1, c1, a2, b2);

            // edge b1c1 and a2c2
            edgeToEdgeTest(b1, c1, a2, c2);

            // edge b1c1 and b2c2
            edgeToEdgeTest(b1, c1, b2, c2);

            return nearestPoints;
        };

        // Measure between Edge and Face when one of them or both are Curved
        this.curvedEdgeToFaceMeasure = function(edge, face) {

            var minDist = Number.MAX_VALUE;
            var nearestPoints = [];
            var vertices = edge.vertices;

            for (var i = 0; i < vertices.length; i += 2) {

                var tempPs = this.nearestPointsInEdgeToFace(vertices[i], vertices[i + 1], face);
                if (tempPs[0].distanceTo(tempPs[1]) < minDist) {
                    minDist = tempPs[0].distanceTo(tempPs[1]);
                    nearestPoints = tempPs;
                }
            }

            this.drawLine(nearestPoints[0], nearestPoints[1]);

            return [nearestPoints[0], nearestPoints[1]];
        };

        // Measure between Curved Face and Face/Curved Face
        this.curvedFaceToFaceMeasure = function(face1, face2) {

            var minDist = Number.MAX_VALUE;
            var nearestPoints = [];

            var v1s = face1.vertices;
            var v2s = face2.vertices;

            face1.computeBoundingSphere();
            face2.computeBoundingSphere();
            var bSphere1 = new THREE.Sphere();
            var bSphere2 = new THREE.Sphere();
            var mins = [];
            var minMax = Number.MAX_VALUE;
            var minV1s = [];
            var minV2s = [];
            face1.bSpheres = [];
            face2.bSpheres = [];

            // Find the smallest max between face2's bounding sphere and face1's triangles' bounding spheres
            for (var i = 0; i < v1s.length; i += 3) {

                bSphere1.setFromPoints([v1s[i], v1s[i + 1], v1s[i + 2]]);
                face1.bSpheres.push(bSphere1.clone());
                var max = bSphere1.center.distanceTo(face2.boundingSphere.center) + bSphere1.radius + face2.boundingSphere.radius;

                if (max < minMax) {
                    minMax = max;
                }
            }

            // Get rid of the triangles whose min is bigger than smallest max in face1
            for (var i = 0; i < v1s.length; i += 3) {

                bSphere1 = face1.bSpheres[i / 3];
                var min = bSphere1.center.distanceTo(face2.boundingSphere.center) - bSphere1.radius - face2.boundingSphere.radius;

                if (min <= minMax) {
                    minV1s.push(i);
                }
            }

            // Find the smallest max between face1's bounding sphere and face2's triangles' bounding spheres
            minMax = Number.MAX_VALUE;
            for (var j = 0; j < v2s.length; j += 3) {

                bSphere2.setFromPoints(v2s[j], v2s[j + 1], v2s[j + 2]);
                face2.bSpheres.push(bSphere2.clone());
                var max = bSphere2.center.distanceTo(face1.boundingSphere.center) + bSphere2.radius + face1.boundingSphere.radius;

                if (max < minMax) {
                    minMax = max;
                }
            }

            // Get rid of the triangles whose min is bigger than smallest max in face2
            for (var j = 0; j < v2s.length; j += 3) {

                bSphere2 = face2.bSpheres[j / 3];
                var min = bSphere2.center.distanceTo(face1.boundingSphere.center) - bSphere2.radius - face1.boundingSphere.radius;

                if (min <= minMax) {
                    minV2s.push(j);
                }
            }

            minMax = Number.MAX_VALUE;
            for (var i = 0; i < minV1s.length; i++) {

                bSphere1 = face1.bSpheres[minV1s[i] / 3];

                for (var j = 0; j < minV2s.length; j++) {

                    bSphere2 = face2.bSpheres[minV2s[j] / 3];
                    var min = bSphere1.center.distanceTo(bSphere2.center) - bSphere1.radius - bSphere2.radius;
                    var max = bSphere1.center.distanceTo(bSphere2.center) + bSphere1.radius + bSphere2.radius;

                    if (max < minMax) {
                        minMax = max;
                        mins.push({i: minV1s[i], j: minV2s[j], value: min});
                    }
                }
            }

            for (var k = 0; k < mins.length; k++) {

                if (mins[k].value <= minMax && mins[k].value < minDist) {

                    var p = this.nearestPointsInTriangleToTriangle(v1s[mins[k].i], v1s[mins[k].i + 1], v1s[mins[k].i + 2], v2s[mins[k].j], v2s[mins[k].j + 1], v2s[mins[k].j + 2]);
                    if (p[0].distanceTo(p[1]) < minDist) {
                        minDist = p[0].distanceTo(p[1]);
                        nearestPoints = p;
                    }
                }
            }

            this.drawLine(nearestPoints[0], nearestPoints[1]);

            return [nearestPoints[0], nearestPoints[1]];

        };

        // Measure from Face to Edge
        this.faceToEdgeMeasure = function(face, normal, faceIntersectPoint, edge, edgeIntersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge);
            var p1;
            var p2;

            if (eps[0].distanceTo(faceIntersectPoint) < eps[1].distanceTo(faceIntersectPoint)) {
                p1 = eps[0];
                p2 = eps[1];
            }
            else {
                p1 = eps[1];
                p2 = eps[0];
            }

            var X0 = new THREE.Vector3();
            X0.subVectors(p2, p1);

            var angle = this.angleLineToPlane(X0, normal);

            if (X0.dot(normal) <= smallNum && X0.dot(normal) >= -smallNum) { // the edge is parallel with the face

                var p = face.vertices[0];
                var X1 = this.nearestPointInPointToPlane(p1, p, normal);

                var point = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);
                this.faceToPointMeasure(face, normal, faceIntersectPoint, point);

                return [p1, X1, angle];
            }
            else { // nonparallel between edge and face

                // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
                // because we don't want to draw the arc so big, this is consistent with Fusion
                var newEp = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);

                this.drawAngleEdgeToFace(face.vertices[0], normal, faceIntersectPoint, p1, newEp, angle);

                //var X1 = this.nearestPointsInEdgeToFace(edge, face);

                //this.drawLine(X1[0], X1[1]);
                //return [X1[0], X1[1], angle];
                return angle;
            }

        };

        // Measure from Edge to Face
        this.edgeToFaceMeasure = function(edge, edgeIntersectPoint, face, normal, faceIntersectPoint) {

            var smallNum = 0.01;

            var eps = _snapper.getEndPointsInEdge(edge);
            var p1;
            var p2;

            if (eps[0].distanceTo(faceIntersectPoint) < eps[1].distanceTo(faceIntersectPoint)) {
                p1 = eps[0];
                p2 = eps[1];
            }
            else {
                p1 = eps[1];
                p2 = eps[0];
            }

            var X0 = new THREE.Vector3();
            X0.subVectors(p2, p1);

            var angle = this.angleLineToPlane(X0, normal);

            if (X0.dot(normal) <= smallNum && X0.dot(normal) >= -smallNum) { // the edge is parallel with the face

                var p = face.vertices[0];
                var X1 = this.nearestPointInPointToPlane(p1, p, normal);

                var newp1 = new THREE.Vector3();
                newp1.subVectors(faceIntersectPoint, X1);
                newp1.add(p1);

                var newp2 = new THREE.Vector3();
                newp2.subVectors(faceIntersectPoint, X1);
                newp2.add(p2);

                this.drawLine(newp1, faceIntersectPoint);
                this.drawExtensionLinePointToPoint(newp1, newp2);
                return [p1, X1, angle];
            }
            else { // nonparallel between edge and face

                // Find the nearest point on the edge to the intersectPoint, make this point as the new endpoint of the edge,
                // because we don't want to draw the arc so big, this is consistent with Fusion
                var newEp = this.nearestPointInPointToLine(edgeIntersectPoint, p1, p2);

                this.drawAngleEdgeToFace(face.vertices[0], normal, faceIntersectPoint, p1, newEp, angle);

                //var X1 = this.nearestPointsInEdgeToFace(edge, face);

                //this.drawLine(X1[0], X1[1]);
                //return [X1[0], X1[1], angle];
                return angle;
            }

        };

        // Get the angle between line and plane
        this.angleLineToPlane = function(v, n) {

            var angle = this.angleVectorToVector(v, n);

            if (angle > 90) {
                angle -= 90;
            }
            else {
                angle = 90 - angle;
            }

            return angle;
        };

        // Draw angle between edge and face
        this.drawAngleEdgeToFace = function(p0, n0, faceIntersectPoint, p1, p2, angle) {

            var p = this.intersectPointLineToPlane(p0, n0, p1, p2);
            if (!p) {
                return;
            }

            var ep1 = p2;

            if (angle === 90) {   // edge and face are vertical with each other
                var ep2 = faceIntersectPoint.clone();
            }
            else {
                var ep2 = this.nearestPointInPointToPlane(p2, p0, n0);
            }

            var n = new THREE.Vector3();
            var n1 = new THREE.Vector3();
            var n2 = new THREE.Vector3();
            n1.subVectors(p2, p1);
            n2.subVectors(ep2, p);
            n.crossVectors(n1, n2);
            n.normalize();

            var midPoint = new THREE.Vector3();

            this.drawAngle(p, ep1, ep2, n, angle, midPoint);

            if (_consumeSingleClick) {

                var label = _angleLabel.label;
                if (!label) {

                    label = _angleLabel.label = document.createElement('div');
                    label.className = 'measure-length';
                    _viewer.container.appendChild(label);

                    var text = document.createElement('div');
                    text.className = 'measure-length-text';
                    label.appendChild(text);

                    label.style.pointerEvents = 'none';

                    // This button is for Markup and Comments
                    //var button = document.createElement('div');
                    //button.className = 'measure-length-button';
                    //button.style.cursor = 'pointer';
                    //button.addEventListener('click', function (event) {
                    //
                    //}, true);
                    //label.appendChild(button);
                }

                label.children[0].textContent = tool.getAngle();
                label.classList.toggle('visible', true);

                _angleLabel.p1 = midPoint.clone();
                _angleLabel.p2 = midPoint.clone();

                this.updateLabelPositions();
            }
        };

        // Get the intersect point between line and plane
        this.intersectPointLineToPlane = function(p0, n0, p1, p2) {

            var smallNum = 0.001;

            var u = new THREE.Vector3();
            var w = new THREE.Vector3();
            u.subVectors(p2, p1);
            w.subVectors(p1, p0);

            var D = n0.dot(u);
            var N = -n0.dot(w);

            if (Math.abs(D) < smallNum) {  // edge is parallel to plane
                if (N == 0)                      // edge lies in plane
                    return null;
                else
                    return null;                    // no intersection
            }

            // they are not parallel
            u.multiplyScalar(N / D);             // compute segment intersect point
            u.add(p1);
            return u;
        };

        // Find the vertex need to draw For circular arc's radius
        this.nearestVertexInVertexToEdge = function(vertex, edge) {

            var nearestPoint;
            var minDist = Number.MAX_VALUE;

            for (var i = 0; i < edge.vertices.length; i++) {
                var dist = vertex.distanceTo(edge.vertices[i]);
                if (minDist > dist) {
                    nearestPoint = edge.vertices[i];
                    minDist = dist;
                }
            }

            return nearestPoint;
        };

        this.isEqualVectors = function (v1, v2, precision) {

            if (Math.abs(v1.x - v2.x) <= precision && Math.abs(v1.y - v2.y) <= precision && Math.abs(v1.z - v2.z) <= precision) {

                return true;
            }

            return false;
        };

        this.isInverseVectors = function (v1, v2, precision) {

            if (Math.abs(v1.x + v2.x) <= precision && Math.abs(v1.y + v2.y) <= precision && Math.abs(v1.z + v2.z) <= precision) {

                return true;
            }

            return false;
        };

        // Set if collapse or expand the xyz delta distance
        this.setSimple = function (simple) {
            if (_simple != simple) {
                _simple = simple;

                for (var name in _lines) {
                    if (name !== 'xyz' && _lines.hasOwnProperty(name)) {
                        var item = _lines[name];
                        if (item.line) {
                            item.line.visible = !simple;

                            if (item.label) {
                                item.label.classList.toggle('visible', !simple);
                            }
                        }
                    }
                }

                _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);
            }
        };

        this.hide = function () {
            var name;

            for (name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name];
                    if (endPoint.mesh) {
                        endPoint.mesh.visible = false;
                    }
                    if (endPoint.label) {
                        endPoint.label.classList.remove('visible');
                    }
                }
            }

            for (name in _edges) {
                if (_edges.hasOwnProperty(name)) {
                    var edge = _edges[name];
                    if (edge.line) {
                        for (var i in edge.line) {
                            edge.line[i].visible = false;
                        }
                    }
                    if (edge.label) {
                        edge.label.classList.remove('visible');
                    }
                }
            }

            for (name in _faces) {
                if (_faces.hasOwnProperty(name)) {
                    var face = _faces[name];
                    if (face.mesh) {
                        face.mesh.visible = false;
                    }
                    if (face.label) {
                        face.label.classList.remove('visible');
                    }
                }
            }

            for (name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        item.line.visible = false;
                    }
                    if (item.label) {
                        item.label.classList.remove('visible');
                    }
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.classList.remove('visible');
            }

            if (_materialAngle) {

                _viewer.impl.clearOverlay(kAngleOverlayName);
                _viewer.impl.clearOverlay(kAngleOutlineOverlayName);
            }

            if (_materialExtensionLine) {

                _viewer.impl.clearOverlay(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {

                _viewer.impl.clearOverlay(kExtensionFaceOverlayName);
            }

            if (_materialGreyOutPlane) {
                _viewer.impl.clearOverlay(kGreyOutPlaneOverlayName);
            }

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);
        };

        this.hideClick = function(clickName) {

            if (_endPoints.hasOwnProperty(clickName)) {
                var endPoint = _endPoints[clickName];
                if (endPoint.mesh) {
                    endPoint.mesh.visible = false;
                }
                if (endPoint.label) {
                    endPoint.label.classList.remove('visible');
                }
            }

            if (_edges.hasOwnProperty(clickName)) {
                var edge = _edges[clickName];
                if (edge.line) {
                    for (var i in edge.line) {
                        edge.line[i].visible = false;
                    }
                }
                if (edge.label) {
                    edge.label.classList.remove('visible');
                }
            }

            if (_faces.hasOwnProperty(clickName)) {
                var face = _faces[clickName];
                if (face.mesh) {
                    face.mesh.visible = false;
                }
                if (face.label) {
                    face.label.classList.remove('visible');
                }
            }

            for (var name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        item.line.visible = false;
                    }
                    if (item.label) {
                        item.label.classList.remove('visible');
                    }
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.classList.remove('visible');
            }

            if (_materialAngle) {

                _viewer.impl.clearOverlay(kAngleOverlayName);
                _viewer.impl.clearOverlay(kAngleOutlineOverlayName);
            }

            if (_materialExtensionLine) {

                _viewer.impl.clearOverlay(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {

                _viewer.impl.clearOverlay(kExtensionFaceOverlayName);
            }

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);

        };

        this.destroy = function () {
            var name;

            for (name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name];
                    if (endPoint.mesh) {
                        _viewer.impl.removeOverlay(kEndPointOverlayName, endPoint.mesh);
                        endPoint.mesh = endPoint.geometry = null;
                    }
                    if (endPoint.label) {
                        endPoint.label.parentNode.removeChild(endPoint.label);
                        endPoint.label = null;
                    }
                }
            }

            for (name in _edges) {
                if (_edges.hasOwnProperty(name)) {
                    var edge = _edges[name];
                    if (edge.line) {
                        _viewer.impl.removeMultipleOverlays(kEdgeOverlayName, edge.line);
                        edge.line = edge.intersectPoint = null;
                    }
                    if (edge.label) {
                        edge.label.parentNode.removeChild(edge.label);
                        edge.label = null;
                    }
                }
            }

            for (name in _faces) {
                if (_faces.hasOwnProperty(name)) {
                    var face = _faces[name];
                    if (face.mesh) {
                        _viewer.impl.removeOverlay(kFaceOverlayName, face.mesh);
                        face.mesh = face.intersectPoint = null;
                    }
                    if (face.label) {
                        face.label.parentNode.removeChild(face.label);
                        face.label = null;
                    }
                }
            }

            if (_materialPoint) {
                _materialPoint = null;
                _viewer.impl.removeOverlayScene(kEndPointOverlayName);
            }

            if (_materialFace) {
                _materialFace = null;
                _viewer.impl.removeOverlayScene(kFaceOverlayName);
            }

            if (_materialLine) {
                _materialLine = null;
                _viewer.impl.removeOverlayScene(kEdgeOverlayName);
            }

            if (_materialExtensionLine) {
                _materialExtensionLine = null;
                _viewer.impl.removeOverlayScene(kExtensionLineOverlayName);
            }

            if (_materialExtensionFace) {
                _materialExtensionFace = null;
                _viewer.impl.removeOverlayScene(kExtensionFaceOverlayName);
            }

            if (_materialGreyOutPlane) {
                _materialGreyOutPlane = null;
                _viewer.impl.clearOverlay(kGreyOutPlaneOverlayName);
            }

            for (name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        _viewer.impl.removeOverlay(item.overlayName, item.line);
                        _viewer.impl.removeOverlayScene(item.overlayName);
                        item.material = item.line = item.geometry = null;
                    }

                    if (item.label) {
                        item.label.parentNode.removeChild(item.label);
                        item.label = null;
                    }
                    item.material = item.line = item.geometry = item.label = item.p1 = item.p2 = null;
                }
            }

            if (_angleLabel.label) {
                _angleLabel.label.parentNode.removeChild(_angleLabel.label);
                _angleLabel.label = null;
            }
            _angleLabel.label = _angleLabel.p1 = _angleLabel.p2 = null;

        };
    }
};
;
(function() {

"use strict";

var avem = AutodeskNamespace('Autodesk.Viewing.Extensions.Measure'),
    av = Autodesk.Viewing,
    ave = Autodesk.Viewing.Extensions,
    avp = Autodesk.Viewing.Private,
    avu = Autodesk.Viewing.UI;

//
// /** @constructor */
//
//
var MeasurePanel = function(measureTool, viewer, id, title, options)
{
    avu.DockingPanel.call(this, viewer.container, id, title, options);

    this.kPanelExpandedHeight  = 310; // px
    this.kPanelCollapsedHeight =  35; //px

    this.isDeltaExpanded = true;
    this.isSettingsExpanded = false;
    this.isolateMeasure = false;

    this.measureTool = measureTool;
    this.viewer = viewer;
    this.parentContainer = viewer.container;

    this.container.classList.add('measurePanel');
    this.container.dockRight = true;

    this.container.style.minWidth  = "300px";
    this.container.style.width = "300px";
    this.container.style.minHeight = this.kPanelCollapsedHeight + "px";
    this.container.style.height    = this.kPanelExpandedHeight + "px";
    this.container.style.maxHeight = this.kPanelExpandedHeight + "px";
    this.container.style.top       = "200px";
    this.container.style.left      = "220px"; // just needs an initial value dock overrides value
    //this.container.style.resize    = "none";
    this.container.style.position  = "absolute";

    this.addEventListener( this.closer, "click", function(e) {
        // WHen the close button is clicked, deactivate the tool as well.
        if (options && options.onCloseCallback)
            options.onCloseCallback();
    });

    // Add arrow to the title and add expand/collapse behavior..
    var titleElement = this.container.children[0];
    //titleElement.classList.add( "measure-panelTitle" );
    titleElement.classList.add( "expanded" );

    options = options || {};
    if (!options.heightAdjustment)
        options.heightAdjustment = 40;
    if (!options.marginTop)
        options.marginTop = 0;
    options.left = false;
    this.createScrollContainer(options);

    this.measureResults = document.createElement("div");
    this.scrollContainer.appendChild( this.measureResults );
    //this.container.style.overflow = "auto";

    var self = this;


    // Add selection 1 section

    this.selection1 = document.createElement("div");    // Container for selection one
    this.selection1.className = "measure-result-container";
    this.measureResults.appendChild(this.selection1);

    var selection1Label = document.createElement('div');    // Icon for selection one
    selection1Label.className = 'measure-selectionOne-label';
    this.selection1.appendChild(selection1Label);

    var selection1Label_icon = document.createElement('div');
    selection1Label_icon.className = 'adsk-icon-first measure-label-icon';
    selection1Label.appendChild(selection1Label_icon);

    this.selection1Result = document.createElement("div");    // Selection result
    this.selection1Result.className = "measure-selection-result";
    this.selection1.appendChild(this.selection1Result);

    var selection1Repick = document.createElement("div");    // Icon for repick button
    selection1Repick.className = 'adsk-icon-refresh measure-repick';
    selection1Repick.addEventListener('click', function (event) {
        self.firstSelectionRepick();
    }, true);
    this.selection1.appendChild(selection1Repick);

    this.addDivider( this.selection1 );


    // Add the result section.
    this.results = document.createElement("div");    // Container for measure result (distance or angle)
    this.results.className = "measure-result-container";
    this.measureResults.appendChild(this.results);

    this.distIcon = document.createElement("div");    // Icon for distance measurement
    this.distIcon.className = 'adsk-icon-measure-distance measure-distance-icon';
    this.results.appendChild(this.distIcon);

    this.angleIcon = document.createElement("div");    // Icon for angle measurement
    this.angleIcon.className = 'adsk-icon-measure-angle measure-angle-icon';
    this.results.appendChild(this.angleIcon);

    this.distanceDiv = document.createElement("div");    // Distance measurement result
    this.distanceDiv.className = 'measure-result';
    this.results.appendChild( this.distanceDiv );

    this.angleDiv = document.createElement("div");    // Angle measurement result
    this.angleDiv.className = 'measure-result';
    this.results.appendChild(this.angleDiv);

    this.initialDiv = document.createElement("div");    // Initial result "0"
    this.initialDiv.className = "measure-initial";
    this.initialDiv.textContent = "0.00";
    this.results.appendChild( this.initialDiv );

    this.settingsButton = document.createElement("div");    // Icon for settings button
    this.settingsButton.className = 'adsk-icon-settings measure-settings-button';
    this.settingsButton.addEventListener('click', function (event) {
        self.showMeasureSettings();
    }, true);
    this.results.appendChild(this.settingsButton);

    this.deltaButton = document.createElement("div");    // Icon for delta button
    this.deltaButton.className = 'adsk-icon-arrow measure-delta-button';
    this.deltaButton.addEventListener('click', function (event) {
        self.toggle();
    }, true);
    this.results.appendChild(this.deltaButton);

    this.deltaXDiv = document.createElement("div");    // Delta X
    this.deltaXDiv.className = 'measure-delta-result';
    this.results.appendChild( this.deltaXDiv );

    var xSpan1 = document.createElement("span");    // "Delta"
    xSpan1.setAttribute("data-i18n", "Delta");
    xSpan1.textContent = av.i18n.translate("Delta");
    this.deltaXDiv.appendChild( xSpan1 );
    var xSpan2 = document.createElement("span");    // "X"
    xSpan2.className = "measure-label-axis-x";
    xSpan2.textContent = "X";
    this.deltaXDiv.appendChild( xSpan2 );
    var xSpan3 = document.createElement("span");    // the value
    this.deltaXDiv.appendChild( xSpan3 );

    this.deltaYDiv = document.createElement("div");    // Delta Y
    this.deltaYDiv.className = 'measure-delta-result';
    this.results.appendChild( this.deltaYDiv );

    var ySpan1 = document.createElement("span");    // "Delta"
    ySpan1.setAttribute("data-i18n", "Delta");
    ySpan1.textContent = av.i18n.translate("Delta");
    this.deltaYDiv.appendChild( ySpan1 );
    var ySpan2 = document.createElement("span");    // "Y"
    ySpan2.className = "measure-label-axis-y";
    ySpan2.textContent = "Y";
    this.deltaYDiv.appendChild( ySpan2 );
    var ySpan3 = document.createElement("span");    // the value
    this.deltaYDiv.appendChild( ySpan3 );

    this.deltaZDiv = document.createElement("div");    // Delta Z
    this.deltaZDiv.className = 'measure-delta-result';
    this.results.appendChild( this.deltaZDiv );

    var zSpan1 = document.createElement("span");    // "Delta"
    zSpan1.setAttribute("data-i18n", "Delta");
    zSpan1.textContent = av.i18n.translate("Delta");
    this.deltaZDiv.appendChild( zSpan1 );
    var zSpan2 = document.createElement("span");    // "Z"
    zSpan2.className = "measure-label-axis-z";
    zSpan2.textContent = "Z";
    this.deltaZDiv.appendChild( zSpan2 );
    var zSpan3 = document.createElement("span");    // the value
    this.deltaZDiv.appendChild( zSpan3 );

    this.addDivider( this.results );


    // Add selection 2 section

    this.selection2 = document.createElement("div");    // Container for selection two
    this.selection2.className = "measure-result-container";
    this.measureResults.appendChild(this.selection2);

    var selection2Label = document.createElement('div');    // Icon for selection two
    selection2Label.className = 'measure-selectionTwo-label';
    this.selection2.appendChild(selection2Label);

    var selection2Label_icon = document.createElement('div');
    selection2Label_icon.className = 'adsk-icon-second measure-label-icon';
    selection2Label.appendChild(selection2Label_icon);

    this.selection2Result = document.createElement("div");    // Selection result
    this.selection2Result.className = "measure-selection-result";
    this.selection2.appendChild(this.selection2Result);

    var selection2Repick = document.createElement("div");    // Icon for repick button
    selection2Repick.className = 'adsk-icon-refresh measure-repick';
    selection2Repick.addEventListener('click', function (event) {
        self.secondSelectionRepick();
    }, true);
    this.selection2.appendChild(selection2Repick);

    this.addDivider( this.selection2 );


    // Settings
    this.measureSettings = document.createElement("div");
    this.measureSettings.className = "measure-settings";
    this.measureSettings.style.display = "none";
    this.measureResults.appendChild(this.measureSettings);

    this.table = document.createElement("table");
    this.table.className = "tftable measure-table";
    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);
    this.measureSettings.appendChild(this.table);

    this.units = [
        { name: 'Unknown', units: '', matches: [''] },                                      // localized in OptionDropDown() call below
        { name: 'Decimal feet', units: 'decimal-ft', matches: ['ft', 'decimal-ft'] },             // localized in OptionDropDown() call below
        { name: 'Feet and fractional inches', units: 'ft-and-fractional-in', matches: ['ft-and-fractional-in'] },         // localized in OptionDropDown() call below
        { name: 'Feet and decimal inches', units: 'ft-and-decimal-in', matches: ['ft-and-decimal-in'] }, // localized in OptionDropDown() call below
        { name: 'Decimal inches', units: 'decimal-in', matches: ['in', 'decimal-in'] },           // localized in OptionDropDown() call below
        { name: 'Fractional inches', units: 'fractional-in', matches: ['fractional-in'] },  // localized in OptionDropDown() call below
        { name: 'Meters', units: 'm', matches: ['m'] },                                     // localized in OptionDropDown() call below
        { name: 'Centimeters', units: 'cm', matches: ['cm'] },                              // localized in OptionDropDown() call below
        { name: 'Millimeters', units: 'mm', matches: ['mm'] },                              // localized in OptionDropDown() call below
        { name: 'Meters and centimeters', units: 'm-and-cm', matches: ['m-and-cm'] }        // localized in OptionDropDown() call below
    ];

    var initialIndex = this.findUnits(),
        unitNames = [];
    for (var i = 0; i < this.units.length; ++i) {
        unitNames.push(this.units[i].name);
    }

    this.unitList = new avp.OptionDropDown("Unit type", this.tbody, unitNames, initialIndex);
    this.addEventListener(this.unitList, "change", function(e) {
        var index = self.unitList.selectedIndex;
        var toUnits = self.units[index].units;
        self.measureTool.setUnits(toUnits);
        self.updatePanel();
        self.setupPrecision();
        if (avp.logger) {
            avp.logger.log({ category: 'pref_changed', name: 'measure/units', value: toUnits });
        }
    });

    this.precisionList = new avp.OptionDropDown("Precision", this.tbody, [], -1);
    this.addEventListener(this.precisionList, "change", function(e) {
        var index = self.precisionList.selectedIndex;
        self.measureTool.setPrecision(index);
        self.updatePanel();
        if (avp.logger) {
            avp.logger.log({ category: 'pref_changed', name: 'measure/precision', value: index });
        }
    });
    this.setupPrecision();

    this.isolate = new avp.OptionCheckbox("Isolate measurement", this.tbody, false);
    this.addEventListener(this.isolate, "change", function(e) {
        var enable = self.isolate.checked;
        self.isolateMeasure = enable;
        if (self.isolateMeasure) {
            self.measureTool.isolateMeasurement();
        }
        else {
            self.measureTool.clearIsolate();
        }
        if (avp.logger) {
            avp.logger.log({ category: 'pref_changed', name: 'measure/isolate', value: enable });
        }
    });

    this.addDivider(this.measureSettings);


    // Add restart section
    var restart = document.createElement('div');
    restart.className = 'measure-restart';
    restart.setAttribute("data-i18n", "Restart");
    restart.textContent = av.i18n.translate("Restart");
    restart.addEventListener('click', function () {
        self.measureTool.clearMeasurement();
    }, false);

    this.measureResults.appendChild(restart);
    this.updatePanel();
    this.addVisibilityListener(function () {
        self.resizeToContent({maxHeight: self.parentContainer.offsetHeight - 75});
    });

    this.hideMeasureResult();

}; // end constructor

MeasurePanel.prototype = Object.create(avu.DockingPanel.prototype);
ave.ViewerPanelMixin.call(MeasurePanel.prototype);

MeasurePanel.prototype.addDropDownMenu = function addDropDownMenu(parent, label, optionList, initialIndex, onchange) {

    // Wrap the onchange with the update to that setting
    var handler = function(e) {
        var selectedIndex = e.target.selectedIndex;
        onchange(selectedIndex);
    };

    var selectElem = document.createElement("select");
    selectElem.className = 'optionDropDown';
    for (var i = 0; i < optionList.length; i++) {
        var item = document.createElement("option");
        item.value = i;
        item.setAttribute("data-i18n",  optionList[i]);
        item.textContent = av.i18n.translate( optionList[i] );
        selectElem.add(item);
    }

    var div = document.createElement("div");
    div.className = "measure-submenu-select";

    var lbl = document.createElement("div");
    lbl.className = "measure-submenu-selectlabel";
    lbl.setAttribute ('for', label);
    lbl.setAttribute("data-i18n", label);
    lbl.textContent = av.i18n.translate( label );
    div.appendChild(lbl);
    div.appendChild(selectElem);

    parent.appendChild(div);

    selectElem.selectedIndex = initialIndex;
    selectElem.onchange = handler;

    return selectElem;
};

MeasurePanel.prototype.addDivider = function addDivider(parent) {
    var item = document.createElement("div");
    item.className = "measure-horizontal-divider";
    parent.appendChild(item);
    return item;
};

MeasurePanel.prototype.findUnits = function findUnits() {
    var i,
        j,
        selectedUnits = this.measureTool.getUnits();
    for (i = 0; i < this.units.length; ++i) {
        var matches = this.units[i].matches;
        if (matches) {
            for (j = 0; j < matches.length; ++j) {
                if (matches[j] === selectedUnits) {
                    return i;
                }
            }
        }
    }
    return 0;
};


MeasurePanel.prototype.setupPrecision = function setupPrecision () {
    while (this.precisionList.dropdownElement.lastChild) {
        this.precisionList.dropdownElement.removeChild(this.precisionList.dropdownElement.lastChild);
    }

    var selectedUnits = this.measureTool.getUnits(),
        precisions;

    if (selectedUnits === 'ft-and-fractional-in' || selectedUnits === 'fractional-in') {
        precisions = ['1', '1/2', '1/4', '1/8', '1/16', '1/32', '1/64'];
    } else {
        precisions = ['0', '0.1', '0.01', '0.001', '0.0001', '0.00001'];
    }

    for (var i = 0; i < precisions.length; ++i) {
        var elem = document.createElement('option');
        elem.value = i;
        elem.textContent = precisions[i];
        this.precisionList.dropdownElement.appendChild(elem);
    }

    var selectedIndex = this.measureTool.getPrecision();
    if (precisions.length <= selectedIndex) {
        selectedIndex = precisions.length - 1;
        self.measureTool.setPrecision(selectedIndex);
    }
    this.precisionList.dropdownElement.selectedIndex = selectedIndex;
};


MeasurePanel.prototype.uninitialize = function uninitialize() {
    this.viewer = null;
    avu.DockingPanel.prototype.uninitialize.call(this);
};

MeasurePanel.prototype.onTitleClick = function onTitleClick(event) {
    //this.toggle();
};

MeasurePanel.prototype.deltaCollapse = function deltaCollapse() {

    this.deltaButton.classList.toggle('rotated');

    this.measureTool.getIndicator().setSimple(this.isDeltaExpanded);

    if (this.isDeltaExpanded) {
        this.deltaXDiv.style.display = "none";
        this.deltaYDiv.style.display = "none";
        this.deltaZDiv.style.display = "none";

        this.isDeltaExpanded = false;
    }
    else {
        this.deltaXDiv.style.display = "block";
        this.deltaYDiv.style.display = "block";
        if (this.viewer.model && !this.viewer.model.is2d()) {
            this.deltaZDiv.style.display = "block";
        }

        this.isDeltaExpanded = true;
    }

    this.resizeToContent();
};

/**
 * Toggles the collapse/expand state of the panel.
 */
MeasurePanel.prototype.toggle = function toggle() {
    this.deltaCollapse();
};

/**
 * Returns the collapse or expand state of the panel.
 * @returns {boolean} true if the panel is expanded.
 */
MeasurePanel.prototype.isExpanded = function isExpanded() {
    return this.container.children[0].classList.contains("expanded");
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
MeasurePanel.prototype.getContentSize = function getContentSize() {
    return {
        height: this.isExpanded() ? this.measureResults.clientHeight + 46 : 0,
        width: this.measureResults.clientWidth
    };
};

MeasurePanel.prototype.updatePanel = function updatePanel() {
    var that = this;
    function setText(elem, name) {
        if (name === 'angle') {
            elem.textContent = "~ " + that.measureTool.getAngle();
        } else if (name === 'xyz') {
            elem.textContent = "~ " + that.measureTool.getDistance(name);
        } else {
            elem.children[2].textContent = " = ~ " + that.measureTool.getDistance(name);
        }
    }

    setText(this.distanceDiv, 'xyz');
    setText(this.deltaXDiv, 'x');
    setText(this.deltaYDiv, 'y');
    setText(this.deltaZDiv, 'z');
    setText(this.angleDiv, 'angle');

    this.unitList.dropdownElement.selectedIndex = this.findUnits();
    this.precisionList.dropdownElement.selectedIndex = this.measureTool.getPrecision();
    this.initialDiv.textContent = avp.formatValueWithUnits(0, null, 3, this.measureTool.getPrecision());

    this.showSelection1();
    this.showSelection2();

};

MeasurePanel.prototype.showDistanceResult = function showDistanceResult(/*optional*/hideXYZ) {
    this.results.style.display = "block";
    this.initialDiv.style.display = "none";
    this.angleDiv.style.display = "none";
    this.angleIcon.style.display = "none";
    this.distanceDiv.style.display = "inline-block";
    this.distIcon.style.display = "inline-block";

    // Add hideXYZ option because parallel faces should only display distance, not XYZ per Fusion's request
    if (!hideXYZ) {
        this.deltaButton.style.display = "inline-block";
        if (this.isDeltaExpanded) {
            this.deltaXDiv.style.display = "block";
            this.deltaYDiv.style.display = "block";
            if (this.viewer.model && !this.viewer.model.is2d()) {
                this.deltaZDiv.style.display = "block";
            }
        }
    }
    else {
        this.deltaButton.style.display = "none";
        if (this.isDeltaExpanded) {
            this.deltaXDiv.style.display = "none";
            this.deltaYDiv.style.display = "none";
            this.deltaZDiv.style.display = "none";
        }
    }

    this.resizeToContent();
};

MeasurePanel.prototype.showAngleResult = function showAngleResult() {
    this.results.style.display = "block";
    this.initialDiv.style.display = "none";
    this.angleDiv.style.display = "inline-block";
    this.angleIcon.style.display = "inline-block";
    this.distanceDiv.style.display = "none";
    this.distIcon.style.display = "none";
    this.deltaButton.style.display = "none";
    if (this.isDeltaExpanded) {
        this.deltaXDiv.style.display = "none";
        this.deltaYDiv.style.display = "none";
        this.deltaZDiv.style.display = "none";
    }
    this.resizeToContent();
};

MeasurePanel.prototype.showSelection1 = function showSelection1() {
    var result = this.measureTool.getFirstGeometry();

    if (result.type === null) {
        return;
    }

    if (result.type === SNAP_VERTEX) { // Vertex

        this.selection1Result.setAttribute("data-i18n", "Vertex");
        this.selection1Result.textContent = av.i18n.translate("Vertex");
        this.selection1Result.style.display = "inline-block";
    }
    else if (result.type === SNAP_EDGE || result.type === SNAP_CURVEDEDGE) { // Edge

        this.selection1Result.setAttribute("data-i18n", "Edge");
        this.selection1Result.textContent = av.i18n.translate("Edge") + " ~ " + this.measureTool.getEdgeLength(result.geometry);
        this.selection1Result.style.display = "inline-block";
    }
    else if (result.type === SNAP_FACE || result.type === SNAP_CURVEDFACE) { // Face

        this.selection1Result.setAttribute("data-i18n", "Face");
        this.selection1Result.textContent = av.i18n.translate("Face") + " ~ " + this.measureTool.getFaceArea(result.geometry);
        this.selection1Result.style.display = "inline-block";
    }
    else if (result.type === SNAP_CIRCULARARC) { // Circular Arc

        this.selection1Result.setAttribute("data-i18n", "Edge");
        if (result.geometry.radius)
            this.selection1Result.textContent = av.i18n.translate("Edge") + " ~ " + this.measureTool.getCircularArcRadius(result.geometry) + " (R)";
        else
            this.selection1Result.textContent = av.i18n.translate("Edge") + " ~ " + this.measureTool.getEdgeLength(result.geometry);
        this.selection1Result.style.display = "inline-block";
    }

    this.selection1.style.display = "block";
    this.resizeToContent();
};

MeasurePanel.prototype.showSelection2 = function showSelection2() {
    var result = this.measureTool.getSecondGeometry();

    if (result.type === null) {
        return;
    }

    if (result.type === SNAP_VERTEX) { // Vertex

        this.selection2Result.setAttribute("data-i18n", "Vertex");
        this.selection2Result.textContent = av.i18n.translate("Vertex");
        this.selection2Result.style.display = "inline-block";
    }
    else if (result.type === SNAP_EDGE || result.type === SNAP_CURVEDEDGE) { // Edge

        this.selection2Result.setAttribute("data-i18n", "Edge");
        this.selection2Result.textContent = av.i18n.translate("Edge") + " ~ " + this.measureTool.getEdgeLength(result.geometry);
        this.selection2Result.style.display = "inline-block";
    }
    else if (result.type === SNAP_FACE || result.type === SNAP_CURVEDFACE) { // Face

        this.selection2Result.setAttribute("data-i18n", "Face");
        this.selection2Result.textContent = av.i18n.translate("Face") + " ~ " + this.measureTool.getFaceArea(result.geometry);
        this.selection2Result.style.display = "inline-block";
    }
    else if (result.type === SNAP_CIRCULARARC) { // Circular Arc

        this.selection2Result.setAttribute("data-i18n", "Edge");
        if (result.geometry.radius)
            this.selection2Result.textContent = av.i18n.translate("Edge") + " ~ " + this.measureTool.getCircularArcRadius(result.geometry) + " (R)";
        else
            this.selection2Result.textContent = av.i18n.translate("Edge") + " ~ " + this.measureTool.getEdgeLength(result.geometry);
        this.selection2Result.style.display = "inline-block";
    }

    this.selection2.style.display = "block";
    this.resizeToContent();
};

MeasurePanel.prototype.firstSelectionRepick = function firstSelectionRepick() {
    this.measureTool.clearFirstPick();

    this.selection1Result.textContent = this.selection2Result.textContent;
    this.clearSelectionTwo();
    this.clearResult();

    this.resizeToContent();
};

MeasurePanel.prototype.secondSelectionRepick = function secondSelectionRepick() {
    this.measureTool.clearSecondPick();

    this.clearSelectionTwo();
    this.clearResult();

    this.resizeToContent();
};

MeasurePanel.prototype.hideMeasureResult = function hideMeasureResult() {
    this.clearSelectionOne();
    this.clearSelectionTwo();
    this.clearResult();
    this.resizeToContent();
};

MeasurePanel.prototype.disableUnitOption = function disableUnitOption( index ) {

    if (index != null) {
        this.unitList.dropdownElement.children[index].style.display = "none";
    }
    else {  // disable all options
        this.unitList.dropdownElement.disabled = true;
    }
};

MeasurePanel.prototype.showMeasureSettings = function showMeasureSettings() {

    if (this.isSettingsExpanded) {
        this.measureSettings.style.display = "none";
        this.isSettingsExpanded = false;
    }
    else {
        this.measureSettings.style.display = "block";
        this.isSettingsExpanded = true;
    }

    this.resizeToContent();
};

MeasurePanel.prototype.clearSelectionOne = function clearSelectionOne() {
    this.selection1Result.setAttribute("data-i18n", "Select Object");
    this.selection1Result.textContent = av.i18n.translate("Select Object");
};

MeasurePanel.prototype.clearSelectionTwo = function clearSelectionOne() {
    this.selection2Result.setAttribute("data-i18n", "Select Object");
    this.selection2Result.textContent = av.i18n.translate("Select Object");
};

MeasurePanel.prototype.clearResult = function clearResult() {
    this.distIcon.style.display = "none";
    this.angleIcon.style.display = "none";
    this.distanceDiv.style.display = "none";
    this.angleDiv.style.display = "none";
    this.initialDiv.style.display = "inline-block";

    this.deltaButton.style.display = "none";
    this.deltaXDiv.style.display = "none";
    this.deltaYDiv.style.display = "none";
    this.deltaZDiv.style.display = "none";
};

avem.MeasurePanel = MeasurePanel;

})();
;AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

var SNAP_VERTEX = 0;
var SNAP_EDGE = 1;
var SNAP_FACE = 2;
var SNAP_CIRCULARARC = 3;
var SNAP_CURVEDEDGE = 4;
var SNAP_CURVEDFACE = 5;
var SNAP_PRECISION = 0.001;

//
// /** @constructor */
//
//
Autodesk.Viewing.Extensions.Measure.Snapper = function(viewer) {

    var _viewer = viewer;

    var _names = ["snapper"];
    var _active = false;

    var _faceOverlayName = 'MeasureTool-snapper-face';
    var _vertexOverlayName = 'MeasureTool-snapper-vertex';
    var _edgeOverlayName = 'MeasureTool-snapper-edge';

    var _radius = null;
    var _distanceToEdge = Number.MAX_VALUE;
    var _distanceToVertex = null;

    var _geomFace = null;
    var _geomEdge = null;
    var _geomVertex = null;
    var _snapNode = null;

    var _geomHighlighted = null; //  {"VERTEX": 0, "EDGE": 1, "FACE": 2}

    var _intersectPoint = null;
    var _faceNormal = null;

    var _isDragging = false;

    var _isSnapped = false;

    var _viewportIndex2d = null;

    var _circularArcCenter = null;
    var _circularArcRadius = null;

    var _clip = null;
    var _firstClickVpId = null; // the viewport index of the first selection for 2D

    this.isActive = function() {
        return _active;
    };

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    this.activate = function() {
        _active = true;
    };

    this.deactivate = function() {
        _active = false;
        this.destroy();
    };

    this.getFace = function() {
        return _geomFace;
    };

    this.getEdge = function() {
        return _geomEdge;
    };

    this.getVertex = function() {
        return _geomVertex;
    };

    this.getGeometry = function() {

        switch (_geomHighlighted) {

            case SNAP_VERTEX: return this.getVertex(); break;
            case SNAP_EDGE: return this.getEdge(); break;
            case SNAP_FACE: return this.getFace(); break;
            case SNAP_CIRCULARARC: return this.getEdge(); break;
            case SNAP_CURVEDEDGE: return this.getEdge(); break;
            case SNAP_CURVEDFACE: return this.getFace(); break;
            default: break;
        }
    };

    this.getSnapNode = function() {
        return _snapNode;
    };

    this.getHighlightGeometry = function() {
        return _geomHighlighted;
    };

    this.getIntersectPoint = function() {
        return _intersectPoint;
    };

    this.getFaceNormal = function() {
        return _faceNormal;
    };

    this.getEndPointsInEdge = function(edge) {

        var vertices = edge.vertices;
        var endPoints = [];

        for (var i = 0; i < vertices.length; ++i) {

            var duplicate = false;

            for (var j = 0; j < vertices.length; ++j) {

                if (j !== i && vertices[j].equals(vertices[i])) {

                    duplicate = true;
                    break;
                }
            }

            if (!duplicate) {

                endPoints.push(vertices[i]);

            }
        }

        return endPoints;
    };

    this.getViewportIndex = function() {
        return _viewportIndex2d;
    };

    this.getCircularArcCenter = function() {
        return _circularArcCenter;
    };

    this.getCircularArcRadius = function() {
        return _circularArcRadius;
    };

    this.getDetectRadius = function() {
        return _radius;
    };

    this.isSnapped = function() {
        return _isSnapped;
    };

    this.setClip = function(clip) {
        _clip = clip;
    };

    this.setFirstClickVpId = function(vpId) {
        _firstClickVpId = vpId;
    };

    this.isEqualWithPrecision = function(a, b) {

        if (Math.abs(a - b) <= SNAP_PRECISION) {
            return true;
        }

        return false;
    };

    this.isEqualVectorsWithPrecision = function(v1, v2) {

        if (Math.abs(v1.x - v2.x) <= SNAP_PRECISION && Math.abs(v1.y - v2.y) <= SNAP_PRECISION && Math.abs(v1.z - v2.z) <= SNAP_PRECISION) {

            return true;
        }

        return false;
    };

    this.isInverseVectorsWithPrecision = function(v1, v2) {

        if (Math.abs(v1.x + v2.x) <= SNAP_PRECISION && Math.abs(v1.y + v2.y) <= SNAP_PRECISION && Math.abs(v1.z + v2.z) <= SNAP_PRECISION) {

            return true;
        }

        return false;
    };

    /**
     * 3D Snapping
     * @param result -Result of Hit Test.
     */
    this.snapping3D = function(result) {

        _snapNode = result.dbId;

        var face = result.face;
        _intersectPoint = result.intersectPoint;
        var fragIds;

        if (result.fragId.length === undefined) {
            fragIds = [result.fragId];
        } else {
            fragIds = result.fragId;
        }

        // This is for Fusion model with topology data
        if (_viewer.model.hasTopology()) {

            // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.
            if (_snapNode) {
                fragIds = [];

                _viewer.model.getData().instanceTree.enumNodeFragments(_snapNode, function(fragId) {
                    fragIds.push(fragId);
                }, true);
            }

            _geomFace = _geomEdge = _geomVertex = null;
            _distanceToEdge = Number.MAX_VALUE;

            for (var fi = 0; fi < fragIds.length; ++fi) {

                var fragId = fragIds[fi];
                var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragId);
                var geometry = mesh.geometry;

                var topoIndex = _viewer.model.getTopoIndex(fragId);
                var topology = _viewer.model.getTopology(topoIndex);
                var facesTopology = topology.faces;
                var edgesTopology = topology.edges;
                var verticesTopology = topology.vertices;

                if (!_geomFace) {
                    _geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, mesh);

                    if (_geomFace) {
                        _geomFace.fragId = fragId;
                    }

                    var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
                    _faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();
                }

                // Need to iterate all frags with same dbId, because when meshes are attached with each other, edges topology data will only be on one mesh.
                this.edgeSnappingWithTopology(_intersectPoint, geometry, edgesTopology, mesh);

            }

            _geomVertex = this.vertexSnappingWithTopology(_geomEdge, _intersectPoint);

            if (_geomFace) {

                // Determine which one should be drawn: face , edge or vertex
                _radius = this.setDetectRadius(_intersectPoint);

                if (_distanceToVertex < _radius) {

                    this.drawPoint(_geomVertex);
                    _geomHighlighted = SNAP_VERTEX;

                }
                else if (_distanceToEdge < _radius) {

                    this.drawLine(_geomEdge);

                    var center = this.edgeIsCircle(_geomEdge);
                    if (center) {
                        _circularArcCenter = center;
                        _circularArcRadius = center.distanceTo(_geomEdge.vertices[0]);
                        _geomHighlighted = SNAP_CIRCULARARC;
                    }
                    else if (this.edgeIsCurved(_geomEdge)) {
                        _geomHighlighted = SNAP_CURVEDEDGE;
                    }
                    else {
                        _geomHighlighted = SNAP_EDGE;
                    }

                }
                else {

                    this.drawFace(_geomFace);

                    if (this.faceIsCurved(_geomFace)) {
                        _geomHighlighted = SNAP_CURVEDFACE;
                    }
                    else {
                        _geomHighlighted = SNAP_FACE;
                    }

                }
                
                _isSnapped = true;
            }
        }
        else {

            for (var fi = 0; fi < fragIds.length; ++fi) {

                var fragId = fragIds[fi];
                var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragId);
                var geometry = mesh.geometry;

                _geomFace = this.faceSnapping(face, geometry);

                if (_geomFace) {

                    _geomFace.applyMatrix(mesh.matrixWorld);
                    _geomEdge = this.edgeSnapping(_geomFace, _intersectPoint);
                    _geomVertex = this.vertexSnapping(_geomEdge, _intersectPoint);

                    var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
                    _faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();

                    // Determine which one should be drawn: face , edge or vertex
                    _radius = this.setDetectRadius(_intersectPoint);

                    if (_distanceToVertex < _radius) {

                        this.drawPoint(_geomVertex);
                        _geomHighlighted = SNAP_VERTEX;

                    }
                    else if (_distanceToEdge < _radius) {

                        this.drawLine(_geomEdge);
                        _geomHighlighted = SNAP_EDGE;

                    }
                    else {

                        this.drawFace(_geomFace);
                        _geomHighlighted = SNAP_FACE;

                    }

                    _isSnapped = true;

                    break;
                }
            }
        }
    };

    this.faceSnappingWithTopology = function(face, geometry, facesTopology, mesh) {

        var vA = new THREE.Vector3();
        var vB = new THREE.Vector3();
        var vC = new THREE.Vector3();

        var geom = new THREE.Geometry();

        var attributes = geometry.attributes;

        if (attributes.index !== undefined) {

            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;

            // Find the index of face topology list which includes the intersect face(triangle)
            for (var i = 0; i < facesTopology.length; i++) {

                var indexList = facesTopology[i].indexList;
                var faceId = facesTopology[i].id;
                for (var j = 0; j < indexList.length; j += 3) {

                    if (face.a === indexList[j]) {
                        if ((face.b === indexList[j + 1] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j + 1])) {
                            break;
                        }
                    }
                    else if (face.a === indexList[j + 1]) {
                        if ((face.b === indexList[j] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j])) {
                            break;
                        }
                    }
                    else if (face.a === indexList[j + 2]) {
                        if ((face.b === indexList[j] && face.c === indexList[j + 1]) || (face.b === indexList[j + 1] && face.c === indexList[j])) {
                            break;
                        }
                    }
                }

                if (j < indexList.length) {
                    break;
                }
            }

            if (i < facesTopology.length) {

                for (var j = 0; j < indexList.length; j += 3) {
                    vA.set(
                        positions[ indexList[j] * stride ],
                        positions[ indexList[j] * stride + 1 ],
                        positions[ indexList[j] * stride + 2 ]
                    );
                    vB.set(
                        positions[ indexList[j + 1] * stride ],
                        positions[ indexList[j + 1] * stride + 1 ],
                        positions[ indexList[j + 1] * stride + 2 ]
                    );
                    vC.set(
                        positions[ indexList[j + 2] * stride ],
                        positions[ indexList[j + 2] * stride + 1 ],
                        positions[ indexList[j + 2] * stride + 2 ]
                    );

                    var vIndex = geom.vertices.length;

                    geom.vertices.push(vA.clone());
                    geom.vertices.push(vB.clone());
                    geom.vertices.push(vC.clone());

                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));
                }
            }
        }

        //console.log(face);

        if (geom.vertices.length > 0) {

            geom.faceId = faceId;
            geom.applyMatrix(mesh.matrixWorld);
            return geom;
        }
        else {

            return null;
        }

    };

    /**
     * Find the closest face next to the cast ray
     * @param face - the intersect triangle of Hit Test.
     * @param geometry - the geometry of mesh
     */
    this.faceSnapping = function(face, geometry) {

        var vA = new THREE.Vector3();
        var vB = new THREE.Vector3();
        var vC = new THREE.Vector3();

        var geom = new THREE.Geometry();  //Geometry which includes all the triangles on the same plane.

        var attributes = geometry.attributes;

        if (attributes.index !== undefined) {

            var indices = attributes.index.array || geometry.ib;
            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;
            var offsets = geometry.offsets;

            if ( !offsets || offsets.length === 0) {

                offsets = [{start: 0, count: indices.length, index: 0}];

            }

            for (var oi = 0; oi < offsets.length; ++oi) {

                var start = offsets[oi].start;
                var count = offsets[oi].count;
                var index = offsets[oi].index;

                for (var i = start; i < start + count; i += 3) {

                    var a = index + indices[i];
                    var b = index + indices[i + 1];
                    var c = index + indices[i + 2];

                    vA.set(
                        positions[a * stride],
                        positions[a * stride + 1],
                        positions[a * stride + 2]
                    );
                    vB.set(
                        positions[b * stride],
                        positions[b * stride + 1],
                        positions[b * stride + 2]
                    );
                    vC.set(
                        positions[c * stride],
                        positions[c * stride + 1],
                        positions[c * stride + 2]
                    );

                    var faceNormal = THREE.Triangle.normal(vA, vB, vC);

                    var va = new THREE.Vector3();
                    va.set(
                        positions[ face.a * stride ],
                        positions[ face.a * stride + 1 ],
                        positions[ face.a * stride + 2 ]
                    );

                    if (this.isEqualVectorsWithPrecision(faceNormal, face.normal) && this.isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))
                    {

                        var vIndex = geom.vertices.length;

                        geom.vertices.push(vA.clone());
                        geom.vertices.push(vB.clone());
                        geom.vertices.push(vC.clone());

                        geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));

                    }
                }
            }
        }

        if (geom.vertices.length > 0) {

            return this.getTrianglesOnSameFace(geom, face, positions, stride);
        }
        else {

            return null;
        }
    };

    /**
     * Find triangles on the same face with the triangle intersected with the cast ray
     * @param geom -Geometry which includes all the triangles on the same plane.
     * @param face -Triangle which intersects with the cast ray.
     * @param positions -Positions of all vertices.
     * @param stride -Stride for the interleaved buffer.
     */
    this.getTrianglesOnSameFace = function(geom, face, positions, stride) {

        var isIncludeFace = false; // Check if the intersect face is in the mesh
        var vertexIndices = geom.vertices.slice();

        var va = new THREE.Vector3();
        va.set(
            positions[ face.a * stride ],
            positions[ face.a * stride + 1 ],
            positions[ face.a * stride + 2 ]
        );
        var vb = new THREE.Vector3();
        vb.set(
            positions[ face.b * stride ],
            positions[ face.b * stride + 1 ],
            positions[ face.b * stride + 2 ]
        );
        var vc = new THREE.Vector3();
        vc.set(
            positions[ face.c * stride ],
            positions[ face.c * stride + 1 ],
            positions[ face.c * stride + 2 ]
        );
        var intersectFace = new THREE.Geometry();
        intersectFace.vertices.push(va);
        intersectFace.vertices.push(vb);
        intersectFace.vertices.push(vc);
        intersectFace.faces.push(new THREE.Face3(0, 1, 2));

        var vCount = [];

        do {

            vCount = [];

            for (var j = 0; j < vertexIndices.length; j += 3) {

                // The triangle which is intersected with the ray
                if (vertexIndices[j].equals(va) && vertexIndices[j + 1].equals(vb) && vertexIndices[j + 2].equals(vc)) {

                    isIncludeFace = true;
                    vCount.push(j);
                    continue;
                }

                for (var k = 0; k < intersectFace.vertices.length; k += 3) {

                    // The triangles which are on the same face with the intersected triangle
                    if (this.trianglesSharedEdge(vertexIndices[j], vertexIndices[j + 1], vertexIndices[j + 2],
                            intersectFace.vertices[k], intersectFace.vertices[k + 1], intersectFace.vertices[k + 2])) {

                        var vIndex = intersectFace.vertices.length;
                        intersectFace.vertices.push(vertexIndices[j].clone());
                        intersectFace.vertices.push(vertexIndices[j + 1].clone());
                        intersectFace.vertices.push(vertexIndices[j + 2].clone());
                        intersectFace.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));

                        vCount.push(j);
                        break;
                    }
                }
            }

            for (var ci = vCount.length - 1; ci >= 0; --ci) {

                vertexIndices.splice(vCount[ci], 3);

            }

        } while (vCount.length > 0);

        if (isIncludeFace) {
            return intersectFace;
        }
        else {
            return null;
        }

    };

    /**
     * Check if the two triangle share edge, the inputs are their vertices
     */
    this.trianglesSharedEdge = function(a1, a2, a3, b1, b2, b3) {

        var c1 = false;
        var c2 = false;
        var c3 = false;

        if (a1.equals(b1) || a1.equals(b2) || a1.equals(b3)) {
            c1 = true;
        }
        if (a2.equals(b1) || a2.equals(b2) || a2.equals(b3)) {
            c2 = true;
        }
        if (a3.equals(b1) || a3.equals(b2) || a3.equals(b3)) {
            c3 = true;
        }

        if (c1 & c2 || c1 & c3 || c2 & c3) {
            return true;
        }

        return false;
    };

    this.edgeSnappingWithTopology = function(intersectPoint, geometry, edgesTopology, mesh) {

        var edgeGeom = new THREE.Geometry();
        var minDistTopoIndex;
        var minDist = Number.MAX_VALUE;

        var vA = new THREE.Vector3();
        var vB = new THREE.Vector3();

        var attributes = geometry.attributes;

        if (attributes.index !== undefined && edgesTopology != undefined) {

            var positions = geometry.vb ? geometry.vb : attributes.position.array;
            var stride = geometry.vb ? geometry.vbstride : 3;

            // Find the index of edge topology list which includes the nearest edge segment to the intersect point
            for (var i = 0; i < edgesTopology.length; i++) {

                var indexList = edgesTopology[i].indexList;
                // In edges topology index list the type is LineStrip
                for (var j = 0; j < indexList.length - 1; j++) {
                    vA.set(
                        positions[ indexList[j] * stride ],
                        positions[ indexList[j] * stride + 1 ],
                        positions[ indexList[j] * stride + 2 ]
                    );
                    vB.set(
                        positions[ indexList[j + 1] * stride ],
                        positions[ indexList[j + 1] * stride + 1 ],
                        positions[ indexList[j + 1] * stride + 2 ]
                    );

                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);

                    var dist = this.distancePointToLine(intersectPoint, vA, vB);
                    if (dist < minDist) {
                        minDist = dist;
                        minDistTopoIndex = i;
                    }
                }
            }

            if (minDistTopoIndex) {
                indexList = edgesTopology[minDistTopoIndex].indexList;
                for (var k = 0; k < indexList.length - 1; k++) {
                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k] * stride], positions[indexList[k] * stride + 1], positions[indexList[k] * stride + 2]));
                    // To make the line's type to LinePieces which is used by drawLine function
                    edgeGeom.vertices.push(new THREE.Vector3(positions[indexList[k + 1] * stride], positions[indexList[k + 1] * stride + 1], positions[indexList[k + 1] * stride + 2]));
                }
            }
        }

        if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {

            _distanceToEdge = minDist;
            edgeGeom.applyMatrix(mesh.matrixWorld);
            _geomEdge = edgeGeom;
        }
    };

    /**
     * Find the closest edge next to the intersect point
     * @param face -Face which is found by faceSnapping.
     * @param intersectPoint -IntersectPoint between cast ray and face.
     * @param mesh -The whole mesh of one fragment.
     */
    this.edgeSnapping = function(face, intersectPoint) {

        var lineGeom = new THREE.Geometry();
        var isEdge_12 = true;
        var isEdge_13 = true;
        var isEdge_23 = true;

        for (var i = 0; i < face.vertices.length; i += 3) {

            for (var j = 0; j < face.vertices.length; j += 3) {

                if ( i !== j ) {
                    // Check edge 12
                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])
                        || face.vertices[i].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])
                        || face.vertices[i + 1].equals(face.vertices[j + 2]))) {

                        isEdge_12 = false;

                    }
                    // Check edge 13
                    if ((face.vertices[i].equals(face.vertices[j]) || face.vertices[i].equals(face.vertices[j + 1])
                        || face.vertices[i].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])
                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {

                        isEdge_13 = false;

                    }
                    // Check edge 23
                    if ((face.vertices[i + 1].equals(face.vertices[j]) || face.vertices[i + 1].equals(face.vertices[j + 1])
                        || face.vertices[i + 1].equals(face.vertices[j + 2]))
                        && (face.vertices[i + 2].equals(face.vertices[j]) || face.vertices[i + 2].equals(face.vertices[j + 1])
                        || face.vertices[i + 2].equals(face.vertices[j + 2]))) {

                        isEdge_23 = false;

                    }
                }
            }

            if (isEdge_12) {

                lineGeom.vertices.push(face.vertices[i].clone());
                lineGeom.vertices.push(face.vertices[i + 1].clone());

            }
            if (isEdge_13) {

                lineGeom.vertices.push(face.vertices[i].clone());
                lineGeom.vertices.push(face.vertices[i + 2].clone());

            }
            if (isEdge_23) {

                lineGeom.vertices.push(face.vertices[i + 1].clone());
                lineGeom.vertices.push(face.vertices[i + 2].clone());

            }

            isEdge_12 = true;
            isEdge_13 = true;
            isEdge_23 = true;

        }

        //return lineGeom;

        var edgeGeom = new THREE.Geometry();
        var minDistIndex;
        var minDist = Number.MAX_VALUE;

        for (var k = 0; k < lineGeom.vertices.length; k += 2) {

            var dist = this.distancePointToLine(intersectPoint, lineGeom.vertices[k], lineGeom.vertices[k + 1]);

            if (dist < minDist) {
                minDist = dist;
                minDistIndex = k;
            }

        }

        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex ].clone());
        edgeGeom.vertices.push(lineGeom.vertices[ minDistIndex + 1 ].clone());

        edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeGeom.vertices);

        _distanceToEdge = minDist;

        return edgeGeom;

    };

    this.distancePointToLine = function (point, lineStart, lineEnd) {

        var X0 = new THREE.Vector3();
        var X1 = new THREE.Vector3();
        var distance;
        var param;

        X0.subVectors(lineStart, point);
        X1.subVectors(lineEnd, lineStart);
        param = X0.dot(X1);
        X0.subVectors(lineEnd, lineStart);
        param = -param / X0.dot(X0);

        if (param < 0) {
            distance = point.distanceTo(lineStart);
        }
        else if (param > 1) {
            distance = point.distanceTo(lineEnd);
        }
        else {
            X0.subVectors(point, lineStart);
            X1.subVectors(point, lineEnd);
            X0.cross(X1);
            X1.subVectors(lineEnd, lineStart);

            distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));
        }

        return distance;
    };

    this.getConnectedLineSegmentsOnSameLine = function(lineGeom, edgeVertices) {

        var vertices = lineGeom.vertices.slice();
        var va = edgeVertices[0];
        var vb = edgeVertices[1];

        var vCount = [];

        do {

            vCount = [];

            for (var j = 0; j < vertices.length; j += 2) {

                // The line which has min distance to intersection point
                if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {

                    continue;
                }

                for (var k = 0; k < edgeVertices.length; k += 2) {

                    // The line segments which are connected on the same line
                    if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||
                        vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {

                        var V0 = new THREE.Vector3();
                        var V1 = new THREE.Vector3();

                        V0.subVectors(edgeVertices[k],  edgeVertices[k + 1]);
                        V0.normalize();
                        V1.subVectors(vertices[j],vertices[j + 1]);
                        V1.normalize();

                        //if (V0.equals(V1) || V0.equals(V1.negate())) {
                        if (this.isEqualVectorsWithPrecision(V0, V1) || this.isInverseVectorsWithPrecision(V0, V1))
                        {

                            vCount.push(j);
                            break;

                        }
                    }
                }
            }

            for (var ci = vCount.length - 1; ci >= 0; --ci) {

                edgeVertices.push(vertices[ vCount[ci] ]);
                edgeVertices.push(vertices[ vCount[ci] + 1 ]);
                vertices.splice(vCount[ci], 2);

            }

        } while (vCount.length > 0);

        return edgeVertices;

    };

    this.vertexSnappingWithTopology = function(edge, intersectPoint) {

        var minDist = Number.MAX_VALUE;
        var point = new THREE.Vector3();

        if (edge && edge.vertices.length > 1) {
            var dist1 = intersectPoint.distanceTo(edge.vertices[0]);
            var dist2 = intersectPoint.distanceTo(edge.vertices[edge.vertices.length - 1]);

            if (dist1 <= dist2) {
                minDist = dist1;
                point = edge.vertices[0].clone();
            }
            else {
                minDist = dist2;
                point = edge.vertices[edge.vertices.length - 1].clone();
            }
        }

        _distanceToVertex = minDist;

        return point;
    };

    /**
     * Find the closest vertex next to the intersect point
     * @param edge -Edge which is found by edgeSnapping.
     * @param intersectPoint -IntersectPoint between cast ray and face.
     */
    this.vertexSnapping = function(edge, intersectPoint) {

        var minDist = Number.MAX_VALUE;
        var point = new THREE.Vector3();

        for (var i = 0; i < edge.vertices.length; ++i) {

            var dist = intersectPoint.distanceTo(edge.vertices[i]);

            if (dist < minDist - SNAP_PRECISION) {

                minDist = dist;
                point = edge.vertices[i].clone();

            }
        }

        _distanceToVertex = minDist;

        return point;
    };

    // This is only a workaround to detect if an edge is circle
    this.edgeIsCircle = function(edge) {

        var vertices = edge.vertices;

        // Exclude squares and regular polygons
        if (vertices.length < 8) {
            return false;
        }

        if (vertices[0].equals(vertices[vertices.length - 1])) {

            var center = new THREE.Vector3(0, 0, 0);
            for (var i = 0; i < vertices.length; i += 2) {
                center.add(vertices[i]);
            }
            center.divideScalar(vertices.length / 2.0);

            var radius = center.distanceTo(vertices[0]);
            for (var i = 0; i < vertices.length; i += 2) {
                if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {
                    continue;
                }
                else {
                    return false;
                }
            }
            return center;
        }
        else {
            return false;
        }
    };

    this.edgeIsCurved = function (edge) {

        var vertices = edge.vertices;

        if (vertices.length <= 2) {
            return false;
        }
        else if (vertices[0].equals(vertices[vertices.length - 1])) {
            return true;
        }
        else {
            var V1 = new THREE.Vector3();
            V1.subVectors(vertices[0], vertices[1]);

            var V2 = new THREE.Vector3();
            for (var i = 2; i < vertices.length; i += 2) {
                V2.subVectors(vertices[i], vertices[i + 1]);
                if (!this.isEqualVectorsWithPrecision(V1, V2)) {
                    return true;
                }
            }

            return false;
        }
    };

    this.faceIsCurved = function (face) {

        var vertices = face.vertices;
        var faces = face.faces;

        if (faces.length <= 1) {
            return false;
        }
        else {
            var fN1 = THREE.Triangle.normal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c]);
            var vA1 = vertices[faces[0].a];

            for (var i = 1; i < faces.length; i++) {
                var fN2 = THREE.Triangle.normal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c]);
                var vA2 = vertices[faces[i].a];

                if (!this.isEqualVectorsWithPrecision(fN1, fN2) || !this.isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {
                    return true;
                }
            }

            return false;
        }
    };

    this.angleVector2 = function(vector) {

        if (vector.x > 0 && vector.y >= 0) {
            return Math.atan(vector.y / vector.x);
        }
        else if (vector.x >= 0 && vector.y < 0) {
            return Math.atan(vector.y / vector.x) + Math.PI * 2;
        }
        else if (vector.x < 0 && vector.y <= 0) {
            return Math.atan(vector.y / vector.x) + Math.PI;
        }
        else if (vector.x <= 0 && vector.y > 0) {
            return Math.atan(vector.y / vector.x) + Math.PI;
        }
        else{ // x = 0, y = 0
            return null;
        }
    };

    function GeometryCallback(viewer, snapper) {
        this.viewer = viewer;
        this.snapper = snapper;

        this.lineGeom = new THREE.Geometry();
        this.circularArc = null;
        this.circularArcCenter;
        this.circularArcRadius;
        this.ellipticalArc = null;
        this.ellipticalArcCenter;

        this.minDist = Number.MAX_VALUE;

        this.vpIdLine = null;
        this.vpIdCircular = null;
        this.vpIdElliptical = null;

        this.detectRadius = this.snapper.getDetectRadius();
    }

    GeometryCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {
        //stderr("line segment");
        var intersectPoint = this.snapper.getIntersectPoint();
        var vertices = this.lineGeom.vertices;
        var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);
        var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);

        var dist = this.snapper.distancePointToLine(intersectPoint, v1, v2);
        if (dist <= this.detectRadius && dist < this.minDist) {

            vertices.splice(0, 2, v1, v2);
            this.minDist = dist;

            this.vpIdLine = vpId;
        }
    };

    GeometryCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {
        //stderr("circular arc");
        var intersectPoint = this.snapper.getIntersectPoint();
        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);

        var center = new THREE.Vector2(cx, cy);
        var dist = point.distanceTo(center);
        point.sub(center);

        var angle = this.snapper.angleVector2(point);

        if (Math.abs(dist - radius) <= this.detectRadius) {

            if (end > start && angle >= start && angle <= end) {
                var arc = new THREE.CircleGeometry(radius, 100, start, end - start);
            }
            else if (end < start && (angle >= start || angle <= end)) {
                var arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);
            }
            else {
                return;
            }
            arc.vertices.splice(0, 1);
            arc.applyMatrix(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));
            this.circularArc = arc;
            this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);
            this.circularArcRadius = radius;

            this.vpIdCircular = vpId;
        }
    };

    GeometryCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {
        //stderr("elliptical arc");
        var intersectPoint = this.snapper.getIntersectPoint();
        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);

        var major1 = major - this.detectRadius;
        var minor1 = minor - this.detectRadius;
        var major2 = major + this.detectRadius;
        var minor2 = minor + this.detectRadius;

        var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);
        var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);

        var center = new THREE.Vector2(cx, cy);
        point.sub(center);
        point.x *= minor;
        point.y *= major;
        var angle = this.snapper.angleVector2(point);

        if (end > Math.PI * 2) {
            end = Math.PI * 2;
        }

        if (equation1 >= 1 && equation2 <= 1) {

            if ((end > start && angle >= start && angle <= end) || (end < start && (angle >= start || angle <= end))){
                var curve = new THREE.EllipseCurve(cx, cy, major, minor, start, end, false);
                var path = new THREE.Path(curve.getPoints(50));
                var arc = path.createPointsGeometry(50);

                if (!this.snapper.isEqualWithPrecision(end - start, Math.PI * 2))
                {
                    arc.vertices.pop();
                }
                arc.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));
                this.ellipticalArc = arc;
                this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);

                this.vpIdElliptical = vpId;
            }
        }
    };


    this.snapping2D = function(result) {

        if (!result) {
            return;
        }
        
        var intersectPoint = result.intersectPoint;
        var fragIds = result.fragId;

        //if (_clip && !_viewer.model.pointInPolygon(intersectPoint.x, intersectPoint.y, _clip.contours, _clip.points)) {
        //    return;
        //}

        if (typeof fragIds === "undefined") {
            return;
        }
        else if (!Array.isArray(fragIds)) {
            fragIds = [fragIds];
        }

        _intersectPoint = intersectPoint;

        // Determine which one should be drawn: line, circular arc or elliptical arc
        _radius = this.setDetectRadius(intersectPoint);

        var gc = new GeometryCallback(_viewer, this);

        for (var fi = 0; fi < fragIds.length; ++fi) {

            var mesh = _viewer.impl.getRenderProxy(_viewer.model, fragIds[fi]);

            var vbr = new Autodesk.Viewing.Private.VertexBufferReader(mesh.geometry);
            vbr.enumGeomsForObject(result.dbId, gc);

        }

        if (gc.circularArc) {

            _viewportIndex2d = gc.vpIdCircular;

            // Only snap the geometries which belong to the same viewport as the first selection
            if (_firstClickVpId !== null && _firstClickVpId !== _viewportIndex2d)
                return;

            if (intersectPoint.distanceTo(gc.circularArc.vertices[0]) < _radius) {

                _geomVertex = gc.circularArc.vertices[0];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else if (intersectPoint.distanceTo(gc.circularArc.vertices[gc.circularArc.vertices.length - 1]) < _radius) {

                _geomVertex = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else {

                this.lineStripToPieces(gc.circularArc);
                _geomEdge = gc.circularArc;
                this.drawLine(_geomEdge);
                _circularArcCenter = gc.circularArcCenter;
                _circularArcRadius = gc.circularArcRadius;
                _geomHighlighted = SNAP_CIRCULARARC;
            }

            _isSnapped = true;

        }
        else if (gc.ellipticalArc) {

            _viewportIndex2d = gc.vpIdElliptical;

            // Only snap the geometries which belong to the same viewport as the first selection
            if (_firstClickVpId !== null && _firstClickVpId !== _viewportIndex2d)
                return;

            if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[0]) < _radius) {

                _geomVertex = gc.ellipticalArc.vertices[0];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else if (intersectPoint.distanceTo(gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1]) < _radius) {

                _geomVertex = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else {

                this.lineStripToPieces(gc.ellipticalArc);
                _geomEdge = gc.ellipticalArc;
                this.drawLine(_geomEdge);
                // Before we have measure design for elliptical arc, measure the center for now
                _circularArcCenter = gc.ellipticalArcCenter;
                _circularArcRadius = null;
                _geomHighlighted = SNAP_CIRCULARARC;
            }

            _isSnapped = true;

        }
        else if (gc.lineGeom.vertices.length) {

            _viewportIndex2d = gc.vpIdLine;

            // Only snap the geometries which belong to the same viewport as the first selection
            if (_firstClickVpId !== null && _firstClickVpId !== _viewportIndex2d)
                return;

            if (intersectPoint.distanceTo(gc.lineGeom.vertices[0]) < _radius) {

                _geomVertex = gc.lineGeom.vertices[0];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else if (intersectPoint.distanceTo(gc.lineGeom.vertices[1]) < _radius) {

                _geomVertex = gc.lineGeom.vertices[1];
                this.drawPoint(_geomVertex);
                _geomHighlighted = SNAP_VERTEX;
            }
            else {

                _geomEdge = gc.lineGeom;
                this.drawLine(_geomEdge);
                _geomHighlighted = SNAP_EDGE;
            }

            _isSnapped = true;
        }

    };

    this.lineStripToPieces = function(geom) {

        var vertices = geom.vertices;
        for (var i = vertices.length - 2; i > 0; i--) {
            vertices.splice(i, 0, vertices[i]);
        }
    };

    this.createOverlay = function(overlayName) {

        _viewer.impl.createOverlayScene(overlayName);

    };

    this.addOverlay = function(overlayName, mesh) {

        _viewer.impl.addOverlay(overlayName, mesh);

    };

    this.clearOverlay = function() {

        if (_viewer.impl.overlayScenes[_faceOverlayName]) {
            _viewer.impl.clearOverlay(_faceOverlayName);
        }

        if (_viewer.impl.overlayScenes[_vertexOverlayName]) {
            _viewer.impl.clearOverlay(_vertexOverlayName);
        }

        if (_viewer.impl.overlayScenes[_edgeOverlayName]) {
            _viewer.impl.clearOverlay(_edgeOverlayName);
        }

    };

    /**
     * Draw the planar face
     * @param geom -Geometry which needs to be draw.
     * @param mesh -Mesh which is loaded.
     */
    this.drawFace = function(geom) {

        this.createOverlay(_faceOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        //geom.attributes.index.array = new geom.attributes.index.array.constructor(indicesNew);
        var snapperPlane = new THREE.Mesh(geom, material, true);
        //snapperPlane.matrixWorld = mesh.matrixWorld;

        this.addOverlay(_faceOverlayName, snapperPlane);

    };

    this.cylinderMesh = function(pointX, pointY, material) {

        var direction = new THREE.Vector3().subVectors(pointY, pointX);
        var orientation = new THREE.Matrix4();
        orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
            0, 0, 1, 0,
            0, -1, 0, 0,
            0, 0, 0, 1));
        var edgeGeometry = new THREE.CylinderGeometry(0.5, 0.5, direction.length(), 8, 1, true);
        var edge = new THREE.Mesh(edgeGeometry, material);
        edge.applyMatrix(orientation);
        edge.position.x = (pointY.x + pointX.x) / 2;
        edge.position.y = (pointY.y + pointX.y) / 2;
        edge.position.z = (pointY.z + pointX.z) / 2;
        return edge;

    };

    this.drawLine = function(geom) {

        this.createOverlay(_edgeOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        // Line Pieces
        for (var i = 0; i < geom.vertices.length; i += 2) {
            var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material);
            this.setEdgeScale(cylinder);
            this.addOverlay(_edgeOverlayName, cylinder);
        }
    };

    this.drawArc = function(geom) {

        this.createOverlay(_edgeOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        // Line Strip
        for (var i = 0; i < geom.vertices.length - 1; i++) {
            var cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material);
            this.setEdgeScale(cylinder);
            this.addOverlay(_edgeOverlayName, cylinder);
        }
    };

    this.drawPoint = function(point) {

        this.createOverlay(_vertexOverlayName);

        var planeColor = 0x00CC00;
        var planeOpacity = 0.5;

        var material = new THREE.MeshPhongMaterial({
            color: planeColor,
            ambient: planeColor,
            opacity: planeOpacity,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });

        var pointMesh = new THREE.Mesh(new THREE.SphereGeometry(1.0), material);
        //point.applyMatrix4(mesh.matrixWorld);
        pointMesh.position.set(point.x, point.y, point.z);

        this.setPointScale(pointMesh);

        this.addOverlay(_vertexOverlayName, pointMesh);

    };

    this.setScale = function (mesh) {
        var pixelSize = 5;

        var navapi = _viewer.navigation;
        var camera = navapi.getCamera();

        var view = navapi.getEyeVector();
        var position = navapi.getPosition();

        var point = mesh.position.clone();

        var distance = camera.isPerspective ? point.sub(position).dot(view.normalize())
            : navapi.getEyeVector().length();

        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var scale = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

        return scale;
    };

    this.setPointScale = function (pointMesh) {

        var scale = this.setScale(pointMesh);
        pointMesh.scale.x = scale;
        pointMesh.scale.y = scale;
        pointMesh.scale.z = scale;

    };

    this.setEdgeScale = function (cylinderMesh) {

        var scale = this.setScale(cylinderMesh);
        cylinderMesh.scale.x = scale;
        cylinderMesh.scale.z = scale;
    };

    this.updatePointScale = function() {

        var overlay = _viewer.impl.overlayScenes[_vertexOverlayName];
        if (overlay) {
            var scene = overlay.scene;

            for (var i = 0; i < scene.children.length; i++) {
                var pointMesh = scene.children[i];
                if (pointMesh) {

                    this.setPointScale(pointMesh);
                }
            }
        }
    };

    this.updateEdgeScale = function() {

        var overlay = _viewer.impl.overlayScenes[_edgeOverlayName];
        if (overlay) {
            var scene = overlay.scene;

            for (var i = 0; i < scene.children.length; i++) {
                var cylinderMesh = scene.children[i];
                if (cylinderMesh) {

                    this.setEdgeScale(cylinderMesh);
                }
            }
        }
    };

    this.setDetectRadius = function(point) {

        //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of
        //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.
        var pixelSize = 10;

        var navapi = _viewer.navigation;
        var camera = navapi.getCamera();

        var view = navapi.getEyeVector();
        var position = navapi.getPosition();

        var p = point.clone();

        var distance = camera.isPerspective ? p.sub(position).dot(view.normalize())
            : navapi.getEyeVector().length();

        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var radius = pixelSize * worldHeight / (viewport.height * devicePixelRatio);

        return radius;
    };

    this.drawIntersectFace = function(face, positions, stride, mesh) {

        this.createOverlay();

        var va = new THREE.Vector3();
        va.set(
            positions[ face.a * stride ],
            positions[ face.a * stride + 1 ],
            positions[ face.a * stride + 2 ]
        );
        var vb = new THREE.Vector3();
        vb.set(
            positions[ face.b * stride ],
            positions[ face.b * stride + 1 ],
            positions[ face.b * stride + 2 ]
        );
        var vc = new THREE.Vector3();
        vc.set(
            positions[ face.c * stride ],
            positions[ face.c * stride + 1 ],
            positions[ face.c * stride + 2 ]
        );

        var intersectFace = new THREE.Geometry();
        intersectFace.vertices.push(va);
        intersectFace.vertices.push(vb);
        intersectFace.vertices.push(vc);
        intersectFace.faces.push(new THREE.Face3(0, 1, 2));

        var faceMesh = new THREE.Mesh(intersectFace, mesh.material, true);
        faceMesh.matrixWorld = mesh.matrixWorld;

        this.addOverlay(faceMesh);

    };

    this.handleWheelInput = function (delta) {
        this.updatePointScale();
        this.updateEdgeScale();
        return false;
    };

    this.handleButtonDown = function (event, button) {
        _isDragging = true;
        return false;
    };

    this.handleButtonUp = function (event, button) {
        _isDragging = false;
        return false;
    };

    this.handleMouseMove = function (event) {

        if (!_isDragging) {

            this.clearOverlay();

            _geomFace = null;
            _geomEdge = null;
            _geomVertex = null;

            _isSnapped = false;

            var result = _viewer.impl.snappingHitTest(event.canvasX, event.canvasY, false);

            if (result && result.intersectPoint) {

                //console.log("intersect node is " + result.node.dbId);
                //console.log("fragId is " + result.node.fragIds);

                // 3D Snapping
                if (result.face) {

                    this.snapping3D(result);
                }
                // 2D Snapping
                else {

                    this.snapping2D(result);
                }
            }
        }
        return false;
    };

    this.destroy = function() {

        this.clearOverlay();

        _viewer.impl.removeOverlayScene(_faceOverlayName);
        _viewer.impl.removeOverlayScene(_vertexOverlayName);
        _viewer.impl.removeOverlayScene(_edgeOverlayName);

    };

};
;(function() {

/*
 * First Person View tool for LMV
 *
 * This tool provides a first person view with movement using the standard WASD keys
 * to forward/backward/left/right and the QE keys to move vertically.  The mouse or
 * cursor is used to orient the view.  Movement is always along or perpendicular to
 * the view direction.
 *
 * The SHIFT key may be used when moving to increase the speed.  Or the default
 * movement speed may be increased/decreased with the MINUS or EQUAL keys.  The
 * ZERO (0) will reset to the default speed values.
 *
 * @author Hans Kellner (Oct 2014)
 *
 */

AutodeskNamespace('Autodesk.Viewing.Extensions.FirstPerson');

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonTool = function ( viewerapi ) {

    var _isMac = (navigator.userAgent.search("Mac OS") != -1);
    var _navapi = viewerapi.navigation;
    var _container = viewerapi.container;
    var _camera = _navapi.getCamera();
    var _names = ["firstperson"];

    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0 };  // TODO: Use the hotkeymanager for these.
    var _keys = Autodesk.Viewing.theHotkeyManager.KEYCODES;

    var _isActive = false;


    // true to disable mouse & keyboard navigation.  Used when a HUD is visible to simulate
    // a modal dialog.
    var _ignoreMouseAndKeyNav = false;

    // if true then mouse drag changes view orientation, otherwise just mouse move.
    // If this is set to false then auto-tracking is enabled which might be a usability
    // issue depending on where the cursor is locate when the tool is enabled.
    // Movement is based on the distance the cursor is located from the center of
    // the screen.  If the cursor is away from center when the tool is enabled then
    // in auto-tracking (non-drag) mode the camera will begin moving.  This may be
    // disconcerting to the user.
    var _mouseDraggingLookMode = true;

    var _isDragging = false;
    var _mouseButtons = 0;
    var _touchType = null;

    var _clock = new THREE.Clock(true);

    var _hudMessageStartShowTime = -1;
    var _hudMessageShowTime = 5000;     // milliseconds to show HUD

    var _modelUnitScale = 1.0; // meters
    var _modelScaleFactor = 1.0;

    // These values define how fast/slow the camera movements are made.
    // Adjust these to fine tune the movement.
    var _movementSpeedDefault = 2.0;
    var _movementSpeed = 2.0;
    var _wheelMovementSpeed = 1.0;
    var _verticalMovementSpeed = 0.5;
    var _lookSpeed = 0.0035;

    // Distance from middle of screen (non-drag) or start position (drag) that's
    // considered a neutral no-move zone when in non-drag movement mode.
    var _neutralZoneDist = 40;

    var _wheelDelta = 0;

    // Current cursor
    var _mouseXstart = 0, _mouseDX = 0, _lastX = -1e20;
    var _mouseYstart = 0, _mouseDY = 0, _lastY = -1e20;

    // Limits on mouse distance to throttle look speed
    var _mouseXMaxLimit = 400;
    var _mouseYMaxLimit = 400;

    // Relative movement
    var _deltaYaw = 0;
    var _deltaPitch = 0;

    // Key movement flags
    var _moveForward = false;
    var _moveBackward = false;
    var _moveLeft = false;
    var _moveRight = false;
    var _moveUp = false;
    var _moveDown = false;

    // Previous FOV and Perspective settings
    var _previousFov = _camera.fov;
    var _restorePreviousFov = false;

    var _wasPerspective = _camera.isPerspective;
    var _restorePreviousPerspective = false;

    // Help HUD
    var _bDontShowAgain_HelpHUD = false;

    //gamepad
    var _gamepadModule;
    //if this browser supports gamepad, instantiate GamepadModule
    if(navigator.getGamepads || !!navigator.webkitGetGamepads || !!navigator.webkitGamepads){
        _gamepadModule = new Autodesk.Viewing.Extensions.GamepadModule(viewerapi);
    }
    // ToolInterface

    this.isActive = function()
    {
        return _isActive;
    };

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        _clock.start();

        // Switch to perspective
        _wasPerspective = _camera.isPerspective;
        _navapi.toPerspective();

        // Change FOV to a wide value for a better 1st person experience
        _previousFov = _camera.fov;
        _navapi.setVerticalFov(75, true);

        // Unit scale
        _modelUnitScale = viewerapi.model.getUnitScale();

        // Calculate a movement scale factor based on the model bounds.
        var boundsSize = viewerapi.model.getBoundingBox().size();
        _modelScaleFactor = Math.max(Math.min(Math.min(boundsSize.x,boundsSize.y),boundsSize.z) / 10.0, 0.0001);

        // HACK: Place focus in canvas so we get key events.
        viewerapi.canvas.focus();

        _isActive = true;

        // Display the HUD on startup but only if "don't show me again" wasn't requested
        if (viewerapi.getFirstPersonToolPopup() && !_bDontShowAgain_HelpHUD) {
            showHelpHUD();
        }

        addCrosshair();

        if (_gamepadModule) {
            _gamepadModule.activate(this.getName());
        }
    };

    this.deactivate = function(name)
    {
        _isActive = false;

        _clock.stop();

        hideHUD();
        removeCrosshair();

        if (_restorePreviousFov) {
            _navapi.setVerticalFov(_previousFov, true);
        }

        if (_restorePreviousPerspective) {
            if (!_wasPerspective)
                _navapi.toOrthographic();
        }

        if(_gamepadModule)
            _gamepadModule.deactivate();

    };

    this.getCursor = function()
    {
        return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3goOFQoQszohGAAAA9hJREFUSMedll1oHGUUhp8zuzP5291pEvNTomgVjFCCCa0NpAqJEJTUFVv8uWxQLwKCF6IUr7wJ6J30QvBCAlZssA0EkYJaAm1FwU3iakrbVNNuutlukk3dzWyT/ZnJ7ufFTtokbmvX72Y45+N73/Oe8858I+xYSikBJJFI7AmFQh9alvVWoVC47vP5ho4cOXJeRGwqWN4yOQ2oHh0dPROJRNo7OjqIRCKPRxeiP66srBxSSn0vIsX/RaCU0gDV399vNjQ0tB8/fpxAIEAsFuP06dPEYrFvgHqguEMxIqLKdUPbmnArU52dnb2maWJUGeRyOWzbpqGxgXg87gOMncDlwLe2Y5uCwcHBFp/P90k4PE349xkWolGi0SjhPy5hF+UmIEopz/1AtxRcqmJzDQ8P7750+Wq8e9+TPGLe4sSp39jz9LMsxm/izE6gOVnquoIcOHDgnddfe/VEU3PLWkUzSCQSesCzxNtvHKZu11O0137OuTMneYY1+l+px99sci5zgU+/Pv/Z5OTkWeCvigja2tqqri3/RPbiMfSWLvY+/wJ7XwxCOoyz+gPF5C0OzsFZv8NEOOxU7KL5+fkcooFUo9avYt+4htTU43noJVTmIPYvp8hnChSKCr/fr1VMkEqlCgEATUDTAIVykhSWRtj4M4/KKzZ9Z9u2ehCCbVUYhlEaurg7m09NB/GWYhe2r69vV8UEvb29DeIWL+6uIG6w6b1SGAqF0hUTZDKZ7GLKy1w0h+Z1keQuMEDOKbK+oZFIJOyKZqCUEsuy/k4mk6kr0ZH6/Z2CkrttEl1QjuJkKI3z6KGp6vTFpYoVmKaZ9Xg8lleDoq3IzOdBILuygbVgs2YVSNrgOM7o1NTURkUE7qufX15evo5A0VHcnrNRgFgFJF6gsVmntlaIxWKNIlK/s8D/VCAianZ29spmv0vfVoVuaNT6PYhWMpGIGIZhNAGtQC3bbXDfj51YlrWObHeOKu3didfX1x3btgGqgADgu5eafyXT6XT2zmDLnVDg9Xq9uq573fMeQAeqy+HtTAgguq7h0aUsgyZCJpPZcBxnE1xz3fhACqp7enoe+3ZimVg8j6ELiIACEUETWErnsCwrD2h1dXW6C+4A2a033T0VfPD+e8dePvoFb36sM/LzKomkQ1FgMW3z7neL3Gh6jtbW1rmamhrDNM0NYAVIAYWyl06ZPwoNeHh6evqJmZmZiV8vnCBw+yLRRCv7gkdpamr6aGho6KuBgQFnfHx88V7AZQlcEt01jgD+sbGx3V+OjPR07d8fDQaDl1OpVLK7u9swTXP1Qa7NfwCi46BIaoRmhAAAAABJRU5ErkJggg==), auto";
    };

    this.adjustSpeed = function( direction )
    {
        if ( direction === 0 ) { // reset to default
            _movementSpeed = _movementSpeedDefault;
        }
        else {
            _movementSpeed *= (direction > 0) ?  1.10 : 0.90;
            if ( _movementSpeed < 0.01 ) {
                _movementSpeed = 0.01;
            }
        }
    };

    function getEventModifierState(event)
    {
        if ( !!_touchType )
            return false;

        var ctrlKey = event.ctrlKey || (_isMac && event.metaKey);
        var metaKey = event.metaKey && !_isMac;

        //console.log("Mod keys: ctrl = "+ctrlKey+" meta = "+metaKey+" alt^ctrl = "+ (event.altKey ^ ctrlKey));

        return ctrlKey || metaKey || event.shiftKey || event.altKey;
    }

    /////////////////////////////////////////////////////////////////////////
    // Tool event handler callbacks - can use "this".

    this.handleGesture = function( event )
    {
        // Convert Hammer touch-event X,Y into mouse-event X,Y.
        if (event.pointers && event.pointers.length > 0) {
            event.pageX = event.pointers[0].pageX;
            event.pageY = event.pointers[0].pageY;
        }

        switch( event.type )
        {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                if( _touchType === "drag" )
                {
                    this.handleButtonUp(event, 0);
                    _touchType = null;
                    return true;
                }
                return false;
        }

        return false;
    };

    this.handleSingleClick = function( event, button )
    {
        return false;
    };

    this.handleButtonDown = function( event, button )
    {
        hideHUD();

        _mouseButtons += 1 << button;

        var modifierState = getEventModifierState(event);
        if (button === 0 && !modifierState) {

            _mouseXstart = event.pageX - window.innerWidth / 2;
            _mouseYstart = event.pageY - window.innerHeight / 2;

            _lastX = event.pageX;
            _lastY = event.pageY;

            _deltaYaw = _deltaPitch = 0;
            _mouseDX = _mouseDY = 0;
            _isDragging = true;
            return true;
        }

        return true;    // Eat all these so default tools don't screw with view
    };

    this.handleMouseMove = function( event )
    {
        var dx = (_lastX < -1e10) ? 0 : event.pageX - _lastX;
        var dy = (_lastY < -1e10) ? 0 : event.pageY - _lastY;
        _lastX = event.pageX;
        _lastY = event.pageY;

        if ( (_isDragging === _mouseDraggingLookMode) && !_ignoreMouseAndKeyNav)
        {
            // Joystick Camera Orientation
            /** DISABLED
            var xNew = event.pageX - window.innerWidth / 2;
            var yNew = event.pageY - window.innerHeight / 2;

            if (_mouseDraggingLookMode) {
                // If in drag mode then movement is relative to start point
                _mouseDX = xNew - _mouseXstart;
                _mouseDY = yNew - _mouseYstart;
            }
            else {
                _mouseDX = xNew;
                _mouseDY = yNew;
            }

            // A circular area in the middle of the screen or around the start point
            // defines a neutral area in which no movement occurs.
            var mouseMoveDist = Math.sqrt( _mouseDX * _mouseDX + _mouseDY * _mouseDY );
            if ( mouseMoveDist < _neutralZoneDist ) {
                _mouseDX = _mouseDY = 0;
            }
            DISABLED **/

            // Discrete Camera Orientation
            _deltaYaw   += dx * _lookSpeed;
            _deltaPitch += dy * _lookSpeed;
        }

        return true;    // Eat all these so default tools don't screw with view
    };

    this.handleButtonUp = function( event, button )
    {
        _mouseButtons -= 1 << button;

        // If are dragging for a specific button then end dragging no matter
        // what the state of the modifiers.  Otherwise you won't end dragging.
        if (button === 0 && _isDragging) {
            _deltaYaw = _deltaPitch = 0;
            _mouseDX = _mouseDY = 0;
            _isDragging = false;
            return true;
        }

        return true;    // Eat all these so default tools don't screw with view
    };

    this.handleKeyDown = function( event, keyCode )
    {
        if (_ignoreMouseAndKeyNav) {
            return false;
        }

        hideHUD();

        var isModKey = false;
        var handled = false;

        switch( keyCode )
        {
            case _keys.ESCAPE:
                break;

            case _keys.TAB: handled = false; break;

            // Eat the modifiers so defualt tools don't activate and mess with cam
            case _keys.SHIFT:   _modifierState.SHIFT = 1;   isModKey = handled = true; break;
            case _keys.CONTROL: _modifierState.CONTROL = 1; isModKey = handled = true; break;
            case _keys.ALT:     _modifierState.ALT = 1;     isModKey = handled = true; break;
            case _keys.SPACE:   _modifierState.SPACE = 1;   isModKey = handled = true; break;

            case _keys.EQUALS: this.adjustSpeed(1);  handled = true; break;
            case _keys.DASH:   this.adjustSpeed(-1); handled = true; break;
            case _keys.ZERO:   this.adjustSpeed(0);  handled = true; break; // Reset dolly speed to default

            case _keys.UP:
            case _keys.w:
                _moveForward = true; handled = true;
                break;

            case _keys.LEFT:
            case _keys.a:
                _moveLeft = true; handled = true;
                break;

            case _keys.DOWN:
            case _keys.s:
                _moveBackward = true; handled = true;
                break;

            case _keys.RIGHT:
            case _keys.d:
                _moveRight = true; handled = true;
                break;

            case _keys.q:
                _moveUp = true; handled = true;
                break;

            case _keys.e:
                _moveDown = true; handled = true;
                break;

            case _keys.g:
                handled = true;
                break;

            case _keys.F1:
                handled = true;
                break;
        }

        return handled;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        if (_ignoreMouseAndKeyNav) {
            return false;
        }

        var isModKey = false;
        var handled = false;

        switch( keyCode )
        {
            case _keys.TAB:
                handled = false;
                break;

            // Eat the modifiers so defualt tools don't activate and mess with cam
            case _keys.SHIFT:   _modifierState.SHIFT = 0;   isModKey = handled = true; break;
            case _keys.CONTROL: _modifierState.CONTROL = 0; isModKey = handled = true; break;
            case _keys.ALT:     _modifierState.ALT = 0;     isModKey = handled = true; break;
            case _keys.SPACE:   _modifierState.SPACE = 0;   isModKey = handled = true; break;

            case _keys.UP:
            case _keys.w:
                _moveForward = false; handled = true;
                break;

            case _keys.LEFT:
            case _keys.a:
                _moveLeft = false; handled = true;
                break;

            case _keys.DOWN:
            case _keys.s:
                _moveBackward = false; handled = true;
                break;

            case _keys.RIGHT:
            case _keys.d:
                _moveRight = false; handled = true;
                break;

            case _keys.q:
                _moveUp = false; handled = true;
                break;

            case _keys.e:
                _moveDown = false; handled = true;
                break;

            case _keys.g:
                _mouseDX = _mouseDY = 0;
                _mouseDraggingLookMode = !_mouseDraggingLookMode;
                showDraggingLookModeHUD(_mouseDraggingLookMode);
                handled = true;
                break;

            case _keys.F1:
                showHelpHUD();
                handled = true;
                break;
        }

        return handled;
    };

    this.handleWheelInput = function(delta)
    {
        if (_ignoreMouseAndKeyNav) {
            return false;
        }

        if ( _navapi.getReverseZoomDirection() )
            delta *= -1;

        _wheelDelta += delta;

        return true;
    };

    this.handleSingleClick = function( event, button ) {
        return false;
    };

    this.handleDoubleClick = function( event, button ) {
        return false;
    };

    this.handleSingleTap = function( event )
    {
        return this.handleSingleClick(event, 0);
    };

    this.handleDoubleTap = function( event ) {
        return false;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        _moveForward = _moveBackward = false;
        _moveLeft = _moveRight = false;
        _moveUp = _moveDown = false;

        return false;
    };

    this.update = function()
    {

        if (!_isActive || !_navapi.isActionEnabled('walk'))
            return false;

        var delta = _clock.getDelta();//returns delta in unit seconds

        if (_hudMessageStartShowTime > -1) {
            var curTime = new Date().getTime();
            if (curTime - _hudMessageStartShowTime > _hudMessageShowTime) { // seconds
                hideHUD();
            }
        }

        // From the Collaboration extension:
        //the "go home" call may change the camera back to ortho... and we can't do ortho while walking...
        //HACK: Really, the home view should be set once when launch the extension, then set it back.
        if (!_camera.isPerspective) {
            console.log("Lost perspective mode: resetting view.");
            _navapi.toPerspective();
        }

        var localCam = _camera.clone();   // Copy of camera to modify

        // Handle movement changes

        var actualMoveSpeed         = delta * _movementSpeed         * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);
        var actualVerticalMoveSpeed = delta * _verticalMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);


        if (_wheelDelta != 0) {
            var actualWheelMoveSpeed = _wheelDelta * _wheelMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);
            localCam.translateZ( -actualWheelMoveSpeed );
            _wheelDelta = 0;
        }

        if ( _moveForward ) {
            localCam.translateZ(-actualMoveSpeed);
        }

        if ( _moveBackward ) {
            localCam.translateZ( actualMoveSpeed );
        }

        if ( _moveLeft ) {
            localCam.translateX( -actualMoveSpeed );
        }

        if ( _moveRight ) {
            localCam.translateX( actualMoveSpeed );
        }

        if ( _moveUp ) {
            localCam.translateY( actualVerticalMoveSpeed );
        }

        if ( _moveDown ) {
            localCam.translateY( -actualVerticalMoveSpeed );
        }

        var newPosition = localCam.position;
        var posChanged = (newPosition.distanceToSquared(_camera.position) !== 0);

        // Handle look changes

        var actualLookSpeed = delta * _lookSpeed;

        var newTarget = localCam.target;

        var directionFwd = _camera.target.clone().sub(_camera.position);
        //directionFwd = directionFwd.sub((directionFwd.multiply(_camera.worldup)).multiply(_camera.worldup));

        var directionRight = directionFwd.clone().cross(_camera.up).normalize();

        /** Joystick Camera Orientation
         ** This code enabled continuous movement of camera as apposed to the
         ** discrete movement mode below.  Moving the cursor outside of the
         ** center of the view orients the camera in that direction and continues
         ** moving while cursor is outside neutral center.  It works like a
         ** virtual joystick.
         **
         ** Uncomment/Comment these sections to switch the style of camera orientation.
         **/

        /** DISABLED
        var dyawAngle = 0, dpitchAngle = 0;

        if (Math.abs(_mouseDX) > _neutralZoneDist) {
            if (_mouseDX > 0) {
                _mouseDX = Math.min(_mouseDX, _mouseXMaxLimit); // Throttle look speed.
                dyawAngle = (_mouseDX - _neutralZoneDist) * actualLookSpeed;
            }
            else {
                _mouseDX = Math.max(_mouseDX, -_mouseXMaxLimit); // Throttle look speed.
                dyawAngle = (_mouseDX + _neutralZoneDist) * actualLookSpeed;
            }
        }

        if (Math.abs(_mouseDY) > _neutralZoneDist) {
            if (_mouseDY > 0) {
                _mouseDY = Math.min(_mouseDY, _mouseYMaxLimit); // Throttle look speed.
                dpitchAngle = (_mouseDY - _neutralZoneDist) * actualLookSpeed;
            }
            else {
                _mouseDY = Math.max(_mouseDY, -_mouseYMaxLimit); // Throttle look speed.
                dpitchAngle = (_mouseDY + _neutralZoneDist) * actualLookSpeed;
            }
        }

        if (dpitchAngle) {
            var pitchQ = new THREE.Quaternion();
            pitchQ.setFromAxisAngle(directionRight, -dpitchAngle);

            // Need to limit pitch to +-85 degrees so we don't create
            // camera jumping at vertical limits.
            var dirFwdTmp = directionFwd.clone();
            dirFwdTmp.applyQuaternion(pitchQ);

            var vertical = _camera.worldup.clone();
            var vertAngle = dirFwdTmp.angleTo(vertical);
            var vertLimit = THREE.Math.degToRad(5);

            // If new angle is within limits then update values; otherwise ignore
            if ( vertAngle >= vertLimit && vertAngle <= (Math.PI - vertLimit) ) {
                directionFwd.applyQuaternion(pitchQ);
                localCam.up.applyQuaternion(pitchQ);
            }
        }

        if (dyawAngle) {
            var yawQ = new THREE.Quaternion();
            yawQ.setFromAxisAngle(_camera.worldup, -dyawAngle);
            directionFwd.applyQuaternion(yawQ);
            localCam.up.applyQuaternion(yawQ);
        }
        DISABLED **/

        /** Discrete Camera Orientation
         ** Movement based on the delta changes in position or cursor.  See the
         ** the "Dynamic Move" code for an alternative.  In this mode the camera
         ** is oriented based on the delta movement of the cursor.  Movement
         ** stops as camera is oriented to new change of cursor.
         ** TODO: Add logic to smooth motion so camera position ramps towards
         ** the new location rather than discrete jumps.
         **/

        if (_deltaPitch != 0) {
            var pitchQ = new THREE.Quaternion();
            pitchQ.setFromAxisAngle(directionRight, -_deltaPitch);
            // Need to limit pitch to +-85 degrees so we don't create
            // camera jumping at vertical limits.
            var dirFwdTmp = directionFwd.clone();
            dirFwdTmp.applyQuaternion(pitchQ);

            var vertical = _camera.worldup.clone();
            var vertAngle = dirFwdTmp.angleTo(vertical);
            var vertLimit = THREE.Math.degToRad(5);

            // If new angle is within limits then update values; otherwise ignore
            if ( vertAngle >= vertLimit && vertAngle <= (Math.PI - vertLimit) ) {
                directionFwd.applyQuaternion(pitchQ);
                localCam.up.applyQuaternion(pitchQ);
            }

            _deltaPitch = 0.0;
        }

        if (_deltaYaw != 0) {
            var yawQ = new THREE.Quaternion();
            yawQ.setFromAxisAngle(_camera.worldup, -_deltaYaw);
            directionFwd.applyQuaternion(yawQ);
            localCam.up.applyQuaternion(yawQ);
            _deltaYaw = 0.0;
        }

        // Now calc new target location and if it changed.
        newTarget = newPosition.clone().add(directionFwd);
        //now fix newPosition for lockInPlane
        var targetChanged = (newTarget.distanceToSquared(_camera.target) !== 0);
        // If position or target changed then update camera.
        if (posChanged || targetChanged) {

             _navapi.setView(newPosition, newTarget);
            //_camera.position = newPosition.clone();
            //_camera.target = newTarget.clone();
            //_camera.dirty = true;s
            // Force the camera to stay orientated up with world up.
            _navapi.orientCameraUp();
        }

        //gamepad integration
        if(_gamepadModule){
           _camera =  _gamepadModule.update(_camera);
        }

        return _camera.dirty;


    };

    /////////////////////////////////////////////////////////////////////////
    // HUD helpers

    // Show a HUD for a specific amount of time (showDelay > 0) or until closed.
    var showHUD = function(messageSpecs, showDelay, closeCB, buttonCB, checkboxCB)
    {
        // TODO: Tool should not be trying to interact with UI
        // Does not comply with headless viewer policy.
        if (!Autodesk.Viewing.Private.HudMessage) {
            return;
        }

        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCB, buttonCB, checkboxCB);

        if (showDelay > 0) {
            _hudMessageStartShowTime = new Date().getTime();
            _hudMessageShowTime = showDelay;
        }
        else {
            _hudMessageStartShowTime = -1;
            _hudMessageShowTime = 0;
        }
    };

    var hideHUD = function()
    {
        // TODO: Tool should not be trying to interact with UI
        // Does not comply with headless viewer policy.
        if (Autodesk.Viewing.Private.HudMessage) {
            Autodesk.Viewing.Private.HudMessage.dismiss();  // in case it's still visible
        }
        _hudMessageStartShowTime = -1;
    };

    var showDraggingLookModeHUD = function(enabled)
    {
        hideHUD();

        var messageSpecs = {
            "msgTitleKey"   : "View Orientation Drag Mode Toggled",
            "messageKey"    : "View Orientation Drag Mode Toggled",
            "messageDefaultValue"  : (enabled
                ? "Press the primary mouse button and drag to change the view orientation"
                : "Move the cursor to change the view orientation")
        };

        var closeCallback = function() {}; // dummy callback function so that the 'X' is shown
        showHUD(messageSpecs, 0, closeCallback);
    };


    var showHelpHUD = function()
    {
        hideHUD();

        // TODO: Sadly, the HudMessage api doesn't support html formatted messages
        var messageSpecs = {
            "msgTitleKey"           : "First Person Tool",
            "messageKey"            : "First Person Tool",
            "messageDefaultValue"   : "Use the WASD and QE keys to move", // simplify key and remove peroid
            "checkboxChecked"       : _bDontShowAgain_HelpHUD
        };

        var closeCallback = function() {}; // dummy callback function so that the 'X' is shown
        showHUD(messageSpecs, 0, closeCallback, null, function(e) {
            _bDontShowAgain_HelpHUD = e.target.checked;
            viewerapi.setFirstPersonToolPopup(!e.target.checked);
        });
    };

    addCrosshair = function() {
        if (typeof stringToDOM === "function") {
            this.crosshair = stringToDOM('<div id="remote-crosshair"><div class="crosshair-v"></div><div class="crosshair-h"></div></div>f');
            viewerapi.canvasWrap.appendChild(this.crosshair);
        }
    };

    removeCrosshair = function() {
        if (this.crosshair && this.crosshair.parentNode) {
             this.crosshair.parentNode.removeChild(this.crosshair);
        }
    };
};

})();
;
(function() {

//
// First Person
//

'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.FirstPerson');

    /**
     * @class
     * Activates a First Person navigation tool, similar to those found in videogames.<br>
     * It will also replace the default walk tool button when GuiViewer3D is present.
     *
     * @extends {Autodesk.Viewing.Extension}
     * @param {Autodesk.Viewing.Viewer3D} viewer
     * @param {Object} [options] - not used
     * @constructor
     */
Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.constructor = Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension;

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;
    var avu = Autodesk.Viewing.UI;

    // Register tool
    this.tool = new Autodesk.Viewing.Extensions.FirstPerson.FirstPersonTool(viewer);
    viewer.toolController.registerTool(this.tool);

    // Add the ui to the viewer.
    this.createUI();

    // Register listeners
    this.onToolChanged = function (e) {
        if (e.toolName.indexOf('firstperson') === -1) {
            return;
        }
        if (self.firstPersonToolButton) {
            var state = e.active ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE;
            self.firstPersonToolButton.setState(state);
        }
    };

    viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);

    return true;
};

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.createUI = function()
{
    var viewer = this.viewer;
    if (!viewer.getToolbar) return; // Adds support for Viewer3D instance

    var self   = this;
    var avu = Autodesk.Viewing.UI;
    var toolbar = viewer.getToolbar(true);
    var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);

    // Create a button for the tool.
    this.firstPersonToolButton = new avu.Button('toolbar-firstPersonTool');
    this.firstPersonToolButton.setToolTip('First person');
    this.firstPersonToolButton.onClick = function(e) {
        var state = self.firstPersonToolButton.getState();
        if (state === avu.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool("firstperson");
        } else if (state === avu.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    };
    this.firstPersonToolButton.setIcon("adsk-icon-first-person");

    var cameraSubmenuTool = navTools.getControl('toolbar-cameraSubmenuTool');
    if (cameraSubmenuTool) {
        navTools.addControl(this.firstPersonToolButton, {index: navTools.indexOf(cameraSubmenuTool.getId())});
    } else {
        navTools.addControl(this.firstPersonToolButton);
    }
};

Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.unload = function()
{
    var viewer = this.viewer;

    // Remove listeners
    viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = undefined;

    // Remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    // Remove the UI
    if (this.firstPersonToolButton) {
        var toolbar = viewer.getToolbar(false);
        if (toolbar) {
            toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.firstPersonToolButton.getId());
        }
        this.firstPersonToolButton = null;
    }

    //Uh, why does the viewer need to keep track of this in addition to the tool stack?
    if (viewer.getActiveNavigationTool() == this.tool.getName())
        viewer.setActiveNavigationTool();

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.FirstPerson', Autodesk.Viewing.Extensions.FirstPerson.FirstPersonExtension);


})();;/**
 * VR tool for LMV
 *
 * @author Hans Kellner (Oct 2014)
 */

AutodeskNamespace('Autodesk.Viewing.Extensions.VR');

Autodesk.Viewing.Extensions.VR.VRTool = function ( viewer, vrExtension ) {

    var _self = this;

    var _navapi = viewer.navigation;
    var _container = viewer.container;
    var _camera = _navapi.getCamera();
    var _names = ["vr"];

    var _isActive = false;

    var _renderContext = null;    // stereo render context

    var _isXUp = false;
    var _isYUp = true;
    var _isZUp = false;

    // HACK: The first two delta mouse moves are extreme jumps and need to be
    // rejected.  This is used to skip those moves.  Note, it must also be reset
    // to zero whenever switching on/off pointer lock
    var _hackMouseMoveCounter = 0;

    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0 };  // TODO: Use the hotkeymanager for these.
    var _keys = Autodesk.Viewing.theHotkeyManager.KEYCODES;

    var _wheelDelta = 0;

    var _moveForward = false;
    var _moveBackward = false;
    var _moveLeft = false;
    var _moveRight = false;
    var _moveUp = false;
    var _moveDown = false;

    var _touchDragging = false;

    var _clock = new THREE.Clock(true);

    var _hudMessageStartShowTime = -1;
    var _hudMessageShowTime = 5000;         // milliseconds to show HUD

    var _modelScaleFactor = 1.0;

    var _movementSpeedDefault = 16.0;       // for VR make slower (35 for 1st person tool)
	var _movementSpeed = 16.0;
	var _verticalMovementSpeed = 15.0;
	var _wheelMovementSpeed = 3.0;

    var _autoMove = false;                  // true to automatically move camera forward
    var _autoMoveDefaultSpeed = 1.75;       // Default auto-move speed
    var _autoMoveDir = 1;                   // 1 == forward, -1 == reverse (TODO: disabled for now)
    var _autoMoveStartingSpeed = 16.0;      // Save the _movementSpeed at the start of auto-move

    var _darknessThresholdAutoMove = 15;    // avg gray scale pixel value of camera image to trigger auto-move

	var _previousFov = _camera.fov;
    var _wasPerspective = _camera.isPerspective;

    //
    // Google Goggle VR
    //
    var _deviceOrientationVR = null;
    var _noSleepVR = null;
    var _videoHelper = null;

    var _deviceAutoMoveTrigger = false;   // true if device pointed down (trigger); stays true until device tilted back up

    var _toggleAutoMoveStartTime = -1;
    var _firstAutoMoveSpeedChange = true;

    //
    // WebVR Device initialization (Oculus, etc)
    //
    var _deviceWebAPIVR = null;
    var _deviceSensorVR = null;
    var _vrMode = false;

    var _toggleDeviceVRMovementActivateDistance = 0.15;  // distance in meters before active movement
    var _toggleDeviceVRMovement = false;
    var _toggleDeviceVRMovementOrigin = new THREE.Vector3(0,0,0);
    var _toggleDeviceVRMovementLast = new THREE.Vector3(0,0,0);

    //
    // Wearality HMD
    //
    var _deviceWearalityHMD = false;

    // Constants

    var PI_2 = Math.PI / 2.0;

    /////////////////////////////////////////////////////////////////////////
    // ToolInterface

    this.isActive = function()
    {
        return _isActive;
    };

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        if (_isActive)
            return;

        _isXUp = (_camera.worldup && _camera.worldup.x === 1);
        _isYUp = (_camera.worldup && _camera.worldup.y === 1);
        _isZUp = (_camera.worldup && _camera.worldup.z === 1);

        console.log("VRTool : camera world up = "+_camera.worldup.x+","+_camera.worldup.y+","+_camera.worldup.z);

        _clock.start();

        // First check for Oculus or similar device through Web API
        if (getWebAPIVRDevice()) {
            showHelpVRDeviceHMD();
            showUIElements(false);
            console.log("VR Supported (Web API): Oculus, etc.");
        }
        else {
            // Next check for Google Goggle style support
            showHelpVRDeviceOrientation();
            window.addEventListener('deviceorientation', setOrientationControls, true);
        }

        var useVR = (viewer.config && viewer.config.useVR) ? viewer.config.useVR : "";

        // Check for Wearality setting to enable by default
        _deviceWearalityHMD = (useVR.toLowerCase() === "wearality");

        // Create the custom render context for stereo and HMDs
        enableRenderContext(true);

        // NOTE: Handled in stereorendercontext
        //_previousFov = _camera.fov;
        //_navapi.setVerticalFov(75, true);

        // Calculate a movement scale factor based on the model bounds (ignore selection).
        var boundsSize = viewer.utilities.getBoundingBox(true).size();
        _modelScaleFactor = Math.max(Math.min(Math.min(boundsSize.x,boundsSize.y),boundsSize.z) / 100.0, 1.0);

        this.resetPointerTracking();

        // HACK: Attempt to place focus in canvas so we get key events.
        viewer.canvas.focus();

        showHelpHUD();

        _isActive = true;
    };

    this.deactivate = function(name)
    {
        if (!_isActive)
            return;

        _isActive = false;

        hideHUD();

        if (_deviceOrientationVR) {

            if (_videoHelper) {
                _videoHelper.stop();
                _videoHelper = null;
            }

            _deviceOrientationVR.disconnect();
            _deviceOrientationVR = null;

            // turn off no-sleep mode
            if (_noSleepVR)
                _noSleepVR.disable();
        }

        enableRenderContext(false);

        exitFullscreen();

        _clock.stop();

		//_navapi.setVerticalFov(_previousFov, true);
        //if (!_wasPerspective)
        //    _navapi.toOrthographic();

        showUIElements(true);
    };

    this.getCursor = function()
    {
        return "url(data:image/gif;base64,R0lGODlhGAAYAMIDAAQEBH19feDg4P///////////////////yH+EUNyZWF0ZWQgd2l0aCBHSU1QACH5BAEKAAQALAAAAAAYABgAAAMqSLrc/jDKSau9OOvN8fjDNghBIITZEABAgHpr+15jeYpgp+987//AICEBADs=), auto";
    };


    /////////////////////////////////////////////////////////////////////////

    var showUIElements = function(show)
    {
        // Show/hide the toolbar
        var toolbarMenuElements = document.getElementsByClassName('toolbar-menu');
        if (toolbarMenuElements.length > 0) { // HACK: Assume only 1
            if (toolbarMenuElements[0] !== '')
                toolbarMenuElements[0].style.display = show ? 'block' : 'none';
        }
    };

    var adjustSpeed = function( direction )
    {
        if ( direction === 0 ) // reset to default
        {
        	_movementSpeed = _movementSpeedDefault;
        }
        else
        {
            _movementSpeed *= (direction > 0) ?  1.10 : 0.90;
            if ( _movementSpeed < 0.000001 )
                _movementSpeed = 0.000001;
        }
        //console.log("Move Speed = "+_movementSpeed);
    };

    var enableRenderContext = function(enable)
    {
        if ( enable === !!_renderContext )
            return; // no change

        console.log("Enable Render Context: "+enable);

        if (enable)
        {
            viewer.displayViewCube(false, false);

            _wasPerspective = viewer.navigation.isPerspective;
            if (!_wasPerspective)
                viewer.navigation.toPerspective();

            // Enable WarpShade if using an HMD like the Oculus.
            var bUseWarpShader = !!_deviceWebAPIVR;

            var options = null;

            // Support for Wearality HMD?
            if (_deviceWearalityHMD)
            {
                // From Wearality:
                var DEFAULT_IPD = 0.075;  // meters (this kinda depends on person, and latest device has a physical IPD of 0.069  or 69 mm)
                var DEFAULT_CAMERA_ANGLE_OFFSET = -1.5;  // degrees
                var DEFAULT_ASYMMETRY = 0.07;

                // Here is how to set Asytemtric frusum:
                //
                //var horizOblLeft = -DEFAULT_ASYMMETRY;
                //var horizOblRight = DEFAULT_ASYMMETRY;
                //SetObliqueness(horizOblLeft , horizOblRight);
                //
                //private void SetObliqueness(float horizOblLeft, float horizOblRight)
                //{
                //    Matrix4x4 mat1 = camLeft.camera.projectionMatrix;
                //    mat1[0, 2] = horizOblLeft;
                //    mat1[1, 2] = 0;
                //    camLeft.camera.projectionMatrix = mat1;
                //
                //    Matrix4x4 mat2 = camRight.camera.projectionMatrix;
                //    mat2[0, 2] = horizOblRight;
                //    mat2[1, 2] = 0;
                //    camRight.camera.projectionMatrix = mat2;
                //}

                options = {
                    useWarp: bUseWarpShader,

                    HMD: {
                        // Parameters from the Wearality HMD
                        // TODO: Set eyeToScreenDistance, distortionK, and chromaAbParameter values
                        // to match Wearality's.
                        hResolution: 1920,
                        vResolution: 1080,
                        hScreenSize: 0.12576,
                        vScreenSize: 0.07074,
                        interpupillaryDistance: DEFAULT_IPD, // Oculus == 0.0635,
                        lensSeparationDistance: DEFAULT_IPD, // Oculus == 0.0635,
                        eyeToScreenDistance: 0.041,
                        distortionK : [1.0, 0.22, 0.24, 0.0],
                        chromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]
                    }
                };
            }
            else {
                // Default HMD options
                options = {
                    useWarp: bUseWarpShader
                };
            }

            _renderContext = new Autodesk.Viewing.Extensions.Oculus.StereoRenderContext( options );
            viewer.impl.setUserRenderContext(_renderContext);

            //TODO: Not sure why we need this call in order to force the
            //stereo layout to fix itself.
            viewer.resize(viewer.canvas.clientWidth, viewer.canvas.clientHeight);

            // Go fullscreen
            if (_deviceWebAPIVR) {
                launchFullscreen(viewer.impl.canvas, { vrDisplay: _deviceWebAPIVR });
            } else {
                launchFullscreen(viewer.impl.canvas);
            }
        }
        else {
            // disable
            _renderContext = null;
            viewer.impl.setUserRenderContext(null);

            // Restore screen to normal and re-enable viewcube
            viewer.setScreenMode(Autodesk.Viewing.ScreenMode.kNormal);
            viewer.displayViewCube(viewer.prefs.get("viewCube"), false);
        }
    };

    /////////////////////////////////////////////////////////////////////////
    // Tool event handler callbacks - can use "this".

    this.handleSingleTap = function( event )
    {
        //console.log("single tap ("+ (event.pointers ? event.pointers.length : 0)+")");

        // Only interested if we are being run on a mobile device using the
        // Device Orientation api.
        if (_deviceOrientationVR) {
            if ( event.pointers ) {

                if ( event.pointers.length === 1 ) {
                    // Exit VRTool and activate default tool
                    setTimeout(function () {
                        viewer.setActiveNavigationTool(viewer.defaultNavigationToolName);
                    }, 10);
                    return true;
                }
                else if ( event.pointers.length === 2 ) {
                    toggleAutoMove();
                    return true;
                }
            }
        }

        return false;
    };

    this.handleDoubleTap = function( event )
    {
        //console.log("double tap ("+ (event.pointers ? event.pointers.length : 0)+")");
        return false;
    };

    this.handlePressHold = function( event )
    {
        //console.log("press hold ["+(event.type ? event.type : "none")+"] ("+ (event.pointers ? event.pointers.length : 0)+")");
        //if( event.type === "press" )
        //{
        //    event.clientX = event.pointers[0].clientX;
        //    event.clientY = event.pointers[0].clientY;
        //}

        return false;
    };

    this.handleGesture = function( event )
    {
        //console.log("handle gesture ["+(event.type ? event.type : "none")+"]");

        // Only interested if we are being run on a mobile device using the
        // Device Orientation api.
        if (_deviceOrientationVR)
        {
            switch( event.type )
            {
            case "dragstart":
                _touchDragging = true;
                //var x = (event.normalizedX + 1.0) * 0.5;
                //var y = (event.normalizedY + 1.0) * 0.5;
                //console.log("DragStart: "+x+","+y);
                break;

            case "dragmove":
                if (_touchDragging) {
                    //var x = (event.normalizedX + 1.0) * 0.5;
                    //var y = (event.normalizedY + 1.0) * 0.5;
                    //console.log("DragMove: "+x+","+y);
                    // TODO: Use this to adjust auto move speed
                }
                break;

            case "dragend":
                //console.log("DragEnd");
                _touchDragging = false;
                break;
            }
        }

        return false;
    };

    this.handleKeyDown = function( event, keyCode )
    {
        var isModKey = false;
        var handled = false;

        switch( keyCode )
        {
            case _keys.TAB: handled = true; break;

            case _keys.SHIFT:   _modifierState.SHIFT = 1;   isModKey = true; handled = true; break;
            case _keys.CONTROL: _modifierState.CONTROL = 1; isModKey = true; handled = true; break;
            case _keys.ALT:     _modifierState.ALT = 1;     isModKey = true; handled = true; break;

            case _keys.SPACE:
                handled = true; break;

            case _keys.EQUALS: this.adjustSpeed(1);  handled = true; break;
            case _keys.DASH:   this.adjustSpeed(-1); handled = true; break;
            case _keys.ZERO:   this.adjustSpeed(0);  handled = true; break; // Reset dolly speed to default

            case _keys.w:
                // If Ctrol+Shift+W pressed then skip move handling
                if ( _modifierState.CONTROL === 1 && _modifierState.SHIFT === 1) {
                    handled = true;
                    break;
                }
                // fall through
            case _keys.UP:
                _moveForward = true; handled = true;
                break;

			case _keys.LEFT:
			case _keys.a:
                _moveLeft = true; handled = true;
                break;

			case _keys.DOWN:
			case _keys.s:
                _moveBackward = true; handled = true;
                break;

			case _keys.RIGHT:
			case _keys.d:
                _moveRight = true; handled = true;
                break;

			case _keys.q:
                _moveDown = true; handled = true;
                break;

			case _keys.e:
                _moveUp = true; handled = true;
                break;

            case _keys.h:
                handled = true;
                break;
        }

        return handled;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        var isModKey = false;
        var handled = false;

        switch( keyCode )
        {
            case _keys.SHIFT:   _modifierState.SHIFT = 0;   isModKey = true; break;
            case _keys.CONTROL: _modifierState.CONTROL = 0; isModKey = true; break;
            case _keys.ALT:     _modifierState.ALT = 0;     isModKey = true; break;

            case _keys.SPACE:
                // HMD support?
                if ( !!_deviceWebAPIVR ) {
                    // Toggle movement on/off.
                    toggleDeviceVRMovement();
                }
                handled = true;
                break;

            case _keys.w:
                // Ctrl+Shift+W pressed?
                if ( !_moveForward && _modifierState.CONTROL === 1 && _modifierState.SHIFT === 1) {
                    // Toggle Wearality HMD on/off

                    // Exit VRTool and activate default tool
                    setTimeout(function () {
                        enableRenderContext(false);
                        _deviceWearalityHMD = !_deviceWearalityHMD;
                        enableRenderContext(true);
                    }, 10);

                    handled = true;
                    break;
                }
                // fall through for movement handling
            case _keys.UP:
                _moveForward = false; handled = true;
                break;

			case _keys.LEFT:
			case _keys.a:
                _moveLeft = false; handled = true;
                break;

			case _keys.DOWN:
			case _keys.s:
                _moveBackward = false; handled = true;
                break;

			case _keys.RIGHT:
			case _keys.d:
                _moveRight = false; handled = true;
                break;

			case _keys.q:
                _moveDown = false; handled = true;
                break;

			case _keys.e:
                _moveUp = false; handled = true;
                break;

            case _keys.h:
                showHelpHUD();
                handled = true;
                break;
        }

        return handled;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
		_moveForward = false;
		_moveBackward = false;
		_moveLeft = false;
		_moveRight = false;

        return false;
    };

	this.update = function(timeStamp)
    {
        if (!_isActive)
            return;

        var delta = _clock.getDelta();

        if (_hudMessageStartShowTime > -1) {
            var curTime = new Date().getTime();
            if (curTime - _hudMessageStartShowTime > _hudMessageShowTime) { // seconds
                hideHUD();
            }
        }

        var vrUpdatedCameraTarget = false;

        // Oculus support?
        if ( !!_deviceWebAPIVR && updateVRDevice(delta) ) {
            vrUpdatedCameraTarget = true;
        } // Controlling via a VR device?  Then use that rather than default keyboard/mouse controls.
        else if ( !!_deviceOrientationVR && updateDeviceOrientationVR(delta) ) {
            vrUpdatedCameraTarget = true;
        }

		var localCam = _camera.clone();   // Copy of camera to modify

        // Handle movement changes
		var actualMoveSpeed = delta * _movementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);
        //console.log("Actual speed = "+actualMoveSpeed);

        var actualVerticalMoveSpeed = delta * _verticalMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);

        if (_wheelDelta != 0)
        {
            var actualWheelMoveSpeed = _wheelDelta * _wheelMovementSpeed * _modelScaleFactor * (_modifierState.SHIFT === 1 ? 4 : 1);
			localCam.translateZ( -actualWheelMoveSpeed );
            _wheelDelta = 0;
        }

        var autoMoveF = false,
            autoMoveB = false,
            autoMoveL = false,
            autoMoveR = false;

        if (_autoMove) {
            if (0) { //_deviceOrientationVR) {
                // IMPORTANT: The screen orientation effects the direction of camera movement.
                switch(_deviceOrientationVR.screenOrientation) // 0/180 = portait, 90/-90 = landscape
                {
                case 0:
                    autoMoveL = true;
                    break;
                case 180:
                    autoMoveR = true;
                    break;
                case 90:
                    autoMoveF = true;
                    break;
                case -90:
                    autoMoveB = true;
                    break;
                }
            }
            else {
                autoMoveF = true;
            }
        }

		if ( _moveForward || autoMoveF ) {
             localCam.translateZ( -actualMoveSpeed );
        }

		if ( _moveBackward || autoMoveB ) {
		     localCam.translateZ( actualMoveSpeed );
        }

		if ( _moveLeft || autoMoveL ) {
			localCam.translateX( -actualMoveSpeed );
        }

		if ( _moveRight || autoMoveR ) {
			localCam.translateX( actualMoveSpeed );
        }

		if ( _moveUp ) {
            localCam.translateY( actualVerticalMoveSpeed );
        }

		if ( _moveDown ) {
		    localCam.translateY( -actualVerticalMoveSpeed );
        }

        var newPosition = localCam.position;
        var posChanged = (newPosition.distanceToSquared(_camera.position) !== 0);
        if (posChanged) {

    		var newTarget = localCam.target;

            var dxyz = newPosition.clone().sub(_camera.position);
            newTarget.add(dxyz);

		    _navapi.setView(newPosition, newTarget);
        }

        return _camera.dirty;
	};

    this.resetPointerTracking = function()
    {
        _moveForward = _moveBackward = false;
        _moveLeft = _moveRight = false;
        _moveUp = _moveDown = false;

        _mouseDraggingLookMode = false;
    };


    /////////////////////////////////////////////////////////////////////////
    // Auto movement support

    var toggleAutoMove = function()
    {
        // Toggle auto-move state
        _autoMove = !_autoMove;

        // If starting to move then save current speed so it can be restored
        if (_autoMove) {
            _autoMoveStartingSpeed = _movementSpeed;
            _movementSpeed = _autoMoveDefaultSpeed;
            _toggleAutoMoveStartTime = new Date().getTime();
        }
        else {
            // Restore speed after auto-move
            _movementSpeed = _autoMoveStartingSpeed;
        }

        showHelpVRMove(_autoMove);

        return _autoMove;
    };


    /////////////////////////////////////////////////////////////////////////
    // Web API VR Support

    var getWebAPIVRDevice = function()
    {
        var foundVRDevice = false;

        // First check for Oculus style support
        function EnumerateVRDevices(devices) {
            // First find an HMD device
            for (var i = 0; i < devices.length; ++i) {
                if (devices[i] instanceof HMDVRDevice) {
                    _deviceWebAPIVR = devices[i];
                }
            }

            // Next find a sensor that matches the HMD hardwareUnitId
            for (var i = 0; i < devices.length; ++i) {
                if (devices[i] instanceof PositionSensorVRDevice &&
                    (!_deviceWebAPIVR || devices[i].hardwareUnitId == _deviceWebAPIVR.hardwareUnitId)) {
                    _deviceSensorVR = devices[i];

                    foundVRDevice = true;
                }
            }
        }

        if (navigator.getVRDevices) {
            navigator.getVRDevices().then(EnumerateVRDevices);
        } else if (navigator.mozGetVRDevices) {
            navigator.mozGetVRDevices(EnumerateVRDevices);
        } else {
            foundVRDevice = false; // WebVR API not supported
        }

        return foundVRDevice;
    };

    var updateVRDevice = function(delta)
    {
        if (!_deviceSensorVR)
            return false;

        var vrState = _deviceSensorVR.getState();

        if (_camera)
        {
            if (_isZUp) {
                _toggleDeviceVRMovementLast.x = vrState.position.x;
                _toggleDeviceVRMovementLast.y = -vrState.position.z;
                _toggleDeviceVRMovementLast.z = vrState.position.y;
            }
            else {
                _toggleDeviceVRMovementLast.x = vrState.position.x;
                _toggleDeviceVRMovementLast.y = vrState.position.y;
                _toggleDeviceVRMovementLast.z = vrState.position.z;
            }

            if (_toggleDeviceVRMovement)
            {
                // If head movement is greater than a specific amount then start
                // applying movement to camera.  This creates a neutral zone at
                // the "center of the joystick".
                var dist = _toggleDeviceVRMovementOrigin.distanceTo(_toggleDeviceVRMovementLast);
                if (dist >= _toggleDeviceVRMovementActivateDistance)
                {
                    // Every X inches from neutral scale
                    var distMovedFromNeutralScaleFactor = (dist - _toggleDeviceVRMovementActivateDistance) / 0.0762/*3in*/;
                    var actualMoveSpeed = delta * _movementSpeed * _modelScaleFactor * distMovedFromNeutralScaleFactor;

                    var dir = _toggleDeviceVRMovementLast.clone().sub(_toggleDeviceVRMovementOrigin).normalize().multiplyScalar(actualMoveSpeed);

                    _camera.position.add(dir);
                }
            }

            if (_isZUp) {
                _camera.quaternion.x = vrState.orientation.x;
                _camera.quaternion.y = -vrState.orientation.z;
                _camera.quaternion.z = vrState.orientation.y;
                _camera.quaternion.w = vrState.orientation.w;
            }
            else {
                _camera.quaternion.x = vrState.orientation.x;
                _camera.quaternion.y = vrState.orientation.y;
                _camera.quaternion.z = vrState.orientation.z;
                _camera.quaternion.w = vrState.orientation.w;
            }

            // TODO: The LMV camera still uses the old target value which threejs no longer uses.
            // Therefore we need to set it so the view changes.

            // Apply the camera's rotation to the vector looking down the Z axis
            var lookAtDir = new THREE.Vector3( 0, 0, -1 );

            // Models can have different up vectors.  The code above defaults to Y up.
            // Check for other Up directions.
            if (_isZUp) {
                lookAtDir = new THREE.Vector3(lookAtDir.x, -lookAtDir.z, lookAtDir.y);
            }

            lookAtDir.applyQuaternion( _camera.quaternion );

            // then update the target
            _camera.target = _camera.position.clone().add(lookAtDir.clone().multiplyScalar(10));

            _camera.dirty = true;
        }

        return true;
    };

    // Toggle movement on/off.
    //
    // When toggled on the current HMD postion is the new origin.  Movements away from that
    // origin will be used as a virtual joystick.
    var toggleDeviceVRMovement = function()
    {
        // Oculus support?
        if ( !_deviceWebAPIVR )
            return;

        _toggleDeviceVRMovement = !_toggleDeviceVRMovement;

        if (_toggleDeviceVRMovement) {
            _toggleDeviceVRMovementOrigin.copy(_toggleDeviceVRMovementLast);
        }

        showHelpVRMove(_toggleDeviceVRMovement);
    };

    /////////////////////////////////////////////////////////////////////////
    // Device Orientaton VR Support
    var updateDeviceOrientationVR = function(delta)
    {
        if (!_deviceOrientationVR)
            return false;

        // Get the current device orientation quaternion.
        // The quaternion can be applied to the current camera but that will *not* update
        // the target value nor handle world UP differences.  Therefore we need to also
        // update those values.
        var qOrientation = _deviceOrientationVR.update();
        if (!qOrientation)
            return false;
        //qOrientation.rotation.reorder( "YXZ" );

        // For Z-Up models we need to re-orient YZ values.
        if (_isZUp) {
            var t = qOrientation.z;
            qOrientation.z = qOrientation.y;
            qOrientation.y = -t;
        }

        // Models can have different up vectors.  Adjust for that.
        var lookAtDir = _isZUp ? new THREE.Vector3( 0, 1, 0 ) : new THREE.Vector3( 0, 0, -1 );

        // The LMV camera still uses the old target value which threejs no longer uses.
        // Therefore we need to set it so the view changes.
        var newTargetDir = lookAtDir.clone().applyQuaternion( qOrientation );

        // Distance to current target
        var dist = _camera.target.clone().sub(_camera.position).length();

        // then update the target
        _navapi.setTarget(_camera.position.clone().add(newTargetDir.multiplyScalar(dist)));

        // Handle screen orientation?
        //_deviceOrientationVR.screenOrientation == 90 // landscape 90

        // AUTO-MOVE support using video camera
        //
        // Check for a covered video camera.  That will toggle the movement.
        if (_videoHelper)
        {
            // Check if user has allowed video and video can be acquired.
            // NOTE: If the video helper fails to start then the user will
            // not be able to move the camera's position.
            if (_videoHelper.isStarted())
            {
                // Is it ok to check for a "button" press?
                if (_toggleAutoMoveStartTime <= 0)
                {
                    // Yes, so check for a "dark" image from camera.  Use this to
                    // toggle movement on/off
                    if ( _videoHelper.checkVideoThreshold(_darknessThresholdAutoMove) ) {
                        toggleAutoMove();
                    }
                }
                else
                {
                    // We get here if auto-move has been toggled.  Check if the
                    // camera image is still "dark"?
                    var isDark = _videoHelper.checkVideoThreshold(_darknessThresholdAutoMove);

                    // If not then it was uncovered.  Reset timer so toggle can occur again
                    if (!isDark) {
                        _toggleAutoMoveStartTime = -1;
                    }
                    // Else if still covererd and auto-move enabled then increase speed
                    else if (_autoMove)
                    {
                        var curTime = new Date().getTime();
                        var dTime = curTime - _toggleAutoMoveStartTime;

                        // Every 1/4sec increase by orginal speed
                        if (dTime > 250) { // milliseconds
                            _toggleAutoMoveStartTime = curTime; // restart counter

                            _movementSpeed += _autoMoveStartingSpeed;

                            // Reshow HUD so new speed is displayed
                            showHelpVRMove(true);
                        }
                    }
                }
            }
            //console.log("AUTO_MOVE = "+(_autoMove?"TRUE":"FALSE")+" Toggled(50) = "+ (toggled?"TRUE":"FALSE"));
        }
        else // Alternate move support if not using video camera
        {
            // Auto move support.  Tilt down increases speed.
            var lookDownDir = _isZUp ? new THREE.Vector3( 0, 0, -1 ) : new THREE.Vector3( 0, -1, 0 );
            var viewAngle = THREE.Math.radToDeg(newTargetDir.angleTo(lookDownDir));
            //console.log("View angle = "+viewAngle);

            if ( viewAngle < 30 ) {

                // Is this the first time tilting and the trigger hasn't been activated?
                if ( !_deviceAutoMoveTrigger )
                {
                    // Yes, toggle auto-move.
                    toggleAutoMove();

                    _deviceAutoMoveTrigger = true;  // Stays true until device tilted level.

                    // Beginning to move?
                    if (_autoMove) {
                        _firstAutoMoveSpeedChange = true;
                    }
                }
                else
                {
                    // If the user remains tilting device while auto-move
                    // is on then increase speed
                    if (_autoMove)
                    {
                        var curTime = new Date().getTime();
                        var dTime = curTime - _toggleAutoMoveStartTime;

                        // Every X seconds delay, increase by orginal speed.  But the first
                        // delay is longer so speed doesn't increase immediately.
                        var delay = _firstAutoMoveSpeedChange ? 1500 : 1000; // milliseconds

                        if (dTime >= delay)
                        {
                            _firstAutoMoveSpeedChange = false;
                            _toggleAutoMoveStartTime = curTime; // restart counter

                            _movementSpeed += _autoMoveStartingSpeed; // increase speed

                            // Reshow HUD so new speed is displayed
                            showHelpVRMove(true);
                        }
                    }
                }
            }
            // If device tilt is leveled then clear trigger
            else if ( viewAngle >= 30 ) {
                _deviceAutoMoveTrigger = false;
                _toggleAutoMoveStartTime = -1;
            }
        }

        _camera.dirty = true;
        return true;
    };

    var setOrientationControls = function(e)
    {
        if (!e.alpha) {
            return false;
        }

        window.removeEventListener('deviceorientation', setOrientationControls, true);

        _deviceOrientationVR = new THREE.DeviceOrientationControls();
        _deviceOrientationVR.connect();

        // turn on no-sleep mode.  This plays a hidden video that will cause the
        // phone to say awake.
        if (!_noSleepVR) {
            _noSleepVR = new window.NoSleep();
            _noSleepVR.enable();
        }

        // create the video helper.  note that this will enable the video
        // camera which the user will need to allow.  If the user disallows
        // then they may use the "tilt" mode for auto-move.
        _videoHelper = new VideoHelper("videoVR","videoVR-canvas", 1/*camera index*/);  // change cam index for front vs. back
        if (!_videoHelper.start()) {
            _videoHelper = null;    // failed.
            console.log("VideoHelper : Failed to start.");
        }

        showUIElements(false);

        console.log("VR Supported (DeviceOrientation): Google Goggles, etc.");
        return true;
    };

    /////////////////////////////////////////////////////////////////////////
    // HUD helpers

    var showHUD = function(messageSpecs, showDelay)
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();  // in case it's still visible
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs);
        _hudMessageStartShowTime = new Date().getTime();
        if (!showDelay || showDelay <= 0)
            showDelay = 5000;
        _hudMessageShowTime = showDelay;
    };

    var hideHUD = function()
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();  // in case it's still visible
        _hudMessageStartShowTime = -1;
    };

    var showHelpHUD = function()
    {
        // TODO: Sadly, the HudMessage api doesn't support html formatted messages
        var messageSpecs = {
            "msgTitleKey"   : "Virtual Reality Tool",
            "messageKey"    : "Virtual Reality Tool",
            "messageDefaultValue"  : "This is the Virtual Reality tool"
        };

        showHUD(messageSpecs, 3000);
    };

    var showHelpVRMove = function(enable, showDelay)
    {
        if (!showDelay || showDelay <= 0)
            showDelay = 250;

        var string1 = Autodesk.Viewing.i18n.translate("START Auto Move");
        var string2 = Autodesk.Viewing.i18n.translate("STOP Auto Move");
        var msg = (enable ? string1 + " ("+Math.floor(_movementSpeed)+")" : string2);

        var messageSpecs = {
            "msgTitleKey"   : "VR Toggle Move",
            "messageKey"    : "VR Toggle Move",
            "messageDefaultValue"  : msg
        };

        showHUD(messageSpecs, showDelay);
    };

    var showHelpVRDeviceOrientation = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "VR Device Orientation",
            "messageKey"    : "VR Device Orientation",
            "messageDefaultValue"  : "VR Mode Enabled Device Orientation"
        };

        showHUD(messageSpecs, 2000);
    };

    var showHelpVRDeviceHMD = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "VR Head Mounted Display",
            "messageKey"    : "VR Head Mounted Display",
            "messageDefaultValue"  : "VR Mode Enabled Head Mounted Display"
        };

        showHUD(messageSpecs, 2000);
    };
};
;//
// VR
//

'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.VR');

Autodesk.Viewing.Extensions.VR.VRExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.VR.VRExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.VR.VRExtension.prototype.constructor = Autodesk.Viewing.Extensions.VR.VRExtension;

Autodesk.Viewing.Extensions.VR.VRExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);
    var avu = Autodesk.Viewing.UI;

    // Register tool
    this.tool = new Autodesk.Viewing.Extensions.VR.VRTool(viewer, this);
    viewer.toolController.registerTool(this.tool);

    // Add the ui to the viewer.
    this.createUI(toolbar);

    // Register listeners
    this.onToolChanged = function (e) {
        if (e.toolName.indexOf('vr') === -1) {
            return;
        }

        var state = e.active ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE;

        self.vrToolButton.setState(state);
    };

    viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);

    return true;
};

Autodesk.Viewing.Extensions.VR.VRExtension.prototype.createUI = function(toolbar)
{
    var self   = this;
    var viewer = this.viewer;
    var avu = Autodesk.Viewing.UI;

    var navTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);

    // Create a button for the tool.
    this.vrToolButton = new avu.Button('toolbar-vrTool');
    this.vrToolButton.setToolTip('Virtual Reality Tool');
    this.vrToolButton.setIcon("toolbar-vrToolButton");
    this.vrToolButton.onClick = function(e) {
        var state = self.vrToolButton.getState();
        if (state === avu.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool("vr");
        } else if (state === avu.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    };

    var cameraSubmenuTool = navTools.getControl('toolbar-cameraSubmenuTool');
    if (cameraSubmenuTool) {
        navTools.addControl(this.vrToolButton, {index: navTools.indexOf(cameraSubmenuTool.getId())});
    } else {
        navTools.addControl(this.vrToolButton);
    }
};

Autodesk.Viewing.Extensions.VR.VRExtension.prototype.unload = function ()
{
    var viewer = this.viewer;

    // Remove listeners
    viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = undefined;

    // Remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    // Remove the UI
    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        toolbar.getControl(Autodesk.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.vrToolButton.getId());
    }
    this.vrToolButton = null;

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.VR', Autodesk.Viewing.Extensions.VR.VRExtension);
;
(function(){

"use strict";

AutodeskNamespace('Autodesk.Viewing.Extensions.FusionOrbit');

var av = Autodesk.Viewing,
    avu = av.UI,
    avef = av.Extensions.FusionOrbit;


var FusionOrbitExtension = function(viewer, options) {
    av.Extension.call(this, viewer, options);
};

FusionOrbitExtension.prototype = Object.create(av.Extension.prototype);
FusionOrbitExtension.prototype.constructor = FusionOrbitExtension;

FusionOrbitExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar ? viewer.getToolbar(true) : undefined;

    this.tool = new avef.FusionOrbitTool();
    this.tool.setViewer(viewer);
    viewer.toolController.registerTool(this.tool);

    function onToolbarCreated() {
        viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, onToolbarCreated);
        self.createUI();
    }

    if (toolbar) {
        var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);
        if (modelTools && modelTools.getNumberOfControls() > 0) {
            onToolbarCreated();
        } else {
            viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, onToolbarCreated);
        }
    } else {
        viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, onToolbarCreated);
    }

    return true;
};

FusionOrbitExtension.prototype.createUI = function()
{
    var self   = this;
    var viewer = this.viewer;

    var toolbar = viewer.getToolbar(false);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    // save button behaviors, before modifying them
    this.classicBehavior = {};
    this.classicBehavior.orbitOnClick = navTools.orbitbutton.onClick;
    this.classicBehavior.freeorbitOnClick = navTools.freeorbitbutton.onClick;
    this.classicBehavior.returnToDefault = navTools.returnToDefault;

    navTools.freeorbitbutton.onClick = function(e) {
        var state = navTools.freeorbitbutton.getState();
        if (state === avu.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool("fusion orbit");
            navTools.freeorbitbutton.setState(avu.Button.State.ACTIVE);
        }
        else if (state === avu.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
            navTools.freeorbitbutton.setState(avu.Button.State.INACTIVE);
        }
    };

    navTools.orbitbutton.onClick = function(e) {
        var state = navTools.orbitbutton.getState();
        if (state === avu.Button.State.INACTIVE) {
            viewer.setActiveNavigationTool("fusion orbit constrained");
            navTools.orbitbutton.setState(avu.Button.State.ACTIVE);
        }
        else if (state === avu.Button.State.ACTIVE) {
            viewer.setActiveNavigationTool();
            navTools.orbitbutton.setState(avu.Button.State.INACTIVE);
        }
    };

    navTools.returnToDefault = function() {
        // clear active button
        navTools.orbittoolsbutton.setState(avu.Button.State.ACTIVE);
        navTools.orbittoolsbutton.setState(avu.Button.State.INACTIVE);
    };

    // set combo button
    navTools.orbittoolsbutton.setState(avu.Button.State.INACTIVE);
    if (viewer.prefs.fusionOrbitConstrained) {
        navTools.orbittoolsbutton.onClick = navTools.orbitbutton.onClick;
        navTools.orbittoolsbutton.setIcon(navTools.orbitbutton.iconClass);
        viewer.setDefaultNavigationTool("orbit");
    }
    else {
        navTools.orbittoolsbutton.onClick = navTools.freeorbitbutton.onClick;
        navTools.orbittoolsbutton.setIcon(navTools.freeorbitbutton.iconClass);
        viewer.setDefaultNavigationTool("freeorbit");
    }

    // reset
    viewer.setActiveNavigationTool();
    navTools.returnToDefault();
};

FusionOrbitExtension.prototype.unload = function () {
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(false);
    var navTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

    // restore LMV Classic button behaviors
    if (navTools) {
        if (navTools.orbitbutton)
            navTools.orbitbutton.onClick = this.classicBehavior.orbitOnClick;

        if (navTools.freeorbitbutton)
            navTools.freeorbitbutton.onClick = this.classicBehavior.freeorbitOnClick;

        navTools.returnToDefault = this.classicBehavior.returnToDefault;

        if (navTools.orbittoolsbutton) {    // can be null when switching sheets
            navTools.orbittoolsbutton.onClick = navTools.orbitbutton.onClick;
            navTools.orbittoolsbutton.setIcon("adsk-icon-orbit-constrained");
            navTools.orbittoolsbutton.setState(avu.Button.State.ACTIVE);
        }
    }
    viewer.setActiveNavigationTool("orbit");
    viewer.setDefaultNavigationTool("orbit");

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool.setViewer(null);
    this.tool = null;

    return true;
};


avef.FusionOrbitExtension = FusionOrbitExtension;

av.theExtensionManager.registerExtension('Autodesk.Viewing.FusionOrbit', FusionOrbitExtension);

})(); // closure;AutodeskNamespace('Autodesk.Viewing.Extensions.FusionOrbit');

Autodesk.Viewing.Extensions.FusionOrbit.html = [
    '<div class="orbit-gizmo noselect">',
        '<div class="outside"></div>',
        '<div class="ring"></div>',
        '<div class="layout-hor">',
            '<div class="edgemark-area"><div class="edgemark"></div></div>',
        '</div>',
        '<div class="layout-mid">',
            '<div class="layout-ver">',
                '<div class="edgemark-area"><div class="edgemark"></div></div>',
            '</div>',
            '<div class="circle">',
                '<div class="crosshair-area">',
                    '<div class="crosshair-v"></div>',
                    '<div class="crosshair-h"></div>',
                '</div>',
            '</div>',
            '<div class="layout-ver">',
                '<div class="edgemark-area"><div class="edgemark"></div></div>',
            '</div>',
        '</div>',
        '<div class="layout-hor">',
            '<div class="edgemark-area"><div class="edgemark"></div></div>',
        '</div>',
    '</div>',
].join("\n");

Autodesk.Viewing.Extensions.FusionOrbit.FusionOrbitTool = function() {
    var _names = ["fusion orbit", "fusion orbit constrained"];

    var _PERCENT_SIZE = 0.8;
    var _EXIT_PERCENT_SIZE = 1.2;
    var _CIRCLE_CURSOR_STYLE = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAt1BMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8AAAAzMzP6+vri4uISEhKKioqtra2dnZ2EhIR9fX10dHRkZGQdHR3t7e3Hx8e5ubm1tbWoqKhWVlZKSko4ODgICAjv7+/o6OjMzMyxsbFOTk4pKSkXFxcEBAT29vbW1tZ6enpISEgLCwvhzeX+AAAAGXRSTlMANRO0nHRJHfnskIxQRKh89syDVwTWZjEJxPFEswAAAOFJREFUKM+1j+lygkAQhIflEAJe0Rw9u4CCeKKoSTTX+z9XoMJWWeX+ssrvZ3f19DQ5zOw/0DUMQPlmQ72bE2adBp8/Rp3CQUi3ILx+bxj4fjDs9T1Bmo6bbPPN8aDU4bjJt4nb+de789kSFyxn826jW3ICLNZZKU8nWWbrBTCRVm04U8TpjquRFf1Go0d7l8aYOrUR7FGEFr1S9LGymwthgX2gE/Kl0cHPOtF2xOWZ5QpIC93RflW4InkDoPRXesd5LJIMQPzV7tCMa7f6BvhJL79AVDmYTNQ1NhnxbI/uwB8H5Bjd4zQPBAAAAABJRU5ErkJggg==), auto";

    var _orbitModes = {
        HORIZONTAL: 0,
        VERTICAL: 1,
        ROLL: 2
    };

    var _orbitSpeeds = {
        HORIZONTAL: 0.005,
        VERTICAL: 0.005,
        ROLL: 1.0
    };

    var _gizmoElem, _gizmoRect, _ringElem, _outsideElem;
    var _isConstrained;
    var _camera;
    var _isTouch = isTouchDevice();
    var _isClickToExit = false;

    var _mouse = {
        buttons: [],
        src: undefined,
        x: 0,
        y: 0,
        dx: 0,
        dy: 0,
        firstMove: true,   // for dx/dy calc
        mode: undefined
    };

    var _this = this;

    this.setViewer = function(viewer) {
        this.viewer = viewer;
        this.navapi = viewer ? viewer.navigation : null;
    };

    // PRIVATE FUNCTIONS

    var _onMouseDown = function(e) {
        _mouse.buttons[e.touches ? 0 : e.button] = true;
        _mouse.src = e.target.className;
        _mouse.x = 0;
        _mouse.y = 0;
        _mouse.dx = 0;
        _mouse.dy = 0;
        _mouse.firstMove = true;
        _mouse.mode = undefined;

        if (_mouse.src === "ring") {
            _mouse.mode = _orbitModes.ROLL;
        }
        else if (_mouse.src === "edgemark-area") {
            if (e.target.parentNode.className === "layout-ver")
                _mouse.mode = _orbitModes.HORIZONTAL;
            else if (e.target.parentNode.className === "layout-hor")
                _mouse.mode = _orbitModes.VERTICAL;
        }

        _centerPivot();

        e.stopPropagation();
    };

    var _onMouseUp = function(e) {
        _mouse.buttons[e.touches ? 0 : e.button] = false;
        _mouse.src = undefined;
    };

    var _onMouseMove = function(e) {
        if (!_mouse.buttons[0]) return;

        _updateMousePos(e);
        _updateCamera();

        _mouse.firstMove = false;
    };

    var _updateMousePos = function(e) {
        var pageX = e.touches ? e.touches[0].pageX : e.pageX;
        var pageY = e.touches ? e.touches[0].pageY : e.pageY;

        if (!_mouse.firstMove) {
            _mouse.dx = pageX - _mouse.x;
            _mouse.dy = pageY - _mouse.y;
        }
        _mouse.x = pageX;
        _mouse.y = pageY;
    };

    var _updateCamera = function() {

        // if (_mouse.dx === 0 && _mouse.dy === 0) return;
        switch (_mouse.mode) {
            case _orbitModes.ROLL:
                if (!_this.navapi.isActionEnabled('roll')) {
                    return;
                }
                break;
            case _orbitModes.HORIZONTAL:
            case _orbitModes.VERTICAL:
                if (!_this.navapi.isActionEnabled('orbit')) {
                    return;
                }
                break;
        }

        var eyeVec = _camera.target.clone().sub(_camera.position).normalize();
        var rightVec = eyeVec.clone().cross(_camera.up).normalize();
        var upVec = rightVec.clone().cross(eyeVec).normalize();
        _camera.up.copy(upVec);  // update camera.up

        if (_mouse.mode === _orbitModes.ROLL) {
            var start = new THREE.Vector3(_mouse.x - _gizmoRect.center.x, _mouse.y - _gizmoRect.center.y, 0);
            var end = (new THREE.Vector3(_mouse.dx, _mouse.dy, 0)).add(start);
            start.normalize();
            end.normalize();
            var cross = start.clone().cross(end);
            var angle = Math.asin(cross.z);
            _camera.up.applyAxisAngle(eyeVec, -angle*_orbitSpeeds.ROLL);
        }
        else {
            var rotAxis, rotAmount;

            if (_mouse.mode === _orbitModes.HORIZONTAL) {
                rotAmount = -_mouse.dx*_orbitSpeeds.HORIZONTAL;
                if (_isConstrained)
                    _camera.up = Autodesk.Viewing.Navigation.snapToAxis(_camera.up.clone()); // snap up vec
                rotAxis = _camera.up;
            }
            else if (_mouse.mode === _orbitModes.VERTICAL) {
                rotAmount = -_mouse.dy*_orbitSpeeds.VERTICAL;
                if (_isConstrained) {
                    if (_mouse.firstMove)           // first time move, snap
                        _camera.up = Autodesk.Viewing.Navigation.snapToAxis(_camera.up.clone());
                    rotAxis = eyeVec.clone().cross(_camera.up).normalize();  // new right vec
                }
                else {
                    rotAxis = rightVec;
                }
                _camera.up.applyAxisAngle(rotAxis, rotAmount);
            }

            var pivot = _this.navapi.getPivotPoint();
            var newPivotToCam = _camera.position.clone().sub(pivot);
            newPivotToCam.applyAxisAngle(rotAxis, rotAmount);
            _camera.position.addVectors(pivot, newPivotToCam);       // orbit position

            var newPivotToTarget = _camera.target.clone().sub(pivot);
            newPivotToTarget.applyAxisAngle(rotAxis, rotAmount);
            _camera.target.addVectors(pivot, newPivotToTarget);      // orbit target
        }

        _camera.dirty = true;

    };

    // may return camera.target, do not modify
    var _findTarget = function() {
        var eyeVec = _camera.target.clone().sub(_camera.position).normalize();
        var hit = _this.viewer.impl.rayIntersect(new THREE.Ray(_camera.position, eyeVec));
        return (hit && hit.intersectPoint) ?
            hit.intersectPoint :
            _camera.target;
    };

    var _getCameraPlane = function(pos, nor) {
        var planeNor = nor || pos.clone().sub(_camera.position).normalize();
        return new THREE.Plane(
            planeNor, -planeNor.x*pos.x - planeNor.y*pos.y - planeNor.z*pos.z
        );
    };

    var _centerPivot = function() {
        // find distance pivot to camera plane
        // set new pivot to be that distance along eye vector
        var eyeVec = _camera.target.clone().sub(_camera.position).normalize();
        var plane = _getCameraPlane(_camera.position, eyeVec);
        var dist = plane.distanceToPoint(_camera.pivot);
        _camera.pivot.copy(eyeVec).multiplyScalar(dist).add(_camera.position);
    };

    var _onMouseDownCircle = function(e) {
        if (!e.touches && e.button === 0)
            _centerPivot();     // center pivot before passing thru to orbit tool
    };

    var _clickToExit = function(e) {
        if (_isClickToExit)
            _this.viewer.setActiveNavigationTool();
    };

    var _clickToFocus = function(x, y) {
        var hit = _this.viewer.impl.hitTest(x, y);
        var newTarget;

        if (hit && hit.intersectPoint) {
            newTarget = hit.intersectPoint;
        }
        else {
            // intersect camera plane
            var ray = _this.viewer.impl.viewportToRay(_this.viewer.impl.clientToViewport(x, y));
            newTarget = ray.intersectPlane(_getCameraPlane(_camera.target));
        }

        var newCamPos = _camera.position.clone().sub(_findTarget()).add(newTarget);
        _this.navapi.setRequestTransition(true, newCamPos, newTarget, _camera.fov);
    };


    // TOOL INTERFACE

    this.register = function() {
        _gizmoElem = stringToDOM(Autodesk.Viewing.Extensions.FusionOrbit.html);
        _gizmoElem.style.display = "none";
        this.viewer.canvasWrap.insertBefore(_gizmoElem, this.viewer.canvasWrap.firstChild);

        _ringElem = _gizmoElem.querySelector(".ring");
        _ringElem.addEventListener("mousedown", _onMouseDown);

        Array.prototype.forEach.call(_gizmoElem.querySelectorAll(".edgemark-area"), function(elem, i) {
            elem.addEventListener("mousedown", _onMouseDown);
            if (_isTouch) elem.addEventListener("touchstart", _onMouseDown);
        });

        window.addEventListener("mouseup", _onMouseUp);
        window.addEventListener("mousemove", _onMouseMove);

        // click to exit
        _outsideElem = _gizmoElem.querySelector(".outside");
        _outsideElem.addEventListener("mousedown", _clickToExit);

        // before passing thru to orbit (default) tool
        var circleElem = _gizmoElem.querySelector(".circle");
        circleElem.addEventListener("mousedown", _onMouseDownCircle);

        if (_isTouch) {
            _ringElem.addEventListener("touchstart", _onMouseDown);
            window.addEventListener("touchend", _onMouseUp);
            window.addEventListener("touchmove", _onMouseMove);
            _outsideElem.addEventListener("touchstart", _clickToExit);
            circleElem.addEventListener("touchstart", _onMouseDownCircle);
        }

        _camera = this.viewer.impl.camera;
    };

    this.deregister = function() {
        window.removeEventListener("mouseup", _onMouseUp);
        window.removeEventListener("mousemove", _onMouseMove);
        _outsideElem.removeEventListener("mousedown", _clickToExit);

        if (_isTouch) {
            window.removeEventListener("touchend", _onMouseUp);
            window.removeEventListener("touchmove", _onMouseMove);
            _outsideElem.removeEventListener("touchstart", _clickToExit);
        }

        this.viewer.canvasWrap.removeChild(_gizmoElem);

        _gizmoElem = undefined;
        _ringElem = undefined;
        _outsideElem = undefined;
    };

    this.activate = function(name) {
        _gizmoElem.style.display = "";

        this.handleResize();

        _isConstrained = (name === "fusion orbit constrained");

        if (_isConstrained) {
            this.viewer.setDefaultNavigationTool("orbit");
            this.viewer.prefs.set("fusionOrbitConstrained", true);
        }
        else {
            this.viewer.setDefaultNavigationTool("freeorbit");
            this.viewer.prefs.set("fusionOrbitConstrained", false);
        }

        this.viewer.navigation.setZoomTowardsPivot(true);
    };

    this.deactivate = function(name) {
        _gizmoElem.style.display = "none";
        this.viewer.navigation.setZoomTowardsPivot(this.viewer.prefs.zoomTowardsPivot);
    };

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    this.update = function() {
        return false;
    };

    this.handleSingleClick = function( event, button ) {
        _clickToFocus(event.canvasX, event.canvasY);
        return true;
    };

    this.handleDoubleClick = function( event, button ) {
        return true;    // disabled, does not play nice with SingleClick
    };

    this.handleSingleTap = function( event ) {
        _clickToFocus(event.canvasX, event.canvasY);
        return true;
    };

    this.handleDoubleTap = function( event ) {
        return false;    // enabled, DoubleTap doesn't register the first SingleTap
    };

    this.handleKeyDown = function( event, keyCode ) {
        return false;
    };

    this.handleKeyUp = function( event, keyCode ) {
        return false;
    };

    this.handleWheelInput = function(delta) {
        return false;
    };

    this.handleButtonDown = function(event, button) {
        return false;
    };

    this.handleButtonUp = function(event, button) {
        return false;
    };

    this.handleMouseMove = function(event) {
        var rect = this.viewer.impl.canvas.getBoundingClientRect();
        var vp;
        if (rect.width > rect.height) {
            vp = new THREE.Vector2(
                (((event.canvasX+0.5) / rect.width ) * 2 - 1) * rect.width/rect.height,
               -((event.canvasY+0.5) / rect.height) * 2 + 1
            );
        } else {
            vp = new THREE.Vector2(
                (((event.canvasX+0.5) / rect.width ) * 2 - 1),
                (-((event.canvasY+0.5) / rect.height) * 2 + 1) * rect.height/rect.width
            );
        }

        var radius = vp.length();

        var isOutside = radius > _EXIT_PERCENT_SIZE;
        if (_isClickToExit !== isOutside) {
            if (isOutside)
                _outsideElem.style.cursor = "";
            else
                _outsideElem.style.cursor = _CIRCLE_CURSOR_STYLE;
            _isClickToExit = isOutside;
            // console.log("click exit: " + _isClickToExit);
        }

        return false;
    };

    this.handleGesture = function(event) {
        _centerPivot();
        return false;
    };

    this.handleBlur = function(event) {
        return false;
    };

    this.handleResize = function() {
        // for mouse roll
        _gizmoRect = _gizmoElem.getBoundingClientRect();
        _gizmoRect.center = {};
        _gizmoRect.center.x = _gizmoRect.left + _gizmoRect.width/2;
        _gizmoRect.center.y = _gizmoRect.top + _gizmoRect.height/2;

        // resize gizmo
        var dim = (window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth) * _PERCENT_SIZE;
        _gizmoElem.style.width = _gizmoElem.style.height = ""+dim+"px";
        _gizmoElem.style.top = _gizmoElem.style.left = "calc(50% - "+(dim/2)+"px)";
        _ringElem.style.borderWidth = ""+(dim*0.1)+"px";
    };
};
;
AutodeskNamespace('Autodesk.Viewing.Private.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avu = av.UI,
        avpc = avp.Collaboration;


    function RemoteControllerTool(viewer, client, p2p) {

        var _stick1 = new THREE.Vector2();
        var _stick2 = new THREE.Vector2();
        var _explodeSpeed = 0;
        var _flydir = null;
        var _camera;
        var _viewer = viewer;

        var MOVE_SCALE = 0.02;
        var AUTOMOVE_SCALE = 0.002;
        var LOOK_SCALE = 0.05;
        var EXPLODE_SCALE = 0.01;
        var _modelScale = 1.0;


        var _viewerState;
        var _savepoints = [];
        var _nextsavepoint = 0;
        var VIEWER_STATE_FILTER = {
            seedURN: false,
            objectSet: true,
            viewport: true,
            renderOptions: {
                environment: false,
                ambientOcclusion: false,
                toneMap: {
                    exposure: false
                },
                appearance: false
            }
        };

        var initScale = function() {
            if (!viewer.impl.model.is2d()) {
                var size = viewer.impl.model.getData().bbox.size();
                var diagLength = size.length();
                MOVE_SCALE *= diagLength;
                AUTOMOVE_SCALE *= diagLength;
                viewer.removeEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, initScale);
            }
        };

        viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, initScale);


        //viewtx.client.addEventListener("joystick", this.onJoystick);

        this.getNames = function() {
            return ["joystick"];
        };

        this.getName = function() {
            return "joystick";
        };


        this.activate = function(name) {
            client.addEventListener("joystick", onJoystick);
            p2p.addEventListener("joystick", onJoystick);
            _camera = _viewer.navigation.getCamera();

            if (_viewer.model) {
                var box = _viewer.model.getBoundingBox();
                _modelScale = box.size().length() * 0.001;
                _viewerState = new avp.ViewerState(_viewer);
            }
        };

        this.deactivate = function(name) {
            client.removeEventListener("joystick", onJoystick);
            p2p.removeEventListener("joystick", onJoystick);
            _camera = null;
            _viewerState = null;
            _savepoints.length = 0;
        };

        this.update = function(timeStamp) {

            //the "go home" call may change the camera back to ortho... and we can't do ortho while walking...
            //HACK: Really, the home view should be set once when launch the extension, then set it back.
            if (!_camera.isPerspective)
                viewer.navigation.toPerspective();

            if (_flydir) {
                var automove = _flydir.clone().multiplyScalar(AUTOMOVE_SCALE);
                _camera.position.add(automove);
                _camera.target.add(automove);
            }

            if (_explodeSpeed != 0) {
                var ns = viewer.getExplodeScale() + _explodeSpeed * EXPLODE_SCALE;
                if (ns > 1) ns = 1;
                if (ns < 0) ns = 0;
                viewer.explode(ns);
            }

            if (_stick1.x == 0 && _stick1.y == 0 && _stick2.x == 0 && _stick2.y == 0)
                return !!(_flydir || _explodeSpeed);

            var direction = _camera.target.clone().sub(_camera.position);
            var distance = direction.length();
            direction.multiplyScalar(1.0/distance);
            var right = direction.clone().cross(_camera.up).normalize();

            var forwardMove = direction.clone().multiplyScalar(_stick1.y * MOVE_SCALE);
            _camera.position.add(forwardMove);
            _camera.target.add(forwardMove);


            var strafeMove = right.clone().multiplyScalar(_stick1.x * MOVE_SCALE);
            _camera.position.add(strafeMove);
            _camera.target.add(strafeMove);

            var lookUpDown = new THREE.Quaternion();
            lookUpDown.setFromAxisAngle(right, _stick2.y * LOOK_SCALE);
            var ndir = direction.clone().applyQuaternion(lookUpDown);
            _camera.up.applyQuaternion(lookUpDown);

            var lookLeftRight = new THREE.Quaternion();
            lookLeftRight.setFromAxisAngle(_camera.worldup, -_stick2.x * LOOK_SCALE);
            ndir.applyQuaternion(lookLeftRight);
            _camera.up.applyQuaternion(lookLeftRight);

            ndir.multiplyScalar(distance);
            _camera.target.copy(_camera.position).add(ndir);

            // update automove direction
            if (_flydir)
                _flydir.copy(_camera.target).sub(_camera.position).normalize();

            return true;
        };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};
        this.handleKeyDown = function( event, keyCode ) {return false;};
        this.handleKeyUp = function( event, keyCode ) {return false;};
        this.handleWheelInput = function(delta) { return false; };
        this.handleButtonDown = function(event, button) { return false; };
        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {return false;};
        this.handleGesture = function(event, touches) {return false;};
        this.handleTouchChange = function(event, touches) {return false;};
        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};


        function onJoystick(e) {
            var state = e.data.msg;
            _stick1.x = state.x1;
            _stick1.y = state.y1;
            _stick2.x = state.x2;
            _stick2.y = state.y2;
            _explodeSpeed = state.explode;

            if (state.command) {
                if (state.command == "gohome") {
                    _stick1.x = _stick1.y = 0;
                    _stick2.x = _stick2.y = 0;
                    viewer.navigation.setRequestHomeView(true);
                    viewer.showAll();
                    viewer.impl.selector.clearSelection();
                    viewer.explode(0);
                    _flydir = null;
                }
                else if (state.command == "select") {
                    var res = viewer.impl.hitTestViewport(new THREE.Vector3(0,0,0));

                    if (res) {
                        viewer.impl.selector.toggleSelection(res.dbId, res.model);
                    } else {
                        viewer.impl.selector.clearSelection();
                    }

                }
                else if (state.command == "hide") {
                    var res = viewer.impl.hitTestViewport(new THREE.Vector3(0,0,0));

                    if (res) {
                        viewer.hide(res.dbId);
                    }
                }
                else if (state.command == "fly") {
                    if (!_flydir) {
                        _flydir = _camera.target.clone().sub(_camera.position).normalize();
                    } else {
                        _flydir = null;
                    }
                } else if (state.command == "savepoint") {
                    var state = _viewerState.getState(VIEWER_STATE_FILTER);
                    _savepoints.push(state);
                    alertify.success("Savepoint created.");
                } else if (state.command == "nextsavepoint") {
                    if (_savepoints.length) {
                        if (_nextsavepoint >= _savepoints.length)
                            _nextsavepoint = 0;

                        _viewerState.restoreState(_savepoints[_nextsavepoint++]);
                    }
                }
            }

            //console.log(state);
        };

    };


    //==================================================================================
    //Extension interface

    /** @constructor */
    ave.RemoteControl = function (viewer, options) {
        av.Extension.call(this, viewer, options);

        this.viewer = viewer;
        this.client = avp.MessageClient.GetInstance();
        this.p2p = new avp.P2PClient(this.client);
        this.controllerTool = new RemoteControllerTool(viewer, this.client, this.p2p);
        viewer.toolController.registerTool(this.controllerTool);

    };

    ave.RemoteControl.prototype = Object.create(av.Extension.prototype);
    ave.RemoteControl.prototype.constructor = ave.RemoteControl;


    ave.RemoteControl.prototype.createUI = function() {
        var scope = this;
        var viewer = this.viewer;

        this.controlButton = new avu.Button('toolbar-remoteControlTool');
        this.controlButton.setToolTip('Pair with controller device');
        this.controlButton.onClick = function() {
            if (this.getState() === avu.Button.State.INACTIVE) {
                scope.connect();
                this.setState(avu.Button.State.ACTIVE);
            }
            else {
                scope.disconnect();
                this.setState(avu.Button.State.INACTIVE);
            }
        };

        this.controlButton.setIcon("adsk-icon-game-controller");
        viewer.modelTools.addControl(this.controlButton);

        this.panel = new Autodesk.Viewing.UI.DockingPanel(viewer.container, "remote-panel", "Remote Control");
        this.panel.width = 300;
        this.panel.height = 375;
        this.panel.container.style.width = this.panel.width+"px";
        this.panel.container.style.height = this.panel.height+"px";
        this.panel.container.style.top = (window.innerHeight-this.panel.height)/2 + "px";
        this.panel.container.style.left = (window.innerWidth-this.panel.width)/2 + "px";
        this.panel.body = document.createElement("div");
        this.panel.body.classList.add("body");
        this.panel.container.appendChild(this.panel.body);
        var text1 = Autodesk.Viewing.i18n.translate("Go to this link");
        var text2 = Autodesk.Viewing.i18n.translate("Scan the QR code with your device");
        var text3 = Autodesk.Viewing.i18n.translate("or");
        this.panel.body.innerHTML = [
            '<p data-i18n="' + text1 + '">' + text1 + '</p>',
            '<p><a class="url" target="_blank" href="#">Link</a></p>',
            '<p data-i18n="'+ text3 +'">' + text3 + '</p>',
            '<p data-i18n="' + text2 + '">' + text2 + '</p>',
            '<img class="qr-img" src="">',
        ].join("\n");
        this.panel.link = this.panel.container.querySelector(".url");
        this.panel.code = this.panel.container.querySelector(".code");
        this.panel.qrImg = this.panel.container.querySelector(".qr-img");
    };

    ave.RemoteControl.prototype.load = function () {
        var viewer = this.viewer;
        var scope = this;

        // add the button to the toolbar
        if(viewer.modelTools && viewer.modelTools.getNumberOfControls() > 0) {
            scope.createUI();
        } else {
            viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
        }

        function onToolbarCreated(e) {
            viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            scope.createUI();
        }

        return true;
    };

    ave.RemoteControl.prototype.unload = function () {

        var viewer = this.viewer;

        this.p2p.hangup();
        this.client.disconnect();

        viewer.toolController.deactivateTool(this.controllerTool.getName());

        if (this.panel) {
            this.panel.setVisible(false);
            this.panel = null;
        }

        // TODO_HACK: Find out why removing the button fails
        if (this.controlButton) {
            try {
                viewer.modelTools.removeControl(this.controlButton);
                this.controlButton = null;
            } catch (err) {
                stderr('RemoteControlReceiver - Failed to remove controlButton');
                this.controlButton = null;
            }
        }

        return true;
    };

    ave.RemoteControl.prototype.addCrosshair = function() {
        this.crosshair = stringToDOM('<div id="remote-crosshair"><div class="crosshair-v"></div><div class="crosshair-h"></div></div>');
        this.viewer.canvasWrap.appendChild(this.crosshair);
    };

    ave.RemoteControl.prototype.removeCrosshair = function() {
        if (this.crosshair) this.crosshair.remove();
    };

    ave.RemoteControl.prototype.connect = function(cb) {
        if (this.client.isConnected()) {
            console.log("RemoteControl already connected");
            return;
        }

        var scope = this;
        avp.loadDependency("lmv_io", "socket.io-1.3.5.js", function(){
            scope.connectAux(cb);
        });
    };

    ave.RemoteControl.prototype.connectAux = function(cb) {
        var scope = this;
        var viewer = this.viewer;
        scope.client.addEventListener("connectSucceeded", function(e) {
            stderr("connect succeeded");
            var sessionId = e.data.id + "rc";
            scope.client.join(sessionId);

            var rcURL = (LMV_RESOURCE_ROOT.length ? LMV_RESOURCE_ROOT : window.location.origin + "/") + "rc.html?sessionId=" + sessionId + "&env=" + avp.env;

            var qrImgURL = "http://chart.googleapis.com/chart?cht=qr&chs=200x200&choe=UTF-8&chld=H|0&chl=" + escape(rcURL);

            var panel = scope.panel;
            if (panel) {
                panel.link.href = rcURL;
                panel.link.innerHTML = (LMV_RESOURCE_ROOT.length ? LMV_RESOURCE_ROOT : window.location.origin + "/") + "rc.html";
                panel.qrImg.src = qrImgURL;
                panel.setVisible(true);
            }

            function popupRemover() {
                if (panel) panel.setVisible(false);
                scope.p2p.removeEventListener("dataChannelAdded", popupRemover);
                scope.addCrosshair();
            }
            scope.p2p.addEventListener("dataChannelAdded", popupRemover);

            if (cb && cb instanceof Function)
                cb(rcURL);
        });

        viewer.navigation.toPerspective();
        scope.client.connect();

        viewer.toolController.activateTool(scope.controllerTool.getName());
    };

    ave.RemoteControl.prototype.disconnect = function() {
        this.p2p.hangup();
        this.client.disconnect();
        this.viewer.toolController.deactivateTool(this.controllerTool.getName());
        this.removeCrosshair();
    };

    av.theExtensionManager.registerExtension('Autodesk.Viewing.RemoteControl', ave.RemoteControl);



})();
;(function(){

AutodeskNamespace('Autodesk.Viewing.Extensions.GamepadModule');

/***
* GamepadModule is a tool (not an extension) that reacts to input from
* a gamepad controller plugged into the hosting machine.
 *
* @param viewerapi
* @constructor
*/
Autodesk.Viewing.Extensions.GamepadModule = function ( viewerapi ) {

    var _navapi = viewerapi.navigation;
    var _container = viewerapi.container;
    var _camera = _navapi.getCamera();

    var _modelScaleFactor = 1.0;

    var _explodeSpeed = 0;

    var _THRESHOLD = 0.1;
    var _SPEED_ADJUST = 5.5,
        _INITIAL_SPEED_SCALAR = 6,
        _speed_scalar = _INITIAL_SPEED_SCALAR;


    var _btnPressMap = {};
    var _gamepad;
    var _hudMessageStartShowTime;
    var _hudMessageShowTime;
    var _viewerState;
    var _savepoints;
    var _nextsavepoint;

    //Nav mode toggle
    var _lockInPlane;

    var _clock = new THREE.Clock(true);

    var VIEWER_STATE_FILTER = {
        seedURN: false,
        objectSet: true,
        viewport: true,
        renderOptions: {
            environment: false,
            ambientOcclusion: false,
            toneMap: {
                exposure: false
            },
            appearance: false
        }
    };
    var _actualMoveSpeed;
    var _movementSpeed = 2.0;
    var _INITIAL_FOV = 75;
    var _ZOOM_SCALAR = -45;//smaller => closer zoom
    var _altitudeLockCoord;
    var _currentTool;

    /*Face Buttons*/
    var _BUTTONS = {
        SOUTH_BTN : 0,
        EAST_BTN : 1,
        WEST_BTN : 2,
        NORTH_BTN : 3,

        /*Shoulder and trigger buttons*/
        LEFT_SHOULDER : 4,
        RIGHT_SHOULDER : 5,
        LEFT_TRIGGER : 6,//ANALOG
        RIGHT_TRIGGER : 7,//ANALOG

        /*directional pad (DPad)*/
        SOUTH_DPAD : 13,
        EAST_DPAD : 15,
        WEST_DPAD : 14,
        NORTH_DPAD : 12,

        /*Joystick buttons (press joystick in)*/
        LEFT_STICK_BUTTON: 10,
        RIGHT_STICK_BUTTON: 11

    };

    var _STICKS = {
        //Axis//
        /*Left and right joysticks*/
        LEFT_STICK_X : 0,//ANALOG
        LEFT_STICK_Y : 1,//ANALOG
        RIGHT_STICK_X : 2,//ANALOG
        RIGHT_STICK_Y : 3//ANALOG
    };

    var _BLANK_FUNC = function() {};
    var _BUTTON_MAPPING = {};
    for (var k in _BUTTONS) {
        if(_BUTTONS.hasOwnProperty(k))
            _BUTTON_MAPPING[_BUTTONS[k]] = _BLANK_FUNC;
    }

    var init = function() {

    };

    this.activate = function (toolName) {
        // Calculate a movement scale factor based on the model bounds.
        var boundsSize = viewerapi.model.getBoundingBox().size();
        _modelScaleFactor = Math.max(Math.min(Math.min(boundsSize.x, boundsSize.y), boundsSize.z) / 10.0, 0.0001);
        _gamepad = navigator.getGamepads()[0];
        _viewerState = new Autodesk.Viewing.Private.ViewerState(viewerapi);
        _savepoints = [];
        _nextsavepoint = 0;
        _currentTool = toolName;
        setMapping(toolName);
    };

    this.deactivate = function(){
        //console.log("DEACTIVATE");
        _currentTool = null;
        _viewerState = null;
    };

    this.update = function (delta, camera) {

        if(camera)
            _camera = camera;
        delta = _clock.getDelta();

        //poll for gamepad connection
        _gamepad = navigator.getGamepads()[0];

        if (_hudMessageStartShowTime > -1) {
            var curTime = new Date().getTime();
            if (curTime - _hudMessageStartShowTime > _hudMessageShowTime) { // seconds
                hideHUD();
            }
        }

        if(_gamepad) {
            _actualMoveSpeed = delta * _movementSpeed * _modelScaleFactor * _speed_scalar;// (_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value > _THRESHOLD ? _SPEED_ADJUST * _gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value + _MAX_SPEED_SCALAR : _MAX_SPEED_SCALAR);
            // From the Collaboration extension:
            //the "go home" call may change the camera back to ortho... and we can't do ortho while walking...
            //HACK: Really, the home view should be set once when launch the extension, then set it back.
            if (!_camera.isPerspective) {
                //console.log("Lost perspective mode: resetting view.");
                _navapi.toPerspective();
            }
            if (_gamepad) {//TODO test for connection (change of state?)
                if (inputDetected()) {//need to update camera scene
                   // console.log("needs update");
                    _camera.dirty = true;
                    if (_lockInPlane) {
                        _altitudeLockCoord = _camera.position.z;
                    }

                    var direction = _camera.target.clone().sub(_camera.position);
                    var distance = direction.length();
                    direction.multiplyScalar(1.0 / distance);
                    var right = direction.clone().cross(_camera.up).normalize();
                    if (Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_Y]) > _THRESHOLD) {
                        var forwardMove = direction.clone().multiplyScalar(-_gamepad.axes[_STICKS.LEFT_STICK_Y] * _actualMoveSpeed);
                        _camera.position.add(forwardMove);
                        _camera.target.add(forwardMove);
                    }

                    if (Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_X]) > _THRESHOLD) {
                        var strafeMove = right.clone().multiplyScalar(_gamepad.axes[_STICKS.LEFT_STICK_X] * _actualMoveSpeed);
                        _camera.position.add(strafeMove);
                        _camera.target.add(strafeMove);
                    }

                    var lookUpDown = new THREE.Quaternion();
                    var ndir = direction;
                    if (Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_Y]) > _THRESHOLD) {

                        var tempCam = _camera.clone();//modify this camera to see if it will be in viable range
                        var tempDir = direction.clone();

                        lookUpDown.setFromAxisAngle(right, -_gamepad.axes[_STICKS.RIGHT_STICK_Y] * _actualMoveSpeed / 2);//lookscale

                        tempDir.applyQuaternion(lookUpDown);
                        tempCam.up.applyQuaternion(lookUpDown);
                        var vertical = tempCam.worldup.clone();
                        var vertAngle = tempDir.angleTo(vertical);
                        var vertLimit = THREE.Math.degToRad(5);

                        // If new angle is within limits then update values; otherwise ignore
                        if ( vertAngle >= vertLimit && vertAngle <= (Math.PI - vertLimit) ) {
                            ndir = direction.clone().applyQuaternion(lookUpDown);
                            _camera.up.applyQuaternion(lookUpDown);
                        }
                    }

                    var lookLeftRight = new THREE.Quaternion();
                    if (Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_X]) > _THRESHOLD) {
                        lookLeftRight.setFromAxisAngle(_camera.worldup, -_gamepad.axes[_STICKS.RIGHT_STICK_X] * _actualMoveSpeed / 2);//lookscale
                        ndir.applyQuaternion(lookLeftRight);
                        _camera.up.applyQuaternion(lookLeftRight);
                    }

                    /*HANDLE ALL BUTTON INPUTS*/
                    handleGamepadFaceButtons();
                    /**************************/

                    if (_lockInPlane)
                        _camera.position.z = _altitudeLockCoord;

                    ndir.multiplyScalar(distance);
                    _camera.target.copy(_camera.position).add(ndir);
                }
            }
        }
        return _camera;
    };


    // Show a HUD for a specific amount of time (showDelay > 0) or until closed.
    var showHUD = function(messageSpecs, showDelay, closeCB, buttonCB, checkboxCB)
    {
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs, closeCB, buttonCB, checkboxCB);

        if (showDelay > 0) {
            _hudMessageStartShowTime = new Date().getTime();
            _hudMessageShowTime = showDelay;
        }
        else {
            _hudMessageStartShowTime = -1;
            _hudMessageShowTime = 0;
        }
    };

    var hideHUD = function()
    {
        Autodesk.Viewing.Private.HudMessage.dismiss();  // in case it's still visible
        _hudMessageStartShowTime = -1;
    };

    var showDPadHud = function(direction)
    {
        hideHUD();
        var message;
        switch(direction) {
            case "up":
                message = _lockInPlane ? "Vertical Lock Mode" : "Fly mode"; break;
            case "left":
                break;
            case "right":
                break;
            case "down":
                break;
        }

        var messageSpecs = {
            "msgTitleKey"   : "View Orientation Drag Mode Toggled",
            "messageKey"    : "View Orientation Drag Mode Toggled",
            "messageDefaultValue"  : message

        };
        showHUD(messageSpecs, 2000);//show hud for 2secs

    };

    //checks for any button doing anything important
    function inputDetected(){
        //check to see if we pressed a button last frame
        //loop through mapping to only check buttons we care about
        for (var btn in _BUTTON_MAPPING) {
            if (_BUTTON_MAPPING.hasOwnProperty(btn)) {
                if(_gamepad.buttons[btn].pressed){
                    if(_gamepad.buttons[btn].value != 0.5) {
                        _btnPressMap[btn] = true;//its pressed!
                        return true;
                    }
                }
            }
        }
        for (var btn in _btnPressMap) {
            if (_btnPressMap.hasOwnProperty(btn)) {
                if(_btnPressMap[btn]){
                    //_btnPressMap[btn] = false;//
                    return true;
                }
            }
        }
        //now check movement
        return !(Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_X]) < _THRESHOLD &&
                Math.abs(_gamepad.axes[_STICKS.LEFT_STICK_Y]) < _THRESHOLD &&
                Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_X]) < _THRESHOLD &&
                Math.abs(_gamepad.axes[_STICKS.RIGHT_STICK_Y]) < _THRESHOLD);

    }

    /*
    will check face buttons (including Directional Pad) for input
     */
    function handleGamepadFaceButtons(){
        for(var btn in _BUTTONS){
            if(_BUTTONS.hasOwnProperty(btn)){
                handleGamepadButton(_BUTTONS[btn]);
            }
        }
    }

    function handleGamepadButton(buttonIdx) {
        //buttons in first IF are testing for being held (good for analog inputs and held down buttons)
        //ELSE IF will activate upon RELEASE of a button
        if (_gamepad.buttons[buttonIdx].value > _THRESHOLD) {
            _btnPressMap[buttonIdx] = true;//set was_pressed
            switch (buttonIdx) {
                case _BUTTONS.LEFT_SHOULDER:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.RIGHT_SHOULDER:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.LEFT_TRIGGER:
                    _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.LEFT_TRIGGER].value); break;
                case _BUTTONS.RIGHT_TRIGGER:
                    _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value); break;
            }
        }
        //ON RELEASE
        else if (_btnPressMap[buttonIdx]) {
            _btnPressMap[buttonIdx] = false;
            switch (buttonIdx) {
                case _BUTTONS.SOUTH_BTN:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.EAST_BTN:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.WEST_BTN:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.NORTH_BTN:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.NORTH_DPAD:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.SOUTH_DPAD:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.WEST_DPAD:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.EAST_DPAD:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.RIGHT_STICK_BUTTON:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.LEFT_STICK_BUTTON:
                    _BUTTON_MAPPING[buttonIdx](); break;
                case _BUTTONS.LEFT_TRIGGER:
                    _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.LEFT_TRIGGER].value); break;
                case _BUTTONS.RIGHT_TRIGGER:
                    _BUTTON_MAPPING[buttonIdx](_gamepad.buttons[_BUTTONS.RIGHT_TRIGGER].value); break;
            }
        }
    }

    var setMapping = function(mapping){
        switch(mapping) {
            case "headtracker":
                _BUTTON_MAPPING[_BUTTONS.SOUTH_BTN] = selectObject;
                _BUTTON_MAPPING[_BUTTONS.SOUTH_DPAD] = goHome;
                _BUTTON_MAPPING[_BUTTONS.NORTH_DPAD] = toggleNavMode;
                _BUTTON_MAPPING[_BUTTONS.WEST_BTN] = hideObject;
                _BUTTON_MAPPING[_BUTTONS.LEFT_SHOULDER] = decAltitude;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_SHOULDER] = incAltitude;
                _BUTTON_MAPPING[_BUTTONS.LEFT_TRIGGER] = explode;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_TRIGGER] = fineSpeedAdjust;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_STICK_BUTTON] = deselectAll;
                _BUTTON_MAPPING[_BUTTONS.LEFT_STICK_BUTTON] = unhideAll;
                break;
            default:
                _BUTTON_MAPPING[_BUTTONS.SOUTH_BTN] = selectObject;
                _BUTTON_MAPPING[_BUTTONS.EAST_BTN] = createSavePoint;
                _BUTTON_MAPPING[_BUTTONS.WEST_BTN] = hideObject;
                _BUTTON_MAPPING[_BUTTONS.NORTH_BTN] = showPropertyPanel;
                _BUTTON_MAPPING[_BUTTONS.SOUTH_DPAD] = goHome;
                _BUTTON_MAPPING[_BUTTONS.WEST_DPAD] = previousSavePoint;
                _BUTTON_MAPPING[_BUTTONS.EAST_DPAD] = nextSavePoint;
                _BUTTON_MAPPING[_BUTTONS.NORTH_DPAD] = toggleNavMode;
                _BUTTON_MAPPING[_BUTTONS.LEFT_SHOULDER] = decAltitude;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_SHOULDER] = incAltitude;
                _BUTTON_MAPPING[_BUTTONS.LEFT_TRIGGER] = triggerZoom;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_TRIGGER] = fineSpeedAdjust;
                _BUTTON_MAPPING[_BUTTONS.RIGHT_STICK_BUTTON] = deselectAll;
                _BUTTON_MAPPING[_BUTTONS.LEFT_STICK_BUTTON] = unhideAll;
                break;
        }
    };

    //things buttons can do below
    var goHome = function(){
        viewerapi.navigation.setRequestHomeView(true);
        viewerapi.showAll();
        viewerapi.impl.selector.clearSelection();
        viewerapi.explode(0);
    };

    //Shoulder buttons and triggers
    var decAltitude = function() {
        if (_lockInPlane)
            _altitudeLockCoord += (-_gamepad.buttons[_BUTTONS.LEFT_SHOULDER].pressed) * _actualMoveSpeed;
        else
            _camera.translateY(-_gamepad.buttons[_BUTTONS.LEFT_SHOULDER].pressed * _actualMoveSpeed);
    };

    var incAltitude = function() {
        if (_lockInPlane)
            _altitudeLockCoord += (_gamepad.buttons[_BUTTONS.RIGHT_SHOULDER].pressed) * _actualMoveSpeed;
        else
            _camera.translateY(_gamepad.buttons[_BUTTONS.RIGHT_SHOULDER].pressed * _actualMoveSpeed);
    };

    var explode = function(analog_value){
        if (analog_value > _THRESHOLD) {
            if (analog_value == 0.5) {//not set yet
                viewerapi.explode(0);
                return;
            }
            _explodeSpeed = analog_value;
            var ns = _explodeSpeed;
            if (ns > 1) ns = 1;
            if (ns < 0) ns = 0;
            viewerapi.explode(ns);
        }
        else
            viewerapi.explode(0);
    };


    //Triggers are analog, so pass in value of trigger
    var triggerZoom = function(analog_value){
        if (analog_value > _THRESHOLD) {
            if(analog_value == 0.5) {
                _camera.fov = _INITIAL_FOV;
                _btnPressMap[_BUTTONS.LEFT_TRIGGER] = false;
                return;
            }
            //linear interp: y = -40x + 75
            ///75 is original fov angle. smaller slope = greater max zoom.
            // equation will interpolate between based on trigger pressure (analog)
            _camera.fov = _ZOOM_SCALAR * analog_value + _INITIAL_FOV;
        }
        else {
            _camera.fov = _INITIAL_FOV;//originally 75
        }
    };

    var fineSpeedAdjust = function(analog_value){
        if(analog_value > _THRESHOLD){
            if(analog_value == 0.5) {//ignore
                //TODO set speed correctly before input received AND have whole speedadjust down here!!
                _btnPressMap[_BUTTONS.RIGHT_TRIGGER] = false;
                return;
            }
            _speed_scalar = -(_SPEED_ADJUST * analog_value) + _INITIAL_SPEED_SCALAR;
        }
        else{
            _speed_scalar = _INITIAL_SPEED_SCALAR;
        }

    };

    var createSavePoint = function(){
        var state = _viewerState.getState(VIEWER_STATE_FILTER);
        _savepoints.push(state);
        stderr("Savepoint created.");
    };

    var previousSavePoint = function(){
        if (_savepoints.length) {
            _nextsavepoint--;
            if (_nextsavepoint < 0)
                _nextsavepoint = _savepoints.length - 1;
            _viewerState.restoreState(_savepoints[_nextsavepoint]);
        }
    };

    var nextSavePoint = function(){
        if (_savepoints.length) {
            _nextsavepoint++;
            if (_nextsavepoint >= _savepoints.length)
                _nextsavepoint = 0;
            _viewerState.restoreState(_savepoints[_nextsavepoint]);
        }
    };

    var selectObject = function(){
        var res = viewerapi.impl.hitTestViewport(new THREE.Vector3(0, 0, 0));
        if(_currentTool == "headtracker"){
            //vr tool forgets to do this, necessary for center selection
            _camera.updateMatrixWorld();
        }
        if (res) {
            viewerapi.impl.selector.toggleSelection(res.dbId, res.model);
            //viewerapi.fitToView(res.dbId);
        } else {
            viewerapi.impl.selector.clearSelection();
        }
    };

    var deselectAll = function() {
        viewerapi.impl.selector.clearSelection();
    };

    var unhideAll = function() {
        viewerapi.showAll();
        viewerapi.impl.selector.clearSelection();
        viewerapi.explode(0);
    };

    var hideObject = function(){
        var res = viewerapi.impl.hitTestViewport(new THREE.Vector3(0, 0, 0), false);
        if (res) {
            if (res.dbId in viewerapi.getHiddenNodes())
                viewerapi.show(res.dbId);
            else
                viewerapi.hide(res.dbId);
        }
    };

    var showPropertyPanel = function(){
        viewerapi.getPropertyPanel(true).setVisible(!viewerapi.getPropertyPanel(true).isVisible());
    };

    var toggleNavMode = function(){
        _lockInPlane = !_lockInPlane;
        if(_lockInPlane)
            _altitudeLockCoord = _camera.position.z;
        showDPadHud("up");
    };

    init();
};

})(); // closure;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Section');

/**
 * SectionExtension adds UI elements for section analysis
 */
Autodesk.Viewing.Extensions.Section.SectionExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
    this.viewer = viewer;

};

Autodesk.Viewing.Extensions.Section.SectionExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.constructor = Autodesk.Viewing.Extensions.Section.SectionExtension;


/**
 * Registers the SectionTool, hotkeys and event handlers.
 *
 * @returns {boolean}
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.load = function() {
    var that = this;
    var viewer = this.viewer;

    this.tool = new Autodesk.Viewing.Extensions.Section.SectionTool(viewer);
    viewer.toolController.registerTool(this.tool);
    this.sectionStyle = null;
    this.supportedStyles = ["X", "Y", "Z", "BOX"];

    if (viewer.getToolbar) {
        var toolbar = viewer.getToolbar(true);
        if (toolbar) {
            this.onToolbarCreated();
        } else {
            this.onToolbarCreatedBinded = this.onToolbarCreated.bind(this);
            viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        }
    }

    this.onResetBinded = this.onReset.bind(this);
    viewer.addEventListener(Autodesk.Viewing.RESET_EVENT, this.onResetBinded);

    this.HOTKEYS_ID = "Autodesk.Section.Hotkeys";
    var hotkeys = [{
        keycodes: [
            Autodesk.Viewing.theHotkeyManager.KEYCODES.ESCAPE
        ],
        onRelease: function () {
            return that.enableSectionTool(false);
        }
    }];
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.HOTKEYS_ID, hotkeys);

    return true;
};

/**
 * Unregisters the SectionTool, hotkeys and event handlers.
 *
 * @returns {boolean}
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    this.destroyUI();

    viewer.removeEventListener(Autodesk.Viewing.RESET_EVENT, this.onResetBinded);
    this.onResetBinded = null;

    if (this.onToolbarCreatedBinded) {
        viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        this.onToolbarCreatedBinded = null;
    }

    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

/**
 * Whether the section planes are active or not.
 *
 * @returns {boolean}
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.isActive = function() {
    return this.tool.isActive();
};

/**
 * Toggles activeness of section planes.
 *
 * @returns {boolean} Whether the section plane is active or not.
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.toggle = function() {
    if (this.isActive()) {
        this.enableSectionTool(false);
    } else {
        var style = this.sectionStyle || "X";
        this.setSectionStyle(style, true);
    }
    return this.isActive(); // Need to check for isActive() again.
};

/**
 * Returns the current type of plane that will cut-though the geometry.
 *
 * @returns {null|String} Either "X" or "Y" or "Z" or "BOX" or null.
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.getSectionStyle = function() {
    return this.sectionStyle;
};

/**
 * Sets the Section plane style.
 *
 * @param {String} style - Accepted values are 'X', 'Y', 'Z' and 'BOX' (in Caps)
 * @param {Boolean} [preserveSection] - Whether sending the current style value resets the cut planes.
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.setSectionStyle = function(style, preserveSection) {

    if (this.supportedStyles.indexOf(style) === -1) {
        return false;
    }

    var bActive = this.isActive();
    var bNewStyle = (this.sectionStyle !== style) || !preserveSection;
    this.sectionStyle = style;

    if (bActive && bNewStyle) {
        this.tool.setSection(style);
    }
    else if (!bActive) {
        this.enableSectionTool(true);
        if (bNewStyle) {
            this.tool.setSection(style);
        } else {
            this.tool.attachControl(true);
        }
    }
    return true;
};


/**
 *
 * @param enable
 * @returns {boolean}
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.enableSectionTool = function(enable) {
    var toolController = this.viewer.toolController,
        isActive = this.tool.isActive();

    if (enable && !isActive) {
        toolController.activateTool("section");
        if (this.sectionToolButton) {
            this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.ACTIVE);
        }
        return true;

    } else if (!enable && isActive) {
        toolController.deactivateTool("section");
        if (this.sectionToolButton) {
            this.sectionToolButton.setState(Autodesk.Viewing.UI.Button.State.INACTIVE);
        }
        return true;
    }
    return false;
};

/**
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.onToolbarCreated = function() {
    if (this.onToolbarCreatedBinded) {
        this.viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, this.onToolbarCreatedBinded);
        this.onToolbarCreatedBinded = null;
    }
    this.createUI();
};

/**
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.onReset = function() {
    this.tool.resetSection();
};

/***
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.createUI = function()
{
    var viewer = this.viewer;
    var AVU = Autodesk.Viewing.UI;

    this.sectionToolButton = new AVU.ComboButton("toolbar-sectionTool");
    this.sectionToolButton.setToolTip('Section analysis');
    this.sectionToolButton.setIcon("adsk-icon-section-analysis");
    this.createSubmenu(this.sectionToolButton);

    // make sure inspect tools is visible
    var toolbar = viewer.getToolbar(false);
    var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);

    // place section tool before reset tool
    var resetTool = modelTools.getControl("toolbar-resetTool");
    if (resetTool) {
        modelTools.addControl(this.sectionToolButton, {index: modelTools.indexOf(resetTool.getId())});
    } else {
        modelTools.addControl(this.sectionToolButton, {index: 0});
    }
};

/**
 *
 * @param parentButton
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.createSubmenu = function(parentButton)
{
    var that = this;
    var viewer = this.viewer;
    var AVU = Autodesk.Viewing.UI;

    function createNavToggler(button, name) {
        return function() {
            var state = button.getState();
            if (state === AVU.Button.State.INACTIVE) {
                button.setState(AVU.Button.State.ACTIVE);
                that.enableSectionTool(true);
                if (this instanceof AVU.ComboButton === false) {
                    that.tool.setSection(name);
                } else {
                    that.tool.attachControl(true);
                }
            } else if (state === AVU.Button.State.ACTIVE) {
                button.setState(AVU.Button.State.INACTIVE);
                that.enableSectionTool(false);
            }
            that.sectionStyle = name;
        };
    }

    function updateSectionButtons() {
        var areVectorsEqual = (function () {
            var v = new THREE.Vector3();
            return function(a, b, sqtol) {
                v.subVectors(a, b);
                return v.lengthSq() < sqtol;
            };
        })();

        var unitx = new THREE.Vector3(1, 0, 0);
        var unity = new THREE.Vector3(0, 1, 0);
        var unitz = new THREE.Vector3(0, 0, 1);
        var right = viewer.autocam.getWorldRightVector();
        var up = viewer.autocam.getWorldUpVector();
        var front = viewer.autocam.getWorldFrontVector();

        var tol = 0.0001;
        if (areVectorsEqual(up, unitx, tol)) {
            that.sectionYButton.setIcon("adsk-icon-plane-x");
        } else if (areVectorsEqual(up, unitz, tol)) {
            that.sectionYButton.setIcon("adsk-icon-plane-z");
        } else {
            that.sectionYButton.setIcon("adsk-icon-plane-y");
        }

        if (areVectorsEqual(right, unity, tol)) {
            that.sectionXButton.setIcon("adsk-icon-plane-y");
        } else if (areVectorsEqual(right, unitz, tol)) {
            that.sectionXButton.setIcon("adsk-icon-plane-z");
        } else {
            that.sectionXButton.setIcon("adsk-icon-plane-x");
        }

        if (areVectorsEqual(front, unitx, tol)) {
            that.sectionZButton.setIcon("adsk-icon-plane-x");
        } else if (areVectorsEqual(front, unity, tol)) {
            that.sectionZButton.setIcon("adsk-icon-plane-y");
        } else {
            that.sectionZButton.setIcon("adsk-icon-plane-z");
        }

        viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, updateSectionButtons);
    }

    var sectionXButton = this.sectionXButton = new AVU.Button("toolbar-sectionTool-x");
    sectionXButton.setToolTip('Add X plane');
    sectionXButton.setIcon("adsk-icon-plane-x");
    sectionXButton.onClick = createNavToggler(sectionXButton, 'X');
    parentButton.addControl(sectionXButton);

    var sectionYButton = this.sectionYButton = new AVU.Button("toolbar-sectionTool-y");
    sectionYButton.setToolTip('Add Y plane');
    sectionYButton.setIcon("adsk-icon-plane-y");
    sectionYButton.onClick = createNavToggler(sectionYButton, 'Y');
    parentButton.addControl(sectionYButton);

    var sectionZButton = this.sectionZButton = new AVU.Button("toolbar-sectionTool-z");
    sectionZButton.setToolTip('Add Z plane');
    sectionZButton.setIcon("adsk-icon-plane-z");
    sectionZButton.onClick = createNavToggler(sectionZButton, 'Z');
    parentButton.addControl(sectionZButton);

    var sectionBoxButton = this.sectionBoxButton = new AVU.Button("toolbar-sectionTool-box");
    sectionBoxButton.setToolTip('Add box');
    sectionBoxButton.setIcon("adsk-icon-box");
    sectionBoxButton.onClick = createNavToggler(sectionBoxButton, 'BOX');
    parentButton.addControl(sectionBoxButton);

    viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, updateSectionButtons);
};

/**
 * @private
 */
Autodesk.Viewing.Extensions.Section.SectionExtension.prototype.destroyUI = function()
{
    var viewer = this.viewer;

    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);
        if (modelTools && this.sectionToolButton) {
            var inspectSubmenu = modelTools.getControl("toolbar-inspectSubMenu");
            if (inspectSubmenu) {
                inspectSubmenu.removeControl(this.sectionToolButton.getId());
            } else {
                modelTools.removeControl(this.sectionToolButton.getId());
            }
            this.sectionToolButton = null;
        }
    }
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Section', Autodesk.Viewing.Extensions.Section.SectionExtension);
;AutodeskNamespace('Autodesk.Viewing.Extensions.Section');


Autodesk.Viewing.Extensions.Section.tintColor = { r: 1, g: 1, b: 0 };
Autodesk.Viewing.Extensions.Section.tintIntensity = 0.2;


/**
 * Tool that provides visual controls for the user to change the cutplane's position and angle.
 * It can (and should) be hooked to [ToolController's registerTool]{@Autodesk.Viewing.ToolController#registerTool}
 *
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer3D instance
 * @param {Object} [options] - This component is not customizable.
 * @constructor
 */
Autodesk.Viewing.Extensions.Section.SectionTool = function(viewer, options)
{
    var _viewer  = viewer.impl;

    var _names = ["section"];
    var _active = false;

    var _isDragging = false;
    var _isPlaneOn = true;

    var _transRotControl;
    var _transControl;
    var _sectionGroups = [];
    var _sectionPlanes = [];
    var _sectionPicker = [];
    var _activeMode = "";
    var _overlayName = "gizmo";
    var _touchType = null;
    var _initialized = false;
    var _visibleAtFirst = true;
    var _outlineIndices = [[0, 1], [1, 3], [3, 2], [2, 0]];
    var AVES = Autodesk.Viewing.Extensions.Section;
    
    init_TransformGizmos();
    init_SectionMesh();

    function initControl() {

        if (_initialized)
            return;

        _transRotControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, "transrotate");
        _transRotControl.addEventListener('change', updateViewer);
        _transRotControl.setSnap(Math.PI/2, Math.PI/36); // snap to 90 degs within 5 degs range 

        _transControl = new THREE.TransformControls(_viewer.camera, _viewer.canvas, "translate");
        _transControl.addEventListener('change', updateViewer);

        // add to overlay scene
        if (_viewer.overlayScenes[_overlayName] === undefined) {
            _viewer.createOverlayScene(_overlayName);
        }
        _viewer.addOverlay(_overlayName, _transRotControl);
        _viewer.addOverlay(_overlayName, _transControl);

        viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);
        viewer.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);
        viewer.addEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);
        viewer.addEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);
    
        _initialized = true;
    }

    function deinitControl() {
        
        if (!_initialized)
            return;
    
        _viewer.removeOverlay(_overlayName, _transRotControl);
        _transRotControl.removeEventListener('change', updateViewer);
        _transRotControl = null;
        _viewer.removeOverlay(_overlayName, _transControl);
        _transControl.removeEventListener('change', updateViewer);
        _transControl = null;
        _viewer.removeOverlayScene(_overlayName);

        viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, updateControls);
        viewer.removeEventListener(Autodesk.Viewing.ISOLATE_EVENT, updateSections);
        viewer.removeEventListener(Autodesk.Viewing.HIDE_EVENT, updateSections);
        viewer.removeEventListener(Autodesk.Viewing.SHOW_EVENT, updateSections);
        
        _initialized = false;
    }

    function updateViewer() {
        _viewer.invalidate(false, false, true);
    }

    function updateControls() {
        if (_transRotControl) {
            _transRotControl.update();
        }
        if (_transControl) {
            _transControl.update();
        }
    }

    function updateSections() {
        if (_sectionPlanes.length === 1) {
            updatePlaneMeshes(true);
            updateControls();
            updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
        }
    }

    function mix(a, b, val) {
        return a * (1.0 - val) + b * val;
    }
    
    function getDiffuseColor(material) {
       return material.color || new THREE.Color(0xffffff);
    }

    function getSpecularColor(material) {
        return material.specular || new THREE.Color(0xffffff);
    }

    function tintColor(c) {
        var intensity = Autodesk.Viewing.Extensions.Section.tintIntensity;
        var tc = Autodesk.Viewing.Extensions.Section.tintColor;
        c.r = mix(c.r, tc.r, intensity);
        c.g = mix(c.g, tc.g, intensity);
        c.b = mix(c.b, tc.b, intensity);
    }
    
    function updateCapMeshes(plane) {

        init_three_triangulator();
        init_three_intersector();
    

        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);
            
        var section = new THREE.Object3D();
        section.name = "section";
        _viewer.sceneAfter.add(section);
        
        var section3D = new THREE.Object3D();
        section.add(section3D);
        var section2D = new THREE.Object3D();
        section.add(section2D);

        var avp = Autodesk.Viewing.Private;


        var toPlaneCoords = avp.Intersector.makePlaneBasis(plane);
        var fromPaneCoords = new THREE.Matrix4().getInverse(toPlaneCoords);

        var mat2dname = _viewer.matman().create2DMaterial(null, {skipCircles:true, skipEllipticals:true}, false, false);
        var mat2d = _viewer.matman().findMaterial(null, mat2dname);
        mat2d.transparent = true;
        mat2d.depthTest = true;
        mat2d.polygonOffset = true;
        mat2d.polygonOffsetFactor = -1;
        mat2d.polygonOffsetUnits = 1;

        var box = new THREE.Box3();

        var worldBox = _viewer.getVisibleBounds(true);   
        
        //some heuristic for line width of the section outline based on model size
        //half a percent of the model size is what we do here.
        var lineWidth = 0.5 * 5e-5 * worldBox.size().length();

        var models = _viewer.modelQueue().getModels();

        models.forEach(function(model) {

            var it = model.getData().instanceTree;
            if (!it)
                return;
            var frags = model.getFragmentList();

            //We have to go node by node and combine the fragments for each node into
            //a single 2D slice polygon.
            it.enumNodeChildren(model.getRootId(), function(dbId) {

                if (it.isNodeHidden(dbId) || it.isNodeOff(dbId)) {
                    return;
                }

                var intersects = [];
                var m;

                //All fragments that belong to the same node make part of the
                //same object so we have to accumulate all their intersections into one list
                it.enumNodeFragments(dbId, function(fragId) {

                    frags.getWorldBounds(fragId, box);
                    if (!avp.Intersector.intersectBoxPlane(plane, box))
                        return;

                    m = frags.getVizmesh(fragId);

                    if (!m.geometry)
                        return;
                    if (m.geometry.is2d || m.geometry.isLines)
                        return;
                    if (!m.material.cutplanes)
                        return;

                    avp.Intersector.intersectMeshPlane(plane, m, intersects);

                 }, false);


                if (intersects.length) {

                    var bbox = new THREE.Box3();
                    avp.Intersector.convertToPlaneCoords(toPlaneCoords, intersects, bbox);

                    //Create the 2D line geometry
                    var vbb = new avp.VertexBufferBuilder(false, 8 * intersects.length);

                    var color = getDiffuseColor(m.material);
                    var r = 0|(color.r * 0.25)*255.5;
                    var g = 0|(color.g * 0.25)*255.5;
                    var b = 0|(color.b * 0.25)*255.5;

                    var c = 0xff000000 | (b<<16) | (g<<8) | r;

                    var cset = new avp.Triangulator.ContourSet(intersects, bbox);
                    cset.snapEdges();
                    cset.sanitizeEdges();
                    cset.stitchContours();

                    for (var j=0; j<cset.contours.length; j++) {

                        var cntr = cset.contours[j];

                        var r = 0|Math.random()*255.5;
                        var g = 0|Math.random()*255.5;
                        var b = 0|Math.random()*255.5;
                        var rc = 0xff000000 | (b<<16) | (g<<8) | r;

                        var isClosed = (cntr[0] === cntr[cntr.length-1]);

                        for (var k=1; k<cntr.length; k++) {
                            var pt1 = cset.pts[cntr[k-1]];
                            var pt2 = cset.pts[cntr[k]];
                            vbb.addSegment(pt1.x, pt1.y, pt2.x, pt2.y, 0, 0.02, /*isClosed ? c : rc*/c, dbId, 0);
                        }

                    }


                    var mdata = { mesh: vbb.toMesh() };

                    avp.BufferGeometryUtils.meshToGeometry(mdata);

                    var bg2d = mdata.geometry;
                    bg2d.streamingDraw = true;
                    bg2d.streamingIndex = true;

                    var mesh2d = new THREE.Mesh(bg2d, mat2d);

                    mesh2d.matrix.copy(fromPaneCoords);
                    mesh2d.matrixAutoUpdate = false;
                    mesh2d.frustumCulled = false;
                    section2D.add(mesh2d);


                    //Create triangulated capping polygon
                    if (true) {

                        //Create the 3D mesh
                        var tin = new avp.Triangulator.TriangulatedSurface(cset);

                        if (tin.indices.length) {

                            var bg = new THREE.BufferGeometry();

                            var pos = new Float32Array(3*tin.pts.length);
                            for (var j=0; j<tin.pts.length; j++) {
                                pos[3*j] = tin.pts[j].x;
                                pos[3*j+1] = tin.pts[j].y;
                                pos[3*j+2] = 0;
                            }
                            bg.addAttribute("position", new THREE.BufferAttribute(pos, 3));

                            var packNormals = m.material.packedNormals;
                            var normal = packNormals ? new Uint16Array(2*tin.pts.length) : new Float32Array(3*tin.pts.length);

                            for (var j=0; j<tin.pts.length; j++) {

                                if (packNormals) {
                                    var pnx = (0/*Math.atan2(0, 0)*/ / Math.PI + 1.0) * 0.5;
                                    var pny = (1.0 + 1.0) * 0.5;

                                    normal[j*2] = (pnx * 65535)|0;
                                    normal[j*2+1] = (pny * 65535)|0;
                                } else {
                                    normal[3*j] = 0;
                                    normal[3*j+1] = 0;
                                    normal[3*j+2] = 1;
                                }
                            }

                            bg.addAttribute("normal", new THREE.BufferAttribute(normal, packNormals ? 2 : 3));
                            if (packNormals) {
                                bg.attributes.normal.bytesPerItem = 2;
                                bg.attributes.normal.normalize = true;
                            }

                            var index = new Uint16Array(tin.indices.length);
                            index.set(tin.indices);

                            bg.addAttribute("index", new THREE.BufferAttribute(index, 1));

                            bg.streamingDraw = true;
                            bg.streamingIndex = true;

                            var mat = _viewer.matman().cloneMaterial(m.material);

                            mat.packedNormals = packNormals;
                            mat.cutplanes = null;
                            mat.side = THREE.FrontSide;
                            mat.depthTest = true;
                            mat.map = null;
                            mat.bumpMap = null;
                            mat.normalMap = null;
                            mat.alphaMap = null;
                            mat.specularMap = null;
                            mat.transparent = false;
                            mat.depthWrite = true;
                            mat.hatchPattern = true;
                            mat.needsUpdate = true;

                            var angle = (m.material.id+2) * Math.PI * 0.125;
                            var tan = Math.tan(angle);
                            mat.hatchParams = new THREE.Vector2(tan, 10.0);
                            mat.hatchTintColor = Autodesk.Viewing.Extensions.Section.tintColor;
                            mat.hatchTintIntensity = Autodesk.Viewing.Extensions.Section.tintIntensity;

                            // If the material is prism, clear all the map definitions.
                            if (mat.prismType != null) {
                                mat.defines = {};
                                mat.defines[mat.prismType.toUpperCase()] = "";
                                if (mat.prismType == "PrismWood") {
                                    mat.defines["NO_UVW"] = "";
                                }
                            }

                            var capmesh = new THREE.Mesh(bg, mat);
                            capmesh.matrix.copy(fromPaneCoords);
                            capmesh.matrixAutoUpdate = false;
                            capmesh.dbId = dbId;
                            capmesh.fragId = intersects.fragId;

                            section3D.add(capmesh);
                        }

                    }

                }


            }, true); //enumNodeChildren

        }); //models.forEach

    }

    function createPlaneMesh(plane, bbox) {
        var quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), plane.normal);
        var geometry;

        if (bbox) {
            // project bbox to set plane size
            var ptMax = plane.projectPoint(bbox.max);
            var ptMin = plane.projectPoint(bbox.min);
            var invQuat = quat.clone().inverse();
            ptMax.applyQuaternion(invQuat);
            ptMin.applyQuaternion(invQuat);
            var size = new THREE.Vector3().subVectors(ptMax, ptMin);
            geometry = new THREE.PlaneBufferGeometry(size.x, size.y);
        } else {
            // project bounding sphere
            bbox = _viewer.getVisibleBounds();
            var size = 2.0 * bbox.getBoundingSphere().radius;
            geometry = new THREE.PlaneBufferGeometry(size, size);
        }

        var material = new THREE.MeshBasicMaterial({
            opacity: 0,
            color: 0xffffff,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });

        var mesh = new AVES.SectionMesh(geometry, material, plane);
        var pt = plane.projectPoint(bbox.center());       
        mesh.position.copy(pt);
        mesh.quaternion.multiply(quat);

        // add outlines with inverted background color
        var bgColor = Autodesk.Viewing.Private.LightPresets[_viewer.currentLightPreset()].bgColorGradient;
        var color = "rgb(" + (255-bgColor[0]) + "," + (255-bgColor[1]) + "," + (255-bgColor[2]) + ")";
        var lineMaterial = new THREE.LineBasicMaterial({color: color, linewidth:1, depthTest: false});
        var pos = mesh.geometry.getAttribute('position');
        for (var i = 0; i < _outlineIndices.length; i++) {
            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize),
                                   new THREE.Vector3().fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize));
            var line = new THREE.Line(geometry, lineMaterial);
            mesh.add(line);
            mesh.outlines.push(line);
        }

        return mesh;
    }

    function updatePlaneMeshes(rebuild) {
    
        traverseSections(function(child) {
            if (child instanceof AVES.SectionMesh) {

                if (child.connectivity.length > 0) {
                    // section box
                    var minv = new THREE.Matrix4().getInverse(child.matrixWorld);
                    var pt = new THREE.Vector3();
                    var pos = child.geometry.getAttribute('position');
                    for (var i = 0; i < pos.length / pos.itemSize; i++) {
                        var connect = child.connectivity[i];
                        if (intersectPlanes(child.plane, connect[0], connect[1], pt) !== null) {
                            pt.applyMatrix4(minv);
                            pos.setXYZ(i, pt.x, pt.y, pt.z);
                        }
                    };
                    pos.needsUpdate = true;
                    child.geometry.computeBoundingBox();
                    child.geometry.computeBoundingSphere();

                    for (var i = 0; i < child.outlines.length; i++) {
                        var line = child.outlines[i];
                        line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);
                        line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);
                        line.geometry.verticesNeedUpdate = true;
                    }
                } else {
                    // section plane
                    if (rebuild) {
                        var bbox = _viewer.getVisibleBounds();
                        var size = 2.0 * bbox.getBoundingSphere().radius;
                        var pt = child.plane.projectPoint(bbox.center());
                        child.geometry = new THREE.PlaneBufferGeometry(size, size);
                        child.position.copy(pt);
                        var pos = child.geometry.getAttribute('position');
                        for (var i = 0; i < child.outlines.length; i++) {
                            var line = child.outlines[i];
                            line.geometry.vertices[0].fromArray(pos.array, _outlineIndices[i][0] * pos.itemSize);
                            line.geometry.vertices[1].fromArray(pos.array, _outlineIndices[i][1] * pos.itemSize);
                            line.geometry.verticesNeedUpdate = true;
                        }
                    }
                }
            }
        });
    }

    function traverseSections(callback) {
        for (var i = 0; i < _sectionGroups.length; i++) {           
            _sectionGroups[i].traverse(callback);
        }
    }

    function setSectionPlanes() {
        traverseSections(function(child) {
            if (child instanceof AVES.SectionMesh) {
                child.update();
            }
        });
        if (_sectionPlanes.length === 1) {
            updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
        }
        _viewer.setCutPlanes(_sectionPlanes);
    }

    function showPlane(set) {
        for (var i = 0; i < _sectionGroups.length; i++) {
            _sectionGroups[i].visible = set;
        }
        
        if (_isPlaneOn !== set)
            updateViewer();

        _isPlaneOn = set;
    }

    function showSection(set) {
        if (set && _sectionPlanes.length > 0) {
            if (_sectionPlanes.length === 1) {
                updateCapMeshes(new THREE.Plane().setComponents(_sectionPlanes[0].x, _sectionPlanes[0].y, _sectionPlanes[0].z, _sectionPlanes[0].w));
            }
            viewer.setCutPlanes(_sectionPlanes);
        }
        showPlane(set);
    }

    function attachControl(control, mesh) {
        control.attach(mesh);
        control.setPosition(mesh.position);
        control.visible = true;
    }

    function setPlane(normal) {
        // flip normal if facing inward as eye direction
        var eyeVec = _viewer.api.navigation.getEyeVector();
        if (eyeVec.dot(normal) > 0) {
            normal.negate();
        }
        var group = new THREE.Group();
        var plane = new THREE.Plane(normal, 0);
        var mesh = createPlaneMesh(plane, null);
        group.add(mesh);
        _sectionPlanes.push(mesh.planeVec);
        _sectionGroups.push(group);
        _viewer.addOverlay(_overlayName, group);
        attachControl(_transRotControl, mesh);
        _transRotControl.showRotationGizmos(true);
        _sectionPicker = _transRotControl.getPicker();
        setSectionPlanes();
    }

    function setBox() {
        var normals = [
            new THREE.Vector3(1, 0, 0), 
            new THREE.Vector3(0, 1, 0), 
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(0, -1, 0),
            new THREE.Vector3(0, 0, -1)
        ];

        var connectivities = [
            [[1, 2], [1, 5], [2, 4], [4, 5]], // 0
            [[3, 5], [0, 5], [2, 3], [0, 2]], // 1
            [[1, 3], [0, 1], [3, 4], [0, 4]], // 2
            [[1, 5], [1, 2], [4, 5], [2, 4]], // 3
            [[2, 3], [0, 2], [3, 5], [0, 5]], // 4
            [[0, 1], [3, 1], [0, 4], [3, 4]]  // 5
        ];

        var group = new THREE.Group();
        var obbox = _viewer.getVisibleBounds();
        var center = obbox.center();
        var bbox = new THREE.Box3(obbox.min, center);
        var planes = [], meshes = [];
        for (var i = 0; i < normals.length; i++) {
            var plane = new THREE.Plane(normals[i], -1 * center.dot(normals[i]));
            planes.push(plane);

            // offset plane with negative normal to form an octant
            if (i > 2) {
                var ptMax = plane.orthoPoint(bbox.max);
                var ptMin = plane.orthoPoint(bbox.min);
                var size = new THREE.Vector3().subVectors(ptMax, ptMin);
                plane.constant -= size.length();                
            }

            var mesh = createPlaneMesh(plane, bbox);
            group.add(mesh);
            meshes.push(mesh);
            _sectionPlanes.push(mesh.planeVec);
        }

        // build connectivity
        for (var i = 0; i < meshes.length; i++) {
            var mesh = meshes[i];
            var connectivity = connectivities[i];
            for (var j = 0; j < connectivity.length; j++) {
                var nc = [];
                var ct = connectivity[j];
                for (var k = 0; k < ct.length; k++) {
                    nc.push(planes[ct[k]]);
                }
                mesh.connectivity.push(nc);
            }
        }
        
        _sectionGroups.push(group);
        _viewer.addOverlay(_overlayName, group);

        attachControl(_transRotControl, _sectionGroups[0].children[0]);
        attachControl(_transControl, _sectionGroups[0]);
        _transRotControl.showRotationGizmos(false);
        _sectionPicker = _transRotControl.getPicker().concat(_transControl.getPicker());

        setSectionPlanes();
    }

    var intersectPlanes = (function () {
        var m = new THREE.Matrix3();
        var n23 = new THREE.Vector3();
        var n31 = new THREE.Vector3();
        var n12 = new THREE.Vector3();
        return function(plane1, plane2, plane3, optionalTarget) {
            m.set(plane1.normal.x, plane1.normal.y, plane1.normal.z,
                  plane2.normal.x, plane2.normal.y, plane2.normal.z,
                  plane3.normal.x, plane3.normal.y, plane3.normal.z);
            
            var det = m.determinant();
            if (det === 0) return null;

            n23.crossVectors(plane2.normal, plane3.normal).multiplyScalar(-plane1.constant);
            n31.crossVectors(plane3.normal, plane1.normal).multiplyScalar(-plane2.constant);
            n12.crossVectors(plane1.normal, plane2.normal).multiplyScalar(-plane3.constant);

            var result = optionalTarget || new THREE.Vector3();
            return result.copy(n23).add(n31).add(n12).divideScalar(det);
        };
    })();

    var intersectObjects = (function () {
        var pointerVector = new THREE.Vector3();
        var pointerDir = new THREE.Vector3();
        var ray = new THREE.Raycaster();
        var camera = _viewer.camera;

        return function(pointer, objects, recursive) {
            var rect = _viewer.canvas.getBoundingClientRect();
            var x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
            var y = - ((pointer.clientY - rect.top) / rect.height) * 2 + 1;
            
            if (camera.isPerspective) {
                pointerVector.set(x, y, 0.5);
                pointerVector.unproject(camera);
                ray.set(camera.position, pointerVector.sub(camera.position).normalize());
            } else {
                pointerVector.set(x, y, -1);
                pointerVector.unproject(camera);
                pointerDir.set(0, 0, -1);
                ray.set(pointerVector, pointerDir.transformDirection(camera.matrixWorld));
            }

            var intersections = ray.intersectObjects(objects, recursive);
            return intersections[0] ? intersections[0] : null;
        };
    })();

    // public functions

    /**
     * When active, the geometry will be sectioned by the current set cut plane.
     * @returns {boolean}
     */
    this.isActive = function() {
        return _active;
    };

    /**
     * Facilitates the initialization of a cut plane
     *
     * @param {String} name - Either 'X', 'Y', 'Z' or 'BOX'
     */
    this.setSection = function(name) {
        this.clearSection();
        switch (name) {
            case 'X':
                var normal = new THREE.Vector3(1, 0, 0);
                setPlane(normal);
                break;
            case 'Y':
                var normal = new THREE.Vector3(0, 1, 0);
                setPlane(normal);
                break;
            case 'Z':
                var normal = new THREE.Vector3(0, 0, 1);
                setPlane(normal);
                break;
            case 'BOX':
                setBox();
                break;
        }
        _activeMode = name;
    };

    /**
     * Removes any (and all) currently set cut plane(s).
     */
    this.clearSection = function() {

        if (_transRotControl)
            _transRotControl.detach();

        if (_transControl)
            _transControl.detach();

        // remove all sections
        while(_sectionPlanes.length > 0) {
            _sectionPlanes.pop();
        }

        while(_sectionGroups.length > 0) {
            var group = _sectionGroups.pop();
            _viewer.removeOverlay(_overlayName, group);
        }
        
        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);

        _viewer.setCutPlanes();
    };

    this.isPlaneOn = function() {
        return _isPlaneOn;
    };

    this.showPlane = function(set) {
        showPlane(set);
    };

    /**
     * Whether translation and rotation controls are visible or not.
     * @param {Boolean} set
     */
    this.attachControl = function(set) {
        if (set) {
            attachControl(_transRotControl, _sectionGroups[0].children[0]);
            _transRotControl.highlight();
            if (_activeMode === 'BOX')
                attachControl(_transControl, _sectionGroups[0]);
        } else {
            _transRotControl.detach();
            _transControl.detach();
        }
    };

    /**
     * Invokes setSection with the last set of parameters used.
     */
    this.resetSection = function() {
        this.setSection(_activeMode);
    };

    // tool interface

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    this.register = function() {
    };

    this.deregister = function() {
        this.clearSection();
        deinitControl();
    };

    /**
     * [ToolInterface] Activates the tool
     * @param {String} name - unused
     */
    this.activate = function(name) {

        initControl();

        _active = true;
        _isDragging = false;
        _visibleAtFirst = true;

        // keep only one section all the time per design
        _sectionPlanes = _sectionPlanes || [];

        showSection(true);
    };

    /**
     * [ToolInterface] Deactivates the tool
     * @param {String} name - unused
     */
    this.deactivate = function(name) {
        _active = false;
        _isDragging = false;

        var oldsection = _viewer.sceneAfter.getObjectByName("section");
        if (oldsection)
            _viewer.sceneAfter.remove(oldsection);


        showSection(false);
        _viewer.setCutPlanes();
        _transRotControl.detach();
        _transControl.detach();
    };

    this.update = function(highResTimestamp) {
        return false;
    };

    this.handleSingleClick = function(event, button) {
        var pointer = event.pointers ? event.pointers[ 0 ] : event;
        var result = intersectObjects(pointer, _sectionGroups[0].children);
        if (result) {
            attachControl(_transRotControl, result.object);
            _transRotControl.highlight();
            updateViewer();
        }

        return false;
    };

    this.handleDoubleClick = function(event, button) {
        return false;
    };

    this.handleSingleTap = function(event) {
        return this.handleSingleClick(event, 0);
    };

    this.handleDoubleTap = function(event) {
        return false;
    };

    this.handleKeyDown = function(event, keyCode) {
        return false;
    };

     this.handleKeyUp = function(event, keyCode) {
        return false;
    };

    this.handleWheelInput = function(delta) {
        return false;
    };

    this.handleButtonDown = function(event, button) {
        _isDragging = true;
        if (_transControl.onPointerDown(event))
            return true;
        return _transRotControl.onPointerDown(event);
    };

    this.handleButtonUp = function(event, button) {
        _isDragging = false;
        if (_transControl.onPointerUp(event)) 
            return true;
        return _transRotControl.onPointerUp(event);
    };

    this.handleMouseMove = function(event) {
        if (_isDragging) {
            if (_transControl.onPointerMove(event) ) {
                setSectionPlanes();
                _transRotControl.update();
                return true;
            }
            if (_transRotControl.onPointerMove(event)) {
                setSectionPlanes();
                updatePlaneMeshes();
                return true;
            }
        }

        if (event.pointerType !== 'touch') {
            var pointer = event.pointers ? event.pointers[ 0 ] : event;
            var result = intersectObjects(pointer, _sectionGroups[0].children);
            if (result) {
                _visibleAtFirst = false;
            }

            // show gizmo + plane when intersecting on non-touch 
            var visible = _visibleAtFirst || (result || intersectObjects(pointer, _sectionPicker, true)) ? true : false;
            _transRotControl.visible = visible;
            _transControl.visible = _transControl.object !== undefined && visible;
            showPlane(visible);
        }

        if (_transControl.onPointerHover(event))
            return true;

        return _transRotControl.onPointerHover(event);
    };

    this.handleGesture = function(event) {
        switch (event.type) {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                if (_touchType === "drag") {
                    _touchType = null;
                    return this.handleButtonUp(event, 0);
                }
                return false;
        }
        return false;
    };

    this.handleBlur = function(event) {
        return false;
    };

    this.handleResize = function() {
    };

    this.handlePressHold = function(event) {
        return true;
    };
};

function init_SectionMesh() {

if (Autodesk.Viewing.Extensions.Section.SectionMesh)
    return;

Autodesk.Viewing.Extensions.Section.SectionMesh = function(geometry, material, plane)
{
    THREE.Mesh.call(this, geometry, material, false);

    this.plane = plane;
    this.planeVec = new THREE.Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant);
    this.connectivity = [];
    this.outlines = [];
};

Autodesk.Viewing.Extensions.Section.SectionMesh.prototype = Object.create(THREE.Mesh.prototype);
Autodesk.Viewing.Extensions.Section.SectionMesh.prototype.constructor = Autodesk.Viewing.Extensions.Section.SectionMesh;

Autodesk.Viewing.Extensions.Section.SectionMesh.prototype.update = function()
{
    this.plane.normal.set(0, 0, 1);
    this.plane.normal.applyQuaternion(this.quaternion);

    var normal = this.plane.normal;
    var d = -1 * this.getWorldPosition().dot(normal);
    this.planeVec.set(normal.x, normal.y, normal.z, d);
    this.plane.constant = d;
};

}

;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Fusion360Sim');

/** @constructor */
Autodesk.Viewing.Extensions.Fusion360Sim.SimulationDef = function () {
    this.studyNode;
    this.constraintsNode = -1;
    this.constraintNodes = [];
    this.loadsNode = -1;
    this.loadNodes = [];
    this.resultsNode = -1;
    this.bodyNode = -1;
    this.resultTypes = {};
    this.resultGroups = {};
   // this.modelNodes = [];
    this.simNodes = [];
    this.modelNodes = [];

    this.modalAnalysis = false;
    this.modalResults = {};

    this.modelStructurePanel = null;
    this.simExt = null;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimulationDef.prototype.associateResult = function(resultName,resultNode) {
    this.resultTypes[resultNode] = resultName;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimulationDef.prototype.associateResultGroup = function (resultGroupName, resultGroupNode) {
    this.resultGroups[resultGroupNode] = resultGroupName;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimulationDef.prototype.associateModalResult = function (resultName, resultNode) {

    var subResultNode = [];
    subResultNode = this.modalResults[resultName];
    if (subResultNode == null) {
        var subNode = [];
        subNode.push(resultNode);
        subResultNode = subNode;
    }
    else {
        subResultNode.push(resultNode);
    }
    this.modalResults[resultName] = subResultNode;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimulationDef.prototype.reset = function () {
    this.studyNode = -1;
    this.constraintsNode = -1;
    this.constraintNodes = [];
    this.loadsNode = -1;
    this.loadNodes = [];
    this.resultsNode = -1;
    this.bodyNode = -1;
    this.resultTypes = {};
    this.resultGroups = {};

    this.simNodes = [];
    this.modelNodes = [];

    this.modalAnalysis = false;
    this.modalResults = {};

    this.modelStructurePanel = null;
}
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Fusion360Sim');

/** @constructor */
Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel = function (viewer) {
    this.viewer = viewer;
    this.simDef = null;
    Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, 'Simulation-Panel', 'Simulation Results');
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.constructor = Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel;

/**
 * Override so that the panel is updated with the currently selected node's properties,
 * and that default properties are loaded when the model is first loaded.
 */
Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.initialize = function () {
    Autodesk.Viewing.UI.DockingPanel.prototype.initialize.call(this);
    var self = this;

    this.kPanelExpandedHeight = 420; //px
    this.kPanelCollapsedHeight = 35; //px

    this.container.classList.add('measurePanel');
    this.container.dockRight = true;

    this.container.style.minWidth  = "380px";
    this.container.style.width = "380px";
    this.container.style.minHeight = this.kPanelCollapsedHeight + "px";
    this.container.style.height    = this.kPanelExpandedHeight + "px";
    this.container.style.maxHeight = this.kPanelExpandedHeight + "px";
    this.container.style.top       = "150px";
    this.container.style.left      = "220px"; // just needs an initial value dock overrides value
    //this.container.style.resize    = "none";
    this.container.style.position  = "absolute";

    this.legend = document.createElement("div");
    this.container.appendChild( this.legend );

    //this.constraints = document.createElement("div");
    //this.constraints.style.width = "40px";
    //this.constraints.style.height = "40px";
    //this.constraints.style.backgroundColor = "grey";
    //this.constraints.style.margin = "5px";
    //this.constraints.style.position = "absolute";
    //this.constraintsShow = false;
    //this.constraints.addEventListener("click",function() {
    //    self.constraintsShow = !self.constraintsShow;
    //    self.constraints.style.backgroundColor = self.constraintsShow ? "green" : "grey";
    //    if (self.constraintsShow)
    //        self.viewer.show(self.simDef.constraintsNode);
    //    else
    //        self.viewer.hide(self.simDef.constraintsNode);

    //});
    //this.loads = document.createElement("div");
    //this.loads.style.width = "40px";
    //this.loads.style.height = "40px";
    //this.loads.style.backgroundColor = "grey";
    //this.loads.style.margin = "5px";
    //this.loads.style.position = "absolute";
    //this.loads.style.left = "50px";
    //this.loadsShow = false;
    //this.loads.addEventListener("click",function() {
    //    self.loadsShow = !self.loadsShow;
    //    self.loads.style.backgroundColor = self.loadsShow ? "green" : "grey";
    //    if (self.loadsShow)
    //        self.viewer.show(self.simDef.loadsNode);
    //    else
    //        self.viewer.hide(self.simDef.loadsNode);

    //});

    //this.legend.appendChild(this.constraints);
    //this.legend.appendChild(this.loads);

    //result groups control
    this.resultsGroup = document.createElement("select");
    this.resultsGroup.classList.add('simulation-resultGroup');
    this.resultsGroup.style.position = "absolute";
    this.resultsGroup.style.top = "42px";
    this.resultsGroup.style.width = "180px";
    this.resultsGroup.style.left = "5px";
    this.resultsGroup.style.color = "black";
    this.resultsGroup.style.height = "22px";
    this.resultsGroup.style.border = "1px";
    this.resultsGroup.addEventListener("change", function (event) {
        self.viewer.hide(self.simDef.resultsNode);
        if(self.simDef.modalAnalysis == false)
            self.fillResultTypes(self.resultsGroup.value);
        else
            self.fillModalResultTypes(self.resultsGroup.value);

        setTimeout(function () {
            self.setSimObjectsVisibility();
        }, 100);
    });
    this.legend.appendChild(this.resultsGroup);

    //result types control
    this.resultTypes = document.createElement("select");
    this.resultTypes.classList.add('simulation-resultTypes');
    this.resultTypes.style.position = "absolute";
    this.resultTypes.style.top = "42px";
    this.resultTypes.style.width = "180px";
    this.resultTypes.style.left = "190px";
    this.resultTypes.style.color = "black";
    this.resultTypes.style.height = "22px";
    this.resultTypes.style.border = "1px";
    this.resultTypes.addEventListener("change", function (event) {
        self.viewer.hide(self.simDef.resultsNode);
        self.setSimObjectsVisibility();
        //self.simDef.modelStructurePanel.onClick(Number(self.resultTypes.value), null);
    });
    this.legend.appendChild(this.resultTypes);

    this.colorScale = document.createElement("div");
    this.colorScale.classList.add('simulation-colorscale');
    this.colorScale.style.width = "210px";
    this.colorScale.style.height = "20px";
    this.colorScale.style.margin = "5px";
    this.colorScale.style.position = "absolute";
    this.colorScale.style.left = "-70px";
    this.colorScale.style.top = "170px";
    this.colorScale.style.backgroundRepeat = "repeat";
    this.legend.appendChild(this.colorScale);

    this.colorScaleTopText = document.createElement("div");
    this.colorScaleTopText.style.position = "absolute";
    this.colorScaleTopText.style.left = "52px";
    this.colorScaleTopText.style.top = "73px";
    this.colorScaleTopText.innerHTML = "- 3333";
    this.legend.appendChild(this.colorScaleTopText);

    this.colorScaleBottomText = document.createElement("div");
    this.colorScaleBottomText.style.position = "absolute";
    this.colorScaleBottomText.style.left = "52px";
    this.colorScaleBottomText.style.top = "281px";
    this.colorScaleBottomText.innerHTML = "- 3333";
    this.legend.appendChild(this.colorScaleBottomText);

    //line
    this.line = document.createElement("hr");
    this.line.style.position = "absolute";
    this.line.style.top = "300px";
    this.line.style.width = "100%";
    this.line.style.borderTop = "1px solid black";
    this.legend.appendChild(this.line);

    //info
    // create elements <table> and a <tbody>
    this.tbl = document.createElement("table");
    this.tblBody = document.createElement("tbody");

    // append the <tbody> inside the <table>
    this.tbl.appendChild(this.tblBody);
    // put <table> in the <body>
    this.legend.appendChild(this.tbl);
    // tbl border attribute to
    //this.tbl.setAttribute("border", "2");
    this.tbl.style.position = "absolute";
    this.tbl.style.top = "310px";

    this.tbl.style.margin = "5px";

};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setSimulationDef = function (simDef) {
    this.simDef = simDef;
    var that = this;
    //name
    var studyNode = Number(this.simDef.studyNode);
    function getPropertyValue(properties, propertyName) {
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            if (property.displayName === propertyName) {
                return property.displayValue;
            }
        }
        return null;
    }

    function onStudyPropertiesRetrieved(studyNode) {
        var name = getPropertyValue(studyNode.properties, "Name");
        that.setTitle(name);
    }

    function onError(status, message, data) {
       // onNodeProcessed();
    }

    this.viewer.getProperties(studyNode, onStudyPropertiesRetrieved, onError);

    var studyName;
    //result groups
    if (this.simDef.modalAnalysis == true)
        studyName = Autodesk.Viewing.i18n.translate("Modal Frequencies");
    else
        studyName = Autodesk.Viewing.i18n.translate("Static Stress");

    //info
    //Analysis type
    if (!this.rowType) {
        this.rowType = document.createElement("tr");
        this.cellType1 = document.createElement("td");
        this.cellTextType1 = document.createTextNode(Autodesk.Viewing.i18n.translate("Analysis Type"));
        this.cellType1.appendChild(this.cellTextType1);
        this.cellType1.style.width = '180px';
        this.cellType2 = document.createElement("td");
        this.cellTextType2 = document.createTextNode(studyName);
        this.cellType2.appendChild(this.cellTextType2);
        this.rowType.appendChild(this.cellType1);
        this.rowType.appendChild(this.cellType2);
        this.tblBody.appendChild(this.rowType);

        //nodes
        this.rowNodes = document.createElement("tr");
        this.cellNodes1 = document.createElement("td");
        this.cellTextNodes1 = document.createTextNode(Autodesk.Viewing.i18n.translate("Nodes"));
        this.cellNodes1.appendChild(this.cellTextNodes1);
        //this.cellType1.style.width = '150px';
        this.cellNodes2 = document.createElement("td");
        var nodesCount = '1872';
        this.cellTextNodes2 = document.createTextNode(nodesCount);
        this.cellNodes2.appendChild(this.cellTextNodes2);
        this.rowNodes.appendChild(this.cellNodes1);
        this.rowNodes.appendChild(this.cellNodes2);
        this.tblBody.appendChild(this.rowNodes);

        //elements
        this.rowElements = document.createElement("tr");
        this.cellElements1 = document.createElement("td");
        this.cellTextElements1 = document.createTextNode(Autodesk.Viewing.i18n.translate("Elements"));
        this.cellElements1.appendChild(this.cellTextElements1);
        //this.cellType1.style.width = '150px';
        this.cellElements2 = document.createElement("td");
        var elementsCount = '1084';
        this.cellTextElements2 = document.createTextNode(elementsCount);
        this.cellElements2.appendChild(this.cellTextElements2);
        this.rowElements.appendChild(this.cellElements1);
        this.rowElements.appendChild(this.cellElements2);
        this.tblBody.appendChild(this.rowElements);

        //min
        this.rowMin = document.createElement("tr");
        this.cellMin1 = document.createElement("td");
        this.cellTextMin1 = document.createTextNode(Autodesk.Viewing.i18n.translate("Min"));
        this.cellMin1.appendChild(this.cellTextMin1);
        //this.cellType1.style.width = '150px';
        this.cellMin2 = document.createElement("td");
        var minCount = '0.000E+02 MPa';
        this.cellTextMin2 = document.createTextNode(minCount);
        this.cellMin2.appendChild(this.cellTextMin2);
        this.rowMin.appendChild(this.cellMin1);
        this.rowMin.appendChild(this.cellMin2);
        this.tblBody.appendChild(this.rowMin);

        //max
        this.rowMax = document.createElement("tr");
        this.cellMax1 = document.createElement("td");
        this.cellTextMax1 = document.createTextNode(Autodesk.Viewing.i18n.translate("Max"));
        this.cellMax1.appendChild(this.cellTextMax1);
        //this.cellType1.style.width = '150px';
        this.cellMax2 = document.createElement("td");
        var maxCount = '5.117E+02 MPa';
        this.cellTextMax2 = document.createTextNode(maxCount);
        this.cellMax2.appendChild(this.cellTextMax2);
        this.rowMax.appendChild(this.cellMax1);
        this.rowMax.appendChild(this.cellMax2);
        this.tblBody.appendChild(this.rowMax);
    }
    else {
        this.cellTextType2.nodeValue = studyName;
    }

    this.resultsGroup.options.length = 0;
    if (this.simDef.modalAnalysis == false) {
        var groupKeys = Object.keys(simDef.resultGroups);
        if(!groupKeys  || groupKeys.length == 0) {
          this.setSimObjectsVisibility();
          return;
        }
        for (var i = 0; i < groupKeys.length; i++) {
            var item = document.createElement("option");
            item.value = groupKeys[i];
            var name = simDef.resultGroups[groupKeys[i]];
            item.setAttribute("data-i18n", name);
            item.textContent = Autodesk.Viewing.i18n.translate(name);
            this.resultsGroup.add(item);
        }
    }
    else {
        var groupKeys = Object.keys(simDef.modalResults);
        if(!groupKeys  || groupKeys.length == 0) {
          this.setSimObjectsVisibility();
          return;
        }

        for (var i = 0; i < groupKeys.length; i++) {
            var item = document.createElement("option");
            item.value = groupKeys[i];
            var name = groupKeys[i];
            item.setAttribute("data-i18n", name);
            item.textContent = Autodesk.Viewing.i18n.translate(name);
            this.resultsGroup.add(item);
        }
    }
    if (this.resultsGroup.options.length <= 1) {
        this.resultsGroup.disabled = true;
        this.resultsGroup.style.webkitAppearance = "none";
        this.resultsGroup.style.mozappearance = "none";
        this.resultsGroup.style.MozAppearance = "none";
        this.resultsGroup.style.appearance = "none";
        //this.resultsGroup.style.lineHeight = "19px";
    }
    else {
        this.resultsGroup.disabled = false;
        this.resultsGroup.style.webkitAppearance = "";
        this.resultsGroup.style.mozappearance = "";
        this.resultsGroup.style.MozAppearance = "";
        this.resultsGroup.style.appearance = "";
        //this.resultsGroup.style.lineHeight = "";
    }

    var that = this;
    var model = that.viewer.model;
    model.getObjectTree(function(instanceTree) {
        that.instanceTree = instanceTree;
        if (that.simDef.modalAnalysis == false)
            that.fillResultTypes(that.resultsGroup.value);
        else
            that.fillModalResultTypes(that.resultsGroup.value);

        setTimeout(function () {
            simDef.simExt.showResultsDlg(true);
            simDef.simExt.applySettings();
            that.setSimObjectsVisibility();
        }, 500);

    });

    //elements & nodes
    var resultsNode = Number(this.simDef.resultsNode);
    function onResultsPropertiesRetrieved(resultsNode) {
        var elements = getPropertyValue(resultsNode.properties, "Elements");
        var nodes = getPropertyValue(resultsNode.properties, "Nodes");
        that.cellTextElements2.nodeValue = elements;
        that.cellTextNodes2.nodeValue = nodes;
    }

    this.viewer.getProperties(resultsNode, onResultsPropertiesRetrieved, onError);
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.processNodes = function (instanceTree, onProcessed) {
    var that = this;

    // Find all of the nodes to process.
    //
    var nodeIdsToProcess = [];

    var simDef = this.simDef;
    if (!simDef)
        simDef = new Autodesk.Viewing.Extensions.Fusion360Sim.SimulationDef();
    else
        simDef.reset();

    instanceTree.enumNodeChildren(instanceTree.getRootId(), function (dbId) {
        nodeIdsToProcess.push(dbId);
    }, true);

    function getPropertyValue(properties, propertyName) {
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            if (property.displayName === propertyName) {
                return property.displayValue;
            }
        }
        return null;
    }

    function processNodeId(node, onNodeProcessed) {
        function onPropertiesRetrieved(result) {

            ////force to hide until all init
            //that.viewer.hide(node);

            var properties = result.properties;
            var name = getPropertyValue(result.properties, 'A1C6011B-E1A6-4ADF-975D-A0003C592F87');
            if (name) {
                var bSimNode = true;
                if (name == "SIM_CONSTRAINTS") {
                    simDef.constraintsNode = node;
                }
                else if (name == "SIM_CONSTRAINT") {
                    simDef.constraintNodes.push(node);
                }
                else if (name == "SIM_LOADS") {
                    simDef.loadsNode = node;
                }
                else if (name == "SIM_LOAD") {
                    simDef.loadNodes.push(node);
                }
                else if (name == "SIM_RESULTS_SCALAR_PLOT") {
                    if (simDef.modalAnalysis == false)
                        simDef.associateResult(getPropertyValue(properties, "Name"), node);
                    else
                        simDef.associateModalResult(getPropertyValue(properties, "Name"), node);
                }
                else if (name == "SIM_RESULTS_GROUP") {
                    if (simDef.modalAnalysis == false)
                        simDef.associateResultGroup(getPropertyValue(properties, "Name"), node);
                }
                else if (name == "SIM_RESULTS") {
                    simDef.resultsNode = node;
                    that.viewer.hide(node);
                }
                else if (name == "SIM_STUDY") {
                    simDef.studyNode = node;
                    var type = getPropertyValue(result.properties, "Study Type");
                    if (type == 'SimCaseModalFrequencies')
                        simDef.modalAnalysis = true;
                }
                else if (name == "SIM_RESULTS_SCALAR_PLOT_BODY") {

                }
                else if (name == "SIM_RESULTS_SAMPLE") {

                }
                //else {
                //    simDef.modelNodes.push(node);
                //    bSimNode = false;
                //}

                if (bSimNode == true) {
                    simDef.simNodes.push(node);
                }
            }
            else {
                simDef.modelNodes.push(node);
            }

            onNodeProcessed();
        }

        function onError(status, message, data) {
            onNodeProcessed();
        }

        if (node && that.viewer)
            that.viewer.getProperties(node, onPropertiesRetrieved, onError);
    }

    // Process the nodes one by one.
    //
    function processNext() {
        if (nodeIdsToProcess.length > 0) {
            processNodeId(nodeIdsToProcess.shift(), processNext);
        } else {
            // No more nodes to process - call the provided callback.
            //
            Autodesk.Viewing.Extensions.Fusion360Sim.$getObjectTree = function () {
                return simDef;
            };
            onProcessed(simDef);
        }
    }
    processNext();
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.initModel = function (instanceTree, simExt) {
    if (!this.viewer)
        return;

    var that = this;
    that.processNodes(instanceTree, function (simDef) {
        simDef.simExt = simExt;
        that.setSimulationDef(simDef);
    });

    that.addEventListener(that.viewer, Autodesk.Viewing.ISOLATE_EVENT,
    function (e) {
        //hide highlighted nodes
        if(that.simDef.loadsNode != -1)
            that.hightlightNode(that.simDef.loadsNode, false);
        if (that.simDef.constraintsNode != -1)
            that.hightlightNode(that.simDef.constraintsNode, false);

        if (that.simDef.modelNodes && that.simDef.modelNodes.length > 0) {
            for (var i = 0; i < that.simDef.modelNodes.length; ++i) {
                that.hightlightNode(that.simDef.modelNodes[i], false);
            }
        }

        var nodes = e.nodeIdArray;
        if (nodes) {
            // show all
            if (nodes.length == 0) {
                that.setSimObjectsVisibility();
            }
            else {
                if (nodes.length == 1) //take care about one
                {
                    if(that.isModelNode(nodes[0])) {
                        //that.setModelNodesVisible(true);
                        //hide loads
                        if(that.simDef.loadsNode)
                            that.viewer.hide(that.simDef.loadsNode);
                        //hide constraints
                        if(that.simDef.constraintsNode)
                            that.viewer.hide(that.simDef.constraintsNode);
                        //hide results
                        if(that.simDef.resultsNode)
                            that.viewer.hide(that.simDef.resultsNode);
                    }
                }
            }
        }
    });
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.hightlightNode = function (node, bHighlight) {

    var viewer = this.viewer.impl;
    var that = this;

    //check for root node
    var isRoot = false;
    var instanceTree = this.viewer.model.getData().instanceTree;
    if (instanceTree) {
        var rootId = instanceTree.getRootId();
        isRoot = (typeof node == "number" && node === rootId);
        //isModelNode = !isRoot;
    }
    if (isRoot && bHighlight)
        return;

    that.instanceTree.enumNodeFragments(node, function (fragId) {
        viewer.highlightFragment(that.viewer.model, fragId, bHighlight, true);
    }, true);
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.fillResultTypes = function (resultGroupKey) {
    var that = this;
    that.resultTypes.options.length = 0;
    var node = Number(resultGroupKey);
    function getPropertyValue(properties, propertyName) {
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            if (property.displayName === propertyName) {
                return property.displayValue;
            }
        }
        return null;
    }

    function onGroupPropertiesRetrieved(groupResult) {
        var resultGroup = getPropertyValue(groupResult.properties, "Result group");

        function onResultPropertiesRetrieved(resultType) {
            var resultTypeGroup = getPropertyValue(resultType.properties, "Result group");
            if (resultTypeGroup === resultGroup) {
                var item = document.createElement("option");
                item.value = resultType.dbId;
                var name = that.simDef.resultTypes[resultType.dbId];
                item.setAttribute("data-i18n", name);
                item.textContent = Autodesk.Viewing.i18n.translate(name);
                that.resultTypes.add(item);

                if (that.resultTypes.options.length <= 1) {
                    that.resultTypes.disabled = true;
                    that.resultTypes.style.webkitAppearance = "none";
                    that.resultTypes.style.mozappearance = "none";
                    that.resultTypes.style.MozAppearance = "none";
                    that.resultTypes.style.appearance = "none";
                    //that.resultTypes.style.lineHeight = "19px";
                }
                else {
                    that.resultTypes.disabled = false;
                    that.resultTypes.style.webkitAppearance = "";
                    that.resultTypes.style.mozappearance = "";
                    that.resultTypes.style.MozAppearance = "";
                    that.resultTypes.style.appearance = "";
                    //that.resultTypes.style.lineHeight = "";
                }
            }

        }
        //result types
        var keys = Object.keys(that.simDef.resultTypes);
        for (var i = 0; i < keys.length; i++) {
            var resultNode = Number(keys[i]);
            that.viewer.getProperties(resultNode, onResultPropertiesRetrieved, onError);
        }
    }

    function onError(status, message, data) {
        // onNodeProcessed();
    }

    that.viewer.getProperties(node, onGroupPropertiesRetrieved, onError);
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.fillModalResultTypes = function (resultGroupKey) {
    var that = this;
    that.resultTypes.options.length = 0;
    function getPropertyValue(properties, propertyName) {
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            if (property.displayName === propertyName) {
                return property.displayValue;
            }
        }
        return null;
    }

    var resultGroup = resultGroupKey;

    function onResultPropertiesRetrieved(resultType) {
        var resultTypeGroup = getPropertyValue(resultType.properties, "Result type");
        if (resultTypeGroup === resultGroup) {
            var item = document.createElement("option");
            item.value = resultType.dbId;

            var resultMode = getPropertyValue(resultType.properties, "Mode");
            var name = resultMode;
            item.setAttribute("data-i18n", name);
            item.textContent = name; //Autodesk.Viewing.i18n.translate(name); //Mode 1: 200 Hz -> result from translate 200 Hz -> not acceptable
            that.resultTypes.add(item);

            that.simDef.associateResult(name, resultType.dbId);

            if (that.resultTypes.options.length <= 1) {
                that.resultTypes.disabled = true;
                that.resultTypes.style.webkitAppearance = "none";
                that.resultTypes.style.mozappearance = "none";
                that.resultTypes.style.MozAppearance = "none";
                that.resultTypes.style.appearance = "none";
               // that.resultTypes.style.lineHeight = "19px";
            }
            else {
                that.resultTypes.disabled = false;
                that.resultTypes.style.webkitAppearance = "";
                that.resultTypes.style.mozappearance = "";
                that.resultTypes.style.MozAppearance = "";
                that.resultTypes.style.appearance = "";
               // that.resultTypes.style.lineHeight = "";
            }
        }

    }
    //result types
    var keys = that.simDef.modalResults[resultGroup];
    for (var i = 0; i < keys.length; i++) {
        var resultNode = Number(keys[i]);
        that.viewer.getProperties(resultNode, onResultPropertiesRetrieved, onError);
    }
    // }

    function onError(status, message, data) {
        // onNodeProcessed();
    }
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.uninitialize = function () {
    Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);
    this.viewer = null;
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setTitle = function (title, options) {
    if (!title) {
        title = 'Simulations';
        options = options || {};
        options.localizeTitle = true;
    }
    Autodesk.Viewing.UI.DockingPanel.prototype.setTitle.call(this, title, options);
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setModelNodesVisible = function (bVisible) {
    if (this.simDef.modelNodes && this.simDef.modelNodes.length > 0) {
        for (var k = 0; k < this.simDef.modelNodes.length; k++) {
            var modelNode = this.simDef.modelNodes[k];
            //check for root node
            var isRoot = false;
            var instanceTree = this.viewer.model.getData().instanceTree;
            if (instanceTree) {
                var rootId = instanceTree.getRootId();
                isRoot = (typeof modelNode == "number" && modelNode === rootId);
                //isModelNode = !isRoot;
            }
            if (isRoot)
                continue;
            if (bVisible)
                this.viewer.show(modelNode);
             else
                this.viewer.hide(modelNode);
        }
    }
}

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isModelNode = function (node) {
    if (!this.simDef.modelNodes || this.simDef.modelNodes.length == 0)
        return false;

    return this.simDef.modelNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setNodeVisibility = function (node, visible) {
    if (visible) {
        this.viewer.show(node);
    } else {
        this.viewer.hide(node)
    }
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimLoadNode = function (node) {
    if (!this.simDef.loadNodes) return false;
    return this.simDef.loadNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimConstraintNode = function (node) {
    if (!this.simDef.constraintNodes) return false;
    return this.simDef.constraintNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimLoadsNode = function (node) {
    if (this.simDef.loadsNode == -1) return false;
    return this.simDef.loadsNode == node;
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimConstraintsNode = function (node) {
    if (this.simDef.constraintsNode == -1) return false;
    return this.simDef.constraintsNode == node;
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimStudyNode = function (node) {
    if (!this.simDef.studyNode) return false;
    return this.simDef.studyNode == node;
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimResultsNode = function (node) {
    if (!this.simDef.resultsNode) return false;
    return this.simDef.resultsNode == node;
};

Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setSimObjectsVisibility = function (node) {
    //if no results then show model and hide results panel
    if (!this.resultTypes || this.resultTypes.options.length == 0) {
        this.setModelNodesVisible(true);
        this.simDef.simExt.showResultsDlg(false);
        return;
    }

    var that = this;
    this.viewer.hide(this.simDef.resultsNode);

    var resultNode = Number(this.resultTypes.value);
    if (!node) {//this is called from Results panel
        //hide models
        this.setModelNodesVisible(false);

        //show result
        this.viewer.show(resultNode);

        //show loads
        if(this.simDef.loadsNode != -1)
            this.viewer.show(this.simDef.loadsNode);

        //show constraints
        if(this.simDef.constraintsNode != -1)
            this.viewer.show(this.simDef.constraintsNode);
    }
    else {
        //var isModelNode = this.isModelNode(node);
        //check for root node
        var isRoot = false;
        var instanceTree = this.viewer.model.getData().instanceTree;
        if (instanceTree) {
            var rootId = instanceTree.getRootId();
            isRoot = (typeof node == "number" && node === rootId);
            //isModelNode = !isRoot;
        }

        //if (isModelNode) {
        //    this.setModelNodesVisible(true);
        //    //hide result
        //    this.viewer.hide(resultNode);
        //    this.viewer.hide(this.simDef.resultsNode);
        //}
        //else {
            //hide models
            this.setModelNodesVisible(false);

            var isLoadNode = this.isSimLoadNode(node);
            var isLoadsNode = this.isSimLoadsNode(node);
            var isConstraintNode = this.isSimConstraintNode(node);
            var isConstraintsNode = this.isSimConstraintsNode(node);
            var isSimStudyNode = this.isSimStudyNode(node);
            //if (isConstraintNode || isLoadNode || isSimStudyNode || isConstraintsNode || isLoadsNode)
            //    this.viewer.show(node);

            this.viewer.hide(this.simDef.resultsNode);
            //show result
            this.viewer.show(resultNode);

            //if (isRoot) {
                if (this.simDef.loadsNode)
                    this.viewer.show(this.simDef.loadsNode);
                if(this.simDef.constraintsNode)
                    this.viewer.show(this.simDef.constraintsNode);
        // }
                if (!isRoot && !isSimStudyNode) {
                    instanceTree.enumNodeFragments(node, function (fragId) {
                        that.viewer.impl.highlightFragment(that.viewer.model, fragId, true, true);
                    }, true);
                }
        //}

    }

    //this.viewer.fitToView();

    var that = this;
    function getPropertyValue(properties, propertyName) {
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            if (property.displayName === propertyName) {
                return property.displayValue;
            }
        }
        return null;
    }

    function onResultPropertiesRetrieved(resultType) {
        var minValue = getPropertyValue(resultType.properties, "Minimal value");
        var maxValue = getPropertyValue(resultType.properties, "Maximal value");
        var reversed = getPropertyValue(resultType.properties, "Scale reversed");
        var unit = getPropertyValue(resultType.properties, "Unit");
        that.cellTextMin2.nodeValue = minValue + " " + unit;
        that.cellTextMax2.nodeValue = maxValue + " " + unit;

        var minRefValue = getPropertyValue(resultType.properties, "Lower referential value");
        var maxRefValue = getPropertyValue(resultType.properties, "Upper referential value");
        if (reversed == "True") {
            //var temp = maxRefValue;
            //maxRefValue = minRefValue;
            //minRefValue = temp;
            that.colorScale.style.transform = "rotate(90deg)";
            that.colorScale.style.moztransform = "rotate(90deg)";
            that.colorScale.style.webkittransform = "rotate(90deg)";
        }
        else {
            that.colorScale.style.transform = "rotate(-90deg)";
            that.colorScale.style.moztransform = "rotate(-90deg)";
            that.colorScale.style.webkittransform = "rotate(-90deg)";
        }
        that.colorScaleTopText.innerHTML = "- " + maxRefValue + " " + unit;;
        that.colorScaleBottomText.innerHTML = "- " + minRefValue + " " + unit;
    }

    that.viewer.getProperties(resultNode, onResultPropertiesRetrieved, onError);

    function onError(status, message, data) {
        // onNodeProcessed();
    }

};
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Fusion360Sim');

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel = function (ext, title, options) {
    Autodesk.Viewing.Extensions.ViewerModelStructurePanel.call(this, ext.viewer, title, options);
    this.viewer = ext.viewer;
    this.ext = ext;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype = Object.create(Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype);
Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.constructor = Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel;

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.setGallery = function (gallery) {
    this.simGalleryPanel = gallery;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.initialize = function () {
    Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.initialize.call(this);
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.isSimResultsNode = function (node) {
    if (!this.simGalleryPanel || !this.simGalleryPanel.simDef || !this.simGalleryPanel.simDef.resultsNode) return false;
    return this.simGalleryPanel.simDef.resultsNode == node;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.isSimStudyNode = function (node) {
    if (!this.simGalleryPanel || !this.simGalleryPanel.simDef || !this.simGalleryPanel.simDef.studyNode) return false;
    return this.simGalleryPanel.simDef.studyNode == node;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.isModelNode = function (node) {
    if (!this.simGalleryPanel || !this.simGalleryPanel.simDef || !this.simGalleryPanel.simDef.modelNodes || this.simGalleryPanel.simDef.modelNodes.length == 0)
        return false;

    return this.simGalleryPanel.simDef.modelNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.shouldInclude = function (node) {
    // Exclude study node.
    //
    if (this.isSimStudyNode(node))
        return false;

    return true;
}

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.onClick = function (node, event) {
    Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onClick.call(this, node, event);
    this.simGalleryPanel.setModelNodesVisible(true);
    this.simGalleryPanel.hightlightNode(node, true);

    //hide loads
    if (this.simGalleryPanel.simDef.loadsNode)
        this.viewer.hide(this.simGalleryPanel.simDef.loadsNode);
    //hide constraints
    if (this.simGalleryPanel.simDef.constraintsNode)
        this.viewer.hide(this.simGalleryPanel.simDef.constraintsNode);
    //hide results
    if (this.simGalleryPanel.simDef.resultsNode)
        this.viewer.hide(this.simGalleryPanel.simDef.resultsNode);
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.expandStudyNode = function () {
    if (!this.simGalleryPanel.simDef.studyNode) return;
    this.tree.setCollapsed(this.simGalleryPanel.simDef.studyNode, false);
};;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Fusion360Sim');

Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel = function (ext, title, options) {
    Autodesk.Viewing.Extensions.ViewerModelStructurePanel.call(this, ext.viewer, title, options);
    this.viewer = ext.viewer;
    this.ext = ext;

    this.container.style.left = "350px";
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype = Object.create(Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype);
Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.constructor = Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel;

Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.setGallery = function (gallery) {
    this.simGalleryPanel = gallery;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.isSimResultsNode = function (node) {
    if (!this.simGalleryPanel || !this.simGalleryPanel.simDef || !this.simGalleryPanel.simDef.resultsNode) return false;
    return this.simGalleryPanel.simDef.resultsNode == node;
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.isModelNode = function (node) {
    if (!this.simGalleryPanel || !this.simGalleryPanel.simDef || !this.simGalleryPanel.simDef.modelNodes || this.simGalleryPanel.simDef.modelNodes.length == 0)
        return false;

    return this.simGalleryPanel.simDef.modelNodes.indexOf(node) == 1;
};

//Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.isSimResultGroupNode = function (node) {
//    if (!this.simGalleryPanel || !this.simGalleryPanel.simDef || !this.simGalleryPanel.simDef.resultGroups || this.simGalleryPanel.simDef.resultGroups.length == 0)
//        return false;

//    var groupKeys = Object.keys(this.simGalleryPanel.simDef.resultGroups);
//    for (var i = 0; i < groupKeys.length; i++) {
//        var id = Number(groupKeys[i]);
//        if(id == node)
//            return true;
//    }

//    return false;
//};

Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.shouldInclude = function (node) {
    // Exclude results and model nodes.
    //
    if (this.isSimResultsNode(node) || this.isModelNode(node))
        return false;

    return true;
}

Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.onClick = function (node, event) {
    Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onClick.call(this, node, event);
    this.simGalleryPanel.setSimObjectsVisibility(node);
};

Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.expandStudyNode = function () {
    if (!this.simGalleryPanel.simDef.studyNode) return;
    this.tree.setCollapsed(this.simGalleryPanel.simDef.studyNode, false);
};;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Fusion360Sim');

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation = function (viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
    this.viewer = viewer;
    this.simButton = null;
    this.useSetupPanel = true;
    this.useModelPanel = true;
    if (options) {
        if(options.useSetupPanel !== undefined)
            this.useSetupPanel = options.useSetupPanel;

        if (options.useModelPanel !== undefined)
            this.useModelPanel = options.useModelPanel;
    }
};

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype.constructor = Autodesk.Viewing.Extensions.Fusion360Sim.Simulation;

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype.load = function () {
    var that = this;
    var viewer = this.viewer;

    that.galleryPanel = new Autodesk.Viewing.Extensions.Fusion360Sim.GalleryPanel(that.viewer);
    that.viewer.addPanel(that.galleryPanel);

    that.simButton = new Autodesk.Viewing.UI.Button('toolbar-simulation');
    that.simButton.setToolTip('Simulation Results');
    that.simButton.onClick = function (e) {
        var visible = that.galleryPanel.isVisible();
        that.galleryPanel.setVisible(!visible);
        that.simButton.setState(!visible ? Autodesk.Viewing.UI.Button.State.ACTIVE : Autodesk.Viewing.UI.Button.State.INACTIVE);
    };
    that.simButton.setIcon('toolbar-simulationIcon');
    viewer.settingsTools.addControl(that.simButton, { index: 1 });

    // Change these viewer settings for SIM files.
    //
    //keep defaults
    this.hideLines = viewer.prefs.get("lineRendering");
    this.ghosting = viewer.prefs.get("ghosting");
    this.ambientShadow = viewer.prefs.get("ambientShadows");
    this.antialiazing = viewer.prefs.get("antialiasing");
    this.lightPreset = viewer.prefs.get("lightPreset");

    ////////////////////////////////////////////////////
    var handleNewGeometry = function () {
        viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, handleNewGeometry);
        var model = that.viewer.model;
        model.getObjectTree(function (instanceTree) {
            that.galleryPanel.initModel(instanceTree, that);
            if(that.useModelPanel)
                that.initModelBrowser();

            if(that.useSetupPanel)
                that.initSetupPanel();
        });
    };

    //this is being called when you switched in left panel
    //in Jupiter
    this.initIfLoaded = function () {
        //var that = this;
        var model = that.viewer.model;
        if (model && model.isLoadDone) {
            model.getObjectTree(function (instanceTree) {
                setTimeout(function () {
                    that.galleryPanel.initModel(instanceTree, that);
                    if (that.useModelPanel)
                        that.initModelBrowser();

                    if (that.useSetupPanel)
                        that.initSetupPanel();
                }, 100);
            });
        }
    };

    var model = that.viewer.model;
    if (model && model.isLoadDone) {
        viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.initIfLoaded );
        model.getObjectTree(function (instanceTree) {
            setTimeout(function () {
                that.galleryPanel.initModel(instanceTree, that);
                if (that.useModelPanel)
                    that.initModelBrowser();

                if (that.useSetupPanel)
                    that.initSetupPanel();
            }, 100);
        });
    }
    else {
        viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, handleNewGeometry);
    }

    return true;
};

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype.unload = function () {
    this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.initIfLoaded);

    this.showResultsDlg(false);
    this.viewer.settingsTools.removeControl(this.simButton);

    this.viewer.removePanel(this.galleryPanel);
    this.galleryPanel.uninitialize();

    // restore viewer settings back.
    //
    this.viewer.hideLines(!this.hideLines);
    this.viewer.setGhosting(this.ghosting);
    this.viewer.setQualityLevel(this.ambientShadow, this.antialiazing);
    this.viewer.setLightPreset(this.lightPreset);
    //// Remove the panel from the viewer.
    ////
    if(this.modelStructurePanel)
        this.viewer.setModelStructurePanel(null);

    if(this.simSetupPanel)  {
        this.simSetupPanel.setVisible(false);  // This ensures the button is in the correct state.
        this.viewer.removePanel(this.simSetupPanel);
        this.simSetupPanel.uninitialize();
    }

    return true;
};

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype.initSetupPanel = function () {
    var that = this;
    setTimeout(function () {
        //setup button
        that.simSetupButton = new Autodesk.Viewing.UI.Button('toolbar-simulation-setup');
        that.simSetupButton.setToolTip('Simulation Setup');
        that.simSetupButton.onClick = function (e) {
            var visible = that.simSetupPanel.isVisible();
            that.simSetupPanel.setVisible(!visible);
            that.simSetupButton.setState(!visible ? Autodesk.Viewing.UI.Button.State.ACTIVE : Autodesk.Viewing.UI.Button.State.INACTIVE);
        };
        that.simSetupButton.setIcon('toolbar-simulationSetupIcon');
        that.viewer.settingsTools.addControl(that.simSetupButton, { index: 0 });

        //setup panel
        that.simSetupPanel = new Autodesk.Viewing.Extensions.Fusion360Sim.SimSetupPanel(that, Autodesk.Viewing.i18n.translate('Simulation Setup Loading'), that.options);
        that.simSetupPanel.setGallery(that.galleryPanel);

        that.viewer.addPanel(that.simSetupPanel);

        // If the model already exists, then set it now.  Otherwise, it will be
        // set later when the model is created in load().
        //
        if (that.viewer.model) {
            that.viewer.model.getObjectTree(function (instanceTree) {
                that.simSetupPanel.setModel(instanceTree, Autodesk.Viewing.i18n.translate('Simulation Setup'));
            });
        }
    }, 100);
};

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype.initModelBrowser = function () {
    var that = this;
    setTimeout(function () {
        that.modelStructurePanel = new Autodesk.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel(that, 'Simulation Model Structure Loading', that.options);
        that.viewer.setModelStructurePanel(that.modelStructurePanel);
        that.modelStructurePanel.setGallery(that.galleryPanel);
    }, 100);
};

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype.showResultsDlg = function (show) {
    this.simButton.setState(show ? Autodesk.Viewing.UI.Button.State.ACTIVE : Autodesk.Viewing.UI.Button.State.INACTIVE);
    this.simButton.setVisible(show);
    this.galleryPanel.setVisible(show);
};

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype.applySettings = function (show) {
    this.viewer.hideLines(false);
    this.viewer.setGhosting(false);
    this.viewer.setQualityLevel(false, true);
    this.viewer.setLightPreset(4);
};

Autodesk.Viewing.Extensions.Fusion360Sim.Simulation.prototype.simData = function () {
    return this.galleryPanel.simDef;
};

/**
 * Register the extension with the extension manager.
 */
Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Fusion360.Simulation', Autodesk.Viewing.Extensions.Fusion360Sim.Simulation);
;/**
 * @author arodic / https://github.com/arodic
 *
 * @author chiena -- Modified for Autodesk LMV web viewer
 */
 /*jshint sub:true*/

function init_TransformGizmos() {

    'use strict';

    var GizmoMaterial = function ( parameters ) {

        THREE.MeshBasicMaterial.call( this );

        this.depthTest = false;
        this.depthWrite = false;
        this.side = THREE.FrontSide;
        this.transparent = true;

        this.setValues( parameters );

        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;

        this.highlight = function( highlighted ) {

            if ( highlighted ) {

                this.color.setRGB( 1, 230/255, 3/255 );
                this.opacity = 1;

            } else {

                this.color.copy( this.oldColor );
                this.opacity = this.oldOpacity;

            }

        };

    };

    GizmoMaterial.prototype = Object.create( THREE.MeshBasicMaterial.prototype );

    var GizmoLineMaterial = function ( parameters ) {

        THREE.LineBasicMaterial.call( this );

        this.depthTest = false;
        this.depthWrite = false;
        this.transparent = true;
        this.linewidth = 1;

        this.setValues( parameters );

        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;

        this.highlight = function( highlighted ) {

            if ( highlighted ) {

                this.color.setRGB( 1, 230/255, 3/255 );
                this.opacity = 1;

            } else {

                this.color.copy( this.oldColor );
                this.opacity = this.oldOpacity;

            }

        };

    };

    GizmoLineMaterial.prototype = Object.create( THREE.LineBasicMaterial.prototype );

    // polyfill
    if (THREE.PolyhedronGeometry === undefined) {
        THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

            THREE.Geometry.call( this );

            this.type = 'PolyhedronGeometry';

            this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            };

            radius = radius || 1;
            detail = detail || 0;

            var that = this;

            for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

                prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

            }

            var midpoints = [], p = this.vertices;

            var faces = [];

            for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

                var v1 = p[ indices[ i     ] ];
                var v2 = p[ indices[ i + 1 ] ];
                var v3 = p[ indices[ i + 2 ] ];

                faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

            }

            var centroid = new THREE.Vector3();

            for ( var i = 0, l = faces.length; i < l; i ++ ) {

                subdivide( faces[ i ], detail );

            }


            // Handle case when face straddles the seam

            for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

                var uvs = this.faceVertexUvs[ 0 ][ i ];

                var x0 = uvs[ 0 ].x;
                var x1 = uvs[ 1 ].x;
                var x2 = uvs[ 2 ].x;

                var max = Math.max( x0, Math.max( x1, x2 ) );
                var min = Math.min( x0, Math.min( x1, x2 ) );

                if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

                    if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
                    if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
                    if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

                }

            }


            // Apply radius

            for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

                this.vertices[ i ].multiplyScalar( radius );

            }


            // Merge vertices

            this.mergeVertices();

            this.computeFaceNormals();

            this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


            // Project vector onto sphere's surface

            function prepare( vector ) {

                var vertex = vector.normalize().clone();
                vertex.index = that.vertices.push( vertex ) - 1;

                // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

                var u = azimuth( vector ) / 2 / Math.PI + 0.5;
                var v = inclination( vector ) / Math.PI + 0.5;
                vertex.uv = new THREE.Vector2( u, 1 - v );

                return vertex;

            }


            // Approximate a curved face with recursively sub-divided triangles.

            function make( v1, v2, v3 ) {

                var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
                that.faces.push( face );

                centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

                var azi = azimuth( centroid );

                that.faceVertexUvs[ 0 ].push( [
                    correctUV( v1.uv, v1, azi ),
                    correctUV( v2.uv, v2, azi ),
                    correctUV( v3.uv, v3, azi )
                ] );

            }


            // Analytically subdivide a face to the required detail level.

            function subdivide( face, detail ) {

                var cols = Math.pow(2, detail);
                var cells = Math.pow(4, detail);
                var a = prepare( that.vertices[ face.a ] );
                var b = prepare( that.vertices[ face.b ] );
                var c = prepare( that.vertices[ face.c ] );
                var v = [];

                // Construct all of the vertices for this subdivision.

                for ( var i = 0 ; i <= cols; i ++ ) {

                    v[ i ] = [];

                    var aj = prepare( a.clone().lerp( c, i / cols ) );
                    var bj = prepare( b.clone().lerp( c, i / cols ) );
                    var rows = cols - i;

                    for ( var j = 0; j <= rows; j ++) {

                        if ( j == 0 && i == cols ) {

                            v[ i ][ j ] = aj;

                        } else {

                            v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

                        }

                    }

                }

                // Construct all of the faces.

                for ( var i = 0; i < cols ; i ++ ) {

                    for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

                        var k = Math.floor( j / 2 );

                        if ( j % 2 == 0 ) {

                            make(
                                v[ i ][ k + 1],
                                v[ i + 1 ][ k ],
                                v[ i ][ k ]
                            );

                        } else {

                            make(
                                v[ i ][ k + 1 ],
                                v[ i + 1][ k + 1],
                                v[ i + 1 ][ k ]
                            );

                        }

                    }

                }

            }


            // Angle around the Y axis, counter-clockwise when looking from above.

            function azimuth( vector ) {

                return Math.atan2( vector.z, - vector.x );

            }


            // Angle above the XZ plane.

            function inclination( vector ) {

                return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

            }


            // Texture fixing helper. Spheres have some odd behaviours.

            function correctUV( uv, vector, azimuth ) {

                if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
                if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
                return uv.clone();

            }

        };

        THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
    }

    // polyfill
    if (THREE.OctahedronGeometry === undefined) {
        THREE.OctahedronGeometry = function ( radius, detail ) {

            this.parameters = {
                radius: radius,
                detail: detail
            };

            var vertices = [
                1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
            ];

            var indices = [
                0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
            ];

            THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

            this.type = 'OctahedronGeometry';

            this.parameters = {
                radius: radius,
                detail: detail
            };
        };

        THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
    }

    // polyfill
    if (THREE.TorusGeometry === undefined) {
        THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

            THREE.Geometry.call( this );

            this.type = 'TorusGeometry';

            this.parameters = {
                radius: radius,
                tube: tube,
                radialSegments: radialSegments,
                tubularSegments: tubularSegments,
                arc: arc
            };

            radius = radius || 100;
            tube = tube || 40;
            radialSegments = radialSegments || 8;
            tubularSegments = tubularSegments || 6;
            arc = arc || Math.PI * 2;

            var center = new THREE.Vector3(), uvs = [], normals = [];

            for ( var j = 0; j <= radialSegments; j ++ ) {

                for ( var i = 0; i <= tubularSegments; i ++ ) {

                    var u = i / tubularSegments * arc;
                    var v = j / radialSegments * Math.PI * 2;

                    center.x = radius * Math.cos( u );
                    center.y = radius * Math.sin( u );

                    var vertex = new THREE.Vector3();
                    vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
                    vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
                    vertex.z = tube * Math.sin( v );

                    this.vertices.push( vertex );

                    uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
                    normals.push( vertex.clone().sub( center ).normalize() );

                }

            }

            for ( var j = 1; j <= radialSegments; j ++ ) {

                for ( var i = 1; i <= tubularSegments; i ++ ) {

                    var a = ( tubularSegments + 1 ) * j + i - 1;
                    var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
                    var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
                    var d = ( tubularSegments + 1 ) * j + i;

                    var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
                    this.faces.push( face );
                    this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

                    face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
                    this.faces.push( face );
                    this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

                }

            }

            this.computeFaceNormals();

        };

        THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
    }

    var createCircleGeometry = function ( radius, facing, arc ) {

        var geometry = new THREE.Geometry();
        arc = arc ? arc : 1;
        for ( var i = 0; i <= 64 * arc; ++i ) {
            if ( facing == 'x' ) geometry.vertices.push( new THREE.Vector3( 0, Math.cos( i / 32 * Math.PI ), Math.sin( i / 32 * Math.PI ) ).multiplyScalar(radius) );
            if ( facing == 'y' ) geometry.vertices.push( new THREE.Vector3( Math.cos( i / 32 * Math.PI ), 0, Math.sin( i / 32 * Math.PI ) ).multiplyScalar(radius) );
            if ( facing == 'z' ) geometry.vertices.push( new THREE.Vector3( Math.sin( i / 32 * Math.PI ), Math.cos( i / 32 * Math.PI ), 0 ).multiplyScalar(radius) );
        }

        return geometry;
    };

    var createArrowGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

        var arrowGeometry = new THREE.Geometry();
        var mesh = new THREE.Mesh( new THREE.CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) );
        mesh.position.y = 0.5;
        mesh.updateMatrix();

        arrowGeometry.merge( mesh.geometry, mesh.matrix );

        return arrowGeometry;
    };

    var createLineGeometry = function ( axis ) {

        var lineGeometry = new THREE.Geometry();
        if ( axis === 'X') 
            lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 1, 0, 0 ) );
        else if ( axis === 'Y' ) 
            lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );
        else if ( axis === 'Z' )
            lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 1 ) );

        return lineGeometry;
    };

    THREE.TransformGizmo = function () {

        var scope = this;
        var showPickers = false; //debug
        var showActivePlane = false; //debug

        this.init = function () {

            THREE.Object3D.call( this );

            this.handles = new THREE.Object3D();
            this.pickers = new THREE.Object3D();
            this.planes = new THREE.Object3D();
            this.highlights = new THREE.Object3D();
            this.hemiPicker = new THREE.Object3D();
            this.subPickers = new THREE.Object3D();

            this.add(this.handles);
            this.add(this.pickers);
            this.add(this.planes);
            this.add(this.highlights);
            this.add(this.hemiPicker);
            this.add(this.subPickers);

            //// PLANES

            var planeGeometry = new THREE.PlaneBufferGeometry( 50, 50, 2, 2 );
            var planeMaterial = new THREE.MeshBasicMaterial( { wireframe: true } );
            planeMaterial.side = THREE.DoubleSide;

            var planes = {
                "XY":   new THREE.Mesh( planeGeometry, planeMaterial ),
                "YZ":   new THREE.Mesh( planeGeometry, planeMaterial ),
                "XZ":   new THREE.Mesh( planeGeometry, planeMaterial ),
                "XYZE": new THREE.Mesh( planeGeometry, planeMaterial )
            };

            this.activePlane = planes["XYZE"];

            planes["YZ"].rotation.set( 0, Math.PI/2, 0 );
            planes["XZ"].rotation.set( -Math.PI/2, 0, 0 );

            for (var i in planes) {
                planes[i].name = i;
                this.planes.add(planes[i]);
                this.planes[i] = planes[i];
                planes[i].visible = false;
            }

            this.setupGizmos();
            this.activeMode = "";

            // reset Transformations

            this.traverse(function ( child ) {
                if (child instanceof THREE.Mesh) {
                    child.updateMatrix();

                    var tempGeometry = new THREE.Geometry();
                    if (child.geometry instanceof THREE.BufferGeometry) {
                        child.geometry = new THREE.Geometry().fromBufferGeometry( child.geometry );
                    }
                    tempGeometry.merge( child.geometry, child.matrix );

                    child.geometry = tempGeometry;
                    child.position.set( 0, 0, 0 );
                    child.rotation.set( 0, 0, 0 );
                    child.scale.set( 1, 1, 1 );
                }
            });

        };

        this.hide = function () {
            this.traverse(function( child ) {
                child.visible = false;
            });
        };

        this.show = function () {
            this.traverse(function( child ) {
                child.visible = true;
                if (child.parent == scope.pickers || child.parent == scope.hemiPicker ) child.visible = showPickers;
                if (child.parent == scope.planes ) child.visible = false;
            });
            this.activePlane.visible = showActivePlane;
        };

        this.highlight = function ( axis ) {
            this.traverse(function( child ) {
                if ( child.material && child.material.highlight ) {
                    if ( child.name == axis ) {
                        child.material.highlight( true );
                    } else {
                        child.material.highlight( false );
                    }
                }
            });
        };

        this.setupGizmos = function () {

            var addGizmos = function( gizmoMap, parent ) {

                for ( var name in gizmoMap ) {

                    for ( var i = gizmoMap[name].length; i--;) {

                        var object = gizmoMap[name][i][0];
                        var position = gizmoMap[name][i][1];
                        var rotation = gizmoMap[name][i][2];
                        var visble = gizmoMap[name][i][3];

                        object.name = name;

                        if ( position ) object.position.set( position[0], position[1], position[2] );
                        if ( rotation ) object.rotation.set( rotation[0], rotation[1], rotation[2] );
                        if ( visble ) object.visble = visble;

                        parent.add( object );

                    }

                }

            };

            this.setHandlePickerGizmos();

            addGizmos(this.handleGizmos, this.handles);
            addGizmos(this.pickerGizmos, this.pickers);
            addGizmos(this.highlightGizmos, this.highlights);
            addGizmos(this.hemiPickerGizmos, this.hemiPicker);
            addGizmos(this.subPickerGizmos, this.subPickers);

            this.hide();
            this.show();

        };

    };

    THREE.TransformGizmo.prototype = Object.create( THREE.Object3D.prototype );

    THREE.TransformGizmo.prototype.update = function ( rotation, eye ) {

        var vec1 = new THREE.Vector3( 0, 0, 0 );
        var vec2 = new THREE.Vector3( 0, 1, 0 );
        var lookAtMatrix = new THREE.Matrix4();

        this.traverse(function(child) {
            if ( child.name ) {
                if ( child.name.search("E") != -1 ) {
                    child.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( eye, vec1, vec2 ) );
                } else if ( child.name.search("X") != -1 || child.name.search("Y") != -1 || child.name.search("Z") != -1 ) {
                    child.quaternion.setFromEuler( rotation );
                }
            }
        });

    };

    THREE.TransformGizmoTranslate = function () {

        THREE.TransformGizmo.call( this );

        this.setHandlePickerGizmos = function () {

            var arrowGeometry = createArrowGeometry( 0, 0.05, 0.2, 12, 1, false );
            var lineXGeometry = createLineGeometry( 'X' );
            var lineYGeometry = createLineGeometry( 'Y' );
            var lineZGeometry = createLineGeometry( 'Z' );

            this.handleGizmos = {
                X: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xf12c2c } ) ), [ 0.5, 0, 0 ], [ 0, 0, -Math.PI/2 ] ],
                    [ new THREE.Line( lineXGeometry, new GizmoLineMaterial( { color: 0xf12c2c } ) ) ]
                ],
                Y: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x0bb80b } ) ), [ 0, 0.5, 0 ] ],
                    [   new THREE.Line( lineYGeometry, new GizmoLineMaterial( { color: 0x0bb80b } ) ) ]
                ],
                Z: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x2c2cf1 } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ],
                    [ new THREE.Line( lineZGeometry, new GizmoLineMaterial( { color: 0x2c2cf1 } ) ) ]
                ],
                XYZ: [
                    [ new THREE.Mesh( new THREE.OctahedronGeometry( 0.1, 0 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, 0, 0 ] ]
                ],
                XY: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0xffff00, opacity: 0.25 } ) ), [ 0.15, 0.15, 0 ] ]
                ],
                YZ: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ), [ 0, 0.15, 0.15 ], [ 0, Math.PI/2, 0 ] ]
                ],
                XZ: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.29, 0.29 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ), [ 0.15, 0, 0.15 ], [ -Math.PI/2, 0, 0 ] ]
                ]
            };

            this.pickerGizmos = {
                X: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0.6, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]
                ],
                Y: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0.6, 0 ] ]
                ],
                Z: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.6 ], [ Math.PI/2, 0, 0 ] ]
                ],
                XYZ: [
                    [ new THREE.Mesh( new THREE.OctahedronGeometry( 0.2, 0 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]
                ],
                XY: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0xffff00, opacity: 0.25 } ) ), [ 0.2, 0.2, 0 ] ]
                ],
                YZ: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ), [ 0, 0.2, 0.2 ], [ 0, Math.PI/2, 0 ] ]
                ],
                XZ: [
                    [ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ), [ 0.2, 0, 0.2 ], [ -Math.PI/2, 0, 0 ] ]
                ]
            };

            this.hemiPickerGizmos = {
                XYZ: [
                    [ new THREE.Mesh( new THREE.BoxGeometry( 1.2, 1.2, 1.2 ), new GizmoMaterial( { color: 0x0000ff } ) ), [ 0.5, 0.5, 0.5 ], null, false ]
                ]
            };

        };

        this.setActivePlane = function ( axis, eye ) {

            var tempMatrix = new THREE.Matrix4();
            eye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ "XY" ].matrixWorld ) ) );

            if ( axis == "X" ) {
                this.activePlane = this.planes[ "XY" ];
                if ( Math.abs(eye.y) > Math.abs(eye.z) ) this.activePlane = this.planes[ "XZ" ];
            }

            if ( axis == "Y" ){
                this.activePlane = this.planes[ "XY" ];
                if ( Math.abs(eye.x) > Math.abs(eye.z) ) this.activePlane = this.planes[ "YZ" ];
            }

            if ( axis == "Z" ){
                this.activePlane = this.planes[ "XZ" ];
                if ( Math.abs(eye.x) > Math.abs(eye.y) ) this.activePlane = this.planes[ "YZ" ];
            }

            if ( axis == "XYZ" ) this.activePlane = this.planes[ "XYZE" ];

            if ( axis == "XY" ) this.activePlane = this.planes[ "XY" ];

            if ( axis == "YZ" ) this.activePlane = this.planes[ "YZ" ];

            if ( axis == "XZ" ) this.activePlane = this.planes[ "XZ" ];

            this.hide();
            this.show();

        };

        this.init();

    };

    THREE.TransformGizmoTranslate.prototype = Object.create( THREE.TransformGizmo.prototype );

    THREE.TransformGizmoRotate = function () {

        THREE.TransformGizmo.call( this );

        this.setHandlePickerGizmos = function () {

            this.handleGizmos = {
                RX: [
                    [ new THREE.Line( createCircleGeometry(1,'x',0.5), new GizmoLineMaterial( { color: 0xff0000 } ) ) ]
                ],
                RY: [
                    [ new THREE.Line( createCircleGeometry(1,'y',0.5), new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]
                ],
                RZ: [
                    [ new THREE.Line( createCircleGeometry(1,'z',0.5), new GizmoLineMaterial( { color: 0x0000ff } ) ) ]
                ],
                RE: [
                    [ new THREE.Line( createCircleGeometry(1.25,'z',1), new GizmoLineMaterial( { color: 0x00ffff } ) ) ]
                ],
                RXYZE: [
                    [ new THREE.Line( createCircleGeometry(1,'z',1), new GizmoLineMaterial( { color: 0xff00ff } ) ) ]
                ]
            };

            this.pickerGizmos = {
                RX: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, -Math.PI/2, -Math.PI/2 ] ]
                ],
                RY: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, 0 ] ]
                ],
                RZ: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, Math.PI ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]
                ],
                RE: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1.25, 0.12, 2, 24 ), new GizmoMaterial( { color: 0x00ffff, opacity: 0.25 } ) ) ]
                ],
                RXYZE: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 2, 24 ), new GizmoMaterial( { color: 0xff00ff, opacity: 0.25 } ) ) ]
                ]
            };

        };

        this.setActivePlane = function ( axis ) {

            if ( axis == "RE" ) this.activePlane = this.planes[ "XYZE" ];

            if ( axis == "RX" ) this.activePlane = this.planes[ "YZ" ];

            if ( axis == "RY" ) this.activePlane = this.planes[ "XZ" ];

            if ( axis == "RZ" ) this.activePlane = this.planes[ "XY" ];

            this.hide();
            this.show();

        };

        this.update = function ( rotation, eye2 ) {

            THREE.TransformGizmo.prototype.update.apply( this, arguments );

            var tempMatrix = new THREE.Matrix4();
            var worldRotation = new THREE.Euler( 0, 0, 1 );
            var tempQuaternion = new THREE.Quaternion();
            var unitX = new THREE.Vector3( 1, 0, 0 );
            var unitY = new THREE.Vector3( 0, 1, 0 );
            var unitZ = new THREE.Vector3( 0, 0, 1 );
            var quaternionX = new THREE.Quaternion();
            var quaternionY = new THREE.Quaternion();
            var quaternionZ = new THREE.Quaternion();
            var eye = eye2.clone();

            worldRotation.copy( this.planes["XY"].rotation );
            tempQuaternion.setFromEuler( worldRotation );

            tempMatrix.makeRotationFromQuaternion( tempQuaternion ).getInverse( tempMatrix );
            eye.applyMatrix4( tempMatrix );

            this.traverse(function(child) {

                tempQuaternion.setFromEuler( worldRotation );

                if ( child.name == "RX" ) {
                    quaternionX.setFromAxisAngle( unitX, Math.atan2( -eye.y, eye.z ) );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
                    child.quaternion.copy( tempQuaternion );
                }

                if ( child.name == "RY" ) {
                    quaternionY.setFromAxisAngle( unitY, Math.atan2( eye.x, eye.z ) );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );
                    child.quaternion.copy( tempQuaternion );
                }

                if ( child.name == "RZ" ) {
                    quaternionZ.setFromAxisAngle( unitZ, Math.atan2( eye.y, eye.x ) );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );
                    child.quaternion.copy( tempQuaternion );
                }

            });

        };

        this.init();

    };

    THREE.TransformGizmoRotate.prototype = Object.create( THREE.TransformGizmo.prototype );

    THREE.TransformGizmoTranslateRotate = function () {

        THREE.TransformGizmo.call( this );

        var scope = this;

        this.setHandlePickerGizmos = function () {

            var arrowGeometry = createArrowGeometry( 0, 0.05, 0.2, 12, 1, false );
            var lineGeometry = new THREE.Geometry();
            lineGeometry.vertices.push( new THREE.Vector3( 0, 0, -0.1 ), new THREE.Vector3( 0, 0, 0.1 ), new THREE.Vector3( -0.1, 0, 0 ), new THREE.Vector3( 0.1, 0, 0 ) );
            var theta = 0.15;

            this.handleGizmos = {
                Z: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xffffff } ) ), [ 0, 0, 0.25 ], [ Math.PI/2, 0, 0 ] ],
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.015, 0.015, 0.6, 4, 1, false ), new GizmoMaterial( { color: 0xffffff } ) ), [ 0, 0, 0.5 ],[ Math.PI/2, 0, 0 ] ]
                ],
                RX: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.015, 12, 60, theta * 2 * Math.PI ), new GizmoMaterial( { color: 0xff0000 } ) ), [ 0, 0, 0 ], [ theta * Math.PI, -Math.PI/2, 0 ] ],
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.05, 0.05, 0.015, 60, 1, false ), new GizmoMaterial( { color: 0xff0000 } ) ), [ 0, 0, 1 ], [ Math.PI/2, 0, 0 ] ]
                ],
                RY: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.015, 12, 60, theta * 2 * Math.PI ), new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, (0.5-theta)*Math.PI ] ],
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.05, 0.05, 0.01, 60, 1, false ), new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 1 ] ]
                ]
            };

            this.pickerGizmos = {
                Z: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.12, 0.12, 0.65, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ]
                ],
                RX: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, theta * 2 * Math.PI ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ theta * Math.PI, -Math.PI/2, 0 ] ]
                ],
                RY: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.12, 4, 12, theta * 2 * Math.PI ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, (0.5-theta)*Math.PI ] ]
                ]
            };

            this.subPickerGizmos = {
                Z: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.12, 0.12, 0.65, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ]
                ]
            };

            this.highlightGizmos = {
                Z: [
                ],
                RX: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.02, 12, 60, 2 * Math.PI ), new GizmoMaterial( { color: 0xff0000, opacity: 1 } ) ), [ 0, 0, 0 ], [ 0, -Math.PI/2, -Math.PI/2 ], false ]
                ],
                RY: [
                    [ new THREE.Mesh( new THREE.TorusGeometry( 1, 0.02, 12, 60, 2 * Math.PI ), new GizmoMaterial( { color: 0x0000ff, opacity: 1 } ) ), [ 0, 0, 0 ], [ Math.PI/2, 0, 0 ], false ]
                ]
            };

            this.hemiPickerGizmos = {
                XYZ: [
                    [ new THREE.Mesh( new THREE.SphereGeometry( 1.2, 8, 8, 0, Math.PI ), new GizmoMaterial( { color: 0x0000ff } ) ), null, null, false ]
                ]
            };

        };

        this.setActivePlane = function ( axis, eye ) {

            if ( this.activeMode == "translate" ) {

                var tempMatrix = new THREE.Matrix4();
                eye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ "XY" ].matrixWorld ) ) );

                if ( axis == "X" ) {
                    this.activePlane = this.planes[ "XY" ];
                    if ( Math.abs(eye.y) > Math.abs(eye.z) ) this.activePlane = this.planes[ "XZ" ];
                }

                if ( axis == "Y" ){
                    this.activePlane = this.planes[ "XY" ];
                    if ( Math.abs(eye.x) > Math.abs(eye.z) ) this.activePlane = this.planes[ "YZ" ];
                }

                if ( axis == "Z" ){
                    this.activePlane = this.planes[ "XZ" ];
                    if ( Math.abs(eye.x) > Math.abs(eye.y) ) this.activePlane = this.planes[ "YZ" ];
                }

            } else if ( this.activeMode == "rotate" ){

                if ( axis == "RX" ) this.activePlane = this.planes[ "YZ" ];

                if ( axis == "RY" ) this.activePlane = this.planes[ "XZ" ];

                if ( axis == "RZ" ) this.activePlane = this.planes[ "XY" ];

            }

            this.hide();
            this.show();

        };

        this.update = function ( rotation, eye2 ) {

            if ( this.activeMode == "translate" ) {

                THREE.TransformGizmo.prototype.update.apply( this, arguments );

            } else if ( this.activeMode == "rotate" ) {

                THREE.TransformGizmo.prototype.update.apply( this, arguments );

                var tempMatrix = new THREE.Matrix4();
                var worldRotation = new THREE.Euler( 0, 0, 1 );
                var tempQuaternion = new THREE.Quaternion();
                var unitX = new THREE.Vector3( 1, 0, 0 );
                var unitY = new THREE.Vector3( 0, 1, 0 );
                var unitZ = new THREE.Vector3( 0, 0, 1 );
                var quaternionX = new THREE.Quaternion();
                var quaternionY = new THREE.Quaternion();
                var quaternionZ = new THREE.Quaternion();
                var eye = eye2.clone();

                worldRotation.copy( this.planes["XY"].rotation );
                tempQuaternion.setFromEuler( worldRotation );

                tempMatrix.makeRotationFromQuaternion( tempQuaternion ).getInverse( tempMatrix );
                eye.applyMatrix4( tempMatrix );

                this.traverse(function(child) {

                    tempQuaternion.setFromEuler( worldRotation );

                    if ( child.name == "RX" ) {
                        quaternionX.setFromAxisAngle( unitX, Math.atan2( -eye.y, eye.z ) );
                        tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
                        child.quaternion.copy( tempQuaternion );
                    }

                    if ( child.name == "RY" ) {
                        quaternionY.setFromAxisAngle( unitY, Math.atan2( eye.x, eye.z ) );
                        tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );
                        child.quaternion.copy( tempQuaternion );
                    }

                    if ( child.name == "RZ" ) {
                        quaternionZ.setFromAxisAngle( unitZ, Math.atan2( eye.y, eye.x ) );
                        tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );
                        child.quaternion.copy( tempQuaternion );
                    }

                });

            }

        };

        this.show = function () {
            this.traverse(function( child ) {
                if ( scope.parent == null || (scope.parent.useAllPickers || child.parent != scope.handles) ) child.visible = true;
                if ( child.material ) child.material.opacity = child.material.oldOpacity;
                if ( child.parent == scope.pickers || child.parent == scope.hemiPicker || child.parent == scope.subPickers) child.visible = false;
                if ( child.parent == scope.planes || child.parent == scope.highlights ) child.visible = false;
            });
            this.activePlane.visible = false;
        };

        this.highlight = function ( axis ) {
            this.traverse(function( child ) {
                if ( child.material && child.material.highlight ) {
                    if ( child.name == axis ) {
                        if ( child.parent == scope.highlights || child.parent == scope.handles ) child.visible = true;
                        child.material.highlight( true );
                    } else {
                        child.material.highlight( false );
                        child.material.opacity = 0.1;
                    }
                }
            });
        };

        this.init();

    };

    THREE.TransformGizmoTranslateRotate.prototype = Object.create( THREE.TransformGizmo.prototype );

    THREE.TransformGizmoScale = function () {

        THREE.TransformGizmo.call( this );

        this.setHandlePickerGizmos = function () {

            var arrowGeometry = createArrowGeometry( 0.125, 0.125, 0.125 );
            var lineXGeometry = createLineGeometry( 'X' );
            var lineYGeometry = createLineGeometry( 'Y' );
            var lineZGeometry = createLineGeometry( 'Z' );

            this.handleGizmos = {
                X: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0xff0000 } ) ), [ 0.5, 0, 0 ], [ 0, 0, -Math.PI/2 ] ],
                    [ new THREE.Line( lineXGeometry, new GizmoLineMaterial( { color: 0xff0000 } ) ) ]
                ],
                Y: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x00ff00 } ) ), [ 0, 0.5, 0 ] ],
                    [ new THREE.Line( lineYGeometry, new GizmoLineMaterial( { color: 0x00ff00 } ) ) ]
                ],
                Z: [
                    [ new THREE.Mesh( arrowGeometry, new GizmoMaterial( { color: 0x0000ff } ) ), [ 0, 0, 0.5 ], [ Math.PI/2, 0, 0 ] ],
                    [ new THREE.Line( lineZGeometry, new GizmoLineMaterial( { color: 0x0000ff } ) ) ]
                ],
                XYZ: [
                    [ new THREE.Mesh( new THREE.BoxGeometry( 0.125, 0.125, 0.125 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]
                ]
            };

            this.pickerGizmos = {
                X: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0xff0000, opacity: 0.25 } ) ), [ 0.6, 0, 0 ], [ 0, 0, -Math.PI/2 ] ]
                ],
                Y: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x00ff00, opacity: 0.25 } ) ), [ 0, 0.6, 0 ] ]
                ],
                Z: [
                    [ new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0, 1, 4, 1, false ), new GizmoMaterial( { color: 0x0000ff, opacity: 0.25 } ) ), [ 0, 0, 0.6 ], [ Math.PI/2, 0, 0 ] ]
                ],
                XYZ: [
                    [ new THREE.Mesh( new THREE.BoxGeometry( 0.4, 0.4, 0.4 ), new GizmoMaterial( { color: 0xffffff, opacity: 0.25 } ) ) ]
                ]
            };

        };

        this.setActivePlane = function ( axis, eye ) {

            var tempMatrix = new THREE.Matrix4();
            eye.applyMatrix4( tempMatrix.getInverse( tempMatrix.extractRotation( this.planes[ "XY" ].matrixWorld ) ) );

            if ( axis == "X" ) {
                this.activePlane = this.planes[ "XY" ];
                if ( Math.abs(eye.y) > Math.abs(eye.z) ) this.activePlane = this.planes[ "XZ" ];
            }

            if ( axis == "Y" ){
                this.activePlane = this.planes[ "XY" ];
                if ( Math.abs(eye.x) > Math.abs(eye.z) ) this.activePlane = this.planes[ "YZ" ];
            }

            if ( axis == "Z" ){
                this.activePlane = this.planes[ "XZ" ];
                if ( Math.abs(eye.x) > Math.abs(eye.y) ) this.activePlane = this.planes[ "YZ" ];
            }

            if ( axis == "XYZ" ) this.activePlane = this.planes[ "XYZE" ];

            this.hide();
            this.show();

        };

        this.init();

    };

    THREE.TransformGizmoScale.prototype = Object.create( THREE.TransformGizmo.prototype );

    THREE.TransformControls = function ( camera, domElement, mode ) {

        // TODO: Make non-uniform scale and rotate play nice in hierarchies
        // TODO: ADD RXYZ contol

        THREE.Object3D.call( this );

        domElement = ( domElement !== undefined ) ? domElement : document;

        this.gizmo = {};
        switch ( mode ) {
            case "translate":
                this.gizmo[mode] = new THREE.TransformGizmoTranslate();
                break;
            case "rotate":           
               this.gizmo[mode] = new THREE.TransformGizmoRotate();
               break;
            case "transrotate":
                this.gizmo[mode] = new THREE.TransformGizmoTranslateRotate();
                break;
            case "scale":
                this.gizmo[mode] = new THREE.TransformGizmoScale();
                break;
        }

        this.add(this.gizmo[mode]);
        this.gizmo[mode].hide();

        this.object = undefined;
        this.snap = null;
        this.snapDelta = 0;
        this.space = "world";
        this.size = 1;
        this.axis = null;
        this.useAllPickers = true;

        this.unitX = new THREE.Vector3( 1, 0, 0 );
        this.unitY = new THREE.Vector3( 0, 1, 0 );
        this.unitZ = new THREE.Vector3( 0, 0, 1 );
        this.normal = new THREE.Vector3(0, 0, 1);

        if ( mode === "transrotate" ) {
            var geometry = new THREE.Geometry();
            geometry.vertices.push( new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1) );
            var material = new THREE.LineBasicMaterial( {color: 0x000000, linewidth:2, depthTest: false} );
            this.startLine = new THREE.Line( geometry, material );
            var geometry = new THREE.Geometry();
            var material = new THREE.LineBasicMaterial( {color: 0xffe603, linewidth:2, depthTest: false} );
            geometry.vertices.push( new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1) );
            this.endLine = new THREE.Line( geometry, material );
            var geometry = new THREE.Geometry();
            var material = new THREE.LineDashedMaterial({color: 0x000000, linewidth:1, depthTest: false});
            geometry.vertices.push( new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 1, 0) );
            this.centerLine = new THREE.Line( geometry, material );

            var map = THREE.ImageUtils.loadTexture(Autodesk.Viewing.Private.getResourceUrl("res/textures/centerMarker_X.png"));
            map.magFilter = map.minFilter = THREE.NearestFilter;
            var geometry = new THREE.CircleGeometry( 0.1, 32 );
            var material = new THREE.MeshBasicMaterial({opacity: 1, side: THREE.DoubleSide, transparent:true, map:map});
            this.centerMark = new THREE.Mesh( geometry, material );
            this.centerMark.rotation.set(Math.PI/2, 0, 0);

            this.ticks = {};
            var map = THREE.ImageUtils.loadTexture(Autodesk.Viewing.Private.getResourceUrl("res/textures/cardinalPoint.png"));
            map.magFilter = map.minFilter = THREE.NearestFilter;
            var material = new THREE.MeshBasicMaterial({depthTest: false, opacity: 1, transparent:true, side: THREE.DoubleSide, map:map});
            var w = 0.12, h = 0.25, d = 1.15;

            this.ticks["RX"] = new THREE.Object3D();
            var geometry = new THREE.PlaneBufferGeometry(w, h);
            var mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 0, -d-h/2);
            mesh.rotation.set(Math.PI/2, Math.PI/2, 0);
            this.ticks["RX"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(0, d+h/2, 0);
            mesh.rotation.set(0, Math.PI/2, 0);
            this.ticks["RX"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(0, 0, d+h/2);
            mesh.rotation.set(0, Math.PI/2, Math.PI/2);
            this.ticks["RX"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(0, -d-h/2, 0);
            mesh.rotation.set(0, Math.PI/2, 0);
            this.ticks["RX"].add(mesh);

            this.ticks["RY"] = new THREE.Object3D();
            mesh = mesh.clone();
            mesh.position.set(0, 0, -d-h/2);
            mesh.rotation.set(Math.PI/2, 0, 0);
            this.ticks["RY"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(-d-h/2, 0, 0);
            mesh.rotation.set(Math.PI/2, 0, Math.PI/2);
            this.ticks["RY"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(0, 0, d+h/2);
            mesh.rotation.set(Math.PI/2, 0, 0);
            this.ticks["RY"].add(mesh);

            mesh = mesh.clone();
            mesh.position.set(d+h/2, 0, 0);
            mesh.rotation.set(Math.PI/2, 0, Math.PI/2);
            this.ticks["RY"].add(mesh);
        }

        var scope = this;

        var _dragging = false;
        var _mode = mode;
        var _plane = "XY";

        var changeEvent = { type: "change" };
        var mouseDownEvent = { type: "mouseDown" };
        var mouseUpEvent = { type: "mouseUp", mode: _mode };
        var objectChangeEvent = { type: "objectChange" };

        var ray = new THREE.Raycaster();
        var pointerVector = new THREE.Vector3();
        var pointerDir = new THREE.Vector3();

        var point = new THREE.Vector3();
        var offset = new THREE.Vector3();

        var rotation = new THREE.Vector3();
        var offsetRotation = new THREE.Vector3();
        var scale = 1;

        var lookAtMatrix = new THREE.Matrix4();
        var eye = new THREE.Vector3();

        var tempMatrix = new THREE.Matrix4();
        var tempVector = new THREE.Vector3();
        var tempQuaternion = new THREE.Quaternion();
        var projX = new THREE.Vector3();
        var projY = new THREE.Vector3();
        var projZ = new THREE.Vector3();

        var quaternionXYZ = new THREE.Quaternion();
        var quaternionX = new THREE.Quaternion();
        var quaternionY = new THREE.Quaternion();
        var quaternionZ = new THREE.Quaternion();
        var quaternionE = new THREE.Quaternion();

        var oldPosition = new THREE.Vector3();
        var oldScale = new THREE.Vector3();
        var oldRotationMatrix = new THREE.Matrix4();

        var parentRotationMatrix  = new THREE.Matrix4();
        var parentScale = new THREE.Vector3();

        var worldPosition = new THREE.Vector3();
        var worldRotation = new THREE.Euler();
        var worldRotationMatrix  = new THREE.Matrix4();
        var camPosition = new THREE.Vector3();
        var camRotation = new THREE.Euler();

        this.attach = function ( object ) {

            scope.object = object;

            this.gizmo[_mode].show();

            scope.update();

            scope.updateUnitVectors();

        };

        this.detach = function ( object ) {

            scope.object = undefined;
            this.axis = null;

            this.gizmo[_mode].hide();

        };

        this.setMode = function ( mode ) {

            _mode = mode ? mode : _mode;

            if ( _mode == "scale" ) scope.space = "local";

            this.gizmo[_mode].show();

            this.update();
            scope.dispatchEvent( changeEvent );

        };

        this.getPicker = function () {

            return scope.gizmo[_mode].hemiPicker.children;

        };

        this.setPosition = function ( position ) {

            this.object.position.copy ( position );
            this.update();
        
        };

        this.setNormal = function ( normal ) {

            tempQuaternion.setFromUnitVectors( this.normal, normal );
            this.unitX.applyQuaternion( tempQuaternion );
            this.unitY.applyQuaternion( tempQuaternion );
            this.unitZ.applyQuaternion( tempQuaternion );
            this.normal.copy( normal );
            if (this.object) {
                this.object.quaternion.multiply ( tempQuaternion );
            }
            this.update();
        };

        this.setSnap = function ( snap, delta ) {

            scope.snap = snap;
            scope.snapDelta = delta;

        };

        this.setSize = function ( size ) {

            scope.size = size;
            this.update();
            scope.dispatchEvent( changeEvent );

        };

        this.setSpace = function ( space ) {

            scope.space = space;
            this.update();
            scope.dispatchEvent( changeEvent );

        };

        this.update = function (highlight) {

            if ( scope.object === undefined ) return;

            scope.object.updateMatrixWorld();
            worldPosition.setFromMatrixPosition( scope.object.matrixWorld );
            worldRotation.setFromRotationMatrix( tempMatrix.extractRotation( scope.object.matrixWorld ) );

            camera.updateMatrixWorld();
            camPosition.setFromMatrixPosition( camera.matrixWorld );
            //camRotation.setFromRotationMatrix( tempMatrix.extractRotation( camera.matrixWorld ) );

            this.position.copy( worldPosition );

            this.quaternion.setFromEuler( worldRotation );

            this.normal.set( 0, 0, 1 );
            this.normal.applyEuler( worldRotation );

            // keep same screen height (100px)
            var dist = worldPosition.distanceTo( camPosition );
            var height = camera.isPerspective? 2 * Math.tan( camera.fov * Math.PI / 360 ) * dist : dist;
            var rect = domElement.getBoundingClientRect();
            scale = 100 * height / rect.height;
            this.scale.set( scale, scale, scale );

            //eye.copy( camPosition ).sub( worldPosition ).normalize();

            //if ( scope.space == "local" )
            //    this.gizmo[_mode].update( worldRotation, eye );
            //else if ( scope.space == "world" )
            //    this.gizmo[_mode].update( new THREE.Euler(), eye );

            if (highlight)
                this.gizmo[_mode].highlight( scope.axis );

        };

        this.updateUnitVectors = function () {

            this.unitX.set( 1, 0, 0 );
            this.unitY.set( 0, 1, 0 );
            this.unitZ.set( 0, 0, 1 );
            this.unitX.applyEuler( worldRotation );
            this.unitY.applyEuler( worldRotation );
            this.unitZ.applyEuler( worldRotation );

        };

        this.showRotationGizmos = function (set) {

            var handles = this.gizmo[_mode].handles.children;
            for ( var i = 0; i < handles.length; i++ ) {
                var child = handles[i];
                child.visible = true;
                if ( child.name.search("R") !== -1 ) child.visible = set;
            }
            this.useAllPickers = set;
            
        };

        this.highlight = function () {

            this.gizmo[_mode].highlight( this.axis || "Z" );

        };

        this.onPointerHover = function( event ) {

            if ( scope.object === undefined || _dragging === true ) return false;

            var pointer = event.pointers ? event.pointers[ 0 ] : event;

            var intersect = intersectObjects( pointer, scope.useAllPickers? scope.gizmo[_mode].pickers.children: scope.gizmo[_mode].subPickers.children );

            var axis = null;
            var mode = "";

            if ( intersect ) {

                axis = intersect.object.name;
                mode = axis.search("R") != -1 ? "rotate" : "translate";

            }

            if ( scope.axis !== axis ) {

                scope.axis = axis;
                scope.gizmo[_mode].activeMode = mode;
                scope.update(true);
                scope.dispatchEvent( changeEvent );

            } 

            if (scope.axis === null) {

                scope.gizmo[_mode].show();
            
            }

            return intersect? true : false;

        }

        this.onPointerDown = function( event ) {

            if ( scope.object === undefined || _dragging === true ) return false;
            
            var pointer = event.pointers ? event.pointers[ 0 ] : event;

            if ( event.pointerType === 'touch' ) {

                var intersect = intersectObjects( pointer, scope.useAllPickers? scope.gizmo[_mode].pickers.children: scope.gizmo[_mode].subPickers.children );

                var axis = null;
                var mode = "";

                if ( intersect ) {

                    axis = intersect.object.name;
                    mode = axis.search("R") != -1 ? "rotate" : "translate";

                }

                if ( scope.axis !== axis ) {

                    scope.axis = axis;
                    scope.gizmo[_mode].activeMode = mode;
                }
            }

            var intersect = null;

            if ( pointer.button === 0 || pointer.button === undefined ) {

                intersect = intersectObjects( pointer, scope.useAllPickers? scope.gizmo[_mode].pickers.children: scope.gizmo[_mode].subPickers.children );

                if ( intersect ) {

                    scope.dispatchEvent( mouseDownEvent );

                    scope.axis = intersect.object.name;

                    scope.update();

                    eye.copy( camera.position ).sub( worldPosition ).normalize();

                    scope.gizmo[_mode].setActivePlane( scope.axis, eye );

                    var planeIntersect = intersectObjects( pointer, [scope.gizmo[_mode].activePlane] );

                    if ( planeIntersect )
                        offset.copy( planeIntersect.point );

                    oldPosition.copy( scope.object.position );
                    oldScale.copy( scope.object.scale );

                    oldRotationMatrix.extractRotation( scope.object.matrix );
                    worldRotationMatrix.extractRotation( scope.object.matrixWorld );

                    if ( scope.object.parent ) {
                        parentRotationMatrix.extractRotation( scope.object.parent.matrixWorld );
                        parentScale.setFromMatrixScale( tempMatrix.getInverse( scope.object.parent.matrixWorld ) );
                    } else {
                        parentRotationMatrix.extractRotation( scope.object.matrixWorld );
                        parentScale.setFromMatrixScale( tempMatrix.getInverse( scope.object.matrixWorld ) );
                    }

                    // show rotation start line and ticks
                    if ( _mode === "transrotate" && scope.gizmo[_mode].activeMode === "rotate" ) {
                        scope.startLine.geometry.vertices[0].set(0, 0, 0).applyMatrix4( scope.matrixWorld );
                        scope.startLine.geometry.vertices[1].set(0, 0, 1).applyMatrix4( scope.matrixWorld );
                        scope.startLine.geometry.verticesNeedUpdate = true;
                        scope.parent.add( scope.startLine );

                        var pos = scope.object.geometry.getAttribute('position');
                        var pt1 = new THREE.Vector3().fromAttribute(pos, 0).applyMatrix4( scope.object.matrixWorld );
                        var pt2 = new THREE.Vector3().fromAttribute(pos, 1).applyMatrix4( scope.object.matrixWorld );
                        var pt3 = new THREE.Vector3().fromAttribute(pos, 2).applyMatrix4( scope.object.matrixWorld );
                        var pt4 = new THREE.Vector3().fromAttribute(pos, 3).applyMatrix4( scope.object.matrixWorld );
                        if (scope.axis === "RX") {
                            pt1.lerp(pt3, 0.5);
                            pt2.lerp(pt4, 0.5);
                            var dist = pt1.distanceTo(pt2);
                            scope.centerLine.material.dashSize = dist / 15;
                            scope.centerLine.material.gapSize = dist / 30;
                            scope.centerLine.geometry.vertices[0].copy(pt1);
                            scope.centerLine.geometry.vertices[1].copy(pt2);
                        } else {
                            pt1.lerp(pt2, 0.5);
                            pt3.lerp(pt4, 0.5);
                            var dist = pt1.distanceTo(pt3);
                            scope.centerLine.material.dashSize = dist / 15;
                            scope.centerLine.material.gapSize = dist / 30;
                            scope.centerLine.geometry.vertices[0].copy(pt1);
                            scope.centerLine.geometry.vertices[1].copy(pt3);
                        }
                        scope.centerLine.geometry.computeLineDistances();
                        scope.centerLine.geometry.verticesNeedUpdate = true;
                        scope.parent.add( scope.centerLine );

                        scope.ticks[scope.axis].position.copy( scope.position );
                        scope.ticks[scope.axis].quaternion.copy( scope.quaternion );
                        scope.ticks[scope.axis].scale.copy( scope.scale );
                        scope.parent.add( scope.ticks[scope.axis] );
                    }

                }

            }

            _dragging = true;

            return intersect? true: false;

        }

        this.onPointerMove = function( event ) {

            if ( scope.object === undefined || scope.axis === null || _dragging === false ) return false;

            var pointer = event.pointers ? event.pointers[ 0 ] : event;

            var planeIntersect = intersectObjects( pointer, [scope.gizmo[_mode].activePlane] );

            if ( planeIntersect )
                point.copy( planeIntersect.point );

            var mode = scope.gizmo[_mode].activeMode;
            if ( mode == "translate" ) {

                point.sub( offset );
                point.multiply(parentScale);

                if ( scope.space == "local" ) {

                    point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

                    projX.copy( this.unitX );
                    projY.copy( this.unitY );
                    projZ.copy( this.unitZ );
                    tempVector.set( 0, 0, 0 );
                    if ( scope.axis.search("X") != -1 ) {
                        projX.multiplyScalar( point.dot( this.unitX ) );
                        tempVector.add( projX );
                    }
                    if ( scope.axis.search("Y") != -1 ) {
                        projY.multiplyScalar( point.dot( this.unitY ) );
                        tempVector.add(projY);
                    }
                    if ( scope.axis.search("Z") != -1 ) {
                        projZ.multiplyScalar( point.dot( this.unitZ ) );
                        tempVector.add( projZ );
                    }
                    point.copy( tempVector );

                    point.applyMatrix4( oldRotationMatrix );

                    scope.object.position.copy( oldPosition );
                    scope.object.position.add( point );

                }

                if ( scope.space == "world" || scope.axis.search("XYZ") != -1 ) {

                    projX.copy( this.unitX );
                    projY.copy( this.unitY );
                    projZ.copy( this.unitZ );
                    tempVector.set( 0, 0, 0 );
                    if ( scope.axis.search("X") != -1 ) {
                        projX.multiplyScalar( point.dot( this.unitX ) );
                        tempVector.add( projX );
                    }
                    if ( scope.axis.search("Y") != -1 ) {
                        projY.multiplyScalar( point.dot( this.unitY ) );
                        tempVector.add(projY);
                    }
                    if ( scope.axis.search("Z") != -1 ) {
                        projZ.multiplyScalar( point.dot( this.unitZ ) );
                        tempVector.add( projZ );
                    }
                    point.copy( tempVector );

                    point.applyMatrix4( tempMatrix.getInverse( parentRotationMatrix ) );

                    scope.object.position.copy( oldPosition );
                    scope.object.position.add( point );

                }

            } else if ( mode == "scale" ) {

                point.sub( offset );
                point.multiply(parentScale);

                if ( scope.space == "local" ) {

                    if ( scope.axis == "XYZ") {

                        scale = 1 + ( ( point.y ) / 50 );

                        scope.object.scale.x = oldScale.x * scale;
                        scope.object.scale.y = oldScale.y * scale;
                        scope.object.scale.z = oldScale.z * scale;

                    } else {

                        point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

                        if ( scope.axis == "X" ) scope.object.scale.x = oldScale.x * ( 1 + point.x / 50 );
                        if ( scope.axis == "Y" ) scope.object.scale.y = oldScale.y * ( 1 + point.y / 50 );
                        if ( scope.axis == "Z" ) scope.object.scale.z = oldScale.z * ( 1 + point.z / 50 );

                    }

                }

            } else if ( mode == "rotate") {

                point.sub( worldPosition );
                point.multiply(parentScale);
                tempVector.copy(offset).sub( worldPosition );
                tempVector.multiply(parentScale);

                if ( scope.axis == "RE" ) {

                    point.applyMatrix4( tempMatrix.getInverse( lookAtMatrix ) );
                    tempVector.applyMatrix4( tempMatrix.getInverse( lookAtMatrix ) );

                    rotation.set( Math.atan2( point.z, point.y ), Math.atan2( point.x, point.z ), Math.atan2( point.y, point.x ) );
                    offsetRotation.set( Math.atan2( tempVector.z, tempVector.y ), Math.atan2( tempVector.x, tempVector.z ), Math.atan2( tempVector.y, tempVector.x ) );

                    tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );

                    var rotz = rotation.z - offsetRotation.z;
                    if ( scope.snap !== null ) {
                        var rotsnap = Math.round( rotz / scope.snap ) * scope.snap;
                        if ( Math.abs(rotsnap-rotz) < scope.snapDelta ) {
                            rotz = rotsnap;
                        }
                    }
                    quaternionE.setFromAxisAngle( eye, rotz );
                    quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionE );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

                    scope.object.quaternion.copy( tempQuaternion );

                } else if ( scope.axis == "RXYZE" ) {

                    var tempAxis = point.clone().cross(tempVector).normalize(); // rotation axis

                    tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );

                    var rot = - point.clone().angleTo(tempVector);
                    if ( scope.snap !== null ) {
                        var rotsnap = Math.round( rot / scope.snap ) * scope.snap;
                        if ( Math.abs(rotsnap-rot) < scope.snapDelta ) {
                            rot = rotsnap;
                        }
                    }
                    quaternionX.setFromAxisAngle( tempAxis, rot );
                    quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

                    scope.object.quaternion.copy( tempQuaternion );

                } else if ( scope.space == "local" ) {

                    point.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

                    tempVector.applyMatrix4( tempMatrix.getInverse( worldRotationMatrix ) );

                    var projx = point.dot(this.unitX), projy = point.dot(this.unitY), projz = point.dot(this.unitZ);
                    var tempx = tempVector.dot(this.unitX), tempy = tempVector.dot(this.unitY), tempz = tempVector.dot(this.unitZ);
                    rotation.set( Math.atan2( projz, projy ), Math.atan2( projx, projz ), Math.atan2( projy, projx ) );
                    offsetRotation.set( Math.atan2( tempz, tempy ), Math.atan2( tempx, tempz ), Math.atan2( tempy, tempx ) );

                    var rotx = rotation.x - offsetRotation.x;
                    var roty = rotation.y - offsetRotation.y;
                    var rotz = rotation.z - offsetRotation.z;
                    if ( scope.snap !== null ) {
                        if ( scope.axis.search("X") != -1 ) {
                            var rotsnap = Math.round( rotx / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-rotx) < scope.snapDelta ) {
                                rotx = rotsnap;
                            }
                        }
                        if ( scope.axis.search("Y") != -1 ) {
                            var rotsnap = Math.round( roty / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-roty) < scope.snapDelta ) {
                                roty = rotsnap;
                            }
                        }
                        if ( scope.axis.search("Z") != -1 ) {
                            var rotsnap = Math.round( rotz / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-rotz) < scope.snapDelta ) {
                                rotz = rotsnap;
                            }
                        }
                    }
                    quaternionX.setFromAxisAngle( this.unitX, rotx );
                    quaternionY.setFromAxisAngle( this.unitY, roty );
                    quaternionZ.setFromAxisAngle( this.unitZ, rotz );
                    quaternionXYZ.setFromRotationMatrix( oldRotationMatrix );

                    if ( scope.axis == "RX" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionX );
                    if ( scope.axis == "RY" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionY );
                    if ( scope.axis == "RZ" ) quaternionXYZ.multiplyQuaternions( quaternionXYZ, quaternionZ );

                    scope.object.quaternion.copy( quaternionXYZ );

                } else if ( scope.space == "world" ) {

                    var projx = point.dot(this.unitX), projy = point.dot(this.unitY), projz = point.dot(this.unitZ);
                    var tempx = tempVector.dot(this.unitX), tempy = tempVector.dot(this.unitY), tempz = tempVector.dot(this.unitZ);
                    rotation.set( Math.atan2( projz, projy ), Math.atan2( projx, projz ), Math.atan2( projy, projx ) );
                    offsetRotation.set( Math.atan2( tempz, tempy ), Math.atan2( tempx, tempz ), Math.atan2( tempy, tempx ) );

                    tempQuaternion.setFromRotationMatrix( tempMatrix.getInverse( parentRotationMatrix ) );

                    var rotx = rotation.x - offsetRotation.x;
                    var roty = rotation.y - offsetRotation.y;
                    var rotz = rotation.z - offsetRotation.z;
                    if ( scope.snap !== null ) {
                        if ( scope.axis.search("X") != -1 ) {
                            var rotsnap = Math.round( rotx / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-rotx) < scope.snapDelta ) {
                                rotx = rotsnap;
                            }
                        }
                        if ( scope.axis.search("Y") != -1 ) {
                            var rotsnap = Math.round( roty / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-roty) < scope.snapDelta ) {
                                roty = rotsnap;
                            }
                        }
                        if ( scope.axis.search("Z") != -1 ) {
                            var rotsnap = Math.round( rotz / scope.snap ) * scope.snap;
                            if ( Math.abs(rotsnap-rotz) < scope.snapDelta ) {
                                rotz = rotsnap;
                            }
                        }
                    }
                    quaternionX.setFromAxisAngle( this.unitX, rotx );
                    quaternionY.setFromAxisAngle( this.unitY, roty );
                    quaternionZ.setFromAxisAngle( this.unitZ, rotz );
                    quaternionXYZ.setFromRotationMatrix( worldRotationMatrix );

                    if ( scope.axis == "RX" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionX );
                    if ( scope.axis == "RY" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionY );
                    if ( scope.axis == "RZ" ) tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionZ );

                    tempQuaternion.multiplyQuaternions( tempQuaternion, quaternionXYZ );

                    scope.object.quaternion.copy( tempQuaternion );

                }

                // show rotation end line
                if (_mode === "transrotate" ) {
                    scope.add( scope.endLine );
                    scope.add( scope.centerMark );
                }

            }

            // update matrix
            scope.object.matrixAutoUpdate = true;

            scope.update(true);
            scope.dispatchEvent( changeEvent );
            scope.dispatchEvent( objectChangeEvent );

            return planeIntersect? true : false;

        }

        this.onPointerUp = function( event ) {

            if ( _dragging && ( scope.axis !== null ) ) {
                mouseUpEvent.mode = _mode;
                scope.dispatchEvent( mouseUpEvent )
            }
            _dragging = false;

            this.gizmo[_mode].show();

            this.updateUnitVectors();

            // remove rotation start/end lines
            if ( _mode === "transrotate" && this.gizmo[_mode].activeMode === "rotate" ) {
                this.remove( this.endLine );
                this.remove( this.centerMark );
                this.parent.remove( this.centerLine );
                this.parent.remove( this.startLine );
                this.parent.remove( this.ticks[this.axis] );
            }

            return false;

        }

        function intersectObjects( pointer, objects ) {

            var rect = domElement.getBoundingClientRect();
            var x = ( ( pointer.clientX - rect.left ) / rect.width ) * 2 - 1;
            var y = - ( ( pointer.clientY - rect.top ) / rect.height ) * 2 + 1;
          
            if ( camera.isPerspective ) {
                pointerVector.set( x, y, 0.5 );
                pointerVector.unproject( camera );
                ray.set( camera.position, pointerVector.sub( camera.position ).normalize() );
            } else {
                pointerVector.set( x, y, -1 );
                pointerVector.unproject( camera );
                pointerDir.set( 0, 0, -1 );
                ray.set( pointerVector, pointerDir.transformDirection( camera.matrixWorld ) );
            }

            var intersections = ray.intersectObjects( objects, true );
            return intersections[0] ? intersections[0] : false;

        }

    };

    THREE.TransformControls.prototype = Object.create( THREE.Object3D.prototype );

};
;/*
 Alertify is licensed under MIT http://www.opensource.org/licenses/MIT
 Copyright (c) 2012, Fabien Doiron
 */
/*global define*/
(function (global, undefined) {
	"use strict";

	var document = global.document,
	    Alertify;

	Alertify = function () {

		var _alertify = {},
		    dialogs   = {},
		    isopen    = false,
		    keys      = { ENTER: 13, ESC: 27, SPACE: 32 },
		    queue     = [],
		    $, btnCancel, btnOK, btnReset, btnResetBack, btnFocus, elCallee, elCover, elDialog, elLog, form, input, getTransitionEvent;

		/**
		 * Markup pieces
		 * @type {Object}
		 */
		dialogs = {
			buttons : {
				holder : "<nav class=\"alertify-buttons\">{{buttons}}</nav>",
				submit : "<button type=\"submit\" class=\"alertify-button alertify-button-ok\" id=\"alertify-ok\">{{ok}}</button>",
				ok     : "<button class=\"alertify-button alertify-button-ok\" id=\"alertify-ok\">{{ok}}</button>",
				cancel : "<button class=\"alertify-button alertify-button-cancel\" id=\"alertify-cancel\">{{cancel}}</button>"
			},
			input   : "<div class=\"alertify-text-wrapper\"><input type=\"text\" class=\"alertify-text\" id=\"alertify-text\"></div>",
			message : "<p class=\"alertify-message\">{{message}}</p>",
			log     : "<article class=\"alertify-log{{class}}\">{{message}}</article>"
		};

		/**
		 * Return the proper transitionend event
		 * @return {String}    Transition type string
		 */
		getTransitionEvent = function () {
			var t,
			    type,
			    supported   = false,
			    el          = document.createElement("fakeelement"),
			    transitions = {
				    "WebkitTransition" : "webkitTransitionEnd",
				    "MozTransition"    : "transitionend",
				    "OTransition"      : "otransitionend",
				    "transition"       : "transitionend"
			    };

			for (t in transitions) {
				if (el.style[t] !== undefined) {
					type      = transitions[t];
					supported = true;
					break;
				}
			}

			return {
				type      : type,
				supported : supported
			};
		};

		/**
		 * Shorthand for document.getElementById()
		 *
		 * @param  {String} id    A specific element ID
		 * @return {Object}       HTML element
		 */
		$ = function (id) {
			return document.getElementById(id);
		};

		/**
		 * Alertify private object
		 * @type {Object}
		 */
		_alertify = {

			/**
			 * Labels object
			 * @type {Object}
			 */
			labels : {
				ok     : "OK",
				cancel : "Cancel"
			},

			/**
			 * Delay number
			 * @type {Number}
			 */
			delay : 5000,

			/**
			 * Whether buttons are reversed (default is secondary/primary)
			 * @type {Boolean}
			 */
			buttonReverse : false,

			/**
			 * Which button should be focused by default
			 * @type {String}	"ok" (default), "cancel", or "none"
			 */
			buttonFocus : "ok",

			/**
			 * Set the transition event on load
			 * @type {[type]}
			 */
			transition : undefined,

			/**
			 * Set the proper button click events
			 *
			 * @param {Function} fn    [Optional] Callback function
			 *
			 * @return {undefined}
			 */
			addListeners : function (fn) {
				var hasOK     = (typeof btnOK !== "undefined"),
				    hasCancel = (typeof btnCancel !== "undefined"),
				    hasInput  = (typeof input !== "undefined"),
				    val       = "",
				    self      = this,
				    ok, cancel, common, key, reset;

				// ok event handler
				ok = function (event) {
					if (typeof event.preventDefault !== "undefined") event.preventDefault();
					common(event);
					if (typeof input !== "undefined") val = input.value;
					if (typeof fn === "function") {
						if (typeof input !== "undefined") {
							fn(true, val);
						}
						else fn(true);
					}
					return false;
				};

				// cancel event handler
				cancel = function (event) {
					if (typeof event.preventDefault !== "undefined") event.preventDefault();
					common(event);
					if (typeof fn === "function") fn(false);
					return false;
				};

				// common event handler (keyup, ok and cancel)
				common = function (event) {
					self.hide();
					self.unbind(document.body, "keyup", key);
					self.unbind(btnReset, "focus", reset);
					if (hasOK) self.unbind(btnOK, "click", ok);
					if (hasCancel) self.unbind(btnCancel, "click", cancel);
				};

				// keyup handler
				key = function (event) {
					var keyCode = event.keyCode;
					if ((keyCode === keys.SPACE && !hasInput) || (hasInput && keyCode === keys.ENTER)) ok(event);
					if (keyCode === keys.ESC && hasCancel) cancel(event);
				};

				// reset focus to first item in the dialog
				reset = function (event) {
					if (hasInput) input.focus();
					else if (!hasCancel || self.buttonReverse) btnOK.focus();
					else btnCancel.focus();
				};

				// handle reset focus link
				// this ensures that the keyboard focus does not
				// ever leave the dialog box until an action has
				// been taken
				this.bind(btnReset, "focus", reset);
				this.bind(btnResetBack, "focus", reset);
				// handle OK click
				if (hasOK) this.bind(btnOK, "click", ok);
				// handle Cancel click
				if (hasCancel) this.bind(btnCancel, "click", cancel);
				// listen for keys, Cancel => ESC
				this.bind(document.body, "keyup", key);
				if (!this.transition.supported) {
					this.setFocus();
				}
			},

			/**
			 * Bind events to elements
			 *
			 * @param  {Object}   el       HTML Object
			 * @param  {Event}    event    Event to attach to element
			 * @param  {Function} fn       Callback function
			 *
			 * @return {undefined}
			 */
			bind : function (el, event, fn) {
				if (typeof el.addEventListener === "function") {
					el.addEventListener(event, fn, false);
				} else if (el.attachEvent) {
					el.attachEvent("on" + event, fn);
				}
			},

			/**
			 * Use alertify as the global error handler (using window.onerror)
			 *
			 * @return {boolean} success
			 */
			handleErrors : function () {
				if (typeof global.onerror !== "undefined") {
					var self = this;
					global.onerror = function (msg, url, line) {
						self.error("[" + msg + " on line " + line + " of " + url + "]", 0);
					};
					return true;
				} else {
					return false;
				}
			},

			/**
			 * Append button HTML strings
			 *
			 * @param {String} secondary    The secondary button HTML string
			 * @param {String} primary      The primary button HTML string
			 *
			 * @return {String}             The appended button HTML strings
			 */
			appendButtons : function (secondary, primary) {
				return this.buttonReverse ? primary + secondary : secondary + primary;
			},

			/**
			 * Build the proper message box
			 *
			 * @param  {Object} item    Current object in the queue
			 *
			 * @return {String}         An HTML string of the message box
			 */
			build : function (item) {
				var html    = "",
				    type    = item.type,
				    message = item.message,
				    css     = item.cssClass || "";

				html += "<div class=\"alertify-dialog\">";
				html += "<a id=\"alertify-resetFocusBack\" class=\"alertify-resetFocus\" href=\"#\">Reset Focus</a>";

				if (_alertify.buttonFocus === "none") html += "<a href=\"#\" id=\"alertify-noneFocus\" class=\"alertify-hidden\"></a>";

				// doens't require an actual form
				if (type === "prompt") html += "<div id=\"alertify-form\">";

				html += "<article class=\"alertify-inner\">";
				html += dialogs.message.replace("{{message}}", message);

				if (type === "prompt") html += dialogs.input;

				html += dialogs.buttons.holder;
				html += "</article>";

				if (type === "prompt") html += "</div>";

				html += "<a id=\"alertify-resetFocus\" class=\"alertify-resetFocus\" href=\"#\">Reset Focus</a>";
				html += "</div>";

				switch (type) {
				case "confirm":
					html = html.replace("{{buttons}}", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.ok));
					html = html.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);
					break;
				case "prompt":
					html = html.replace("{{buttons}}", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.submit));
					html = html.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);
					break;
				case "alert":
					html = html.replace("{{buttons}}", dialogs.buttons.ok);
					html = html.replace("{{ok}}", this.labels.ok);
					break;
				default:
					break;
				}

				elDialog.className = "alertify alertify-" + type + " " + css;
				elCover.className  = "alertify-cover";
				return html;
			},

			/**
			 * Close the log messages
			 *
			 * @param  {Object} elem    HTML Element of log message to close
			 * @param  {Number} wait    [optional] Time (in ms) to wait before automatically hiding the message, if 0 never hide
			 *
			 * @return {undefined}
			 */
			close : function (elem, wait) {
				// Unary Plus: +"2" === 2
				var timer = (wait && !isNaN(wait)) ? +wait : this.delay,
				    self  = this,
				    hideElement, transitionDone;

				// set click event on log messages
				this.bind(elem, "click", function () {
					hideElement(elem);
				});
				// Hide the dialog box after transition
				// This ensure it doens't block any element from being clicked
				transitionDone = function (event) {
					event.stopPropagation();
					// unbind event so function only gets called once
					self.unbind(this, self.transition.type, transitionDone);
					// remove log message
					elLog.removeChild(this);
					if (!elLog.hasChildNodes()) elLog.className += " alertify-logs-hidden";
				};
				// this sets the hide class to transition out
				// or removes the child if css transitions aren't supported
				hideElement = function (el) {
					// ensure element exists
					if (typeof el !== "undefined" && el.parentNode === elLog) {
						// whether CSS transition exists
						if (self.transition.supported) {
							self.bind(el, self.transition.type, transitionDone);
							el.className += " alertify-log-hide";
						} else {
							elLog.removeChild(el);
							if (!elLog.hasChildNodes()) elLog.className += " alertify-logs-hidden";
						}
					}
				};
				// never close (until click) if wait is set to 0
				if (wait === 0) return;
				// set timeout to auto close the log message
				setTimeout(function () { hideElement(elem); }, timer);
			},

			/**
			 * Create a dialog box
			 *
			 * @param  {String}   message        The message passed from the callee
			 * @param  {String}   type           Type of dialog to create
			 * @param  {Function} fn             [Optional] Callback function
			 * @param  {String}   placeholder    [Optional] Default value for prompt input field
			 * @param  {String}   cssClass       [Optional] Class(es) to append to dialog box
			 *
			 * @return {Object}
			 */
			dialog : function (message, type, fn, placeholder, cssClass) {
				// set the current active element
				// this allows the keyboard focus to be resetted
				// after the dialog box is closed
				elCallee = document.activeElement;
				// check to ensure the alertify dialog element
				// has been successfully created
				var check = function () {
					if ((elLog && elLog.scrollTop !== null) && (elCover && elCover.scrollTop !== null)) return;
					else check();
				};
				// error catching
				if (typeof message !== "string") throw new Error("message must be a string");
				if (typeof type !== "string") throw new Error("type must be a string");
				if (typeof fn !== "undefined" && typeof fn !== "function") throw new Error("fn must be a function");
				// initialize alertify if it hasn't already been done
				this.init();
				check();

				queue.push({ type: type, message: message, callback: fn, placeholder: placeholder, cssClass: cssClass });
				if (!isopen) this.setup();

				return this;
			},

			/**
			 * Extend the log method to create custom methods
			 *
			 * @param  {String} type    Custom method name
			 *
			 * @return {Function}
			 */
			extend : function (type) {
				if (typeof type !== "string") throw new Error("extend method must have exactly one paramter");
				return function (message, wait) {
					this.log(message, type, wait);
					return this;
				};
			},

			/**
			 * Hide the dialog and rest to defaults
			 *
			 * @return {undefined}
			 */
			hide : function () {
				var transitionDone,
				    self = this;
				// remove reference from queue
				queue.splice(0,1);
				// if items remaining in the queue
				if (queue.length > 0) this.setup(true);
				else {
					isopen = false;
					// Hide the dialog box after transition
					// This ensure it doens't block any element from being clicked
					transitionDone = function (event) {
						event.stopPropagation();
						// unbind event so function only gets called once
						self.unbind(elDialog, self.transition.type, transitionDone);
					};
					// whether CSS transition exists
					if (this.transition.supported) {
						this.bind(elDialog, this.transition.type, transitionDone);
						elDialog.className = "alertify alertify-hide alertify-hidden";
					} else {
						elDialog.className = "alertify alertify-hide alertify-hidden alertify-isHidden";
					}
					elCover.className  = "alertify-cover alertify-cover-hidden";
					// set focus to the last element or body
					// after the dialog is closed
					elCallee.focus();
				}
			},

			/**
			 * Initialize Alertify
			 * Create the 2 main elements
			 *
			 * @return {undefined}
			 */
			init : function () {
				// ensure legacy browsers support html5 tags
				document.createElement("nav");
				document.createElement("article");
				document.createElement("section");
				// cover
				if ($("alertify-cover") == null) {
					elCover = document.createElement("div");
					elCover.setAttribute("id", "alertify-cover");
					elCover.className = "alertify-cover alertify-cover-hidden";
					document.body.appendChild(elCover);
				}
				// main element
				if ($("alertify") == null) {
					isopen = false;
					queue = [];
					elDialog = document.createElement("section");
					elDialog.setAttribute("id", "alertify");
                    elDialog.setAttribute("style", "z-index : 999999999");
					elDialog.className = "alertify alertify-hidden";
					document.body.appendChild(elDialog);
				}
				// log element
				if ($("alertify-logs") == null) {
					elLog = document.createElement("section");
					elLog.setAttribute("id", "alertify-logs");
					elLog.className = "alertify-logs alertify-logs-hidden";
					document.body.appendChild(elLog);
				}
				// set tabindex attribute on body element
				// this allows script to give it focus
				// after the dialog is closed
				document.body.setAttribute("tabindex", "0");
				// set transition type
				this.transition = getTransitionEvent();
			},

			/**
			 * Show a new log message box
			 *
			 * @param  {String} message    The message passed from the callee
			 * @param  {String} type       [Optional] Optional type of log message
			 * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding the log
			 *
			 * @return {Object}
			 */
			log : function (message, type, wait) {
				// check to ensure the alertify dialog element
				// has been successfully created
				var check = function () {
					if (elLog && elLog.scrollTop !== null) return;
					else check();
				};
				// initialize alertify if it hasn't already been done
				this.init();
				check();

				elLog.className = "alertify-logs";
				this.notify(message, type, wait);
				return this;
			},

			/**
			 * Add new log message
			 * If a type is passed, a class name "alertify-log-{type}" will get added.
			 * This allows for custom look and feel for various types of notifications.
			 *
			 * @param  {String} message    The message passed from the callee
			 * @param  {String} type       [Optional] Type of log message
			 * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding
			 *
			 * @return {undefined}
			 */
			notify : function (message, type, wait) {
				var log = document.createElement("article");
				log.className = "alertify-log" + ((typeof type === "string" && type !== "") ? " alertify-log-" + type : "");
				log.innerHTML = message;
				// append child
				elLog.appendChild(log);
				// triggers the CSS animation
				setTimeout(function() { log.className = log.className + " alertify-log-show"; }, 50);
				this.close(log, wait);
			},

			/**
			 * Set properties
			 *
			 * @param {Object} args     Passing parameters
			 *
			 * @return {undefined}
			 */
			set : function (args) {
				var k;
				// error catching
				if (typeof args !== "object" && args instanceof Array) throw new Error("args must be an object");
				// set parameters
				for (k in args) {
					if (args.hasOwnProperty(k)) {
						this[k] = args[k];
					}
				}
			},

			/**
			 * Common place to set focus to proper element
			 *
			 * @return {undefined}
			 */
			setFocus : function () {
				if (input) {
					input.focus();
					input.select();
				}
				else btnFocus.focus();
			},

			/**
			 * Initiate all the required pieces for the dialog box
			 *
			 * @return {undefined}
			 */
			setup : function (fromQueue) {
				var item = queue[0],
				    self = this,
				    transitionDone;

				// dialog is open
				isopen = true;
				// Set button focus after transition
				transitionDone = function (event) {
					event.stopPropagation();
					self.setFocus();
					// unbind event so function only gets called once
					self.unbind(elDialog, self.transition.type, transitionDone);
				};
				// whether CSS transition exists
				if (this.transition.supported && !fromQueue) {
					this.bind(elDialog, this.transition.type, transitionDone);
				}
				// build the proper dialog HTML
				elDialog.innerHTML = this.build(item);
				// assign all the common elements
				btnReset  = $("alertify-resetFocus");
				btnResetBack  = $("alertify-resetFocusBack");
				btnOK     = $("alertify-ok")     || undefined;
				btnCancel = $("alertify-cancel") || undefined;
				btnFocus  = (_alertify.buttonFocus === "cancel") ? btnCancel : ((_alertify.buttonFocus === "none") ? $("alertify-noneFocus") : btnOK),
				input     = $("alertify-text")   || undefined;
				form      = $("alertify-form")   || undefined;
				// add placeholder value to the input field
				if (typeof item.placeholder === "string" && item.placeholder !== "") input.value = item.placeholder;
				if (fromQueue) this.setFocus();
				this.addListeners(item.callback);
			},

			/**
			 * Unbind events to elements
			 *
			 * @param  {Object}   el       HTML Object
			 * @param  {Event}    event    Event to detach to element
			 * @param  {Function} fn       Callback function
			 *
			 * @return {undefined}
			 */
			unbind : function (el, event, fn) {
				if (typeof el.removeEventListener === "function") {
					el.removeEventListener(event, fn, false);
				} else if (el.detachEvent) {
					el.detachEvent("on" + event, fn);
				}
			}
		};

		return {
			alert   : function (message, fn, cssClass) { _alertify.dialog(message, "alert", fn, "", cssClass); return this; },
			confirm : function (message, fn, cssClass) { _alertify.dialog(message, "confirm", fn, "", cssClass); return this; },
			extend  : _alertify.extend,
			init    : _alertify.init,
			log     : function (message, type, wait) { _alertify.log(message, type, wait); return this; },
			prompt  : function (message, fn, placeholder, cssClass) { _alertify.dialog(message, "prompt", fn, placeholder, cssClass); return this; },
			success : function (message, wait) { _alertify.log(message, "success", wait); return this; },
			error   : function (message, wait) { _alertify.log(message, "error", wait); return this; },
			set     : function (args) { _alertify.set(args); },
			hide    : function (args) { _alertify.hide(args); },
			labels  : _alertify.labels,
			debug   : _alertify.handleErrors
		};
	};

	// AMD and window support
    // Workaround for 'define' being overridden in A360
	//if (typeof define === "function") {
    if (false) {
        define([], function () { return new Alertify(); });
	} else if (typeof global.alertify === "undefined") {
		global.alertify = new Alertify();
	}

}(this));
;
(function() {

var av = Autodesk.Viewing,
    avp = av.Private;

    var global = av.getGlobal();

    global.auth = null;
    global.VIEWING_URL = undefined;
    global.ACM_SESSION_URL = undefined;
    global.OSS_URL = undefined;
    global.PROTEIN_ROOT = null;
    global.PRISM_ROOT = null;
    global.LOCALIZATION_REL_PATH = "";
    global.LMV_VIEWER_VERSION = "2.5";  // Gets replaced with content from deployment/package.json
    global.LMV_VIEWER_PATCH = "40";// Gets replaced with build number from TeamCity
    global.LMV_BUILD_TYPE = "Production"; // Either Development, Staging or Production
    global.LMV_RESOURCE_VERSION = null;
    global.LMV_RESOURCE_ROOT = "";
    global.LMV_THIRD_PARTY_COOKIE = undefined;

    global.stderr = function() {
        if (ENABLE_TRACE) {
            console.log.apply(console, arguments);
        }
    };

    avp.env = null;
    avp.logger = null;
// GUID of the current active document item.
    avp.docItemId = null;

    avp.token = {
        accessToken : null,
        getAccessToken : null,
        tokenRefreshInterval : null
    };

    // If true, will use a different code path where data structures are
    // optimized for using less memory.
    avp.memoryOptimizedLoading = true;
    avp.GPU_MEMORY_LIMIT = 256 * 1024 * 1024;
    avp.GPU_OBJECT_LIMIT = 10000;

    var isWeakDevice = (av.isMobileDevice());
    if (!isWeakDevice) {
        // This is the fragments count that will persistent in memory all the time
        // even memory is low and some of geometry will be deleted.
        avp.FRAGS_PERSISTENT_COUNT = 10000;
        // This is roughly the max number of fragments that can be handled in one go,
        // and in other words, exceeding this count will trigger on demand loading.
        // I guess on mobile device, this need to change to a smaller value.
        avp.FRAGS_PERSISTENT_MAX_COUNT = 800000;
        // ??? Approximately use a max geometry count as a hint for
        // ??? when start to remove geometry to release memory.
        // ??? This needs experiments and dynamically change due to differnt browsers.
        avp.GEOMS_COUNT_LIMIT = 300000;
    }
    else {
        // The following value are adjusted for weak device.
        // ??? This should be configurable for different type of devices.
        avp.FRAGS_PERSISTENT_COUNT = 2000;
        avp.FRAGS_PERSISTENT_MAX_COUNT = 150000;
        avp.GEOMS_COUNT_LIMIT = 8000;
    }

    // Options for limit memory usage.
    // 1. On demand loading will delay geometry pack file loading,
    //    until rendering need it.
    // 2. As one geometry pack file can contain many meshes that will
    //    be used by a lot of fragments, so can even dismiss those meshes
    //    that are culled by current rendering.
    // 3. Page out geometry acutally will remove some geometry out of core,
    //    so as to free more memory for further rendering.
    // ??? These options will impact rendering performance.
    avp.onDemandLoading = false && avp.memoryOptimizedLoading;
    avp.cullGeometryOnLoading = true && avp.onDemandLoading;
    avp.pageOutGeometryEnabled = true && avp.onDemandLoading;
    avp.PAGEOUT_SUCCESS = 0;
    avp.PAGEOUT_FAIL = 1;
    avp.PAGEOUT_NONE = 2;
    avp.PAGEOUT_PERCENTAGE = 0.35;
    avp.GEOMS_PAGEOUT_COUNT = avp.GEOMS_COUNT_LIMIT * avp.PAGEOUT_PERCENTAGE;

    // A list of resources that record the URL and necessary auxilary information (such as ACM headers and / or
    // session id) required to get the resource. This bag of collection will be passed from JS to native code so
    // all viewer consumable resources could be downloaded on native side for offline viewing.
    // avp.assets = isAndroidDevice() ? [] : null;
    avp.assets = [];
    // Set viewer in offline mode if set to true. In offline mode, viewer would ignore all URNs in bubble JSON
    // and assume the viewables are laid out in local file system path relative to the bubble.json.
    avp.offline = false;
    // Offline resource prefix specified by viewer consumer (e.g. IOS web view). Used as prefix to concatenate with
    // each resource relative path to form the absolute path of each resource.
    avp.offlineResourcePrefix = null;

    var LmvEndpoints = {
        local: {
            LOGGING:    'rtc-dev.api.autodesk.com',
            RTC:        ['https://rtc-dev.api.autodesk.com:443', 'https://lmv.autodesk.com:443'] //port # is required here.
        },
        dev: {
            LOGGING:    'rtc-dev.api.autodesk.com',
            RTC:        ['https://rtc-dev.api.autodesk.com:443', 'https://lmv.autodesk.com:443']
        },
        stg: {
            LOGGING:    'rtc-stg.api.autodesk.com',
            RTC:        ['https://rtc-stg.api.autodesk.com:443', 'https://lmv.autodesk.com:443']
        },
        prod: {
            LOGGING:    'rtc.api.autodesk.com',
            RTC:        ['https://rtc.api.autodesk.com:443', 'https://lmv.autodesk.com:443']
        }
    };

    var ViewingApiUrls = {
        local: "",
        dev: "https://viewing-dev.api.autodesk.com",
        stg: "https://viewing-staging.api.autodesk.com",
        prod: "https://viewing.api.autodesk.com"
    };

    var DevApiUrls = {
        local: "",
        dev: "https://developer-dev.api.autodesk.com",
        stg: "https://developer-stg.api.autodesk.com",
        prod: "https://developer.api.autodesk.com"
    };

    // The apps on https://developer.autodesk.com had to be created under an ADS account... Ask for brozp
    var AdpConfigs = {
        dev: { CLIENT_ID: 'lmv-dev', CLIENT_KEY: 'vcmQyLIGxGeqGRPYDoVQeeoRUAFgibZp', ENDPOINT: 'https://ase-dev.autodesk.com' },
        stg: { CLIENT_ID: 'lmv-stag', CLIENT_KEY: 'kjemi1rwAgsqIqyvDUtc9etPD6MsAzbV', ENDPOINT: 'https://ase-stg.autodesk.com' },
        prod: { CLIENT_ID: 'lmv-prod', CLIENT_KEY: 'iaoUM2CRGydfn703yfPq4MAogZi8I5u4', ENDPOINT: 'https://ase.autodesk.com' }
    }

    var APIS = {
        ACM : '/oss-ext/v1/acmsessions',
        OSS : '/oss/v1',
        VIEWING : '/viewingservice/v1',
        VIEWING2 : '/derivativeservice/v2'
    };

    avp.EnvironmentConfigurations = {
        Local: {
            ROOT:       '',
            VIEWING:    '',
            ACM:        '',
            OSS:        '',
            LMV:        LmvEndpoints["local"]
        },
        Development: {
            ROOT:       ViewingApiUrls["dev"],
            VIEWING:    ViewingApiUrls["dev"] + APIS.VIEWING,
            ACM:        DevApiUrls["dev"] + APIS.ACM,
            OSS:        DevApiUrls["dev"] + APIS.OSS,
            LMV:        LmvEndpoints["dev"]
        },
        Staging: {
            ROOT:       ViewingApiUrls["stg"],
            VIEWING:    ViewingApiUrls["stg"] + APIS.VIEWING,
            ACM:        DevApiUrls["stg"] + APIS.ACM,
            OSS:        DevApiUrls["stg"] + APIS.OSS,
            LMV:        LmvEndpoints["stg"]
        },
        Production: {
            ROOT:       ViewingApiUrls["prod"],
            VIEWING:    ViewingApiUrls["prod"] + APIS.VIEWING,
            ACM:        DevApiUrls["prod"] + APIS.ACM,
            OSS:        DevApiUrls["prod"] + APIS.OSS,
            LMV:        LmvEndpoints["prod"]
        },
        AutodeskDevelopment: {
            ROOT:       DevApiUrls["dev"],
            VIEWING:    DevApiUrls["dev"] + APIS.VIEWING,
            ACM:        DevApiUrls["dev"] + APIS.ACM,
            OSS:        DevApiUrls["dev"] + APIS.OSS,
            LMV:        LmvEndpoints["dev"]
        },
        AutodeskStaging: {
            ROOT:       DevApiUrls["stg"],
            VIEWING:    DevApiUrls["stg"] + APIS.VIEWING,
            ACM:        DevApiUrls["stg"] + APIS.ACM,
            OSS:        DevApiUrls["stg"] + APIS.OSS,
            LMV:        LmvEndpoints["stg"]
        },
        AutodeskProduction: {
            ROOT:       DevApiUrls["prod"],
            VIEWING:    DevApiUrls["prod"] + APIS.VIEWING,
            ACM:        DevApiUrls["prod"] + APIS.ACM,
            OSS:        DevApiUrls["prod"] + APIS.OSS,
            LMV:        LmvEndpoints["prod"]
        },
        DevelopmentV2: {
            ROOT:       ViewingApiUrls["dev"],
            VIEWING:    ViewingApiUrls["dev"] + APIS.VIEWING2,
            ACM:        DevApiUrls["dev"] + APIS.ACM,
            OSS:        DevApiUrls["dev"] + APIS.OSS,
            LMV:        LmvEndpoints["dev"]
        },
        StagingV2: {
            ROOT:       ViewingApiUrls["stg"],
            VIEWING:    ViewingApiUrls["stg"] + APIS.VIEWING2,
            ACM:        DevApiUrls["stg"] + APIS.ACM,
            OSS:        DevApiUrls["stg"] + APIS.OSS,
            LMV:        LmvEndpoints["stg"]
        },
        ProductionV2: {
            ROOT:       ViewingApiUrls["prod"],
            VIEWING:    ViewingApiUrls["prod"] + APIS.VIEWING2,
            ACM:        DevApiUrls["prod"] + APIS.ACM,
            OSS:        DevApiUrls["prod"] + APIS.OSS,
            LMV:        LmvEndpoints["prod"]
        },
        AutodeskDevelopmentV2: {
            ROOT:       DevApiUrls["dev"],
            VIEWING:    DevApiUrls["dev"] + APIS.VIEWING2,
            ACM:        DevApiUrls["dev"] + APIS.ACM,
            OSS:        DevApiUrls["dev"] + APIS.OSS,
            LMV:        LmvEndpoints["dev"]
        },
        AutodeskStagingV2: {
            ROOT:       DevApiUrls["stg"],
            VIEWING:    DevApiUrls["stg"] + APIS.VIEWING2,
            ACM:        DevApiUrls["stg"] + APIS.ACM,
            OSS:        DevApiUrls["stg"] + APIS.OSS,
            LMV:        LmvEndpoints["stg"]
        },
        AutodeskProductionV2: {
            ROOT:       DevApiUrls["prod"],
            VIEWING:    DevApiUrls["prod"] + APIS.VIEWING2,
            ACM:        DevApiUrls["prod"] + APIS.ACM,
            OSS:        DevApiUrls["prod"] + APIS.OSS,
            LMV:        LmvEndpoints["prod"]
        }
    };


    avp.initializeEnvironmentVariable = function (options) {
        var env;

        // Use the enviroment that was explicitly specified.
        //
        if (options && options.env) {
            env = options.env;
        }

        // If not available, check if the environment was specified in the query parameters.
        //
        if (!env) {
            env = avp.getParameterByName("env");
        }

        if (options && options.offlineResourcePrefix) {
            avp.offlineResourcePrefix = options.offlineResourcePrefix;
        }

        if (options && options.offline && options.offline === "true") {
            avp.offline = true;
        }

        // If still not available, try to resolve the environment based on the url.
        //
        if (!env) {
            // FIXME: with the introduction of v2 end points, this would not work. We either
            // have to enforce user must pass an env variable to viewer, or parse URL here.
            switch (window.location.hostname) {
                case "viewing-dev.api.autodesk.com" :
                    env = 'Development';
                    break;
                case "viewing-staging.api.autodesk.com" :
                    env = 'Staging';
                    break;
                case "viewing.api.autodesk.com" :
                    env = 'Production';
                    break;
                case "developer-dev.api.autodesk.com" :
                    env = 'AutodeskDevelopment';
                    break;
                case "developer-stg.api.autodesk.com" :
                    env = 'AutodeskStaging';
                    break;
                case "developer.api.autodesk.com" :
                    env = 'AutodeskProduction';
                    break;

                case "localhost.autodesk.com" :
                    env = 'Local';
                    break;
                case "" : // IP addresses on Chrome.
                    env = 'Local';
                    break;
                case "127.0.0.1" :
                    env = 'Local';
                    break;
                default:
                    env = 'AutodeskProduction';
            }
        }

        console.log("Host name : " + window.location.hostname);
        console.log("Environment initialized as : " + env);
        avp.env = env;
    };

    avp.initializeServiceEndPoints = function (options) {
        var env = avp.env;
        var config = avp.EnvironmentConfigurations[env];
        VIEWING_URL = config['VIEWING'];
        ACM_SESSION_URL = config['ACM'];
        OSS_URL = config['OSS'];

        //Derive the root for static viewer resources based on the
        //location of the main viewer script
        var libList = [
            "viewer3D.js",
            "viewer3D.min.js",
            "firefly.js",
            "firefly.min.js"
        ];
        if (options && options.hasOwnProperty('libraryName'))
            libList.push(options.libraryName);

        var root;
        var scriptUrl;

        // TODO_NOP: this doesn't work for Polymer / Web Components
        for (var i=0; i<libList.length; i++) {
            var script = avp.getScript(libList[i]);
            scriptUrl = script ? script.src : "";
            var idx = scriptUrl.indexOf(libList[i]);
            if (idx >= 0) {
                root = scriptUrl.substr(0, idx);
                break;
            }
        }

        //Derive any custom version request
        LMV_RESOURCE_VERSION = "v" + LMV_VIEWER_VERSION;

        var version = avp.getParameterByNameFromPath("v", scriptUrl);
        if (version && version.length && version != LMV_RESOURCE_VERSION) {
            console.warn("Version string mismatch between requested and actual version: " + version + " vs. " + LMV_RESOURCE_VERSION + ". Using " + version);
            LMV_RESOURCE_VERSION = version;
        } else if (!version || !version.length) {
            LMV_RESOURCE_VERSION = null;
            console.info("No viewer version specified, will implicitly use " + LMV_VIEWER_VERSION);
        }

        LMV_RESOURCE_ROOT = root || LMV_RESOURCE_ROOT;
    };


    avp.refreshCookie = function(token, onSuccess, onError) {

        var xhr = new XMLHttpRequest();
        xhr.onload = onSuccess;
        xhr.onerror = onError;
        xhr.ontimeout = onError;

    // We support two set token end points, the native VS end point and the wrapped apigee end point.
        if (avp.env.indexOf('Autodesk') === 0) {
            // This really sucks, as Apigee end points use different naming pattern than viewing service.
            var url = avp.EnvironmentConfigurations[avp.env].ROOT;

            xhr.open("POST", url + "/utility/v1/settoken", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            xhr.withCredentials = true;

            xhr.send("access-token=" + token);

            // Here we control whether to go through IE 11's authentication code path or not.
            if (_isIE11) {
                avp.accessToken = token;
            }
        }
        else {
            var token =
            {
                "oauth": {
                    "token": token
                }
            };

            // console.log("auth token : " + JSON.stringify(token));

            xhr.open("POST", VIEWING_URL + "/token", true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.withCredentials = true;

            xhr.send(JSON.stringify(token));
        }

    };

    // Refresh the token in request header, in case that the third party cookie is disabled
    avp.refreshRequestHeader = function(token) {

        av.HTTP_REQUEST_HEADERS["Authorization"] = "Bearer " + token;

    };

    avp.refreshToken = function(token, onSuccess, onError) {

        // Store the token, it will be used when third-party cookies are disabled
        avp.token.accessToken = token;

        // At the beginning, try to store the token in cookie
        if (LMV_THIRD_PARTY_COOKIE === undefined) {
            avp.refreshCookie(token, onSuccess, onError);
        } else {
            doTokenRefresh();
        }

        // if third-party cookies are enabled in browser, then put token in cookie
        // if not, put token into request header
        function doTokenRefresh() {

            if (LMV_THIRD_PARTY_COOKIE) {

                avp.refreshCookie(token, onSuccess, onError);

            } else {

                avp.refreshRequestHeader(token);
                onSuccess();

            }
        }

    };

    avp.initializeAuth = function (onSuccessCallback, options) {

        var shouldInitializeAuth = options ? options.shouldInitializeAuth : undefined;
        if (shouldInitializeAuth === undefined) {
            var p = avp.getParameterByName("auth");
            shouldInitializeAuth = (p.toLowerCase() !== "false");
        }

        //Skip Auth in case we are serving the viewer locally
        if (avp.env == "Local" || !shouldInitializeAuth) {
            setTimeout(onSuccessCallback, 0);
            auth = false;
            return auth;
        }

        // Keep this to make existing client code happy.
        auth = true;

        var accessToken;
        if (options && options.getAccessToken) {
            function onGetAccessToken(token /* access token value. */, expire /* expire time, in seconds. */) {
                accessToken = token;
                avp.refreshToken(accessToken, avp.token.tokenRefreshInterval ? null /* If this is a token refresh call,
                 don't invoke the onSuccessCallback which will loadDocument and so on. */
                    : onSuccessCallback);
                var interval = expire - 60; // Refresh 1 minute before token expire.
                if (interval <= 0) {
                    // We can't get a precise upper bound if the token is such a short lived one (expire in a minute),
                    // so just use the original one.
                    interval = expire;
                }
                avp.token.tokenRefreshInterval = interval * 1000;
                setTimeout(function() {options.getAccessToken(onGetAccessToken)}, avp.token.tokenRefreshInterval);
            }
            avp.token.getAccessToken = options.getAccessToken;

            accessToken = options.getAccessToken(onGetAccessToken);

            //Backwards compatibility with the old synchronous API
            if (typeof accessToken == "string" && accessToken) {
                avp.refreshToken(accessToken, onSuccessCallback);
            }

        } else if (options && options.accessToken) {
            accessToken = options.accessToken;
            avp.refreshCookie(accessToken, onSuccessCallback);
            avp.refreshToken(accessToken);
        } else {
            accessToken = avp.getParameterByName("accessToken");
            if (!accessToken) {
                accessToken = "9AMaRKBoPCIBy61JmQ8OLLLyRblS";
                console.log("Warning : no access token is provided. Use built in token : " + accessToken);
            }
            avp.refreshToken(accessToken, onSuccessCallback);
        }

        return auth;
    };

    avp.initializeLogger = function (options) {

        var loggerConfig = {
            endpoint: avp.EnvironmentConfigurations[avp.env].LMV.LOGGING,
            eventCallback: options ? options.eventCallback : undefined
        };
        avp.logger = new avp.Logger(loggerConfig);

        if (options && options.hasOwnProperty('useADP') && options.useADP == false) {
            return;
        }

        // Load Autodesk Data Platform client
        // (and if we're in RequireJS environment, use its APIs to avoid problems)
        var url = 'https://ase-cdn.autodesk.com/adp/v1.0.1/js/adp-web-analytics-sdk.min.js';
        var callback = function() {
            if (typeof (Adp) === 'undefined') {
                stderr('Autodesk Data Platform SDK not found');
                return;
            }

            var adpConfig;
            switch (LMV_BUILD_TYPE) {
                case 'Production': adpConfig = AdpConfigs['prod']; break;
                case 'Staging': adpConfig = AdpConfigs['stg']; break;
                default: adpConfig = AdpConfigs['dev']; break;
            }
            var facets = {
                product: {
                    name: 'LMV',
                    line_name: 'LMV',
                    key: adpConfig.CLIENT_ID,
                    id: adpConfig.CLIENT_KEY,
                    build_id: LMV_VIEWER_VERSION + '.' + LMV_VIEWER_PATCH,
                    build_tag: avp.env
                }
            };
            var config = {
                server: adpConfig.ENDPOINT,
                enable_geo_data: false,
                enable_browser_data: true,
                enable_session_messages: true
            };
            avp.logger.adp = new Adp(facets, config);
        };

        if (typeof requirejs !== 'undefined') {
            requirejs([url], function(adp) {
                window['Adp'] = adp;
                callback();
            });
        } else {
            avp.loadDependency('Adp', url, callback);
        }
    };

    avp.initializeProtein = function () {

        //For local work, don't redirect texture requests to the CDN,
        //because local ones will load much faster, presumably.
        if (ENABLE_DEBUG && avp.env == "Local" && !auth /* when auth is true, the viewer is operating under
        local mode but connect to remote server to get data. */)
            return;

        // In offline mode, viewer will get the texture from the locally cached SVF data sets, instead pinging texture
        // CDN.
        // TODO: this will break when translators stop including Protein into SVF.
        if (avp.offline) {
            return;
        }

        var xhr1 = new XMLHttpRequest();
        xhr1.open("GET", "https://raas-assets.autodesk.com/StaticContent/BaseAddress?family=protein", true);
        xhr1.responseType = "json";

        xhr1.onload = function (e) {
            var res = xhr1.response.url;
            if (res && res.length) {
                res = res.replace("http://", "https://");
                PROTEIN_ROOT = res + "/";
                stderr("Protein root is: " + PROTEIN_ROOT);
            }
        };

        xhr1.send();

        var xhr2 = new XMLHttpRequest();
        xhr2.open("GET", "https://raas-assets.autodesk.com/StaticContent/BaseAddress?family=prism", true);
        xhr2.responseType = "json";

        xhr2.onload = function (e) {
            var res = xhr2.response.url;
            if (res && res.length) {
                res = res.replace("http://", "https://");
                PRISM_ROOT = res + "/";
                stderr("Prism root is: " + PRISM_ROOT);
            }
        };

        //xhr.onerror = ;
        //xhr.ontimeout = ;

        xhr2.send();
    };

    avp.getAuthObject = function () {
        return auth;
    };

// Returns the query parameter value from window url
    avp.getParameterByName = function (name) {
        return avp.getParameterByNameFromPath(name, window.location.href);
    };

// return value of parameter from a url
    avp.getParameterByNameFromPath = function (name, url) {
        name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regexS = "[\\?&]" + name + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(url);
        if (results == null)
            return "";
        else
            return decodeURIComponent(results[1].replace(/\+/g, " "));
    };

    avp.urlIsApiViewingOrDev = function(url) {
                // Dev API endpoints
        return  url.indexOf('developer.api.autodesk.com') !== -1 ||
                url.indexOf('developer-stg.api.autodesk.com') !== -1 ||
                url.indexOf('developer-dev.api.autodesk.com') !== -1 ||
                // Viewing API endpoints
                url.indexOf('viewing.api.autodesk.com') !== -1 ||
                url.indexOf('viewing-staging.api.autodesk.com') !== -1 ||
                url.indexOf('viewing-dev.api.autodesk.com') !== -1;
    };

// Return a default document URN for demo purpose.
    avp.getDemoDocumentURN = function () {
        var documentId;

        switch (avp.env) {
            case "Development" :
                //documentId = "urn:dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6Y29sdW1idXMvTWljaGFlbF9IYW5kLV8tYjE0MDk3ODQxNzcwMDZSQ0Nhci5kd2Y";
                documentId = "urn:dXJuOmFkc2suYTM2MGJldGFkZXY6ZnMuZmlsZTplbnRlcnByaXNlLmxtdnRlc3QuRFM1YTczMFFUYmYwMDIyZDA3NTFhYmE5MjZlZDZkMjJlZDY0P3ZlcnNpb249MQ==";
                break;
            case "Staging" :
                documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbicvTU0zNTAwQXNzZW1ibHkuZHdm";
                break;
            case "Production" :
                documentId = "FIXME";
                break;
            default:
                //documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbmAvUkMgQ2FyLmR3Zg"
                documentId = "https://lmv.rocks/viewer/data/gears/output/bubble.json";
        }

        return documentId;
    };

    avp.setLanguage = function (language, callback) {

        var options = {
            lng: language,
            resGetPath: 'res/locales/__lng__/__ns__.json',
            ns: {
                namespaces: ['allstrings'],
                defaultNs: 'allstrings'
            },
            fallbackLng: "en",
            debug: false
        };

        LOCALIZATION_REL_PATH = "res/locales/" + language + "/";
        Autodesk.Viewing.i18n.init(options, function (t) {
            Autodesk.Viewing.i18n.clearDebugLocString(); //Calls localize as well
            if (callback) {
                callback();
            }
        });
    };

    avp.initializeLocalization = function (options) {
        // Initialize language for localization. The corresponding string files
        // will be downloaded.
        var language = (options && options.language) || navigator.language;

        // use iso scheme (ab/ab-XY)
        var tags = language.split('-');
        language = tags.length > 1 ? tags[0].toLowerCase() + '-' + tags[1].toUpperCase() : tags[0].toLowerCase();
 
        // check supported language tags and subtags
        var supportedTags = ["cs", "de", "en", "es", "fr", "it", "ja", "ko", "pl", "pt-BR", "ru", "tr", "zh-HANS", "zh-HANT"];
        if (supportedTags.indexOf(language) === -1) {
            if (language.indexOf("zh-CN") > -1) language = "zh-HANS";
            else if (language.indexOf("zh-TW") > -1) language = "zh-HANT";
            else if (tags.length > 1 && supportedTags.indexOf(tags[0]) > -1) language = tags[0];
            else language = "en";
        }

        // Uncomment below to default to english
        //language = "en";
        avp.setLanguage(language);
    };

    avp.initializeUserInfo = function (options) {
        if (!options || !options.userInfo) return;
        avp.setUserName(options.userInfo.name);
        if (options.comment2Token) {
            avp.comment2Token = options.comment2Token;
        }
    };


// TODO:  This is here for now, until we find a better place for it.
//
    /**
     * Returns the first source url found containing the given script name.
     * @private
     *
     * @param {string} scriptName
     * @returns {HTMLScriptElement} The script element whose source location matches the input parameter
     */
    avp.getScript = function (scriptName) {
        scriptName = scriptName.toLowerCase();
        var scripts = document.getElementsByTagName('SCRIPT');
        if (scripts && scripts.length > 0) {
            for (var i = 0; i < scripts.length; ++i) {
                if (scripts[i].src && scripts[i].src.toLowerCase().indexOf(scriptName) !== -1) {
                    return scripts[i];
                }
            }
        }
        return null;
    };

    /**
     * Returns the full url of a resource with version.  The version will be determined from the LMV_VIEWER_VERSION variable.
     * @private
     *
     * @param {string} resourceRelativePath - the path of the resource relative to LMV_RESOURCE_ROOT.
     * @returns {string} - the full resource path.
     */
    avp.getResourceUrl = function (resourceRelativePath) {
        var version = LMV_RESOURCE_VERSION;
        return LMV_RESOURCE_ROOT + resourceRelativePath + (version ? ('?v=' + version) : '');
    };

    /**
     * Loads a script (e.g. an external library JS) and calls the callback once loaded.
     * Used for delayed loading of required libraries. Accepts both relative and absolute URLs.
     */
    avp.loadDependency = function(libNamespace, libName, callback) {
        if (typeof window[libNamespace] == "undefined") {
            var s = document.createElement("SCRIPT");
            s.src = libName.indexOf('://') > 0 ? libName : avp.getResourceUrl(libName);
            document.head.appendChild(s);
            if (callback)
                s.onload = callback;
        }
        else if (callback)
            callback();
    };


    /**
     * This is the Initializer class that initializes the viewer runtime, including:
     *
     *  - End points of cloud services the viewer uses, like viewing service and search service.
     *  - Authentication and authorization cookie settings on the client side.
     *  - Misc runtime environment variables and viewer configurations parameters.
     *
     *  @constructor
     *  @param {object} options - The options object contains configuration parameters used to do initializations. If no
     *                            access token or authentication callback is provided, the Initializer will fall back
     *                            on an access token provided in the URL query string, or a previous access token stored in
     *                            the cookie cache, if available.
     *  @param {string} [options.env] - Can be "Development", "Staging" or "Production", for viewers running without PAAS
     *                                  endpoints. Can be "AutodeskDevelopment", "AutodeskStaging", or "AutodeskProduction"
     *                                  for viewers running with PAAS endpoints.
     *  @param {function} [options.getAccessToken] - An function that provides an access token asynchronously. The function signature
     *                                               is getAccessToken(onSuccess), where onSuccess is a callback that getAccessToken function
     *                                               should invoke when a token is granted, with the token being the first input parameter for the
     *                                               onSuccess function, and the token expire time (in seconds) being the second input parameter for the
     *                                               function. Viewer relies on both getAccessToken and the expire time to automatically renew token, so
     *                                               it is critical that getAccessToken must be implemented as described here.
     *  @param {boolean} [options.useADP] - whether to report analytics to ADP. True by default.
     *
     *  @param {string} [options.accessToken] - An access token
     *  @param {string} [options.webGLHelpLink] - A link to a help page on webGL if it's disabled.
     *  @param {string} [options.language] - Preferred language code as defined in RFC 4646, such as "en", "de", "fr", etc.
     *  If no language is set, viewer will pick it up from the browser. If language is not as defined in RFC,
     *  viewer will fall back to "en" but the behavior is undefined.
     *
     *  @param {function} callback - A method the client executes when initialization is finished.
     *
     *  @example
     *   var options = {
     *      env: "Production",
     *      language: "en",
     *      webGLHelpLink: "http://my.webgl.help.link",
     *      getAccessToken: function(onSuccess) {
     *          var accessToken, expire;
     *          // Code to retrieve and assign token value to
     *          // accessToken and expire time in seconds.
     *          onSuccess(accessToken, expire);
     *      }
     *   };
     *   var callback = function() {
     *      alert("initialization complete");
     *   };
     *   Autodesk.Viewing.Initializer(options, callback);
     */
    Autodesk.Viewing.Initializer = function (options, callback) {

        avp.WEBGL_HELP_LINK = options ? options.webGLHelpLink : null;
        avp.initializeEnvironmentVariable(options);
        avp.initializeServiceEndPoints(options);
        avp.initializeProtein();

        function init() {

            //Temporarily silence THREE.warn due to new builds of Chrome producing oodles of shader compile warnings.
            THREE.warn = function() { stderr.apply(stderr, arguments);};

            init_three_dds_loader();
            avp.initializeLogger(options);
            avp.initializeAuth(callback, options);
            avp.initializeLocalization(options);
            avp.initializeUserInfo(options);
        }

        //Kick off a request for the web worker script, so it loads in parallel with three.js
        avp.initWorkerScript();

        //Load three.js then continue initialization
        avp.loadDependency("THREE", "three.min.js", init);
    };

})();
